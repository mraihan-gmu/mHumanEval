{"prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verilmi\u015f \u0259d\u0259dl\u0259r siyah\u0131s\u0131nda h\u0259r hans\u0131 iki \u0259d\u0259din bir-birin\u0259 verilmi\u015f h\u0259dd\u0259n daha yax\u0131n olub-olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131n.\n    N\u00fcmun\u0259:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n","canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n","test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"}
{"prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Bu funksiyaya veril\u0259n m\u0259lumat bir ne\u00e7\u0259 qrup i\u00e7-i\u00e7\u0259 m\u00f6t\u0259riz\u0259l\u0259rd\u0259n ibar\u0259t bir s\u0259tirdir. M\u0259qs\u0259diniz bu qruplar\u0131 ayr\u0131-ayr\u0131 s\u0259tirl\u0259r\u0259 ay\u0131rmaq v\u0259 h\u0259min s\u0259tirl\u0259rin siyah\u0131s\u0131n\u0131 qaytarmaqd\u0131r. Ayr\u0131-ayr\u0131 qruplar tarazl\u0131d\u0131r v\u0259 bir-birin\u0259 i\u00e7-i\u00e7\u0259 deyil. Giri\u015f s\u0259tirind\u0259ki bo\u015fluqlar\u0131 g\u00f6rm\u0259m\u0259zliy\u0259 vurun. N\u00fcmun\u0259:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n","canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n","test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"}
{"prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" M\u00fcsb\u0259t onluq n\u00f6qt\u0259li \u0259d\u0259d verildikd\u0259, onu tam hiss\u0259y\u0259 v\u0259 onluq hiss\u0259y\u0259 ay\u0131rmaq olar.\n\n\u018fd\u0259din onluq hiss\u0259sini qaytar\u0131n.\nM\u0259s\u0259l\u0259n:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n","canonical_solution":"    return number % 1.0\n","test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"}
{"prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Siz\u0259 s\u0131f\u0131r balansla ba\u015flayan bir bank hesab\u0131nda yerl\u0259\u015fdirm\u0259 v\u0259 \u00e7\u0131xar\u0131\u015f \u0259m\u0259liyyatlar\u0131n\u0131n siyah\u0131s\u0131 verilir. Sizin v\u0259zif\u0259niz hesab balans\u0131n\u0131n h\u0259r hans\u0131 bir n\u00f6qt\u0259d\u0259 s\u0131f\u0131rdan a\u015fa\u011f\u0131 d\u00fc\u015f\u00fcb-d\u00fc\u015fm\u0259diyini m\u00fc\u0259yy\u0259n etm\u0259kdir v\u0259 bu n\u00f6qt\u0259d\u0259 funksiya True qaytarmal\u0131d\u0131r. \u018fks halda, False qaytarmal\u0131d\u0131r.\nN\u00fcmun\u0259:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n","canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n","test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"}
{"prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Veril\u0259n giri\u015f n\u00f6mr\u0259l\u0259ri siyah\u0131s\u0131 \u00fc\u00e7\u00fcn, bu datasetin ortalamas\u0131 \u0259traf\u0131nda Orta Absolut Yay\u0131lma\u011f\u0131 hesablay\u0131n.\nOrta Absolut Yay\u0131lma h\u0259r bir element il\u0259 m\u0259rk\u0259z n\u00f6qt\u0259 aras\u0131ndak\u0131 orta absolut f\u0259rqdir:\nMAD = orta | x - x_ortalama |\nN\u00fcmun\u0259:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n","canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n","test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"}
{"prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" H\u0259r iki ard\u0131c\u0131l `numbers` elementinin aras\u0131na bir 'delimeter' n\u00f6mr\u0259si daxil edin.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n","canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n","test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"}
{"prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Bu funksiyaya giri\u015f, bo\u015fluqlarla ayr\u0131lm\u0131\u015f i\u00e7-i\u00e7\u0259 m\u00f6t\u0259riz\u0259l\u0259r qruplar\u0131n\u0131 t\u0259msil ed\u0259n bir s\u0259tirdir.\n    H\u0259r bir qrup \u00fc\u00e7\u00fcn m\u00f6t\u0259riz\u0259l\u0259rin \u0259n d\u0259rin s\u0259viyy\u0259sini \u00e7\u0131xar\u0131n.\n    M\u0259s\u0259l\u0259n,) maksimum iki s\u0259viyy\u0259li i\u00e7-i\u00e7\u0259lik,)) is\u0259 \u00fc\u00e7 s\u0259viyy\u0259li i\u00e7-i\u00e7\u0259lik g\u00f6st\u0259rir.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n","canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n","test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"}
{"prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Verilmi\u015f alt s\u0259tri ehtiva ed\u0259n s\u0259tirl\u0259rd\u0259n ibar\u0259t siyah\u0131n\u0131 filtr edin.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if substring in x]\n","test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"}
{"prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Verilmi\u015f tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131 \u00fc\u00e7\u00fcn siyah\u0131dak\u0131 b\u00fct\u00fcn tam \u0259d\u0259dl\u0259rin c\u0259mi v\u0259 hasilind\u0259n ibar\u0259t olan bir tuple qaytar\u0131n.\n    Bo\u015f c\u0259m 0-a, bo\u015f hasil is\u0259 1-\u0259 b\u0259rab\u0259r olmal\u0131d\u0131r.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n","canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n","test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"}
{"prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Veril\u0259n tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131ndan, ard\u0131c\u0131ll\u0131qda m\u00fc\u0259yy\u0259n anad\u0259k tap\u0131lan \u0259n b\u00f6y\u00fck elementin siyah\u0131s\u0131n\u0131 yarad\u0131n.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n","canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"}
{"prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Verilmi\u015f s\u0259tirin palindrom olub-olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131n \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n","canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"}
{"prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Giri\u015f iki simvoldan ibar\u0259tdir: a v\u0259 b, yaln\u0131z 1 v\u0259 0-lardan ibar\u0259tdir.\n    Bu giri\u015fl\u0259r \u00fcz\u0259rind\u0259 ikilik XOR \u0259m\u0259liyyat\u0131 apar\u0131n v\u0259 n\u0259tic\u0259ni d\u0259 simvol kimi qaytar\u0131n.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n","canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n","test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"}
{"prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" S\u0259tirl\u0259r siyah\u0131s\u0131ndan \u0259n uzunu geri qaytar\u0131n. \u018fg\u0259r eyni uzunluqda bir ne\u00e7\u0259 s\u0259tir varsa, birinci s\u0259tiri geri qaytar\u0131n. \u018fg\u0259r giri\u015f siyah\u0131s\u0131 bo\u015fdursa, None qaytar\u0131n.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n","canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n","test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"}
{"prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \u0130ki tam \u0259d\u0259d a v\u0259 b-nin \u0259n b\u00f6y\u00fck ortaq b\u00f6l\u0259nini qaytar\u0131n.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n","canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n","test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"}
{"prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Giri\u015f s\u0259tirinin b\u00fct\u00fcn prefiksl\u0259rini \u0259n q\u0131sadan \u0259n uzuna q\u0259d\u0259r qaytar\u0131n.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n","canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n","test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"}
{"prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" 0-dan n-\u0259 q\u0259d\u0259r olan n\u00f6mr\u0259l\u0259ri bo\u015fluqlarla ay\u0131raraq bir s\u0259tird\u0259 qaytar\u0131n.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n","canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n","test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"}
{"prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Verilmi\u015f s\u0259tird\u0259 ne\u00e7\u0259 f\u0259rqli simvol oldu\u011funu tap\u0131n.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n","canonical_solution":"    return len(set(string.lower()))\n","test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"}
{"prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Bu funksiyaya daxil olan m\u0259lumat x\u00fcsusi ASCII format\u0131nda musiqi notlar\u0131n\u0131 t\u0259msil ed\u0259n bir s\u0259tirdir.\n    Sizin v\u0259zif\u0259niz bu s\u0259tri analiz etm\u0259k v\u0259 h\u0259r bir notun ne\u00e7\u0259 vur\u011fu s\u00fcrd\u00fcy\u00fcn\u00fc g\u00f6st\u0259r\u0259n tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131n\u0131 qaytarmaqd\u0131r.\n\n    Budur \u0259fsan\u0259:\n    'o' - tam not, d\u00f6rd vur\u011fu s\u00fcr\u00fcr\n    'o|' - yar\u0131m not, iki vur\u011fu s\u00fcr\u00fcr\n    '.|' - d\u00f6rdd\u0259bir not, bir vur\u011fu s\u00fcr\u00fcr\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n","canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n","test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"}
{"prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Verilmi\u015f alt s\u0259trin orijinal s\u0259trd\u0259 ne\u00e7\u0259 d\u0259f\u0259 tap\u0131ld\u0131\u011f\u0131n\u0131 m\u00fc\u0259yy\u0259n edin. \u00dcst-\u00fcst\u0259 d\u00fc\u015f\u0259n hallar\u0131 say\u0131n.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n","canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n","test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"}
{"prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Giri\u015f, 's\u0131f\u0131r'dan 'doqquz'a q\u0259d\u0259r r\u0259q\u0259ml\u0259rd\u0259n ibar\u0259t bo\u015fluqla ayr\u0131lm\u0131\u015f bir s\u0259tirdir.\n    Uy\u011fun se\u00e7iml\u0259r 's\u0131f\u0131r', 'bir', 'iki', '\u00fc\u00e7', 'd\u00f6rd', 'be\u015f', 'alt\u0131', 'yeddi', 's\u0259kkiz' v\u0259 'doqquz'dur.\n    R\u0259q\u0259ml\u0259ri ki\u00e7ikd\u0259n b\u00f6y\u00fcy\u0259 do\u011fru s\u0131ralanm\u0131\u015f qaydada qaytar\u0131n.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n","canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"}
{"prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Verilmi\u015f \u0259d\u0259dl\u0259r siyah\u0131s\u0131ndan bir-birin\u0259 \u0259n yax\u0131n olan iki \u0259d\u0259di se\u00e7in v\u0259 onlar\u0131 ard\u0131c\u0131l \u015f\u0259kild\u0259 qaytar\u0131n.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n","canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n","test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"}
{"prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Veril\u0259n r\u0259q\u0259ml\u0259r siyah\u0131s\u0131na x\u0259tti \u00e7evirm\u0259 t\u0259tbiq edin ki, \u0259n ki\u00e7ik r\u0259q\u0259m 0, \u0259n b\u00f6y\u00fck is\u0259 1 olsun.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n","canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n","test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"}
{"prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Veril\u0259n siyah\u0131n\u0131 yaln\u0131z tam \u0259d\u0259dl\u0259r \u00fc\u00e7\u00fcn python d\u0259y\u0259rl\u0259ri il\u0259 filtr edin.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n","canonical_solution":"    return [x for x in values if isinstance(x, int)]\n","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"}
{"prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Veril\u0259n s\u0259trin uzunlu\u011funu qaytar\u0131n.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n","canonical_solution":"    return len(string)\n","test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"}
{"prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Veril\u0259n n \u0259d\u0259din\u0259 g\u00f6r\u0259, n-d\u0259n ki\u00e7ik olan v\u0259 n-i tam b\u00f6l\u0259n \u0259n b\u00f6y\u00fck \u0259d\u0259di tap\u0131n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n","canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n","test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"}
{"prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Verilmi\u015f tam \u0259d\u0259din sad\u0259 vuruqlar\u0131n\u0131n siyah\u0131s\u0131n\u0131 ki\u00e7ikd\u0259n b\u00f6y\u00fcy\u0259 do\u011fru qaytar\u0131n. \n    H\u0259r bir vuruq faktorla\u015fmada ne\u00e7\u0259 d\u0259f\u0259 g\u00f6rs\u0259nirs\u0259, o q\u0259d\u0259r d\u0259f\u0259 siyah\u0131da g\u00f6st\u0259rilm\u0259lidir.\n    Giri\u015f \u0259d\u0259di b\u00fct\u00fcn vuruqlar\u0131n hasilin\u0259 b\u0259rab\u0259r olmal\u0131d\u0131r.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n","canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n","test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"}
{"prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Bir \u0259d\u0259d siyah\u0131s\u0131ndan bir d\u0259f\u0259d\u0259n \u00e7ox olan b\u00fct\u00fcn elementl\u0259ri \u00e7\u0131xar\u0131n.\n    Qalan elementl\u0259rin s\u0131ras\u0131n\u0131 daxil oldu\u011fu kimi saxlay\u0131n.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n","canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"}
{"prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Verilmi\u015f s\u0259tir \u00fc\u00e7\u00fcn, ki\u00e7ik h\u0259rfl\u0259ri b\u00f6y\u00fck h\u0259rfl\u0259r\u0259 v\u0259 b\u00f6y\u00fck h\u0259rfl\u0259ri ki\u00e7ik h\u0259rfl\u0259r\u0259 \u00e7evirin.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n","canonical_solution":"    return string.swapcase()\n","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"}
{"prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" S\u0259tirl\u0259rin siyah\u0131s\u0131n\u0131 t\u0259k bir s\u0259tr\u0259 birl\u0259\u015fdirin\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n","canonical_solution":"    return ''.join(strings)\n","test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"}
{"prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Bir giri\u015f s\u0259tirl\u0259r siyah\u0131s\u0131n\u0131 yaln\u0131z verilmi\u015f \u00f6n\u0259kl\u0259 ba\u015flayanlar \u00fc\u00e7\u00fcn s\u00fcz\u00fcn.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n","test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"}
{"prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Siyah\u0131dak\u0131 yaln\u0131z m\u00fcsb\u0259t \u0259d\u0259dl\u0259ri qaytar\u0131n.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n","canonical_solution":"    return [e for e in l if e > 0]\n","test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"}
{"prompt":"\n\ndef is_prime(n):\n    \"\"\"\u018fg\u0259r verilmi\u015f \u0259d\u0259d sad\u0259dirs\u0259, true qaytar\u0131n, \u0259ks halda false.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n","canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n","test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"}
{"prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u00c7oxh\u0259dliyi xs \u0259msallar\u0131 il\u0259 x n\u00f6qt\u0259sind\u0259 qiym\u0259tl\u0259ndirir.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n","canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n","test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"}
{"prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Bu funksiya l siyah\u0131s\u0131n\u0131 q\u0259bul edir v\u0259 l' siyah\u0131s\u0131n\u0131 qaytar\u0131r ki,\n    l' siyah\u0131s\u0131 l siyah\u0131s\u0131n\u0131n \u00fc\u00e7\u0259 b\u00f6l\u00fcnm\u0259y\u0259n indeksl\u0259rind\u0259 eynidir, lakin \u00fc\u00e7\u0259 b\u00f6l\u00fcn\u0259n indeksl\u0259rd\u0259ki d\u0259y\u0259rl\u0259r\n    uy\u011fun g\u0259l\u0259n indeksl\u0259rin d\u0259y\u0259rl\u0259rin\u0259 b\u0259rab\u0259rdir, ancaq \u00e7e\u015fidli olur.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n","canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n","test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"}
{"prompt":"\n\ndef unique(l: list):\n    \"\"\"Unikal elementl\u0259ri siyah\u0131da s\u0131rayla qaytar\u0131n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n","canonical_solution":"    return sorted(list(set(l)))\n","test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"}
{"prompt":"\n\ndef max_element(l: list):\n    \"\"\"Siyah\u0131dak\u0131 \u0259n b\u00f6y\u00fck elementi qaytar\u0131n.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n","canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n","test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"}
{"prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"R\u0259q\u0259ml\u0259ri 11 v\u0259 ya 13-\u0259 b\u00f6l\u00fcn\u0259n n-d\u0259n ki\u00e7ik olan tam \u0259d\u0259dl\u0259rd\u0259 7 r\u0259q\u0259minin ne\u00e7\u0259 d\u0259f\u0259 g\u00f6r\u00fcnd\u00fcy\u00fcn\u00fc qaytar\u0131n.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n","canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n","test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"}
{"prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Bu funksiya l siyah\u0131s\u0131n\u0131 q\u0259bul edir v\u0259 l' siyah\u0131s\u0131n\u0131 qaytar\u0131r ki,\n    l'in t\u0259k indeksl\u0259rind\u0259 l il\u0259 eynidir, c\u00fct indeksl\u0259rind\u0259ki d\u0259y\u0259rl\u0259ri is\u0259\n    l'in c\u00fct indeksl\u0259rinin d\u0259y\u0259rl\u0259rin\u0259 b\u0259rab\u0259rdir, lakin s\u0131raya d\u00fcz\u00fclm\u00fc\u015fd\u00fcr.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n","canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n","test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"}
{"prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    qruplar \u00fc\u00e7 h\u0259rfd\u0259n ibar\u0259t olan kodla\u015fd\u0131r\u0131lm\u0131\u015f s\u0259tir qaytar\u0131r.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n","canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n","test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"}
{"prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib n-ci Fibonacci \u0259d\u0259di olan v\u0259 eyni zamanda sad\u0259 \u0259d\u0259d olan \u0259d\u0259di qaytar\u0131r.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n","canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n","test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"}
{"prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t bir siyah\u0131n\u0131 giri\u015f kimi q\u0259bul edir.\n    \u018fg\u0259r siyah\u0131da c\u0259mi s\u0131f\u0131r olan \u00fc\u00e7 f\u0259rqli element varsa, True qaytar\u0131r, \u0259ks halda False qaytar\u0131r.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n","test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"}
{"prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    T\u0259s\u0259vv\u00fcr edin ki, bir yol tamamil\u0259 d\u00fcz v\u0259 sonsuz uzun bir x\u0259ttdir. \nn avtomobil soldan sa\u011fa, eyni zamanda ba\u015fqa bir n avtomobil sa\u011fdan sola s\u00fcr\u00fcr. \nH\u0259r iki avtomobil d\u0259st\u0259si bir-birind\u0259n \u00e7ox uzaq ba\u015flay\u0131r. \nB\u00fct\u00fcn avtomobill\u0259r eyni s\u00fcr\u0259td\u0259 h\u0259r\u0259k\u0259t edir. Bir avtomobil soldan sa\u011fa h\u0259r\u0259k\u0259t ed\u0259n avtomobil sa\u011fdan sola h\u0259r\u0259k\u0259t ed\u0259n avtomobili vurduqda, toqqu\u015fma ba\u015f verir. \nLakin, avtomobill\u0259r sonsuz d\u0259r\u0259c\u0259d\u0259 m\u00f6hk\u0259m v\u0259 g\u00fccl\u00fcd\u00fcr; buna g\u00f6r\u0259 d\u0259 onlar toqqu\u015fmam\u0131\u015f kimi trayektoriyalar\u0131nda h\u0259r\u0259k\u0259t etm\u0259y\u0259 davam edirl\u0259r.\n\nBu funksiya bel\u0259 toqqu\u015fmalar\u0131n say\u0131n\u0131 \u00e7\u0131xar\u0131r.\n    \"\"\"\n","canonical_solution":"    return n**2\n","test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"}
{"prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Elementl\u0259ri 1 art\u0131r\u0131lm\u0131\u015f siyah\u0131n\u0131 qaytar\u0131n.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n","canonical_solution":"    return [(e + 1) for e in l]\n","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"}
{"prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero bir tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131n\u0131 giri\u015f kimi q\u0259bul edir.\n    siyah\u0131da c\u0259mi s\u0131f\u0131r olan iki f\u0259rqli element varsa, True qaytar\u0131r,\n    \u0259ks halda False qaytar\u0131r.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n","test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"}
{"prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Giri\u015f n\u00f6mr\u0259si x-i t\u0259m\u0259l baza il\u0259 d\u0259yi\u015fdirin.\n    Konversiyadan sonra s\u0259tir t\u0259svirini qaytar\u0131n.\n    Baza n\u00f6mr\u0259l\u0259ri 10-dan azd\u0131r.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n","canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n","test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"}
{"prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Bir \u00fc\u00e7buca\u011f\u0131n t\u0259r\u0259finin uzunlu\u011fu v\u0259 h\u00fcnd\u00fcrl\u00fcy\u00fc verildikd\u0259 sah\u0259ni qaytar.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n","canonical_solution":"    return a * h \/ 2.0\n","test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"}
{"prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 r\u0259q\u0259m s\u0131ras\u0131, Fibbonacci s\u0131ras\u0131na b\u0259nz\u0259y\u0259n v\u0259 a\u015fa\u011f\u0131dak\u0131 kimi m\u00fc\u0259yy\u0259n edil\u0259n bir s\u0131ra:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    Xahi\u015f edir\u0259m, fib4 r\u0259q\u0259m s\u0131ras\u0131n\u0131n n-ci elementini s\u0259m\u0259r\u0259li \u015f\u0259kild\u0259 hesablayan bir funksiyan\u0131 yaz\u0131n. T\u0259krarlamadan istifad\u0259 etm\u0259yin.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n","canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n","test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"}
{"prompt":"\n\ndef median(l: list):\n    \"\"\"Siyah\u0131dak\u0131 elementl\u0259rin median\u0131n\u0131 qaytar.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n","canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n","test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"}
{"prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Verilmi\u015f s\u0259tirin palindrom olub-olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131r\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n","test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"}
{"prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"2^n modulu p qaytar.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n","canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n","test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"}
{"prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    H\u0259r bir xarakteri \u0259lifbada 5 h\u0259rf ir\u0259li \u00e7\u0259k\u0259r\u0259k kodlanm\u0131\u015f s\u0259tir qaytar\u0131r.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n","canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n","test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"}
{"prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels, s\u0259tir q\u0259bul ed\u0259n v\u0259 saitl\u0259rsiz s\u0259tir qaytaran bir funksiyad\u0131r.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n","canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"}
{"prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"\u018fg\u0259r l siyah\u0131s\u0131ndak\u0131 b\u00fct\u00fcn r\u0259q\u0259ml\u0259r t h\u0259ddind\u0259n a\u015fa\u011f\u0131d\u0131rsa, True qaytar.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n","canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n","test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"}
{"prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"\u0130ki \u0259d\u0259di x v\u0259 y \u0259lav\u0259 edin\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n","canonical_solution":"    return x + y\n","test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"}
{"prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    \u0130ki s\u00f6z\u00fcn eyni simvollara malik oldu\u011funu yoxlay\u0131n.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n","canonical_solution":"    return set(s0) == set(s1)\n","test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"}
{"prompt":"\n\ndef fib(n: int):\n    \"\"\"n-ci Fibonacci say\u0131n\u0131 qaytar\u0131n.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n","test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"}
{"prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" M\u00f6t\u0259riz\u0259l\u0259r \"<\" v\u0259 \">\" simvollar\u0131ndan ibar\u0259tdir.\n    H\u0259r a\u00e7\u0131lan m\u00f6t\u0259riz\u0259 \u00fc\u00e7\u00fcn uy\u011fun ba\u011flanan m\u00f6t\u0259riz\u0259 varsa, True qaytar.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"}
{"prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Listin elementl\u0259ri monoton \u015f\u0259kild\u0259 artarsa v\u0259 ya azalarsa True qaytar.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n","canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n","test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"}
{"prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u0130ki siyah\u0131da olan t\u0259krarlanmayan ortaq elementl\u0259ri s\u0131ralanm\u0131\u015f qaydada qaytar.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n","canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n","test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"}
{"prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"n-in \u0259n b\u00f6y\u00fck sad\u0259 vuru\u011funu qaytar\u0131n. F\u0259rz edin ki, n > 1 v\u0259 sad\u0259 \u0259d\u0259d deyil.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n","canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n","test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"}
{"prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 1-d\u0259n n-\u0259 q\u0259d\u0259r olan \u0259d\u0259dl\u0259ri toplayan bir funksiyad\u0131r.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n","canonical_solution":"    return sum(range(n + 1))\n","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"}
{"prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" M\u00f6t\u0259riz\u0259l\u0259r \"\" simvollar\u0131n\u0131n birl\u0259\u015fm\u0259sidir.\n    H\u0259r a\u00e7\u0131q m\u00f6t\u0259riz\u0259nin uy\u011fun ba\u011flanan m\u00f6t\u0259riz\u0259si varsa, True qaytar.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"}
{"prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u00e7oxh\u0259dlinin \u0259msallar\u0131n\u0131 t\u0259msil edir.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Bu \u00e7oxh\u0259dlinin t\u00fcrevini eyni formada qaytar\u0131n.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n","canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n","test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"}
{"prompt":"\n\ndef fibfib(n: int):\n    \"\"\"FibFib n\u00f6mr\u0259 ard\u0131c\u0131ll\u0131\u011f\u0131 Fibbonacci ard\u0131c\u0131ll\u0131\u011f\u0131na b\u0259nz\u0259r bir ard\u0131c\u0131ll\u0131qd\u0131r v\u0259 a\u015fa\u011f\u0131dak\u0131 kimi t\u0259yin olunur:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Z\u0259hm\u0259t olmasa, fibfib n\u00f6mr\u0259 ard\u0131c\u0131ll\u0131\u011f\u0131n\u0131n n-ci elementini s\u0259m\u0259r\u0259li \u015f\u0259kild\u0259 hesablayan bir funksiya yaz\u0131n.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n","test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"}
{"prompt":"\nFIX = \"\"\"\nDaha \u00e7ox test hallar\u0131 \u0259lav\u0259 edin.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Tam \u0259d\u0259d x-in r\u0259q\u0259ml\u0259rini dair\u0259vi \u015f\u0259kild\u0259 d\u0259yi\u015fin, r\u0259q\u0259ml\u0259ri sa\u011fa shift q\u0259d\u0259r d\u0259yi\u015fin v\u0259 n\u0259tic\u0259ni s\u0259tir kimi qaytar\u0131n.\n    \u018fg\u0259r shift r\u0259q\u0259ml\u0259rin say\u0131ndan \u00e7oxdursa, r\u0259q\u0259ml\u0259ri t\u0259rsin\u0259 qaytar\u0131n.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n","canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef digitSum(s):\n    \"\"\"Tap\u015f\u0131r\u0131q\n    M\u0259tni giri\u015f kimi q\u0259bul ed\u0259n v\u0259 yaln\u0131z b\u00f6y\u00fck h\u0259rfl\u0259rin ASCII kodlar\u0131n\u0131n c\u0259mini qaytaran funksiya yaz\u0131n.\n\n    N\u00fcmun\u0259l\u0259r:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153\n    \"\"\"\n","canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"}
{"prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Bu tap\u015f\u0131r\u0131qda, meyv\u0259 s\u0259b\u0259tind\u0259 paylanm\u0131\u015f almalar\u0131n v\u0259 porta\u011fallar\u0131n say\u0131n\u0131 g\u00f6st\u0259r\u0259n bir s\u0259tir veril\u0259c\u0259k. Bu s\u0259b\u0259t\u0259 almalar, porta\u011fallar v\u0259 manqo meyv\u0259l\u0259ri daxildir. Veril\u0259n s\u0259tir almalar\u0131n v\u0259 porta\u011fallar\u0131n \u00fcmumi say\u0131n\u0131, tam \u0259d\u0259d is\u0259 s\u0259b\u0259td\u0259ki meyv\u0259l\u0259rin \u00fcmumi say\u0131n\u0131 g\u00f6st\u0259rir. S\u0259b\u0259td\u0259ki manqo meyv\u0259l\u0259rinin say\u0131n\u0131 qaytar\u0131n.\nM\u0259s\u0259l\u0259n:\nfruit_distribution -> 19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n","canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"}
{"prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Bir a\u011fac\u0131n qeyri-m\u0259nfi tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t olan buda\u011f\u0131n\u0131 t\u0259msil ed\u0259n array verildikd\u0259, \n    sizin v\u0259zif\u0259niz d\u00fcy\u00fcnl\u0259rd\u0259n birini qoparmaq v\u0259 geri qaytarmaqd\u0131r.\n    Qopar\u0131lm\u0131\u015f d\u00fcy\u00fcn \u0259n ki\u00e7ik c\u00fct d\u0259y\u0259ri olan d\u00fcy\u00fcn olmal\u0131d\u0131r.\n    \u018fg\u0259r eyni \u0259n ki\u00e7ik c\u00fct d\u0259y\u0259r\u0259 malik bir ne\u00e7\u0259 d\u00fcy\u00fcn tap\u0131larsa, \u0259n ki\u00e7ik index\u0259 malik olan d\u00fcy\u00fcn geri qaytar\u0131lmal\u0131d\u0131r.\n\n    Qopar\u0131lm\u0131\u015f d\u00fcy\u00fcn [ \u0259n ki\u00e7ik d\u0259y\u0259r, onun indexi ] format\u0131nda siyah\u0131 kimi geri qaytar\u0131lmal\u0131d\u0131r.\n    \u018fg\u0259r he\u00e7 bir c\u00fct d\u0259y\u0259r yoxdursa v\u0259 ya verilmi\u015f array bo\u015fdursa, [] qaytar\u0131n.\n\n    Misal1:\n        Giri\u015f: [4,2,3]\n        \u00c7\u0131x\u0131\u015f: [2, 1]\n        \u0130zah: 2 \u0259n ki\u00e7ik c\u00fct d\u0259y\u0259r\u0259 malikdir v\u0259 2 \u0259n ki\u00e7ik index\u0259 malikdir.\n\n    Misal2:\n        Giri\u015f: [1,2,3]\n        \u00c7\u0131x\u0131\u015f: [2, 1]\n        \u0130zah: 2 \u0259n ki\u00e7ik c\u00fct d\u0259y\u0259r\u0259 malikdir v\u0259 2 \u0259n ki\u00e7ik index\u0259 malikdir. \n\n    Misal3:\n        Giri\u015f: []\n        \u00c7\u0131x\u0131\u015f: []\n\n    Misal4:\n        Giri\u015f: [5, 0, 3, 0, 4, 2]\n        \u00c7\u0131x\u0131\u015f: [0, 1]\n        \u0130zah: 0 \u0259n ki\u00e7ik d\u0259y\u0259r\u0259 malikdir, lakin iki s\u0131f\u0131r var,\n                     buna g\u00f6r\u0259 ilk s\u0131f\u0131r se\u00e7il\u0259c\u0259k, hans\u0131 ki \u0259n ki\u00e7ik index\u0259 malikdir.\n\n    M\u0259hdudiyy\u0259tl\u0259r:\n        * 1 <= d\u00fcy\u00fcnl\u0259rin uzunlu\u011fu <= 10000\n        * 0 <= d\u00fcy\u00fcn d\u0259y\u0259ri\"\n    \"\"\"\n","canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"}
{"prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n","canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n","test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"}
{"prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n","canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n","canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"}
{"prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n","canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"}
{"prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Verilmi\u015f tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t arr massivind\u0259 massiv\u0259 palindromik etm\u0259k \u00fc\u00e7\u00fcn d\u0259yi\u015fdirilm\u0259si laz\u0131m olan minimum element say\u0131n\u0131 tap\u0131n. Palindromik massiv, geriy\u0259 v\u0259 ir\u0259liy\u0259 eyni oxunan massivdir. Bir d\u0259yi\u015fiklikd\u0259 bir elementi ba\u015fqa bir element\u0259 d\u0259yi\u015f\u0259 bil\u0259rsiniz.\n\nM\u0259s\u0259l\u0259n:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n","canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"}
{"prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n","canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"}
{"prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Verilmi\u015f \u0259d\u0259din 3 sad\u0259 \u0259d\u0259din hasilin\u0259 b\u0259rab\u0259r olub olmad\u0131\u011f\u0131n\u0131 yoxlayan v\u0259 d\u00fczg\u00fcn olduqda do\u011fru, \n\u0259ks halda yaln\u0131\u015f qaytaran bir funksiya yaz\u0131n. 100-d\u0259n ki\u00e7ik oldu\u011funu bilin.\nMisal:\nis_multiply_prime == D\u00fczg\u00fcn\n30 = 2 * 3 * 5\n    \"\"\"\n","canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n","test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"}
{"prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Sizin v\u0259zif\u0259niz el\u0259 bir funksiyan\u0131 yazmaqd\u0131r ki, \u0259g\u0259r x r\u0259q\u0259mi n-in sad\u0259 q\u00fcvv\u0259sidirs\u0259, true qaytars\u0131n v\u0259 dig\u0259r hallarda false qaytars\u0131n.\n    x yaln\u0131z o halda n-in sad\u0259 q\u00fcvv\u0259sidir ki, n**int=x olsun\n    M\u0259s\u0259l\u0259n:\n    is_simple_power => true\n    is_simple_power => true\n    is_simple_power => true\n    is_simple_power => false\n    is_simple_power => false\n    is_simple_power => false\n    \"\"\"\n","canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n","canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"}
{"prompt":"\ndef hex_key(num):\n    \"\"\"Siz\u0259 veril\u0259n tap\u015f\u0131r\u0131q bir funksiya yazmaqd\u0131r ki, bu funksiya onalt\u0131l\u0131q r\u0259q\u0259mi s\u0259tir kimi q\u0259bul edir v\u0259 onalt\u0131l\u0131q r\u0259q\u0259ml\u0259rd\u0259n ne\u00e7\u0259 d\u0259n\u0259sinin sad\u0259 r\u0259q\u0259m oldu\u011funu hesablay\u0131r.\nOnalt\u0131l\u0131q r\u0259q\u0259ml\u0259r bunlard\u0131r: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nSad\u0259 \u0259d\u0259dl\u0259r bunlard\u0131r: 2, 3, 5, 7, 11, 13, 17,...\nBel\u0259likl\u0259, siz a\u015fa\u011f\u0131dak\u0131 r\u0259q\u0259ml\u0259rin say\u0131n\u0131 m\u00fc\u0259yy\u0259n etm\u0259lisiniz: 2, 3, 5, 7, B, D.\nQeyd: siz giri\u015fin h\u0259mi\u015f\u0259 d\u00fczg\u00fcn oldu\u011funu v\u0259 ya bo\u015f s\u0259tir oldu\u011funu q\u0259bul ed\u0259 bil\u0259rsiniz,\nv\u0259 A, B, C, D, E, F simvollar\u0131n\u0131n h\u0259mi\u015f\u0259 b\u00f6y\u00fck h\u0259rfl\u0259 yaz\u0131ld\u0131\u011f\u0131n\u0131 q\u0259bul ed\u0259 bil\u0259rsiniz.\nMisallar:\nNum = \"AB\" \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 1 olmal\u0131d\u0131r.\nNum = \"1077E\" \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 2 olmal\u0131d\u0131r.\nNum = \"ABED1A33\" \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 4 olmal\u0131d\u0131r.\nNum = \"123456789ABCDEF0\" \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 6 olmal\u0131d\u0131r.\nNum = \"2020\" \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 2 olmal\u0131d\u0131r.\n    \"\"\"\n","canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"}
{"prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Siz\u0259 onluq formada bir r\u0259q\u0259m veril\u0259c\u0259k v\u0259 sizin v\u0259zif\u0259niz onu ikilik formata \u00e7evirm\u0259kdir. Funksiya bir string qaytarmal\u0131d\u0131r v\u0259 h\u0259r bir simvol ikilik r\u0259q\u0259mi t\u0259msil etm\u0259lidir. Stringd\u0259ki h\u0259r bir simvol '0' v\u0259 ya '1' olacaq.\n\nStringin \u0259vv\u0259lind\u0259 v\u0259 sonunda \u0259lav\u0259 olaraq 'db' simvollar\u0131 olacaq. \u018flav\u0259 simvollar formatla ba\u011fl\u0131 k\u00f6m\u0259k etm\u0259k \u00fc\u00e7\u00fcn oradad\u0131r.\n\nN\u00fcmun\u0259l\u0259r:\ndecimal_to_binary   # \"db1111db\" qaytar\u0131r\ndecimal_to_binary   # \"db100000db\" qaytar\u0131r\n    \"\"\"\n","canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef is_happy(s):\n    \"\"\"Siz\u0259 bir s s\u0259tir verilir.\n    Sizin v\u0259zif\u0259niz bu s\u0259tirin xo\u015fb\u0259xt olub olmad\u0131\u011f\u0131n\u0131 yoxlamaqd\u0131r.\n    Bir s\u0259tir, uzunlu\u011fu \u0259n az\u0131 3 olarsa v\u0259 h\u0259r 3 ard\u0131c\u0131l h\u0259rf f\u0259rqli olarsa, xo\u015fb\u0259xt hesab olunur.\n    M\u0259s\u0259l\u0259n:\n    is_happy => Yanl\u0131\u015f\n    is_happy => Yanl\u0131\u015f\n    is_happy => Do\u011fru\n    is_happy => Yanl\u0131\u015f\n    is_happy => Do\u011fru\n    is_happy => Yanl\u0131\u015f\n    \"\"\"\n","canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"}
{"prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Bu semestrin son h\u0259ft\u0259sidir v\u0259 m\u00fc\u0259llim t\u0259l\u0259b\u0259l\u0259r\u0259 qiym\u0259tl\u0259ri verm\u0259lidir. M\u00fc\u0259llim qiym\u0259tl\u0259ndirm\u0259 \u00fc\u00e7\u00fcn \u00f6z alqoritmini yarad\u0131b. Yegan\u0259 problem odur ki, o qiym\u0259tl\u0259ndirm\u0259 \u00fc\u00e7\u00fcn istifad\u0259 etdiyi kodu itirib. O siz\u0259 b\u0259zi t\u0259l\u0259b\u0259l\u0259rin GPA siyah\u0131s\u0131n\u0131 verib v\u0259 sizd\u0259n a\u015fa\u011f\u0131dak\u0131 c\u0259dv\u0259ld\u0259n istifad\u0259 ed\u0259r\u0259k h\u0259rf qiym\u0259tl\u0259rini \u00e7\u0131xara bil\u0259n bir funksiya yazma\u011f\u0131n\u0131z\u0131 ist\u0259yir:\n\nGPA       |    H\u0259rf qiym\u0259ti\n4.0                A+\n> 3.7              A \n> 3.3              A- \n> 3.0              B+\n> 2.7              B \n> 2.3              B-\n> 2.0              C+\n> 1.7              C\n> 1.3              C-\n> 1.0              D+ \n> 0.7              D \n> 0.0              D-\n0.0                E\n\nN\u00fcmun\u0259:\ngrade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n","canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef prime_length(string):\n    \"\"\"Bir s\u0259trin uzunlu\u011funun sad\u0259 \u0259d\u0259d olub-olmad\u0131\u011f\u0131n\u0131 yoxlayan v\u0259 True v\u0259 ya False qaytaran funksiyan\u0131 yaz\u0131n.\nMisallar\nprime_length == True\nprime_length == True\nprime_length == True\nprime_length == False\n    \"\"\"\n","canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"}
{"prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    M\u00fcsb\u0259t tam \u0259d\u0259d n verildikd\u0259, 1 il\u0259 ba\u015flayan v\u0259 ya bit\u0259n n r\u0259q\u0259mli m\u00fcsb\u0259t \u0259d\u0259dl\u0259rin say\u0131n\u0131 qaytar\u0131n.\n    \"\"\"\n","canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef solve(N):\n    \"\"\"M\u00fcsb\u0259t tam \u0259d\u0259d N verildikd\u0259, onun r\u0259q\u0259ml\u0259rinin c\u0259minin ikilikd\u0259 ifad\u0259sini qaytar\u0131n.\n\n    N\u00fcmun\u0259\n        N = 1000 olduqda, r\u0259q\u0259ml\u0259rin c\u0259mi 1 olacaq v\u0259 n\u0259tic\u0259 \"1\" olmal\u0131d\u0131r.\n        N = 150 olduqda, r\u0259q\u0259ml\u0259rin c\u0259mi 6 olacaq v\u0259 n\u0259tic\u0259 \"110\" olmal\u0131d\u0131r.\n        N = 147 olduqda, r\u0259q\u0259ml\u0259rin c\u0259mi 12 olacaq v\u0259 n\u0259tic\u0259 \"1100\" olmal\u0131d\u0131r.\n\n    D\u0259yi\u015f\u0259nl\u0259r:\n        @N tam \u0259d\u0259d\n             M\u0259hdudiyy\u0259tl\u0259r: 0 \u2264 N \u2264 10000.\n    N\u0259tic\u0259:\n         ikilik \u0259d\u0259din s\u0259tir ifad\u0259si\n    \"\"\"\n","canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"}
{"prompt":"\ndef add(lst):\n    \"\"\"Veril\u0259n bo\u015f olmayan tam \u0259d\u0259d siyah\u0131s\u0131 lst. Tek indekslerde olan c\u00fct elementl\u0259ri topla.\n\n    N\u00fcmun\u0259l\u0259r:\n        add ==> 2 \n    \"\"\"\n","canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"}
{"prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Bir s\u0259tri q\u0259bul ed\u0259n v\u0259 onun s\u0131ralanm\u0131\u015f versiyas\u0131n\u0131 qaytaran bir funksiya yaz\u0131n.\n    S\u0259trin s\u0131ralanm\u0131\u015f versiyas\u0131, b\u00fct\u00fcn s\u00f6zl\u0259rin \n    yeni bir s\u00f6zl\u0259 \u0259v\u0259z olundu\u011fu bir s\u0259tdir. Burada b\u00fct\u00fcn simvollar\n    ASCII d\u0259y\u0259rin\u0259 \u0259sas\u0259n artan qaydada yerl\u0259\u015fdirilir.\n    Qeyd: C\u00fcml\u0259d\u0259ki s\u00f6zl\u0259rin s\u0131ras\u0131n\u0131 v\u0259 bo\u015fluqlar\u0131 saxlamal\u0131s\u0131n\u0131z.\n\n    M\u0259s\u0259l\u0259n:\n    anti_shuffle 'Hi' qaytar\u0131r\n    anti_shuffle 'ehllo' qaytar\u0131r\n    anti_shuffle 'Hello !!!Wdlor' qaytar\u0131r\n    \"\"\"\n","canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Siz\u0259 iki \u00f6l\u00e7\u00fcl\u00fc m\u0259lumat verilir, i\u00e7-i\u00e7\u0259 siyah\u0131lar \u015f\u0259klind\u0259,\n    matrisl\u0259r\u0259 b\u0259nz\u0259yir, lakin matrisl\u0259rd\u0259n f\u0259rqli olaraq,\n    h\u0259r s\u0259tir f\u0259rqli sayda s\u00fctunlar ehtiva ed\u0259 bil\u0259r.\n    Veril\u0259n lst v\u0259 tam \u0259d\u0259d x n\u0259z\u0259r\u0259 alaraq, siyah\u0131da x tam \u0259d\u0259dl\u0259rini tap\u0131n\n    v\u0259 koordinatlar siyah\u0131s\u0131n\u0131 qaytar\u0131n, [, ...] bel\u0259 ki,\n    h\u0259r bir tuple koordinatd\u0131r -, 0-dan ba\u015flayaraq.\n    Koordinatlar\u0131 ilkin olaraq s\u0259tirl\u0259r\u0259 g\u00f6r\u0259 artma s\u0131ras\u0131 il\u0259 \u00e7e\u015fidl\u0259yin.\n    H\u0259m\u00e7inin, s\u0259tirl\u0259rin koordinatlar\u0131n\u0131 s\u00fctunlara g\u00f6r\u0259 azalma s\u0131ras\u0131 il\u0259 \u00e7e\u015fidl\u0259yin.\n    \n    N\u00fcmun\u0259l\u0259r:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [,,,,]\n    get_row == []\n    get_row == []\n    \"\"\"\n","canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef sort_array(array):\n    \"\"\"\n    A\u015fa\u011f\u0131dak\u0131 c\u00fcml\u0259ni \u015eimali Az\u0259rbaycan dilin\u0259 t\u0259rc\u00fcm\u0259 edin.\n\nVeril\u0259n m\u0259nfi olmayan tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t bir array\u0131 n\u0259z\u0259r\u0259 alaraq, verilmi\u015f array\u0131n kopyas\u0131n\u0131 \u00e7e\u015fidl\u0259dikd\u0259n sonra qaytar\u0131n,\nsiz verilmi\u015f array\u0131 artan s\u0131raya g\u00f6r\u0259 \u00e7e\u015fidl\u0259y\u0259c\u0259ksiniz, \u0259g\u0259r c\u0259mi t\u0259kdirs\u0259,\nyoxsa \u0259g\u0259r c\u0259mi c\u00fctd\u00fcrs\u0259, onu azalan s\u0131raya g\u00f6r\u0259 \u00e7e\u015fidl\u0259yin.\n\nQeyd:\n* verilmi\u015f array\u0131 d\u0259yi\u015fm\u0259yin.\n\nMisallar:\n* sort_array => []\n* sort_array => [5]\n* sort_array => [0, 1, 2, 3, 4, 5]\n* sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n","canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"}
{"prompt":"\ndef encrypt(s):\n    \"\"\"Bir funksiyan\u0131 encrypt adland\u0131rmaq v\u0259 \n    arqument kimi bir s\u0259tir q\u0259bul etm\u0259k v\u0259 \n    \u0259lifban\u0131 d\u00f6nd\u0259rm\u0259k \u00fc\u00e7\u00fcn \u015fifrl\u0259nmi\u015f bir s\u0259tir qaytarmaq laz\u0131md\u0131r. \n    \u018flifba el\u0259 bir \u015f\u0259kild\u0259 d\u00f6nd\u0259rilm\u0259lidir ki, h\u0259rfl\u0259r iki vurulmu\u015f iki yer\u0259 \n    a\u015fa\u011f\u0131ya do\u011fru h\u0259r\u0259k\u0259t etsin.\n    M\u0259s\u0259l\u0259n:\n    encrypt 'lm' qaytar\u0131r\n    encrypt 'ewhjklnop' qaytar\u0131r\n    encrypt 'kj' qaytar\u0131r\n    encrypt 'ix' qaytar\u0131r\n    \"\"\"\n","canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Siz\u0259 tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t bir siyah\u0131 verilir.\n    next_smallest adl\u0131 bir funksiya yaz\u0131n ki, bu funksiya siyah\u0131n\u0131n ikinci \u0259n ki\u00e7ik elementini qaytars\u0131n.\n    \u018fg\u0259r bel\u0259 bir element yoxdursa, None qaytar\u0131n.\n    \n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n","canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef is_bored(S):\n    \"\"\"\n    Siz\u0259 s\u00f6zl\u0259rd\u0259n ibar\u0259t bir c\u00fcml\u0259 veril\u0259c\u0259k v\u0259 sizin v\u0259zif\u0259niz \"darixmalar\u0131n\" say\u0131n\u0131 hesablamaq olacaq. \"Darixma\" \"M\u0259n\" s\u00f6z\u00fc il\u0259 ba\u015flayan c\u00fcml\u0259dir. C\u00fcml\u0259l\u0259r '.', '?' v\u0259 ya '!' il\u0259 ayr\u0131l\u0131r.\n\nM\u0259s\u0259l\u0259n:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n","canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n","canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef encode(message):\n    \"\"\"\n    Bir funksiya yaz\u0131n ki, o mesaj\u0131 el\u0259 bir \u015f\u0259kild\u0259 \u015fifr\u0259l\u0259sin ki, b\u00fct\u00fcn h\u0259rfl\u0259rin registrini d\u0259yi\u015fsin v\u0259 mesajdak\u0131 b\u00fct\u00fcn saitl\u0259ri ingilis \u0259lifbas\u0131nda h\u0259min saitd\u0259n 2 yer qabaqda olan h\u0259rfl\u0259 \u0259v\u0259z etsin.\nYaln\u0131z h\u0259rfl\u0259r oldu\u011funu q\u0259bul edin.\n\nN\u00fcmun\u0259l\u0259r:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Siz\u0259 bir tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131 verilib.\n\u018fn b\u00f6y\u00fck sad\u0259 \u0259d\u0259d tapmal\u0131 v\u0259 onun r\u0259q\u0259ml\u0259rinin c\u0259mini qaytarmal\u0131s\u0131n\u0131z.\n\nN\u00fcmun\u0259l\u0259r:\nSiyah\u0131 lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 10 olmal\u0131d\u0131r.\nSiyah\u0131 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 25 olmal\u0131d\u0131r.\nSiyah\u0131 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 13 olmal\u0131d\u0131r.\nSiyah\u0131 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 11 olmal\u0131d\u0131r.\nSiyah\u0131 lst = [0,81,12,3,1,21] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 3 olmal\u0131d\u0131r.\nSiyah\u0131 lst = [0,8,1,2,1,7] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 7 olmal\u0131d\u0131r.\n    \"\"\"\n","canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"}
{"prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Bir l\u00fc\u011f\u0259t verildikd\u0259, \u0259g\u0259r b\u00fct\u00fcn a\u00e7arlar ki\u00e7ik h\u0259rfl\u0259rl\u0259 olan s\u0259tirl\u0259rdirs\u0259 v\u0259 ya b\u00fct\u00fcn a\u00e7arlar b\u00f6y\u00fck h\u0259rfl\u0259rl\u0259 olan s\u0259tirl\u0259rdirs\u0259, True qaytar, \u0259ks halda False qaytar.\n\u018fg\u0259r verilmi\u015f l\u00fc\u011f\u0259t bo\u015fdursa, funksiya False qaytarmal\u0131d\u0131r.\nN\u00fcmun\u0259l\u0259r:\ncheck_dict_case True qaytarmal\u0131d\u0131r.\ncheck_dict_case False qaytarmal\u0131d\u0131r.\ncheck_dict_case False qaytarmal\u0131d\u0131r.\ncheck_dict_case False qaytarmal\u0131d\u0131r.\ncheck_dict_case True qaytarmal\u0131d\u0131r.\n    \"\"\"\n","canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"}
{"prompt":"\ndef count_up_to(n):\n    \"\"\"Funksiyan\u0131 icra edin ki, qeyri-m\u0259nfi tam \u0259d\u0259d q\u0259bul edir v\u0259 n-d\u0259n ki\u00e7ik olan ilk n sad\u0259 \u0259d\u0259din massivini qaytar\u0131r.\nM\u0259s\u0259l\u0259n:\ncount_up_to => [2,3]\ncount_up_to => [2,3,5,7]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17,19]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n","canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n","test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"}
{"prompt":"\ndef multiply(a, b):\n    \"\"\"Funksiyan\u0131 tamamlay\u0131n ki, iki tam \u0259d\u0259d q\u0259bul edir v\u0259 onlar\u0131n vahidl\u0259r r\u0259q\u0259ml\u0259rinin hasilini qaytar\u0131r.\n    Daxilolman\u0131n h\u0259mi\u015f\u0259 d\u00fczg\u00fcn oldu\u011funu f\u0259rz edin.\n    N\u00fcmun\u0259l\u0259r:\n    multiply 16 qaytarmal\u0131d\u0131r.\n    multiply 72 qaytarmal\u0131d\u0131r.\n    multiply 0 qaytarmal\u0131d\u0131r.\n    multiply 20 qaytarmal\u0131d\u0131r.\n    \"\"\"\n","canonical_solution":"    return abs(a % 10) * abs(b % 10)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"}
{"prompt":"\ndef count_upper(s):\n    \"\"\"\n    Verilmi\u015f s s\u0259tirind\u0259, c\u00fct indeksl\u0259rd\u0259 olan b\u00f6y\u00fck samitl\u0259rin say\u0131n\u0131 hesablay\u0131n.\n\n    M\u0259s\u0259l\u0259n:\n    count_upper 1 qaytar\u0131r\n    count_upper 0 qaytar\u0131r\n    count_upper 0 qaytar\u0131r\n    \"\"\"\n","canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n","canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"}
{"prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    M\u00fcsb\u0259t tam \u0259d\u0259d n verildikd\u0259, n s\u0259viyy\u0259li da\u015f y\u0131\u011f\u0131n\u0131 d\u00fcz\u0259ltm\u0259lisiniz.\n    Birinci s\u0259viyy\u0259d\u0259 n da\u015f var.\n    N\u00f6vb\u0259ti s\u0259viyy\u0259d\u0259ki da\u015flar\u0131n say\u0131:\n        - \u0259g\u0259r n t\u0259kdirs\u0259, n\u00f6vb\u0259ti t\u0259k \u0259d\u0259d.\n        - \u0259g\u0259r n c\u00fctd\u00fcrs\u0259, n\u00f6vb\u0259ti c\u00fct \u0259d\u0259d.\n    H\u0259r s\u0259viyy\u0259d\u0259ki da\u015flar\u0131n say\u0131n\u0131 bir siyah\u0131da qaytar\u0131n, burada i indeksind\u0259ki element s\u0259viyy\u0259sind\u0259ki da\u015flar\u0131n say\u0131n\u0131 g\u00f6st\u0259rir.\n\n    Misallar:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n","canonical_solution":"    return [n + 2*i for i in range(n)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef words_string(s):\n    \"\"\"\n    Siz\u0259 verg\u00fcll\u0259r v\u0259 ya bo\u015fluqlar il\u0259 ayr\u0131lm\u0131\u015f s\u00f6zl\u0259rd\u0259n ibar\u0259t bir s\u0259tir veril\u0259c\u0259k. Sizin v\u0259zif\u0259niz\n    s\u0259tiri s\u00f6zl\u0259r\u0259 b\u00f6lm\u0259k v\u0259 s\u00f6zl\u0259rin massivini qaytarmaqd\u0131r.\n    \n    M\u0259s\u0259l\u0259n:\n    s\u00f6z\u00fc_b\u00f6l == [\"Salam\", \"m\u0259nim\", \"ad\u0131m\", \"C\u00f6vh\u0259rdir\"]\n    s\u00f6z\u00fc_b\u00f6l == [\"Bir\", \"iki\", \"\u00fc\u00e7\", \"d\u00f6rd\", \"be\u015f\", \"alt\u0131\"]\n    \"\"\"\n","canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"}
{"prompt":"\ndef choose_num(x, y):\n    \"\"\"Bu funksiya iki m\u00fcsb\u0259t r\u0259q\u0259m olan x v\u0259 y-ni q\u0259bul edir v\u0259 [x, y] aral\u0131\u011f\u0131nda olan \u0259n b\u00f6y\u00fck c\u00fct tam \u0259d\u0259di qaytar\u0131r. \u018fg\u0259r bel\u0259 bir \u0259d\u0259d yoxdursa, funksiya -1 qaytarmal\u0131d\u0131r.\n\nM\u0259s\u0259l\u0259n:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n","canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"}
{"prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Siz\u0259 iki m\u00fcsb\u0259t tam \u0259d\u0259d n v\u0259 m verilir v\u0259 sizin v\u0259zif\u0259niz n-d\u0259n m-\u0259 q\u0259d\u0259r \u0259d\u0259dl\u0259rin ortalamas\u0131n\u0131 hesablamakt\u0131r. Cavab\u0131 \u0259n yax\u0131n tam \u0259d\u0259d\u0259 yuvarlay\u0131n v\u0259 onu ikilik sistem\u0259 \u00e7evirin. \u018fg\u0259r n m-d\u0259n b\u00f6y\u00fckd\u00fcrs\u0259, -1 qaytar\u0131n.\nM\u0259s\u0259l\u0259n:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n","canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"}
{"prompt":"\ndef unique_digits(x):\n    \"\"\"M\u00fcsb\u0259t tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t x siyah\u0131s\u0131 verilir. H\u0259r hans\u0131 c\u00fct r\u0259q\u0259m olmayan b\u00fct\u00fcn elementl\u0259ri s\u0131ralanm\u0131\u015f siyah\u0131 \u015f\u0259klind\u0259 qaytar\u0131n.\n\nQeyd: Qaytar\u0131lan siyah\u0131 artan s\u0131rada s\u0131ralanmal\u0131d\u0131r.\n\nM\u0259s\u0259l\u0259n:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n","canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef by_length(arr):\n    \"\"\"\n    Verilmi\u015f tam \u0259d\u0259dl\u0259r massivini g\u00f6t\u00fcr\u0259r\u0259k, 1-d\u0259n 9-a q\u0259d\u0259r olan \u0259d\u0259dl\u0259ri \u00e7e\u015fidl\u0259yin, \u0259m\u0259l\u0259 g\u0259l\u0259n massivi t\u0259rsin\u0259 \u00e7evirin v\u0259 sonra h\u0259r r\u0259q\u0259mi uy\u011fun ad\u0131 il\u0259 \u0259v\u0259z edin: \"Bir\", \"\u0130ki\", \"\u00dc\u00e7\", \"D\u00f6rd\", \"Be\u015f\", \"Alt\u0131\", \"Yeddi\", \"S\u0259kkiz\", \"Doqquz\".\n\nM\u0259s\u0259l\u0259n:\n- arr = [2, 1, 1, 4, 5, 8, 2, 3]\n    -> arr \u00e7e\u015fidl\u0259nir -> [1, 1, 2, 2, 3, 4, 5, 8]\n    -> arr t\u0259rsin\u0259 \u00e7evrilir -> [8, 5, 4, 3, 2, 2, 1, 1]\n    n\u0259tic\u0259: [\"S\u0259kkiz\", \"Be\u015f\", \"D\u00f6rd\", \"\u00dc\u00e7\", \"\u0130ki\", \"\u0130ki\", \"Bir\", \"Bir\"]\n\n- \u018fg\u0259r massiv bo\u015fdursa, bo\u015f massiv qaytar\u0131n:\n  - arr = []\n    n\u0259tic\u0259: []\n\n- \u018fg\u0259r massivd\u0259 q\u0259rib\u0259 \u0259d\u0259d varsa, onlar\u0131 n\u0259z\u0259r\u0259 almay\u0131n:\n  - arr = [1, -1, 55]\n    -> arr \u00e7e\u015fidl\u0259nir -> [-1, 1, 55]\n    -> arr t\u0259rsin\u0259 \u00e7evrilir -> [55, 1, -1]\n    n\u0259tic\u0259: ['Bir']\n    \"\"\"\n","canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"}
{"prompt":"\ndef f(n):\n    \"\"\" Funksiyan\u0131 f-ni h\u0259yata ke\u00e7irin ki, n parametrini q\u0259bul edir,\nv\u0259 n \u00f6l\u00e7\u00fcs\u00fcnd\u0259 bir siyah\u0131 qaytar\u0131r, el\u0259 ki, i indeksind\u0259ki elementin d\u0259y\u0259ri i-nin faktorial\u0131d\u0131r, \u0259g\u0259r i c\u00fctd\u00fcrs\u0259,\nv\u0259 ya \u0259ks halda 1-d\u0259n i-y\u0259 q\u0259d\u0259r olan r\u0259q\u0259ml\u0259rin c\u0259midir.\ni 1-d\u0259n ba\u015flay\u0131r.\ni-nin faktorial\u0131 1-d\u0259n i-y\u0259 q\u0259d\u0259r olan r\u0259q\u0259ml\u0259rin vurulmas\u0131d\u0131r.\nM\u0259s\u0259l\u0259n:\nf == [1, 2, 6, 24, 15]\n    \"\"\"\n","canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n","test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"}
{"prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    M\u00fcsb\u0259t tam \u0259d\u0259d n verildikd\u0259, [1, n] aral\u0131\u011f\u0131nda olan c\u00fct v\u0259 t\u0259k tam palindrome \u0259d\u0259dl\u0259rinin say\u0131n\u0131 g\u00f6st\u0259r\u0259n tuple qaytar\u0131n.\n\n    N\u00fcmun\u02591:\n\n        Giri\u015f: 3\n        \u00c7\u0131x\u0131\u015f:\n        \u0130zahat:\n        Tam palindrome \u0259d\u0259dl\u0259ri 1, 2, 3-d\u00fcr. Onlardan biri c\u00fct, ikisi is\u0259 t\u0259kdir.\n\n    N\u00fcmun\u02592:\n\n        Giri\u015f: 12\n        \u00c7\u0131x\u0131\u015f:\n        \u0130zahat:\n        Tam palindrome \u0259d\u0259dl\u0259ri 1, 2, 3, 4, 5, 6, 7, 8, 9, 11-dir. Onlardan d\u00f6rd\u00fc c\u00fct, alt\u0131s\u0131 is\u0259 t\u0259kdir.\n\n    Qeyd:\n        1. 1 <= n <= 10^3\n        2. Qaytar\u0131lan tuple m\u00fcvafiq olaraq c\u00fct v\u0259 t\u0259k tam palindrome \u0259d\u0259dl\u0259rinin say\u0131n\u0131 g\u00f6st\u0259rir.\n    \"\"\"\n","canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef count_nums(arr):\n    \"\"\"\n    ```python\nBir funksiya count_nums yaz\u0131n ki, bu funksiya tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t bir array q\u0259bul edir v\u0259 r\u0259q\u0259ml\u0259rinin c\u0259mi > 0 olan elementl\u0259rin say\u0131n\u0131 qaytar\u0131r.\n\u018fg\u0259r bir \u0259d\u0259d m\u0259nfidirs\u0259, onun ilk imzal\u0131 r\u0259q\u0259mi m\u0259nfi olacaq:\nm\u0259s\u0259l\u0259n, -123 imzal\u0131 r\u0259q\u0259ml\u0259r\u0259 malikdir -1, 2 v\u0259 3.\n```\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef move_one_ball(arr):\n    \"\"\"Bizd\u0259 N tam \u0259d\u0259dl\u0259rind\u0259n ibar\u0259t 'arr' adl\u0131 bir massiv var: arr[1], arr[2], ..., arr[N]. Massivd\u0259ki \u0259d\u0259dl\u0259r t\u0259sad\u00fcfi qaydada yerl\u0259\u015fdirilmi\u015fdir. Sizin v\u0259zif\u0259niz verilmi\u015f massiv \u00fcz\u0259rind\u0259 a\u015fa\u011f\u0131dak\u0131 \u0259m\u0259liyyat\u0131 yerin\u0259 yetir\u0259r\u0259k onu artan s\u0131ra il\u0259 s\u0131ralaman\u0131n m\u00fcmk\u00fcn olub-olmad\u0131\u011f\u0131n\u0131 m\u00fc\u0259yy\u0259n etm\u0259kdir:\n    Siz ist\u0259nil\u0259n sayda sa\u011fa s\u00fcr\u00fc\u015fd\u00fcrm\u0259 \u0259m\u0259liyyat\u0131 yerin\u0259 yetir\u0259 bil\u0259rsiniz.\n\nBir sa\u011fa s\u00fcr\u00fc\u015fd\u00fcrm\u0259 \u0259m\u0259liyyat\u0131 massivd\u0259ki b\u00fct\u00fcn elementl\u0259ri bir m\u00f6vqe sa\u011fa do\u011fru h\u0259r\u0259k\u0259t etdirm\u0259k dem\u0259kdir. Bu zaman massivd\u0259ki son element ba\u015flan\u011f\u0131c m\u00f6vqey\u0259, y\u0259ni 0-c\u0131 indeks\u0259 ke\u00e7\u0259c\u0259k.\n\n\u018fg\u0259r yuxar\u0131dak\u0131 \u0259m\u0259liyyat\u0131 yerin\u0259 yetir\u0259r\u0259k s\u0131ralanm\u0131\u015f massivi \u0259ld\u0259 etm\u0259k m\u00fcmk\u00fcnd\u00fcrs\u0259, True qaytar\u0131n, \u0259ks halda False qaytar\u0131n.\n\u018fg\u0259r verilmi\u015f massiv bo\u015fdursa, True qaytar\u0131n.\n\nQeyd: Verilmi\u015f massivin elementl\u0259ri unikald\u0131r.\n\nM\u0259s\u0259l\u0259n:\n\nmove_one_ball==>True\n\u0130zahedici: 2 sa\u011fa s\u00fcr\u00fc\u015fd\u00fcrm\u0259 \u0259m\u0259liyyat\u0131 yerin\u0259 yetir\u0259r\u0259k verilmi\u015f massiv \u00fc\u00e7\u00fcn artan s\u0131ra \u0259ld\u0259 etm\u0259k m\u00fcmk\u00fcnd\u00fcr.\nmove_one_ball==>False\n\u0130zahedici: He\u00e7 bir sa\u011fa s\u00fcr\u00fc\u015fd\u00fcrm\u0259 \u0259m\u0259liyyat\u0131 yerin\u0259 yetir\u0259r\u0259k bu massiv \u00fc\u00e7\u00fcn artan s\u0131ra \u0259ld\u0259 etm\u0259k m\u00fcmk\u00fcn deyil.\n                \n    \"\"\"\n","canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"}
{"prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Bu m\u0259s\u0259l\u0259d\u0259 iki \u0259d\u0259d siyah\u0131 q\u0259bul ed\u0259n v\u0259 aralar\u0131ndak\u0131 element m\u00fcbadil\u0259si il\u0259 lst1 siyah\u0131s\u0131n\u0131 yaln\u0131z c\u00fct \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t etm\u0259k m\u00fcmk\u00fcn olub-olmad\u0131\u011f\u0131n\u0131 m\u00fc\u0259yy\u0259n ed\u0259n bir funksiya h\u0259yata ke\u00e7ir\u0259c\u0259ksiniz. lst1 v\u0259 lst2 aras\u0131nda d\u0259yi\u015fdiril\u0259n elementl\u0259rin say\u0131 m\u0259hdud deyil. \u018fg\u0259r lst1 v\u0259 lst2 aras\u0131nda elementl\u0259ri d\u0259yi\u015fdirm\u0259kl\u0259 lst1-in b\u00fct\u00fcn elementl\u0259rini c\u00fct etm\u0259k m\u00fcmk\u00fcnd\u00fcrs\u0259, \"YES\" qaytar\u0131n. \u018fks halda, \"NO\" qaytar\u0131n. M\u0259s\u0259l\u0259n:\nexchange => \"YES\"\nexchange => \"NO\"\nGiri\u015f siyah\u0131lar\u0131n\u0131n bo\u015f olmayaca\u011f\u0131 q\u0259bul edilir.\n    \"\"\"\n","canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"}
{"prompt":"\ndef histogram(test):\n    \"\"\"A\u015fa\u011f\u0131dak\u0131 c\u00fcml\u0259ni \u015eimali Az\u0259rbaycan dilin\u0259 t\u0259rc\u00fcm\u0259 edin:\n\nVerilmi\u015f m\u0259tn bo\u015fluqla ayr\u0131lm\u0131\u015f ki\u00e7ik h\u0259rfl\u0259rd\u0259n ibar\u0259t olan bir s\u0259tirdir, \u0259n \u00e7ox t\u0259krarlanan h\u0259rfin v\u0259 m\u00fcvafiq say\u0131n\u0131n oldu\u011fu l\u00fc\u011f\u0259ti qaytar\u0131n. \u018fg\u0259r bir ne\u00e7\u0259 h\u0259rf eyni tezlikd\u0259dirs\u0259, onlar\u0131n ham\u0131s\u0131n\u0131 qaytar\u0131n.\n\nMisal:\nhistogram == {'a': 1, 'b': 1, 'c': 1}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'b': 4}\nhistogram == {}\n\n    \"\"\"\n","canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Tap\u015f\u0131r\u0131q\n    Biz\u0259 s v\u0259 c iki s\u0259tir verilir, siz c-d\u0259 olan h\u0259r hans\u0131 bir simvola b\u0259rab\u0259r olan b\u00fct\u00fcn simvollar\u0131 s-d\u0259n silm\u0259lisiniz.\n    sonra n\u0259tic\u0259 s\u0259tirinin palindrom olub-olmad\u0131\u011f\u0131n\u0131 yoxlay\u0131n.\n    \u018fg\u0259r bir s\u0259tir geri oxunduqda ir\u0259li oxundu\u011fu kimi oxunursa, ona palindrom deyilir.\n    Siz n\u0259tic\u0259 s\u0259tirini v\u0259 yoxlama \u00fc\u00e7\u00fcn Do\u011fru\/Yanl\u0131\u015f d\u0259y\u0259rini ehtiva ed\u0259n bir tuple qaytarmal\u0131s\u0131n\u0131z.\n    N\u00fcmun\u0259\n    s = \"abcde\", c = \"ae\" \u00fc\u00e7\u00fcn, n\u0259tic\u0259 olmal\u0131d\u0131r\n    s = \"abcdef\", c = \"b\" \u00fc\u00e7\u00fcn, n\u0259tic\u0259 olmal\u0131d\u0131r\n    s = \"abcdedcba\", c = \"ab\" \u00fc\u00e7\u00fcn, n\u0259tic\u0259 olmal\u0131d\u0131r\n    \"\"\"\n","canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n","test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"}
{"prompt":"\ndef odd_count(lst):\n    \"\"\"Verilmi\u015f r\u0259q\u0259ml\u0259rd\u0259n ibar\u0259t s\u0259tirl\u0259r siyah\u0131s\u0131 n\u0259z\u0259r\u0259 al\u0131naraq, bir siyah\u0131 qaytar\u0131n. \n    \u00c7\u0131x\u0131\u015f\u0131n h\u0259r bir elementi i giri\u015fd\u0259ki i-ci s\u0259tird\u0259ki t\u0259k elementl\u0259rin say\u0131n\u0131 g\u00f6st\u0259rm\u0259lidir. \n    Burada b\u00fct\u00fcn i-l\u0259r giri\u015fin i-ci s\u0259tirind\u0259ki t\u0259k r\u0259q\u0259ml\u0259rin say\u0131 il\u0259 \u0259v\u0259z olunmal\u0131d\u0131r.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n","canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Veril\u0259n tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t nums massivini n\u0259z\u0259r\u0259 alaraq, nums-un h\u0259r hans\u0131 bir bo\u015f olmayan alt massivinin minimum c\u0259mini tap\u0131n.\n    N\u00fcmun\u0259\n    minSubArraySum == 1\n    minSubArraySum == -6\n    \"\"\"\n","canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"}
{"prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Siz\u0259 d\u00fczbucaql\u0131 quyu \u015f\u0259b\u0259k\u0259si verilir. H\u0259r bir s\u0131ra t\u0259k bir quyunu t\u0259msil edir v\u0259 h\u0259r bir s\u0131radak\u0131 1 t\u0259k bir su vahidini t\u0259msil edir. H\u0259r bir quyunun suyunu \u00e7\u0131xarmaq \u00fc\u00e7\u00fcn m\u00fcvafiq bir vedr\u0259si var v\u0259 b\u00fct\u00fcn vedr\u0259l\u0259rin eyni tutumu var. Sizin v\u0259zif\u0259niz vedr\u0259l\u0259ri quyulara endir\u0259r\u0259k onlar\u0131 bo\u015faltmaqd\u0131r. Vedr\u0259l\u0259ri endirm\u0259 say\u0131n\u0131 \u00e7\u0131x\u0131\u015f edin.\n\nMisal 1:\n    Giri\u015f: \n        \u015f\u0259b\u0259k\u0259: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        vedr\u0259 tutumu: 1\n    \u00c7\u0131x\u0131\u015f: 6\n\nMisal 2:\n    Giri\u015f: \n        \u015f\u0259b\u0259k\u0259: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        vedr\u0259 tutumu: 2\n    \u00c7\u0131x\u0131\u015f: 5\n\nMisal 3:\n    Giri\u015f: \n        \u015f\u0259b\u0259k\u0259: [[0,0,0], [0,0,0]]\n        vedr\u0259 tutumu: 5\n    \u00c7\u0131x\u0131\u015f: 0\n\nM\u0259hdudiyy\u0259tl\u0259r:\n    * b\u00fct\u00fcn quyular eyni uzunlu\u011fa malikdir\n    * 1 <= \u015f\u0259b\u0259k\u0259.uzunlu\u011fu <= 10^2\n    * 1 <= \u015f\u0259b\u0259k\u0259[:,1].uzunlu\u011fu <= 10^2\n    * \u015f\u0259b\u0259k\u0259[i][j] -> 0 | 1\n    * 1 <= tutum <= 10\n    \"\"\"\n","canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n","test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"}
{"prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Bu Kata-da, qeyri-m\u0259nfi tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t olan bir massivi onlar\u0131n ikilik t\u0259msilind\u0259ki \"bir\"l\u0259rin say\u0131na g\u00f6r\u0259 artan s\u0131raya g\u00f6r\u0259 s\u0131ralamal\u0131s\u0131n\u0131z.\nEyni sayda \"bir\" olan \u0259d\u0259dl\u0259r \u00fc\u00e7\u00fcn, ondal\u0131k qiym\u0259t\u0259 \u0259sas\u0259n s\u0131ralay\u0131n.\n\nBu \u015f\u0259kild\u0259 h\u0259yata ke\u00e7irilm\u0259lidir:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n","canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef select_words(s, n):\n    \"\"\"M\u0259tn s v\u0259 t\u0259bii \u0259d\u0259d n verilmi\u015fdir, sizd\u0259n t\u0259l\u0259b olunur ki, \n    m\u0259tn s-d\u0259n m\u0259hz n samit h\u0259rf ehtiva ed\u0259n b\u00fct\u00fcn s\u00f6zl\u0259ri \n    qaytaran funksiyan\u0131 yazas\u0131n\u0131z v\u0259 bu s\u00f6zl\u0259r m\u0259tnd\u0259ki \n    s\u0131ralama il\u0259 qaytar\u0131lmal\u0131d\u0131r.\n    \u018fg\u0259r m\u0259tn s bo\u015fdursa, funksiya bo\u015f siyah\u0131 qaytarmal\u0131d\u0131r.\n    Qeyd: siz\u0259 daxil olan m\u0259tn yaln\u0131z h\u0259rfl\u0259r v\u0259 bo\u015fluqlar ehtiva edir.\n    Misallar:\n    select_words ==> [\"little\"]\n    select_words ==> [\"Mary\", \"lamb\"]\n    select_words ==> []\n    select_words ==> [\"world\"]\n    select_words ==> [\"Uncle\"]\n    \"\"\"\n","canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"}
{"prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Siz\u0259 bir s\u00f6z verilir. Sizin v\u0259zif\u0259niz s\u00f6z\u00fcn sa\u011f t\u0259r\u0259find\u0259n iki samitin aras\u0131nda duran \u0259n yax\u0131n sait h\u0259rfi tapmaqd\u0131r.\n\nBa\u015fda v\u0259 sonda olan saitl\u0259r n\u0259z\u0259r\u0259 al\u0131nm\u0131r. Yuxar\u0131da g\u00f6st\u0259ril\u0259n \u015f\u0259rt\u0259 uy\u011fun olan sait tap\u0131lmad\u0131qda bo\u015f bir s\u0259tir qaytar\u0131n.\n\nVeril\u0259n s\u0259tirin yaln\u0131z \u0130ngilis h\u0259rfl\u0259rind\u0259n ibar\u0259t oldu\u011funu q\u0259bul ed\u0259 bil\u0259rsiniz.\n\nN\u00fcmun\u0259:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n","canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n","canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"}
{"prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Verilmi\u015f tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t arr massivini v\u0259 m\u00fcsb\u0259t k tam \u0259d\u0259dini n\u0259z\u0259r\u0259 alaraq, arr massivind\u0259ki maksimum k \u0259d\u0259din s\u0131ralanm\u0131\u015f siyah\u0131s\u0131n\u0131 qaytar\u0131n.\n\nN\u00fcmun\u0259 1:\n\nGiri\u015f: arr = [-3, -4, 5], k = 3\n\u00c7\u0131x\u0131\u015f: [-4, -3, 5]\n\nN\u00fcmun\u0259 2:\n\nGiri\u015f: arr = [4, -4, 4], k = 2\n\u00c7\u0131x\u0131\u015f: [4, 4]\n\nN\u00fcmun\u0259 3:\n\nGiri\u015f: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n\u00c7\u0131x\u0131\u015f: [2]\n\nQeyd:\n1. Massivin uzunlu\u011fu [1, 1000] aral\u0131\u011f\u0131nda olacaq.\n2. Massivd\u0259ki elementl\u0259r [-1000, 1000] aral\u0131\u011f\u0131nda olacaq.\n3. 0 <= k <= len\n    \"\"\"\n","canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"}
{"prompt":"\ndef solution(lst):\n    \"\"\"Bo\u015f olmayan tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131 verilmi\u015fdir, c\u00fct m\u00f6vqel\u0259rd\u0259 olan b\u00fct\u00fcn t\u0259k elementl\u0259rin c\u0259mini qaytar\u0131n.\n\n    N\u00fcmun\u0259l\u0259r\n    h\u0259ll ==> 12\n    h\u0259ll ==> 9\n    h\u0259ll ==> 0\n    \"\"\"\n","canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"}
{"prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Verilmi\u015f bo\u015f olmayan tam \u0259d\u0259dl\u0259r massivind\u0259n arr v\u0259 k tam \u0259d\u0259dind\u0259n, arr massivinin ilk k elementl\u0259rind\u0259n \u0259n \u00e7ox iki r\u0259q\u0259mli olan elementl\u0259rin c\u0259mini qaytar\u0131n.\n\nMisal:\n\n    Giri\u015f: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    \u00c7\u0131x\u0131\u015f: 24 # 21 + 3 c\u0259mi\n\n\u015e\u0259rtl\u0259r:\n    1. 1 <= len <= 100\n    2. 1 <= k <= len\n    \"\"\"\n","canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    M\u00fcsb\u0259t tam \u0259d\u0259d n verilmi\u015fdirs\u0259, collatz ard\u0131c\u0131ll\u0131\u011f\u0131nda t\u0259k \u0259d\u0259dl\u0259ri ehtiva ed\u0259n s\u0131ralanm\u0131\u015f siyah\u0131n\u0131 qaytar\u0131n.\n\n    Collatz hipotezi riyaziyyatda bir ard\u0131c\u0131ll\u0131qla ba\u011fl\u0131 hipotezdir v\u0259 bel\u0259 t\u0259yin edilir:\n    h\u0259r hans\u0131 bir m\u00fcsb\u0259t tam \u0259d\u0259d n il\u0259 ba\u015flay\u0131n. Daha sonra h\u0259r bir termin bel\u0259 \u0259ld\u0259 edilir:\n    \u0259g\u0259r \u0259vv\u0259lki termin c\u00fctd\u00fcrs\u0259, n\u00f6vb\u0259ti termin \u0259vv\u0259lki termin yar\u0131s\u0131na b\u0259rab\u0259rdir.\n    \u018fg\u0259r \u0259vv\u0259lki termin t\u0259kdirs\u0259, n\u00f6vb\u0259ti termin \u0259vv\u0259lki termin 3-\u0259 vurulub \u00fcst\u00fcn\u0259 1 \u0259lav\u0259 edil\u0259r\u0259k \u0259ld\u0259 edilir.\n    Hipotez bel\u0259dir ki, n d\u0259y\u0259ri n\u0259 olursa olsun, ard\u0131c\u0131ll\u0131q h\u0259mi\u015f\u0259 1-\u0259 \u00e7atacaq.\n\n    Qeyd:\n        1. Collatz [1] dir.\n        2. Qaytar\u0131lan siyah\u0131 artan s\u0131ralamada olmal\u0131d\u0131r.\n\n    M\u0259s\u0259l\u0259n:\n    get_odd_collatz [1, 5] qaytar\u0131r # 5 \u00fc\u00e7\u00fcn collatz ard\u0131c\u0131ll\u0131\u011f\u0131 [5, 16, 8, 4, 2, 1]-dir, bel\u0259likl\u0259 t\u0259k \u0259d\u0259dl\u0259r yaln\u0131z 1 v\u0259 5-dir.\n    \"\"\"\n","canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef valid_date(date):\n    \"\"\"Bir funksiya yazmal\u0131s\u0131n\u0131z ki, verilmi\u015f tarix s\u0259tirini yoxlas\u0131n v\u0259\n    tarix ke\u00e7\u0259rlidirs\u0259 True, \u0259ks halda False qaytars\u0131n.\n    Tarix a\u015fa\u011f\u0131dak\u0131 qaydalar\u0131n ham\u0131s\u0131na uy\u011fun g\u0259ldikd\u0259 ke\u00e7\u0259rlidir:\n    1. Tarix s\u0259tiri bo\u015f olmamal\u0131d\u0131r.\n    2. G\u00fcnl\u0259rin say\u0131 1-d\u0259n az v\u0259 ya 31-d\u0259n \u00e7ox olmamal\u0131d\u0131r 1,3,5,7,8,10,12 aylar\u0131 \u00fc\u00e7\u00fcn. G\u00fcnl\u0259rin say\u0131 1-d\u0259n az v\u0259 ya 30-dan \u00e7ox olmamal\u0131d\u0131r 4,6,9,11 aylar\u0131 \u00fc\u00e7\u00fcn. V\u0259, g\u00fcnl\u0259rin say\u0131 1-d\u0259n az v\u0259 ya 29-dan \u00e7ox olmamal\u0131d\u0131r 2-ci ay \u00fc\u00e7\u00fcn.\n    3. Aylar 1-d\u0259n az v\u0259 ya 12-d\u0259n \u00e7ox olmamal\u0131d\u0131r.\n    4. Tarix mm-dd-yyyy format\u0131nda olmal\u0131d\u0131r.\n    \n    m\u0259s\u0259l\u0259n:\n    valid_date => True\n\n    valid_date => False\n\n    valid_date => False\n\n    valid_date => True\n\n    valid_date => False\n    \"\"\"\n","canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"}
{"prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n","canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n","test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"}
{"prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n","canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"}
{"prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"\u0130ki interval verilmi\u015fdir,\n    h\u0259r interval bir c\u00fct tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259tdir. M\u0259s\u0259l\u0259n, interval = =.\n    Verilmi\u015f intervallar qapal\u0131 intervallard\u0131r, y\u0259ni interval\u0131 h\u0259m ba\u015flan\u011f\u0131c, h\u0259m d\u0259 son n\u00f6qt\u0259l\u0259ri daxildir.\n    H\u0259r verilmi\u015f interval \u00fc\u00e7\u00fcn q\u0259bul olunur ki, onun ba\u015flan\u011f\u0131c\u0131 son n\u00f6qt\u0259sind\u0259n ki\u00e7ik v\u0259 ya b\u0259rab\u0259rdir.\n    Sizin v\u0259zif\u0259niz bu iki interval\u0131n k\u0259si\u015fm\u0259 uzunlu\u011funun sad\u0259 \u0259d\u0259d olub-olmamas\u0131n\u0131 m\u00fc\u0259yy\u0259n etm\u0259kdir.\n    M\u0259s\u0259l\u0259n, v\u0259 intervallar\u0131n\u0131n k\u0259si\u015fm\u0259si interval\u0131d\u0131r,\n    onun uzunlu\u011fu is\u0259 1-dir, bu is\u0259 sad\u0259 \u0259d\u0259d deyil.\n    \u018fg\u0259r k\u0259si\u015fm\u0259 uzunlu\u011fu sad\u0259 \u0259d\u0259d olarsa, \"B\u018fL\u0130\" qaytar\u0131n,\n    \u0259ks halda, \"XEY\u0130R\" qaytar\u0131n.\n    \u018fg\u0259r bu iki interval k\u0259si\u015fmirs\u0259, \"XEY\u0130R\" qaytar\u0131n.\n\n\n    [giri\u015f\/\u00e7\u0131x\u0131\u015f] n\u00fcmun\u0259l\u0259r:\n    intersection,) ==> \"XEY\u0130R\"\n    intersection,) ==> \"XEY\u0130R\"\n    intersection,) ==> \"B\u018fL\u0130\"\n    \"\"\"\n","canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"}
{"prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Siz\u0259 bir arr tam \u0259d\u0259dl\u0259r massivini verirl\u0259r v\u0259 siz massivd\u0259ki h\u0259r bir \u0259d\u0259din i\u015far\u0259l\u0259rinin hasilin\u0259 vurulan tam \u0259d\u0259dl\u0259rin b\u00f6y\u00fckl\u00fckl\u0259rinin c\u0259mini qaytarmal\u0131s\u0131n\u0131z. \nBu i\u015far\u0259l\u0259r 1, -1 v\u0259 ya 0 il\u0259 ifad\u0259 olunur.\nQeyd: Bo\u015f arr \u00fc\u00e7\u00fcn None qaytar\u0131n.\n\nMisal:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n","canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Verilmi\u015f N s\u0259tir v\u0259 N s\u00fctunlu bir \u015f\u0259b\u0259k\u0259 v\u0259 m\u00fcsb\u0259t tam \u0259d\u0259d k \u00fc\u00e7\u00fcn, \u015f\u0259b\u0259k\u0259nin h\u0259r bir h\u00fcceyr\u0259sind\u0259 bir d\u0259y\u0259r var. [1, N * N] aral\u0131\u011f\u0131ndak\u0131 h\u0259r bir tam \u0259d\u0259d \u015f\u0259b\u0259k\u0259nin h\u00fcceyr\u0259l\u0259rind\u0259 d\u0259qiq bir d\u0259f\u0259 g\u00f6r\u00fcn\u00fcr.\n\n\u015e\u0259b\u0259k\u0259d\u0259 uzunlu\u011fu k olan minimal yolu tapmal\u0131s\u0131n\u0131z. H\u0259r hans\u0131 bir h\u00fcceyr\u0259d\u0259n ba\u015flaya bil\u0259rsiniz v\u0259 h\u0259r add\u0131mda qon\u015fu h\u00fcceyr\u0259l\u0259r\u0259 ke\u00e7\u0259 bil\u0259rsiniz, ba\u015fqa s\u00f6zl\u0259, cari h\u00fccr\u0259nizl\u0259 k\u0259nar payla\u015fan h\u00fcceyr\u0259l\u0259r\u0259 ged\u0259 bil\u0259rsiniz.\nQeyd ed\u0259k ki, uzunlu\u011fu k olan bir yol dem\u0259kdir ki, d\u0259qiq k h\u00fcceyr\u0259ni ziyar\u0259t etm\u0259k.\n\u015e\u0259b\u0259k\u0259d\u0259n k\u0259nara \u00e7\u0131xa B\u0130LM\u018fZS\u0130N\u0130Z.\nUzunlu\u011fu k olan bir yol A, uzunlu\u011fu k olan bir yol B-d\u0259n az hesab olunur \u0259g\u0259r A v\u0259 B ke\u00e7dikl\u0259ri h\u00fcceyr\u0259l\u0259rin d\u0259y\u0259rl\u0259rinin ard\u0131c\u0131l siyah\u0131lar\u0131n\u0131 t\u0259rtib etdikd\u0259n sonra, lst_A leksikoqrafik olaraq lst_B-d\u0259n azd\u0131r, ba\u015fqa s\u00f6zl\u0259, h\u0259r hans\u0131 bir tam \u0259d\u0259d i varsa ki, lst_A[i] < lst_B[i] v\u0259 h\u0259r hans\u0131 bir j \u00fc\u00e7\u00fcn lst_A[j] = lst_B[j] var.\nCavab\u0131n unikal oldu\u011fu garanti edilir.\nUzunlu\u011fu k olan minimal yolun ke\u00e7diyi h\u00fcceyr\u0259l\u0259rin d\u0259y\u0259rl\u0259rinin ard\u0131c\u0131l siyah\u0131s\u0131n\u0131 qaytar\u0131n.\n\nMisallar:\n\n    Giri\u015f: \u015f\u0259b\u0259k\u0259 = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n    \u00c7\u0131x\u0131\u015f: [1, 2, 1]\n\n    Giri\u015f: \u015f\u0259b\u0259k\u0259 = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n    \u00c7\u0131x\u0131\u015f: [1]\n    \"\"\"\n","canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"}
{"prompt":"\ndef tri(n):\n    \"\"\"H\u0259r k\u0259s Fibonacci ard\u0131c\u0131ll\u0131\u011f\u0131n\u0131 bilir, son bir ne\u00e7\u0259 \u0259srd\u0259 riyaziyyat\u00e7\u0131lar t\u0259r\u0259find\u0259n d\u0259rind\u0259n \u00f6yr\u0259nilmi\u015fdir. Ancaq insanlar Tribonacci ard\u0131c\u0131ll\u0131\u011f\u0131n\u0131 bilmirl\u0259r. Tribonacci ard\u0131c\u0131ll\u0131\u011f\u0131 bel\u0259 t\u0259yin olunur:\ntri = 3\ntri = 1 + n \/ 2, \u0259g\u0259r n c\u00fctd\u00fcrs\u0259.\ntri = tri + tri + tri, \u0259g\u0259r n t\u0259kdirs\u0259.\nM\u0259s\u0259l\u0259n:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n       = 2 + 3 + 3 = 8 \nSiz\u0259 qeyri-m\u0259nfi tam \u0259d\u0259d n verilir, siz\u0259 Tribonacci ard\u0131c\u0131ll\u0131\u011f\u0131n\u0131n ilk n + 1 \u0259d\u0259dini qaytarmaq laz\u0131md\u0131r.\nN\u00fcmun\u0259l\u0259r:\ntri = [1, 3, 2, 8]\n    \"\"\"\n","canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"}
{"prompt":"\ndef digits(n):\n    \"\"\"M\u00fcsb\u0259t tam \u0259d\u0259di n verildikd\u0259, t\u0259k r\u0259q\u0259ml\u0259rin hasilini qaytar\u0131n.\n    B\u00fct\u00fcn r\u0259q\u0259ml\u0259r c\u00fct olduqda 0 qaytar\u0131n.\n    M\u0259s\u0259l\u0259n:\n    r\u0259q\u0259ml\u0259r == 1\n    r\u0259q\u0259ml\u0259r == 0\n    r\u0259q\u0259ml\u0259r == 15\n    \"\"\"\n","canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"}
{"prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n","canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"}
{"prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Siz\u0259 \u0259d\u0259dl\u0259rin siyah\u0131s\u0131 verilib.\n    Siz verilmi\u015f siyah\u0131dak\u0131 \u0259d\u0259dl\u0259rin kvadratlar\u0131n\u0131n c\u0259mini qaytarmal\u0131s\u0131n\u0131z,\n    \u0259vv\u0259lc\u0259 siyah\u0131dak\u0131 h\u0259r elementi yuxar\u0131ya do\u011fru yuvarlaqla\u015fd\u0131rmal\u0131s\u0131n\u0131z.\n    N\u00fcmun\u0259l\u0259r:\n    \u018fg\u0259r lst = [1,2,3] olarsa, n\u0259tic\u0259 14 olmal\u0131d\u0131r\n    \u018fg\u0259r lst = [1,4,9] olarsa, n\u0259tic\u0259 98 olmal\u0131d\u0131r\n    \u018fg\u0259r lst = [1,3,5,7] olarsa, n\u0259tic\u0259 84 olmal\u0131d\u0131r\n    \u018fg\u0259r lst = [1.4,4.2,0] olarsa, n\u0259tic\u0259 29 olmal\u0131d\u0131r\n    \u018fg\u0259r lst = [-2.4,1,1] olarsa, n\u0259tic\u0259 6 olmal\u0131d\u0131r\n    \n\n    \"\"\"\n","canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n","canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef can_arrange(arr):\n    \"\"\"Bir funksiyan\u0131 yarad\u0131n ki, verilmi\u015f massivd\u0259 \u00f6z\u00fcnd\u0259n \u0259vv\u0259lki elementd\u0259n b\u00f6y\u00fck v\u0259 ya ona b\u0259rab\u0259r olmayan elementin \u0259n b\u00f6y\u00fck indeksini qaytars\u0131n. \u018fg\u0259r bel\u0259 bir element yoxdursa, -1 qaytars\u0131n. Verilmi\u015f massivd\u0259 t\u0259krarlanan d\u0259y\u0259rl\u0259r olmayacaq.\n\nN\u00fcmun\u0259l\u0259r:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n","canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"}
{"prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n","canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"}
{"prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    A\u015fa\u011f\u0131dak\u0131 c\u00fcml\u0259ni \u015eimali Az\u0259rbaycan dilin\u0259 t\u0259rc\u00fcm\u0259 edin:\n\nBir funksiyan\u0131n yarad\u0131lmas\u0131, hans\u0131 ki, tam \u0259d\u0259dl\u0259r, onluq \u0259d\u0259dl\u0259r v\u0259 ya h\u0259qiqi \u0259d\u0259dl\u0259ri t\u0259msil ed\u0259n s\u0259tirl\u0259r q\u0259bul edir v\u0259 verilmi\u015f d\u0259yi\u015f\u0259n tipi \u00fczr\u0259 b\u00f6y\u00fck olan d\u0259yi\u015f\u0259ni qaytar\u0131r. \u018fg\u0259r d\u0259y\u0259rl\u0259r b\u0259rab\u0259rdirs\u0259, None qaytar\u0131n.\nQeyd: \u018fg\u0259r h\u0259qiqi \u0259d\u0259d s\u0259tir kimi t\u0259msil olunarsa, onluq n\u00f6qt\u0259 . v\u0259 ya , ola bil\u0259r.\n\ncompare_one \u00e2 -> 2.5\ncompare_one \u00e2 -> \"2,3\"\ncompare_one \u00e2 -> \"6\"\ncompare_one \u00e2 -> None\n    \"\"\"\n","canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Qiym\u0259tl\u0259ndir ki, verilmi\u015f n r\u0259q\u0259mi d\u0259qiq 4 m\u00fcsb\u0259t c\u00fct \u0259d\u0259din c\u0259mi kimi yaz\u0131la bil\u0259rmi\n    N\u00fcmun\u0259\n    is_equal_to_sum_even == Yanl\u0131\u015f\n    is_equal_to_sum_even == Yanl\u0131\u015f\n    is_equal_to_sum_even == Do\u011fru\n    \"\"\"\n","canonical_solution":"    return n%2 == 0 and n >= 8\n","test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"}
{"prompt":"\ndef special_factorial(n):\n    \"\"\"Braziliya faktorial\u0131 a\u015fa\u011f\u0131dak\u0131 kimi t\u0259yin edilir:\n    braziliya_faktorial = n! *! *! * ... * 1!\n    burada n > 0\n\n    M\u0259s\u0259l\u0259n:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n","canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"}
{"prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Verilmi\u015f m\u0259tn s\u0259tirind\u0259ki b\u00fct\u00fcn bo\u015fluqlar\u0131 alt x\u0259tl\u0259rl\u0259 \u0259v\u0259z et v\u0259 \u0259g\u0259r bir s\u0259tird\u0259 2-d\u0259n \u00e7ox ard\u0131c\u0131l bo\u015fluq varsa, o zaman b\u00fct\u00fcn ard\u0131c\u0131l bo\u015fluqlar\u0131 \"-\" il\u0259 \u0259v\u0259z et.\n\nfix_spaces == \"N\u00fcmun\u0259\"\nfix_spaces == \"N\u00fcmun\u0259_1\"\nfix_spaces == \"_N\u00fcmun\u0259_2\"\nfix_spaces == \"_N\u00fcmun\u0259-3\"\n    \"\"\"\n","canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"}
{"prompt":"\ndef file_name_check(file_name):\n    \"\"\"Bir funksiyaya fayl\u0131n ad\u0131n\u0131 t\u0259msil ed\u0259n bir s\u0259tir verin v\u0259 funksiyan\u0131z 'B\u0259li' qaytars\u0131n, \u0259g\u0259r fayl\u0131n ad\u0131 ke\u00e7\u0259rlidirs\u0259, \u0259ks halda 'Xeyr' qaytars\u0131n.\nFayl\u0131n ad\u0131 yaln\u0131z a\u015fa\u011f\u0131dak\u0131 \u015f\u0259rtl\u0259r yerin\u0259 yetirildikd\u0259 ke\u00e7\u0259rli hesab olunur:\n- Fayl\u0131n ad\u0131nda \u00fc\u00e7d\u0259n \u00e7ox r\u0259q\u0259m olmamal\u0131d\u0131r.\n- Fayl\u0131n ad\u0131nda d\u0259qiq bir n\u00f6qt\u0259 '.' olmal\u0131d\u0131r.\n- N\u00f6qt\u0259d\u0259n \u0259vv\u0259lki alt s\u0259tir bo\u015f olmamal\u0131d\u0131r v\u0259 lat\u0131n \u0259lifbas\u0131ndan olan bir h\u0259rfl\u0259 ba\u015flamal\u0131d\u0131r.\n- N\u00f6qt\u0259d\u0259n sonrak\u0131 alt s\u0259tir bu d\u0259y\u0259rl\u0259rd\u0259n biri olmal\u0131d\u0131r: ['txt', 'exe', 'dll']\nN\u00fcmun\u0259l\u0259r:\nfile_name_check # => 'B\u0259li'\nfile_name_check # => 'Xeyr'\n    \"\"\"\n","canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"}
{"prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"Bu funksiya tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131n\u0131 q\u0259bul ed\u0259c\u0259k. Siyah\u0131dak\u0131 b\u00fct\u00fcn elementl\u0259r \u00fc\u00e7\u00fcn, \u0259g\u0259r indeks 3-\u00fcn qat\u0131d\u0131rsa, funksiya tam \u0259d\u0259di kvadratla\u015fd\u0131racaq v\u0259 \u0259g\u0259r indeks 4-\u00fcn qat\u0131d\u0131rsa, lakin 3-\u00fcn qat\u0131s\u0131 deyils\u0259, h\u0259min tam \u0259d\u0259di kubla\u015fd\u0131racaq. \u0130ndeksi n\u0259 3-\u00fcn, n\u0259 d\u0259 4-\u00fcn qat\u0131s\u0131 olan elementl\u0259r d\u0259yi\u015fdirilm\u0259y\u0259c\u0259k. Funksiya daha sonra b\u00fct\u00fcn elementl\u0259rin c\u0259mini qaytaracaq.\n\nMisallar:\nlst = [1,2,3] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 6 olmal\u0131d\u0131r\nlst = [] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f 0 olmal\u0131d\u0131r\nlst = [-1,-5,2,-1,-5] \u00fc\u00e7\u00fcn \u00e7\u0131x\u0131\u015f -126 olmal\u0131d\u0131r\n    \"\"\"\n","canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"}
{"prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Verilmi\u015f c\u00fcml\u0259ni t\u0259msil ed\u0259n bir s\u0259tir verilir,\n    c\u00fcml\u0259 b\u0259zi s\u00f6zl\u0259rd\u0259n ibar\u0259tdir v\u0259 aralar\u0131nda bo\u015fluq var,\n    v\u0259 siz, orijinal c\u00fcml\u0259d\u0259ki s\u00f6zl\u0259rd\u0259n ibar\u0259t olan,\n    uzunluqlar\u0131 sad\u0259 \u0259d\u0259dl\u0259rl\u0259 olan s\u00f6zl\u0259ri ehtiva ed\u0259n bir s\u0259tir qaytarmal\u0131s\u0131n\u0131z,\n    yeni s\u0259tird\u0259ki s\u00f6zl\u0259rin s\u0131ras\u0131 orijinal c\u00fcml\u0259d\u0259ki kimi olmal\u0131d\u0131r.\n\n    M\u0259s\u0259l\u0259n1:\n        Giri\u015f: c\u00fcml\u0259 = \"Bu bir testdir\"\n        \u00c7\u0131x\u0131\u015f: \"bir\"\n\n    M\u0259s\u0259l\u0259n2:\n        Giri\u015f: c\u00fcml\u0259 = \"ged\u0259k \u00fczm\u0259y\u0259 ged\u0259k\"\n        \u00c7\u0131x\u0131\u015f: \"ged\u0259k\"\n\n    M\u0259hdudiyy\u0259tl\u0259r:\n        * 1 <= c\u00fcml\u0259nin uzunlu\u011fu <= 100\n        * c\u00fcml\u0259 yaln\u0131z h\u0259rfl\u0259rd\u0259n ibar\u0259tdir\n    \"\"\"\n","canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"}
{"prompt":"\ndef simplify(x, n):\n    \"\"\"Here is the translation of the given sentence into North Azerbaijani:\n\nV\u0259zif\u0259niz x * n ifad\u0259sini sad\u0259l\u0259\u015fdir\u0259c\u0259k bir funksiya yazmaqd\u0131r. \u018fg\u0259r x * n tam \u0259d\u0259d\u0259 b\u0259rab\u0259rdirs\u0259, funksiya True qaytar\u0131r, \u0259ks halda False qaytar\u0131r. H\u0259m x, h\u0259m d\u0259 n hiss\u0259 format\u0131nda olan s\u0259tir t\u0259qdimatlar\u0131d\u0131r v\u0259 a\u015fa\u011f\u0131dak\u0131 formatda olurlar, <sad\u0259> \/ <m\u0259xr\u0259c> burada h\u0259m sad\u0259, h\u0259m d\u0259 m\u0259xr\u0259c m\u00fcsb\u0259t tam \u0259d\u0259dl\u0259rdir.\n\nSiz x v\u0259 n-nin etibarl\u0131 hiss\u0259l\u0259r oldu\u011funu v\u0259 m\u0259xr\u0259cinin s\u0131f\u0131r olmad\u0131\u011f\u0131n\u0131 f\u0259rz ed\u0259 bil\u0259rsiniz.\n\nSad\u0259l\u0259\u015fdir = True\nSad\u0259l\u0259\u015fdir = False\nSad\u0259l\u0259\u015fdir = False\n    \"\"\"\n","canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"}
{"prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Veril\u0259n tam \u0259d\u0259dl\u0259r siyah\u0131s\u0131n\u0131 r\u0259q\u0259ml\u0259rinin c\u0259min\u0259 g\u00f6r\u0259 artan s\u0131raya d\u00fcz\u0259n bir funksiya yaz\u0131n.\nQeyd: \u018fg\u0259r r\u0259q\u0259ml\u0259rinin c\u0259mi eyni olan bir ne\u00e7\u0259 element varsa,\nonlar\u0131 orijinal siyah\u0131dak\u0131 indeksl\u0259rin\u0259 g\u00f6r\u0259 s\u0131ralay\u0131n.\n\nM\u0259s\u0259l\u0259n:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef specialFilter(nums):\n    \"\"\"Bir funksiyan\u0131 yaz\u0131n ki, bu funksiya bir s\u0131ra \u0259d\u0259dl\u0259ri giri\u015f kimi q\u0259bul etsin v\u0259 s\u0131radak\u0131 10-dan b\u00f6y\u00fck olan v\u0259 h\u0259m ilk, h\u0259m d\u0259 son r\u0259q\u0259ml\u0259ri t\u0259k olan elementl\u0259rin say\u0131n\u0131 geri qaytars\u0131n.\nM\u0259s\u0259l\u0259n:\nspecialFilter => 1 \nspecialFilter => 2\n    \"\"\"\n","canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"}
{"prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Siz\u0259 m\u00fcsb\u0259t tam \u0259d\u0259d n verilir. Uzunlu\u011fu n olan tam \u0259d\u0259dli a massivini yaratmal\u0131s\u0131n\u0131z.\n        H\u0259r i \u00fc\u00e7\u00fcn, a[i] = i * i - i + 1.\n        i < j < k olan a massivinin \u00fc\u00e7l\u00fckl\u0259rinin say\u0131n\u0131 tap\u0131n, v\u0259 a[i] + a[j] + a[k] 3-\u0259 b\u00f6l\u00fcn\u0259ndir.\n\n    N\u00fcmun\u0259:\n        Giri\u015f: n = 5\n        \u00c7\u0131x\u0131\u015f: 1\n        \u0130zah:\n        a = [1, 3, 7, 13, 21]\n        Yegan\u0259 uy\u011fun \u00fc\u00e7l\u00fck-d\u00fcr.\n    \"\"\"\n","canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n","test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"}
{"prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n","canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"}
{"prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Bir funksiyan\u0131 yaz\u0131n ki, parametr kimi s\u0259tirl\u0259rd\u0259n ibar\u0259t bir siyah\u0131n\u0131 q\u0259bul etsin,\n    t\u0259rkibind\u0259 t\u0259k uzunluqda olan s\u0259tirl\u0259ri silsin,\n    v\u0259 n\u0259tic\u0259d\u0259 \u0259ld\u0259 olunan siyah\u0131n\u0131 s\u0131ralanm\u0131\u015f qaydada qaytars\u0131n.\n    Siyah\u0131 h\u0259mi\u015f\u0259 s\u0259tirl\u0259rd\u0259n ibar\u0259t bir siyah\u0131d\u0131r v\u0259 he\u00e7 vaxt r\u0259q\u0259ml\u0259rd\u0259n ibar\u0259t bir array deyil,\n    v\u0259 t\u0259krarlanan elementl\u0259r ola bil\u0259r.\n    Siyah\u0131n\u0131n s\u0131ralanmas\u0131 h\u0259r s\u00f6z\u00fcn uzunlu\u011funa g\u00f6r\u0259 artan qaydada olmal\u0131d\u0131r,\n    v\u0259 bu qaydaya \u0259sas\u0259n siyah\u0131n\u0131 qaytarmal\u0131s\u0131n\u0131z.\n    \u018fg\u0259r iki s\u00f6z eyni uzunluqda olarsa, siyah\u0131n\u0131 \u0259lifba s\u0131ras\u0131 il\u0259 s\u0131ralay\u0131n.\n    Funksiya s\u0131ralanm\u0131\u015f qaydada s\u0259tirl\u0259rd\u0259n ibar\u0259t bir siyah\u0131 qaytarmal\u0131d\u0131r.\n    B\u00fct\u00fcn s\u00f6zl\u0259rin eyni uzunluqda olaca\u011f\u0131n\u0131 f\u0259rz ed\u0259 bil\u0259rsiniz.\n    M\u0259s\u0259l\u0259n:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n","canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"}
{"prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Sad\u0259 proqram, \u0259g\u0259r n sad\u0259 \u0259d\u0259d olsa, x d\u0259y\u0259rini qaytarmal\u0131d\u0131r v\u0259 \u0259ks halda y d\u0259y\u0259rini qaytarmal\u0131d\u0131r.\n\nMisallar:\nx_or_y == 34\nx_or_y == 5\n    \n    \"\"\"\n","canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"}
{"prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n","canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"}
{"prompt":"\ndef compare(game,guess):\n    \"\"\"D\u00fc\u015f\u00fcn\u00fcr\u0259m ki, ham\u0131m\u0131z, uzun zamand\u0131r g\u00f6zl\u0259nil\u0259n bir hadis\u0259nin n\u0259tic\u0259sinin n\u0259hay\u0259t m\u0259lum oldu\u011fu an\u0131 xat\u0131rlay\u0131r\u0131q. O anda ya\u015fad\u0131\u011f\u0131n\u0131z hissl\u0259r v\u0259 fikirl\u0259r m\u00fctl\u0259q qeyd edilm\u0259y\u0259 v\u0259 m\u00fcqayis\u0259 edilm\u0259y\u0259 d\u0259y\u0259r. Sizin v\u0259zif\u0259niz bir insan\u0131n bir ne\u00e7\u0259 oyunun n\u0259tic\u0259l\u0259rini d\u00fczg\u00fcn t\u0259xmin edib-etm\u0259diyini m\u00fc\u0259yy\u0259n etm\u0259kdir. Siz\u0259 eyni uzunluqda iki array verilir: biri n\u0259tic\u0259l\u0259rl\u0259, dig\u0259ri is\u0259 t\u0259xminl\u0259rl\u0259. H\u0259r indeks bir oyunu g\u00f6st\u0259rir. H\u0259r t\u0259xminin n\u0259 q\u0259d\u0259r s\u0259hv oldu\u011funu g\u00f6st\u0259r\u0259n eyni uzunluqda bir array qaytar\u0131n. \u018fg\u0259r d\u00fczg\u00fcn t\u0259xmin edibl\u0259rs\u0259, d\u0259y\u0259r 0 olur, \u0259ks halda is\u0259 d\u0259y\u0259r t\u0259xminl\u0259 n\u0259tic\u0259 aras\u0131ndak\u0131 m\u00fctl\u0259q f\u0259rqdir.\n\nmisal:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n","canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Siz\u0259 bir sinifin ad\u0131 v\u0259 geni\u015fl\u0259ndirm\u0259l\u0259r siyah\u0131s\u0131 veril\u0259c\u0259k. Geni\u015fl\u0259ndirm\u0259l\u0259r sinif\u0259 \u0259lav\u0259 sinifl\u0259ri y\u00fckl\u0259m\u0259k \u00fc\u00e7\u00fcn istifad\u0259 olunacaq. Geni\u015fl\u0259ndirm\u0259nin g\u00fcc\u00fc a\u015fa\u011f\u0131dak\u0131 kimidir: G\u0259lin CAP geni\u015fl\u0259ndirm\u0259nin ad\u0131nda olan b\u00f6y\u00fck h\u0259rfl\u0259rin say\u0131 olsun, v\u0259 SM geni\u015fl\u0259ndirm\u0259nin ad\u0131nda olan ki\u00e7ik h\u0259rfl\u0259rin say\u0131 olsun, g\u00fcc CAP - SM fraksiyas\u0131 il\u0259 verilir. Siz \u0259n g\u00fccl\u00fc geni\u015fl\u0259ndirm\u0259ni tapmal\u0131 v\u0259 bu formatda bir s\u0259tir qaytarmal\u0131s\u0131n\u0131z: ClassName.StrongestExtensionName. \u018fg\u0259r iki v\u0259 ya daha \u00e7ox geni\u015fl\u0259ndirm\u0259nin g\u00fcc\u00fc eyni olarsa, siyah\u0131da birinci g\u0259l\u0259n geni\u015fl\u0259ndirm\u0259ni se\u00e7m\u0259lisiniz. M\u0259s\u0259l\u0259n, \u0259g\u0259r siz\u0259 \"Slices\" sinifi v\u0259 geni\u015fl\u0259ndirm\u0259l\u0259r siyah\u0131s\u0131 verilirs\u0259: ['SErviNGSliCes', 'Cheese', 'StuFfed'], siz 'Slices.SErviNGSliCes' qaytarmal\u0131s\u0131n\u0131z, \u00e7\u00fcnki 'SErviNGSliCes' \u0259n g\u00fccl\u00fc geni\u015fl\u0259ndirm\u0259dir. N\u00fcmun\u0259: Strongest_Extension == 'my_class.AA'\n    \"\"\"\n","canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"}
{"prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Siz\u0259 2 s\u00f6z verilir. \u018fg\u0259r ikinci s\u00f6z v\u0259 ya onun h\u0259r hans\u0131 rotasiyas\u0131 birinci s\u00f6zd\u0259 alt s\u0259tir kimi varsa, True qaytarmal\u0131s\u0131n\u0131z.\n    cycpattern_check => False\n    cycpattern_check => True\n    cycpattern_check => False\n    cycpattern_check => True\n    cycpattern_check => False\n    cycpattern_check => True\n\n    \"\"\"\n","canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"}
{"prompt":"\ndef even_odd_count(num):\n    \"\"\"Veril\u0259n tam \u0259d\u0259di n\u0259z\u0259r\u0259 alaraq. T\u0259k v\u0259 c\u00fct r\u0259q\u0259ml\u0259rin say\u0131n\u0131 m\u00fcvafiq olaraq geri qaytaran bir tuple qaytar\u0131n.\n\n     N\u00fcmun\u0259:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n","canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    M\u00fcsb\u0259t tam \u0259d\u0259d verildikd\u0259, onun Roma r\u0259q\u0259ml\u0259ri ekvivalentini s\u0259tir \u015f\u0259klind\u0259 \u0259ld\u0259 edin v\u0259 onu ki\u00e7ik h\u0259rfl\u0259rl\u0259 qaytar\u0131n.\nM\u0259hdudiyy\u0259tl\u0259r: 1 <= \u0259d\u0259d <= 1000\n\nN\u00fcmun\u0259l\u0259r:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n","canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n","canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"}
{"prompt":"\ndef find_max(words):\n    \"\"\"Bir funksiyan\u0131 yaz\u0131n ki, o, bir s\u0131ra s\u00f6zl\u0259ri q\u0259bul etsin.\n    Siyah\u0131da m\u00fcxt\u0259lif s\u00f6zl\u0259r var. Maksimum unikal simvola malik olan s\u00f6z\u00fc qaytar\u0131n. \u018fg\u0259r bir ne\u00e7\u0259 s\u00f6z maksimum unikal simvola malikdirs\u0259, leksik s\u0131ralamada birinci g\u0259l\u0259n s\u00f6z\u00fc qaytar\u0131n.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n","canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"}
{"prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    S\u0259n acl\u0131 dov\u015fansan v\u0259 art\u0131q m\u00fc\u0259yy\u0259n sayda yerk\u00f6k\u00fc yemis\u0259n,\n    amma indi g\u00fcn\u00fcn yem\u0259yini tamamlamaq \u00fc\u00e7\u00fcn daha \u00e7ox yerk\u00f6k\u00fc yem\u0259lis\u0259n.\n    S\u0259n [ yem\u0259kd\u0259n sonra yeyilmi\u015f yerk\u00f6k\u00fc \u00fcmumi say\u0131,\n            yem\u0259kd\u0259n sonra qalan yerk\u00f6k\u00fc say\u0131 ] massivini qaytarmal\u0131san.\n    \u018fg\u0259r kifay\u0259t q\u0259d\u0259r qalan yerk\u00f6k\u00fc yoxdursa, b\u00fct\u00fcn qalan yerk\u00f6k\u00fcl\u0259ri yey\u0259c\u0259ks\u0259n, amma yen\u0259 d\u0259 ac qalacaqsan.\n    \n    N\u00fcmun\u0259:\n    * eat -> [11, 4]\n    * eat -> [12, 1]\n    * eat -> [11, 0]\n    * eat -> [7, 0]\n    \n    D\u0259yi\u015f\u0259nl\u0259r:\n    @number : tam \u0259d\u0259d\n        s\u0259nin yediyin yerk\u00f6k\u00fc say\u0131.\n    @need : tam \u0259d\u0259d\n        s\u0259nin yem\u0259li oldu\u011fun yerk\u00f6k\u00fc say\u0131.\n    @remaining : tam \u0259d\u0259d\n        stokda qalan yerk\u00f6k\u00fc say\u0131.\n    \n    M\u0259hdudiyy\u0259tl\u0259r:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    \u018fyl\u0259nc\u0259l\u0259r :)\n    \"\"\"\n","canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"}
{"prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    \u0130ki operator v\u0259 operand siyah\u0131s\u0131 verilib. Birinci siyah\u0131da \u0259sas c\u0259br \u0259m\u0259liyyatlar\u0131, \n    ikinci siyah\u0131da is\u0259 tam \u0259d\u0259dl\u0259r var. Veril\u0259n iki siyah\u0131dan istifad\u0259 ed\u0259r\u0259k c\u0259br ifad\u0259sini qurun \n    v\u0259 bu ifad\u0259nin qiym\u0259tini qaytar\u0131n.\n\n    \u018fsas c\u0259br \u0259m\u0259liyyatlar\u0131:\n    Toplama \n    \u00c7\u0131xma \n    Vurma \n    Tamsay\u0131 b\u00f6lm\u0259si \n    \u00dcstl\u00fc \n\n    N\u00fcmun\u0259:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    n\u0259tic\u0259 = 2 + 3 * 4 - 5\n    => n\u0259tic\u0259 = 9\n\n    Qeyd:\n        Operator siyah\u0131s\u0131n\u0131n uzunlu\u011fu operand siyah\u0131s\u0131n\u0131n uzunlu\u011fundan bir vahid azd\u0131r.\n        Operand, qeyri-m\u0259nfi tam \u0259d\u0259dl\u0259rd\u0259n ibar\u0259t bir siyah\u0131d\u0131r.\n        Operator siyah\u0131s\u0131nda \u0259n az\u0131 bir operator var v\u0259 operand siyah\u0131s\u0131nda \u0259n az\u0131 iki operand var.\n\n    \"\"\"\n","canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef solve(s):\n    \"\"\"Siz\u0259 bir s s\u0259tri verilir.\n    \u0259g\u0259r s[i] h\u0259rfdirs\u0259, onun ki\u00e7ik h\u0259rfini b\u00f6y\u00fck h\u0259rf\u0259 v\u0259 ya \u0259ksin\u0259 \u00e7evirin,\n    yoxsa, oldu\u011fu kimi saxlay\u0131n.\n    \u018fg\u0259r s s\u0259trind\u0259 he\u00e7 bir h\u0259rf yoxdursa, s\u0259tri t\u0259rsin\u0259 \u00e7evirin.\n    Funksiya n\u0259tic\u0259 olaraq yarad\u0131lm\u0131\u015f s\u0259tri qaytarmal\u0131d\u0131r.\n    N\u00fcmun\u0259l\u0259r\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n","canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"}
{"prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Verilmi\u015f 'm\u0259tn' s\u0259trin\u0259 uy\u011fun md5 hash d\u0259y\u0259rini qaytar.\n    \u018fg\u0259r 'm\u0259tn' bo\u015f s\u0259trdirs\u0259, None qaytar.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n","canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    \u0130ki m\u00fcsb\u0259t tam \u0259d\u0259d a v\u0259 b verildikd\u0259, a v\u0259 b aras\u0131nda olan c\u00fct \u0259d\u0259dl\u0259ri artan s\u0131rayla qaytar\u0131n.\n\nM\u0259s\u0259l\u0259n:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n","canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
