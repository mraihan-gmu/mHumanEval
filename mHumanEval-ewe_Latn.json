{"prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" M\u025bk\u0254 be ny\u025b nye be w\u0254 anyigba \u0192e xexl\u1ebdwo me, nye anyiwo kple anyiwo le asiwo me h\u00e3 eye wo x\u0254\u0303 anyi \u0192e asiwo me \u0256e asiwo \u0192e d\u0254wot\u0254wo.\n\nNubabla:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n","canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n","test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"}
{"prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Here is the translation of the given sentence into Ewe:\n\n\"Nenyea ne fofonye la, w\u00f2ats\u0254 agbale si le e\u014bu towo kple e\u014bu towo \u0192u\u0192o na. W\u00f2ax\u0254a e\u014bu towo siwo le edzi towo kple towo \u0192u\u0192o le esime n\u00e8\u0192u nyate\u0192e kple n\u00e8ts\u0254a e\u014bu a\u0256e siwo m\u00e8\u0256e e\u014bu o. W\u00f2ate \u014but\u0254 nam be w\u00f2ay\u0254 anyigba siwo le fofonye la koe o. Nyanyui a\u0256e:\"\n\nPlease note, Ewe is a language spoken in Ghana and Togo, and the translation aims to accurately capture the meaning and context of the original English text.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n","canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n","test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"}
{"prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Here is the translation of the given sentence into Ewe:\n\nNe w\u00f2ts\u0254 \u0256evi\u0256evi\u014bkpoa\u014bl\u0254lawo \u0256e\u0256e\u0256e le e\u014bu, eye w\u00f2ts\u0254 akpl\u0254la le e\u014bu, eye w\u00f2ts\u0254 \u0256evi\u0256evi\u014bkpoa\u014bl\u0254la le e\u014bu kple akpl\u0254la kple \u0256evi\u0256evi\u014bkpoa\u014bl\u0254la siwo kat\u00e3 nyate\u0192\u00e3 le e\u014bu, eye w\u00f2ts\u0254 \u0256evi\u0256evi\u014bkpoa\u014bl\u0254la siwo kat\u00e3 le e\u014bu kple akpl\u0254la siwo kat\u00e3 nyate\u0192\u00e3 le e\u014bu.\n\nN\u00e0\u0256evi\u0256evi\u014bkpoa\u014bl\u0254la siwo kat\u00e3 le e\u014bu.\n\n\u0189e\u0256e\u0256e:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n","canonical_solution":"    return number % 1.0\n","test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"}
{"prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Mekae ts\u0254a \u0256e\u0256e\u014buwo eye wohe nu siwo w\u0254 le banki konto me eye w\u00f2\u0256e kuku \u0256eka. Wo\u0256o gbe be woa\u014bl\u0254 na nu si dz\u0254 le banki konto me be w\u00f2ts\u0254 le afima eye w\u00f2ts\u0254 le afima, eye le afima siaa me w\u00f2kp\u0254 be ye\u0256i le afima si me. Le afima siaa me, agbal\u1ebda \u0192e d\u0254w\u0254la nye True. Esi mele be w\u00f2kp\u0254 nyuie le afima si me la, agbal\u1ebda \u0192e d\u0254w\u0254la nye False.\nNukunu:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n","canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n","test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"}
{"prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Here is the translation of the provided sentence into Ewe:\n\n\"Ne woabe eg\u0254me \u014bk\u0254wo kat\u00e3 a\u0256e le wo \u014bk\u0254la me, nye \u0263eyi\u0263i me\u0192e Mean Absolute Deviation\n    le t\u0254tr\u0254 \u0256e sia t\u0254tr\u0254 me. \n    Mean Absolute Deviation le \u0256eka me \u0256e \u014bk\u0254wo kat\u00e3 kple t\u0254tr\u0254:\n    MAD = \u0256eka \u014bk\u0254wo kat\u00e3 kple t\u0254tr\u0254 a\u0256e le wo \u014bk\u0254la me:\n    Eg:\"\n\nFeel free to ask if you need further assistance!\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n","canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n","test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"}
{"prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" To translate the sentence \"Insert a number 'delimiter' between every two consecutive elements of input list `numbers`\" into Ewe, it might be written as:\n\n\"Le nun\u0254la 'delimiter' a\u0256e abe wo\u0192e eve eve \u0192e a\u0256eke le \u0256okuiwo si nye `numbers` me.\"\n\nNote: Ewe is a language spoken in Ghana and Togo. Translations can vary slightly based on regional dialects and context.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n","canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n","test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"}
{"prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Here is the translated sentence in Ewe:\n\n\"E\u014bl\u0254 k\u0254k\u0254 si va d\u0254m g\u0254me le esime w\u0254e ab\u0254b\u0254 anyigba\u014buwo si le \u0256eviwo \u0192e te\u0192e me eye wots\u0254 ameawo \u0256o \u0256e me abe wuiesie. \n    Ne w\u00f2do \u014but\u0254 bubuawo me, neva\u0256o \u0256e go \u014but\u0254 sia t\u0254t\u0254 le te\u0192e me. \n    \u0194e eg.) le \u0256eka \u014but\u0254 eve nyate\u0192e me le \u0256eviwo \u0192e te\u0192e me eye)) le \u014but\u0254 et\u0254\u0303wo.\"\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n","canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n","test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"}
{"prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" L\u0254 listi a\u0256e si w\u0254 le nu\u014bl\u0254\u0303wo me eye na\u0256u nu\u014bl\u0254\u0303 a\u0256e si w\u0254 le e\u014butsuwo me.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if substring in x]\n","test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"}
{"prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Esi w\u00f2anya listi a\u0256e si le integerwo me, m\u00e8gbl\u0254 tuple a\u0256e si le sum kple product \u0192e \u0256okuiwo le listi la me. \n    Sum a\u0256e si nye empty la n\u00e0ts\u0254a 0 kple product a\u0256e si nye empty la n\u00e0ts\u0254a 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n","canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n","test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"}
{"prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Here is the translation of the sentence into Ewe:\n\n\"Le wo\u0256e nu siwo le wo\u0256e nu siwo le, nu siwo duk\u0254 me, miekp\u0254a nu siwo nyate\u0192e siwo le afisia.\"\n\nPlease note that translations can vary based on context and regional dialects.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n","canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"}
{"prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Tso dzi le nu si w\u0254e eye ne w\u00f2akp\u0254 be nyatak\u0254 si melea nye nyatak\u0254 be ne kpl\u0254e w\u00f2. \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n","canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"}
{"prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Here is the translation of the given sentence into Ewe:\n\nN\u0254viwo a kple b le siwo \u0256e eme le 1 kple 0 ene le nunye a\u0256ewo. \n    Nya XOR a\u0256e a\u0256ewo h\u00e3 kple n\u0254viwo me kple d\u0254 result h\u00e3 le nunye a\u0256ewo ene.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n","canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n","test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"}
{"prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Esi le agbal\u1ebdwo kat\u00e3 dzi, na\u0256e g\u00e3t\u0254wo kat\u00e3 me t\u0254 \u0256eka si g\u00e3t\u0254 le eme. Na\u0256e t\u0254t\u0254 \u0256eka si le eme d\u0254 le \u014bkeke si le agbal\u1ebdwo kat\u00e3 g\u00e3t\u0254. Na\u0256e None le esime agbal\u1ebdwo kat\u00e3 me\u0256e o.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n","canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n","test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"}
{"prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" W\u0254 d\u0254w\u0254n ny\u0254nuvi yi a\u0256ewo si mew\u0254 a kple b.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n","canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n","test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"}
{"prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" M\u025b\u0303he \u0256e\u0256iwo kat\u00e3 si le nu\u0256e\u0256e me tso nu v\u0254\u0303 kple nu v\u00e3t\u0254 me\u0256o\u0256o\u014bkpo wo le nu\u0256e\u0256e me.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n","canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n","test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"}
{"prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" W\u00f2kpl\u0254 string si le \u0256eka\u0256eka \u0192e xexeme \u0192e \u0256e\u0256e siwo le \u0256okuikui me le 0 to n m\u025bl\u0254\u0303a.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n","canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n","test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"}
{"prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" M\u00e8nya nyate\u0192e si le fia la, ne m\u00edakp\u0254 nu si w\u00f2le le eme siwo nye nuv\u0254\u0303wo \u0192e kple wo\u0192\u00e9 \u0192e nu siwo \u0192e blabla.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n","canonical_solution":"    return len(set(string.lower()))\n","test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"}
{"prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" ```ewe\n\u0189e sia me va le nu\u014bkp\u0254lawo w\u0254 kpe \u0256e asiikii w\u00f2le\u0256e me. \nNuts\u0254\u014bl\u0254 sia nye be n\u00e0ts\u0254 nu\u014bkp\u0254la sia nyate\u0192e eye n\u00e0\u0192e li\u0192owo \u0192e xexl\u1ebdwo \u0192e \u014bk\u0254wo v\u0254 \u0192e \u014bk\u0254wo \u0192ewo kat\u00e3 \u0192e \u014bk\u0254wo \u0192e ak\u0254wo \u0192e \u0256o\u0192e kple nu\u014bkp\u0254la sia \u0192e \u0256e\u014buwo \u0192e ax\u0254wo \u0192e \u0256e\u014buwo \u0192e ak\u0254wo \u0192ewo kat\u00e3 \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo \u0192ewo\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n","canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n","test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"}
{"prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Dzra nyate\u0192e siwo le nuv\u0254\u0303 siwo le fofogbea \u0192e \u0256o\u0256o. \u0194l\u0254 nu siwo wo\u0256e kuku bubu.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n","canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n","test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"}
{"prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Here is the translation in Ewe:\n\n```plaintext\nNunya\u0256o\u0256o nye agbal\u1ebd a\u0256e si me le v\u0254sa\u0256a me le \"zero\" kple \"nine\".\n    Fofoviwo siwo le \u0256e\u0192e nye \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\" kple \"nine\".\n    Kpl\u0254 agbal\u1ebd sia le \u0256e\u0192e siwo le xoxome kple suetome.\n```\n\nIf you have any further specific requirements or adjustments, please let me know!\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n","canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"}
{"prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" M\u00ed\u0192le t\u0254tr\u0254 a\u0256e siwo w\u0254 \u0192omewo eye m\u00edtsi \u0256e eve wo kat\u00e3 siwo neva \u0256e \u0256okui kple \u0256o\u0256o eye m\u00edva gbe wo le \u0256eka \u0256eka.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n","canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n","test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"}
{"prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Ne w\u00f2anya \u014bk\u0254 \u0256eka me nu, \u0256a\u0256o \u0256e \u014bk\u0254t\u0254wo me, gake ne \u0256e \u0256e\u0256i \u0256e\u0256e le wo \u014bk\u0254 me, ne \u0256e\u0256e\u0256i si tu \u0256eke o le wo me wo \u0256e \u0256e\u0256e\u0256i si tu \u0256eka.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n","canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n","test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"}
{"prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" W\u0254 anyi t\u0254wo si le list la me eye n\u0254 \u0256e asi na \u0256eka siwo nye integers.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n","canonical_solution":"    return [x for x in values if isinstance(x, int)]\n","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"}
{"prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" W\u0254 ats\u0254a nu siwo le \u0192e\u0192ew\u0254w\u0254 me.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n","canonical_solution":"    return len(string)\n","test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"}
{"prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" E\u0192e xexl\u1ebdme\u0256e n, gbl\u1ebd e\u0192e v\u0254\u0303 a\u0256eke le n siwo meyim n gb\u00e3\u0256e v\u025b.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n","canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n","test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"}
{"prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Here is the translation of the given sentence into Ewe:\n\n\"D\u0254 nyatakak\u0254wo \u0192e xexl\u1ebdwo tso d\u0254la si w\u00f2na be woakpia \u0256i eye woa\u0256e wo \u0192e d\u0254wok\u0254wo siwo le ab\u0254 \u0256eka me \u0256o. \n    \u0191\u0254li kple nyatakak\u0254wo nyuiwo kat\u00e3 le abe wo\u0256e \u0256e \u0192e xexl\u1ebdwo me. \n    D\u0254la si wow\u0254e nye nyatakak\u0254wo \u0192e xexl\u1ebdwo kat\u00e3 \u0192e xexl\u1ebd.\"\n\nPlease note that Ewe language may not have direct equivalents for some technical terms, and the translation provided seeks to convey the meaning as accurately as possible.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n","canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n","test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"}
{"prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Here is the translation to Ewe:\n\n\"Le list kple xexl\u1ebdwo me, to xexl\u1ebdwo kple yiwo le afisia me. Gbogbl\u1ebd xexl\u1ebdwo si dzoe le list me eye nye game w\u00f2.\"\n\nNote that translations may vary slightly depending on regional dialects within the Ewe-speaking community.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n","canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"}
{"prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Ne w\u0254 d\u0254w\u0254 \u0256e edzi a\u0256e, nudz\u0254dz\u0254 anyigbawo na \u0256e \u0256o\u0256owo kple \u0256o\u0256owo na \u0256e \u0256o\u0256owo.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n","canonical_solution":"    return string.swapcase()\n","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"}
{"prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Kp\u0254 nu\u014bk\u0254wo \u0192e \u014bk\u0254wo na \u0256e \u0256eka \u014bk\u0254 me.\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n","canonical_solution":"    return ''.join(strings)\n","test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"}
{"prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Tia wo le x\u0254listi a\u0256e me \u014but\u0254wo si woate \u014bu na\u0256u a\u0256e si w\u00f2le xoxome.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n","test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"}
{"prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Me\u0256e abe yiawo siwo le lista dzi me\u0256e\u0256e.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n","canonical_solution":"    return [e for e in l if e > 0]\n","test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"}
{"prompt":"\n\ndef is_prime(n):\n    \"\"\"Ne\u0256e be nu si gb\u0254 dze a\u0256e dze le a\u0256e a\u0256e, ne nyate\u0192e eye ne menye nyate\u0192e o.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n","canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n","test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"}
{"prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial kple coefficients xs le point x.\n    return xs[0] kple xs[1] * x kple xs[2] * x^2 kple .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n","canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n","test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"}
{"prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Af\u0254\u0192li si w\u00f2\u0256e e\u0192e \u014bk\u0254me l, w\u00f2\u0256e e\u0192e \u014bk\u0254me l' ene be\n    l' \u0192e \u014bk\u0254wo kat\u00e3 \u0192e \u014bk\u0254 siwo menye \u0256e\u0256e at\u0254\u0303wo \u0256ek\u0254wo me le l me, eye l' \u0192e \u014bk\u0254wo siwo nye \u0256e\u0256e at\u0254\u0303wo \u0256ek\u0254wo \u0192e \u014bk\u0254wo le l me w\u00f2ts\u0254 amewo\n    le nu siwo kat\u00e3 le \u014bk\u0254 siwo nye \u0256e\u0256e at\u0254\u0303wo \u0256ek\u0254wo me le l me, ke bo\u014b l' \u0192e \u014bk\u0254wo siwo nye \u0256e\u0256e at\u0254\u0303wo \u0256ek\u0254wo \u0192e \u014bk\u0254wo \u0192e \u014bk\u0254wo le l me w\u0254na nu.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n","canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n","test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"}
{"prompt":"\n\ndef unique(l: list):\n    \"\"\"N\u0254 agbal\u1ebdwo siwo nenyo kple fofoviwo le akpl\u0254\u0303me.\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n","canonical_solution":"    return sorted(list(set(l)))\n","test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"}
{"prompt":"\n\ndef max_element(l: list):\n    \"\"\"T\u0254\u0303\u014b maximum element le list me.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n","canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n","test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"}
{"prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Mets\u0254 \u0256i\u0256i a\u0256eke \u014bk\u0254t\u00e1t\u0254 7 ts\u0254 \u0256eviwo me le, siwo me\u0256e asi le 11 kple 13 me eye wo\u014bk\u0254 n.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n","canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n","test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"}
{"prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\n\"\u0192e sia kp\u0254 a\u0256e \u0256i\u0256i sia l kple w\u00f2a\u0256e \u0256i\u0256i sia l' a\u0256e eya ta\n    l' \u0192e k\u0254nuwo n\u0254 l \u0192e k\u0254nuwo me le k\u0254nuwo siwo le xexe\u0256iwo me, eye w\u00f2\u0192e xexeme\u0256iwo n\u0254\n    k\u0254nuwo siwo le xexe\u0256iwo me le l me, ke bo\u014b t\u0254 w\u00f2w\u0254 na\u0256e kpl\u1ebd.\"\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n","canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n","test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"}
{"prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    w\u0254a\u028bu encoded string \u0256e gbe\u0256ek\u0254k\u0254 \u0192e a\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e\u0256e.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n","canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n","test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"}
{"prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib de n-n\u025b wo\u0256u\u0256u a\u0256eke le Fibonacci wo\u0256u\u0256uwo me eye w\u00f2le nu\u0256u\u0256u si w\u00f2le \u0256e afisiwo me.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n","canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n","test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"}
{"prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    \"triples_sum_to_zero do go \u014bk\u0254wo si le nyatakakawo me va dz\u0254 \u0192u\u0192o\u0192o.\n    Eva \u0256o True eye w\u00f2ana \u014bk\u0254tedzi\u0256i\u0256i\u0256i et\u0254\u0303wo si le \u014bk\u0254wo me \u0192e nu siwo kat\u00e3 \u0256u ne\u0256e afisia zero, eye w\u00f2ava \u0256o False ka m\u00e8gbe.\"\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n","test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"}
{"prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Here is the translation of the given sentence into Ewe:\n\n```\nT\u0254 asi le abl\u0254\u0256e si ye le a\u0256e ta la me be ye le nyuie eye w\u00f2 le klosalo \u0256e fu la me o.\nn atike siwo le fu la dzi le dz\u0254\u0256e si wo le ga\u0256u\u0256e \u0256e asi o; kple be wo x\u0254a n atike siwo le dz\u0254\u0256e siwo le fu la dzi le dzi\u0256e si wo le asi o.\nAtike evewo \u0192e asi mew\u0254 \u0256e \u0256eke o. Atike siwo le fu la dzi \u0256e asi kple atike siwo le dz\u0254\u0256e \u0256e asi \u0192o \u0256o\u0256iwo le asi o.\nGake, atike le asi la le asi en\u0254w\u0254 kple asi\u0256e\u0256e; eye ke wo le asi \u0256e asi \u0192e asi mew\u0254 \u0256e asi \u0256e atike evewo \u0192e asi o.\nA\u0192e sia wots\u0254 \u0256e asi \u0256e asi \u0192e asi \u0192ome be asi w\u0254 kple asi \u0192e asi \u0256o\u0256iwo \u0192e asi \u0192e asi la mew\u0254 \u0256eka o.\n```\n\nThis translation maintains the meaning and details of the original text while presenting it in Ewe.\n    \"\"\"\n","canonical_solution":"    return n**2\n","test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"}
{"prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Ne\u0256e list la gb\u0254 na \u0256eviwo siwo le eme dzi na\u0256e 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n","canonical_solution":"    return [(e + 1) for e in l]\n","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"}
{"prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    `pairs_sum_to_zero` \u0192e nya \u0192e t\u0254tr\u0254 \u0192e \u0192e \u0256eka ene la \u0192e t\u0254x\u0254x\u0254 \u0192e t\u0254tr\u0254 \u0192e t\u0254x\u0254x\u0254 \u0192e. \n    Eya tae nye be \u0256e be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0192u be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e \u0256eke be wo le t\u0254tr\u0254 \u0192e.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n","test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"}
{"prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\n\"Ts\u0254 numerikali \u0192ome x dzi yi \u0192ome si w\u00f2le. \n    N\u00e0ts\u0254 \u0192ome siwo le bometsitsiwo me \u0256e akpa \u014but\u0254wo me \u0256i.\n    \u0191ome \u0192ome siwo le bometsitsiwo me me\u0256e sia \u0256eke o.\"\n\nNote: Ewe is a language spoken in Ghana and Togo. The translation captures the essence of the technical instructions given in the original sentence.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n","canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n","test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"}
{"prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Mekae lenki a\u0256e kple dzigb\u0254gbl\u0254 na\u0256u \u0256evi a\u0256eke eye ne w\u00f2va do alo alo a\u028ba vevi \u0256e\u0256e lolo na traya\u014bgule.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n","canonical_solution":"    return a * h \/ 2.0\n","test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"}
{"prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 number sequence la \u0192e sequence si le Fibbonacci sequence la \u0192e sequence me w\u00f2. Edzi be y\u00e8:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    M\u00e9di nyuie be ekp\u0254 nu siwo kat\u00e3 le fib4 number sequence la \u0192e n-t\u0254dzikp\u0254 la. M\u00e8nye w\u00f2e gbl\u1ebdnu kple recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n","canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n","test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"}
{"prompt":"\n\ndef median(l: list):\n    \"\"\"D\u0254 mediana \u0192e l\u0254l\u0254awo si le l\u0254\u0303l\u0254\u0303 l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n","canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n","test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"}
{"prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Ne string si wo\u0256e lee nye palindrome.\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n","test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"}
{"prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Ne egbl\u0254 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n","canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n","test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"}
{"prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    W\u0254ts\u0254 agbal\u1ebd siwo \u0192e agbal\u1ebd \u0192u \u0256e asiwo me na 5 de alfab\u025bt me.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n","canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n","test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"}
{"prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels nye function si w\u0254e dze string eye w\u0254 d\u0254 string si mele vowels o va.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n","canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"}
{"prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"T\u0254 d\u0254d\u0254e se \u0256e nyate\u0192e \u0192e nu siwo kat\u00e3 le l \u0192e nuwo me le t me.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n","canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n","test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"}
{"prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Ts\u0254 x kple y \u0192e xexl\u1ebd v\u0254\u0303.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n","canonical_solution":"    return x + y\n","test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"}
{"prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    D\u0254m le nyate\u0192e eve me le wo\u0192e v\u0254\u0303wo \u0192e dze\u0256e \u0192e \u0256e\u0256eawo.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n","canonical_solution":"    return set(s0) == set(s1)\n","test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"}
{"prompt":"\n\ndef fib(n: int):\n    \"\"\"Dzra n-th Fibonacci \u0192e\u0256eke.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n","test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"}
{"prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Here is the translation of the given sentence into Ewe:\n\n\"Brackets nye nyatak\u025b a\u0256eviwo \u0192e \"<\" kple \">\".\n    N\u0254 agbl\u0254 be nyate\u0192e le nu si me w\u00f2akp\u0254a \u0192e nyatak\u025b si kpl\u0254e.\"\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"}
{"prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Ne\u0256e gbe L\u0254\u0303 kple \u0256eviwuiwo kat\u00e3 kp\u0254 akpe \u0256eka \u0256e sia \u0256eke \u0256e gb\u0254\u0303 gb\u0254\u0303 kple gbl\u0254 gbl\u0254.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n","canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n","test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"}
{"prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"M\u025b ke\u0256e nyuie wo \u0192e kplea\u0256e le a\u0256e eve \u0192e \u0256\u0254\u0256\u0254 kplea\u0256e.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n","canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n","test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"}
{"prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\n\"D\u0254 n\u025be \u0256e fiae \u0192e \u0256e\u0256evi \u0192e alo\u0256evi la v\u0254\u0303e. Tso n > 1 eye wots\u0254 agbal\u1ebd o.\"\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n","canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n","test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"}
{"prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n nye function a\u0256e si le sum gba dz\u0254dz\u0254 \u0256e 1 kple n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n","canonical_solution":"    return sum(range(n + 1))\n","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"}
{"prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" In brackets le m\u00ed \u201c\u201d.\n    \u0192e wo n\u025b \u0256e \u0256okui \u0256e w\u00f2 be n\u025b wo a\u0256e \u0256e \u0256okui \u0256e w\u00f2 be n\u025b wo a\u0256e \u0256okui \u0256e w\u00f2 be n\u025b wo a\u0256e \u0256okui n\u025b.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"}
{"prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs le nuwo si w\u00f2gbl\u0254 eye w\u00f2le le polynomial a\u0256e me.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Na \u0192e\u0256evi a\u0256e si le polynomial a\u0256e me le nu siwo dze eg\u0254me.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n","canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n","test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"}
{"prompt":"\n\ndef fibfib(n: int):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\nFibFib \u0192e xexl\u0254lawo kple Fibonacci \u0192e xexl\u0254lawo \u0192e vevi \u0192e vevie \u0192e nu si le eme:\n\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Me\u0256o dzesi si w\u00f2anye na n\u00e0ts\u0254 n-t\u0254 xexl\u0254la FibFib \u0192e xexl\u0254lawo \u0256e\u0256e \u0256e eme.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n","test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"}
{"prompt":"\nFIX = \"\"\"\nD\u0254 test cases kple kple.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\n\"Yi x \u0256i\u0256iwo \u0192e \u0256e\u0256e a\u0256a\u0256a, yi \u0256i\u0256iwo \u0192e \u0256e\u0256e va \u0192ome \u0256e xoxo la \u0256e eye na\u0256o eya be \u028bu\u0256u e\u014bu be string.\nNe shift le \u0256i\u0256iwo \u0192e \u0256e\u0256e me lolo si va, \u0256o \u0256i\u0256iwo a\u0256a\u0256a.\"\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n","canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef digitSum(s):\n    \"\"\"Here is the translation of the provided sentence into Ewe:\n\n```\nD\u0254w\u0254 d\u0254w\u0254 me be men\u0254\u0256e si kpl\u0254 nu si le e\u014bu be w\u00f2atu xoxo kple w\u00f2e\u014bu a\u0256ewo \u014bkui w\u0254m na w\u00f2ate \u014bkui a\u0256ewo me.\n\nNya\u0256e\u0256eviwo:\n    digitSum => 0\n    digitSum => 131\n    digitSum => 67\n    digitSum => 69\n    digitSum => 131\n    digitSum => 153\n```\n    \"\"\"\n","canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"}
{"prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    M\u025b\u0303a\u0256o\u0256o sia, w\u00f2ana be w\u00f2akafui \u0256e sia be w\u0254anu k\u0254k\u0254\u025b siwo le basket kple anyin\u025b siwo le basket me. Basket sia le k\u0254k\u0254\u025b, anyin\u025b kple mango siwo. W\u00f2ana be string si na\u0256u kple xexemea siwo le basket me. String sia w\u00f2ana be k\u0254k\u0254\u025b kple anyin\u025b siwo \u0192e dzesi kple integer sia \u0192e dzesi siwo le basket me. W\u00f2ana be mango siwo \u0192e dzesi si le basket me.\nN\u025b \u0256e sia:\nfruit_distribution -> 19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n","canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"}
{"prompt":"\ndef pluck(arr):\n    \"\"\"\n    Here is the translation of the given sentence into Ewe:\n\n```\nNe woadzi agbal\u1ebd si le d\u0254dzesi si le kpe\u0256e\u0256e eveawo me, wo n\u0254nu nye \u0256o agbal\u1ebd siwo me le agbal\u1ebd siwo me \u0256e eye n\u0254 agbal\u1ebd siwo me le agbal\u1ebd siwo me \u0256e siwo me le agbal\u1ebd siwo me \u0256e siwo me le agbal\u1ebd siwo me \u0256e evea me.\n\nAgbal\u1ebd siwo w\u00f2a\u0256o \u0256a, ne w\u00f2le agbal\u1ebd siwo me la, agbal\u1ebd siwo \u0256e siwo me le agbal\u1ebd siwo me \u0256e evea me le agbal\u1ebd siwo me le agbal\u1ebd siwo me \u0256e evea me.\n\nNe woade agbal\u1ebd siwo me \u0256e siwo me le agbal\u1ebd siwo me \u0256e evea me la, woade agbal\u1ebd siwo me \u0256e siwo me \u0256e siwo me le agbal\u1ebd siwo me \u0256e evea me.\n\nNe w\u00f2le agbal\u1ebd eveawo kple agbal\u1ebd eveawo me \u0256e agbal\u1ebd siwo me, agbal\u1ebd siwo me \u0256e evea me le agbal\u1ebd siwo me le eveawo kple agbal\u1ebd eveawo me \u0256e eveawo.\n\nNe w\u00f2le agbal\u1ebd eveawo kple agbal\u1ebd eveawo me \u0256e agbal\u1ebd siwo me le agbal\u1ebd eveawo me \u0256e eveawo me, agbal\u1ebd eveawo me.\n\nAgbal\u1ebd eveawo me \u0256e agbal\u1ebd siwo me \u0256e evea me le agbal\u1ebd siwo me \u0256e eveawo me le agbal\u1ebd eveawo me le agbal\u1ebd eveawo me le eveawo.\n\nAgbal\u1ebd eveawo me \u0256e agbal\u1ebd siwo me \u0256e eveawo me le agbal\u1ebd siwo me \u0256e eveawo me le agbal\u1ebd siwo me \u0256e eveawo me le eveawo.\n\nAgbal\u1ebd eveawo me \u0256e agbal\u1ebd siwo me \u0256e eveawo me le agbal\u1ebd siwo me \u0256e agbal\u1ebd siwo me \u0256e eveawo me le eveawo.\n\nAgbal\u1ebd eveawo me ne woade agbal\u1ebd eveawo kple agbal\u1ebd eveawo me \u0256e eveawo me le agbal\u1ebd siwo me \u0256e eveawo me le eveawo.\n\nAgbal\u1ebd eveawo me \u0256e eveawo me le agbal\u1ebd siwo me \u0256e eveawo me le eveawo me le agbal\u1ebd siwo me \u0256e eveawo me le eveawo me le eveawo.\n\nAgbal\u1ebd eveawo me \u0256e agbal\u1ebd siwo me \u0256e eveawo me le eveawo me le agbal\u1ebd siwo me \u0256e eveawo me le eveawo me le eveawo me le eveawo.\n\nAgbal\u1ebd eveawo me ne woade agbal\u1ebd eveawo kple agbal\u1ebd siwo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo.\n\nAgbal\u1ebd eveawo me ne woade agbal\u1ebd siwo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo me le eveawo\n    \"\"\"\n","canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"}
{"prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n","canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n","test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"}
{"prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n","canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n","canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"}
{"prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n","canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"}
{"prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Mekae \u014butinya si le Ewe \u0192e gbe me:\n\nNe w\u00f2woa array arr si le integer kat\u00e3wo me la, n\u0254 anyigba si kat\u00e3wo woate \u014bu na\u0256o eye nedzrae na \u0256e array si kpl\u0254 na akpe a\u0256e si le gb\u0254m\u025b eye gb\u0254gb\u0254m\u025b n\u025b. Akpe a\u0256e si le gb\u0254m\u025b eye gb\u0254gb\u0254m\u025b n\u025b nye array si w\u00f2ate \u014bu le gb\u0254m\u025b eye gb\u0254gb\u0254m\u025b n\u025b. Le \u014butinya a\u0256e, w\u00f2ate \u014bu na\u0256o anyigba a\u0256e \u0256e anyigba a\u0256e si woate \u014bu.\n\nNudz\u0254dz\u0254e a\u0256e:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n","canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"}
{"prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n","canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"}
{"prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Here is the translation of the sentence into Ewe:\n\nD\u0254 a\u0256e si w\u00f2ak\u0254 \u0256e be amedede la n\u00e0ts\u0254 eya si w\u00f2\u0256e tso 3 \u0256e\u0256e\u0256e\u0192e xexl\u0254\u0303wo me eye w\u00f2na be nyate\u0192e dze egbe n\u025b.\nN\u00e0ra be le 100 me.\nGbedododa:\nis_multiply_prime == Nyate\u0192e\n30 = 2 * 3 * 5\n    \"\"\"\n","canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n","test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"}
{"prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Wo d\u0254w\u0254lawo nye be wo\u0256e fifea si dze eg\u0254me be ne xwo dze kple nwo eye ne xka le nu siwo me a\u0256e o. xwo dze kple nwo ne n**int=x. \nNenye esime:\nis_simple_power => nyate\u0192e\nis_simple_power => nyate\u0192e\nis_simple_power => nyate\u0192e\nis_simple_power => m\u0254\nis_simple_power => m\u0254\nis_simple_power => m\u0254\n    \"\"\"\n","canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n","canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"}
{"prompt":"\ndef hex_key(num):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\nW\u0254w\u0254a wo be woats\u0254 n\u025b be n\u00e0ts\u0254 a function si n\u00e8 nya \u0256e asi be n\u00e0ts\u0254 anyigba \n    a hexadecimal n\u00f9 kple string kple n\u00e0t\u0254 anyigba \u0192e hexadecimal \n    digits siwo nye primes (prime number, eye w\u00f2 dzo \u0256e \u0256eka le a natural number \n    meto wo kple xexe siwo le wo sub\u0254). \n    Hexadecimal digits nye 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers nye 2, 3, 5, 7, 11, 13, 17,...\n    Ne wo na w\u0254w\u0254 anyigba n\u025b be woada dzidz\u0254 \u0192e digits siwo nye: 2, 3, 5, 7, \n    B, D.\n    Note: w\u00f2na w\u00f2a assume be input siwo nye al\u0254k\u0254k\u0254 eye wo le empty string, \n    kple symbols A, B, C, D, E, F nye w\u00f2na uppercase le. \n    Examples:\n    Ne num = \"AB\" w\u00f2na output si nye 1.\n    Ne num = \"1077E\" w\u00f2na output si nye 2.\n    Ne num = \"ABED1A33\" w\u00f2na output si nye 4.\n    Ne num = \"123456789ABCDEF0\" w\u00f2na output si nye 6.\n    Ne num = \"2020\" w\u00f2na output si nye 2.\n    \"\"\"\n","canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"}
{"prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"W\u00f2abe \u0256eka \u0256eka le decimal me eye w\u00f2 n\u0254nu be w\u00f2akpl\u0254e le binary format me. Function la men\u0254 be w\u00f2a\u0256e string si \u0256e, eye agbe\u0256ifom atsuwo n\u00e8ts\u0254 woagbe\u0256o a\u0256e sia a\u0256e le binary number me. Agbe\u0256ifom atsuwo kat\u00e3 si le string me n\u00e8va '0' kple '1'.\n\nLe string la \u0192e nu\u0256o\u0256ola me va\u0256u n\u0254nu \u0256eka si nye 'db' le e\u0192e menya gb\u00e3t\u0254 eye 'db' le e\u0192e \u0192u. Nu\u0256o\u0256ola sia le g\u0254me ne w\u00f2ats\u0254e eye w\u00f2akpl\u0254 format.\n\nNufialawo:\ndecimal_to_binary   # va 'db1111db'\ndecimal_to_binary   # va 'db100000db'\n    \"\"\"\n","canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef is_happy(s):\n    \"\"\"Mekae \u0256e nu\u014bl\u0254\u0256i\u0256i s.\n    Wo\u0256e\u014bu a\u0256e me alo menye me.\n    Nu\u014bl\u0254\u0256i\u0256i a\u0256e \u0256e me le be e\u014bu \u0256o \u0256eka \u0256e\u0256i 3 eye afisiaa 3 \u0192e d\u0254w\u0254wo n\u0254 d\u0254w\u0254wo siwo menye \u0256eka le a\u0192e.\n    Ne\u014bu be:\n    is_happy => Menye me\n    is_happy => Menye me\n    is_happy => Nye me\n    is_happy => Menye me\n    is_happy => Nye me\n    is_happy => Menye me\n    \"\"\"\n","canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"}
{"prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u00c8y\u025b \u0263leti sia \u0256e semester kple ny\u0254nu-titritr\u0254 la w\u00f2le \u0256o be n\u00e0tso sr\u0254\u0303wo \u0192e dzesiiwo na wo. Ny\u0254nu-titritr\u0254 la le be w\u00f2\u0256e w\u00f2ate\u0192e algorithm si wow\u0254 akpeyi me. Gake nyuie a\u0256e le be, w\u00f2\u0256o code si w\u00f2w\u0254 akpeyi me kple. W\u00f2w\u0254 list si gb\u0254 na w\u00f2 me\u0256e\u0256e sr\u0254\u0303wo \u0192e GPAwo kple w\u00f2le be na\u0256e function a\u0256e si w\u00f2ale list si \u0192e letter gradewo le table si dzi:\n             \n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n\n    Example:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n","canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef prime_length(string):\n    \"\"\"M\u025b a\u0256e sia n\u025b E\u028begbe:\n\nTs\u0254 function a\u0256e si ts\u0254 string a\u0256e eye w\u00f2va d\u0254 nyate\u0192e tso string la \u0192e\n    \u0256eviwo me w\u0254 \u0256evi si nye \u0192e\u0256e\u0192o deka alo \u0192e\u0256e\u0192o domet\u0254 \u0256eka\n    \u0194e\u028buwo\n    prime_length == Nyate\u0192e\n    prime_length == Nyate\u0192e\n    prime_length == Nyate\u0192e\n    prime_length == \u0191e\u0256e\u0192o\n    \"\"\"\n","canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"}
{"prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    M\u00edets\u0254 n\u0254viwo n\u0254viwo \u0192e xexl\u1ebdme n, m\u00edet\u0254 xexl\u1ebdme \u0192e n\u0254viwo n\u0254viwo \u0192e xexl\u1ebdme n\u0254viwo \u0192e xexl\u1ebdme n\u0254viwo \u0192e n\u0254viwo \u0192e xexl\u1ebdme 1 si wo ts\u0254a \u0192e \u0256e sia \u0256e 1.\n    \"\"\"\n","canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef solve(N):\n    \"\"\"M\u00e8ts\u0254 N a\u0256e si le anyigba dzi n\u025b, nya be mado sum si le e\u0192e xexl\u1ebd me na w\u00f2.\n\n    \u0194e\u0256e\u014bu\n        Ne N = 1000 la, xexl\u1ebd sum alo 1 eye nu si w\u00f2akl\u0254na gbl\u0254 be \"1\".\n        Ne N = 150 la, xexl\u1ebd sum alo 6 eye nu si w\u00f2akl\u0254na gbl\u0254 be \"110\".\n        Ne N = 147 la, xexl\u1ebd sum alo 12 eye nu si w\u00f2akl\u0254na gbl\u0254 be \"1100\".\n\n    Variabl\u1ebdwo:\n        @N integer\n            Constraints: 0 \u2264 N \u2264 10000.\n    Nusiwo:\n         dzesi\u014bk\u0254\u0192e \u0192e binary number a\u0256e si nye string.\n    \"\"\"\n","canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"}
{"prompt":"\ndef add(lst):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\nMets\u0254 list si le \u0256eka ta\u0256ea\u0256e \u0256eka me sia me eye na\u0256o evee si le dzidzime\u0256eka \u014bk\u0254 me.\n\n    A\u028bl\u0254\u028b\u0254wo:\n        add ==> 2 \n    \"\"\"\n","canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"}
{"prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Here is the translation of the given text into Ewe:\n\n```\nTs\u0254 function si le string de asi eye wots\u0254 e\u0256e asi nyui le. \n    Asi nyui si le string me, nye string si ne wo\u0256e anyigba \n    eye woats\u0254 anyigba siawo de asi\u014bk\u0254\u014bk\u0254wo siwo le \n    agbal\u1ebdwo me le n\u0254via\u0256o\u0256o be asiiwo de asi\u014bk\u0254\u014bk\u0254wo g\u0254me be woaxa\u0256e e\u014bu le asi\u014bk\u0254\u014bk\u0254wo me.\n    Note: Ne wo\u0256e anyigba kple space siwo le nyatakaka me.\n\n    Example:\n    anti_shuffle neva 'Hi'\n    anti_shuffle neva 'ehllo'\n    anti_shuffle neva 'Hello !!!Wdlor'\n```\n    \"\"\"\n","canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Ewe is a language spoken in Ghana and Togo. Here is the translation of the given sentence into Ewe:\n\n```\nM\u00edegbl\u0254e \u028bu \u0256eka si w\u00f2anya \u0256e E\u028begbe me:\n    W\u00f2\u0256e data 2 dimensional a\u0256e na, eye w\u00f2\u0256o be wo\u0256o nested lists,\n    si le asi eye w\u00f2ny\u00e9 matrix, ke bo\u014b, eye w\u00f2ny\u00e9 w\u00f2le matrices,\n    row a\u0256e siwo kat\u00e3 le ga\u0256u\u0256u \u0256eka na columns siwo kat\u00e3 le.\n    Ne w\u00f2\u0256e lst kple integer x na, yi\u0256e integers x si le list me,\n    eye w\u00f2\u0256o list a\u0256e kple tuples [, ...] na\n    siwo kat\u00e3 le tuple a\u0256e le coordinate -, siwo kat\u00e3 le 0 me\u0256e.\n    Sort coordinates siwo kat\u00e3 le rows me le ascending order \u0256e\u0256e.\n    Eye gak\u00e9 w\u00f2sort coordinates siwo le row me le columns me le descending order \u0256e\u0256e.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [,,,,]\n    get_row == []\n    get_row == []\n```\n    \"\"\"\n","canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef sort_array(array):\n    \"\"\"\n    M\u025bts\u0254 wo\u0256e E\u028begbe:\n```\nN\u00e9 w\u0254m n\u025b array si le wo domet\u0254 \u0256eka siwo me le be woate \u014bu az\u0254 array si le wo dome m\u025b, az\u0254 du \u0256a h\u00e3 ne sum le x\u0254si,\nne sum le \u0256eka, az\u0254 du d\u00e3 le dzidzi\u0256e me.\n\nN\u0254t\u0254:\n* M\u00edebu array si le wo dome m\u025b o.\n\nN\u0254nyigba:\n* sort_array => []\n* sort_array => [5]\n* sort_array => [0, 1, 2, 3, 4, 5]\n* sort_array => [6, 5, 4, 3, 2, 1, 0]\n```\n    \"\"\"\n","canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"}
{"prompt":"\ndef encrypt(s):\n    \"\"\"Create a function encrypt va d\u0254 blibo si va se\u0192e eye\n    n\u0254 blibo si va se\u0192e tso alphabet si va w\u0254a z\u0254. \n    Alphabet si va w\u0254a z\u0254 le nyate\u0192e me na \u014butil\u0254 blibo si va w\u0254a z\u0254 na e\u0192e \n    me ko blibo si va w\u0254a z\u0254 le anyi \u0192e blibo eve si x\u0254 anyi blibo eve \u0192e \n    me. \n    Ne le nu \u014bu:\n    encrypt va se 'lm'\n    encrypt va se 'ewhjklnop'\n    encrypt va se 'kj'\n    encrypt va se 'ix'\n    \"\"\"\n","canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    M\u00edets\u0254 \u0192e\u0192e sia \u0192e E\u028begbe tu:\n\nW\u00f2le a\u028bahe \u0256eka \u0256e \u0256eka \u0192e xexl\u1ebdmewo.\nTso \u0192e\u0192e a\u0256e si nye next_smallest a\u0256e \u0256o ge \u0256e \u014bk\u0254wo me, eye w\u00f2le fia 2nd smallest element \u0256e xexl\u1ebdme la me.\nM\u00edets\u0254 None le gb\u0254 na m\u00ed, ne menye element siaa o.\n\nnext_smallest == 2\nnext_smallest == 2\nnext_smallest == None\nnext_smallest == None\n    \"\"\"\n","canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef is_bored(S):\n    \"\"\"\n    Mek\u0254e nawo \u0192e dzesiwo, eye w\u00f2dea gbe be ne w\u00f2akp\u0254 nu siwo \u0256e asi le dzesiwo me. Nu si mew\u0254e be dzesi si na\u0256o \"M\" kple \"I\" \u0192e \u014bk\u0254 dzi. Dzesinuwo \u0192e xexl\u1ebdwo nye '.', '?' kple '!'.\n\nNe eya nye:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n","canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n","canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef encode(message):\n    \"\"\"\n    Sorry, it seems like you want me to translate the instructions for a coding function into the Ewe language. Here is the translation:\n\n```\nTs\u0254 \u0256e\u0256e si w\u00f2le be w\u00f2ts\u0254 a\u028banu\u014bl\u0254la si kpl\u0254 a\u028bak\u0254k\u0254wo, eye w\u00f2ts\u0254e \n    \u0192e k\u0254k\u0254wo kpli be w\u00f2\u0256e\u0256e k\u0254wo me le be wo\u0256e am\u00e9 ga si le \n    \u028be\u0192e k\u0254k\u0254wo \u0192e n\u0254\u0192e me. \n    \n    Examples:\n```\n\nNote: Providing examples in Ewe might require detailed context and understanding of specific vocabulary, which the translation here aims to keep consistent with the original technical instruction.\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Mekp\u0254na \u0256e sia p\u0254.\n\n    \u0194e a\u0256eke mia\u0256o \u0256e dzesiwo me.\n    Miaw\u0254 d\u0254w\u0254w\u0254 kple \u0256e dzesi si eye miaye esi d\u0254dzesi et\u0254wo n\u0254 o.\n\n    Nudeme\u0256e\u0256e:\n    Ne lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] la, d\u0254dzesi si mia\u0256o be 10\n    Ne lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] la, d\u0254dzesi si mia\u0256o be 25\n    Ne lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] la, d\u0254dzesi si mia\u0256o be 13\n    Ne lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] la, d\u0254dzesi si mia\u0256o be 11\n    Ne lst = [0,81,12,3,1,21] la, d\u0254dzesi si mia\u0256o be 3\n    Ne lst = [0,8,1,2,1,7] la, d\u0254dzesi si mia\u0256o be 7\n    \"\"\"\n","canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"}
{"prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Here is the translation of the given sentence into Ewe:\n\n\"N\u00e1 \u0256e\u0256e\u0256e sia, nye True ne gomekp\u0254kp\u0254wo kat\u00e3 nye str\u0254\u0303wo le dzidz\u0254 dzi alo gomekp\u0254kp\u0254wo kat\u00e3 nye str\u0254\u0303wo le \u0263li dzi, ne nyae nye False. Nuv\u0254\u0303 gb\u0254gb\u0254a nye False ne gomekp\u0254kp\u0254a si nye \u0256e\u0256e\u0256e sia dzi eye w\u00f2le. Nuxa na:\ncheck_dict_case gb\u0254gb\u0254e nye True.\ncheck_dict_case gb\u0254gb\u0254e nye False.\ncheck_dict_case gb\u0254gb\u0254e nye False.\ncheck_dict_case gb\u0254gb\u0254e nye False.\ncheck_dict_case gb\u0254gb\u0254e nye True.\"\n    \"\"\"\n","canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"}
{"prompt":"\ndef count_up_to(n):\n    \"\"\"This sentence translates to Ewe as follows:\n\n```\nDze abe yia si le gbe si me yia a\u0256e si nye nono-kplea\u0256e eye w\u00f2akpe dze xexea\u0256wo si le n me eye w\u00f2akpl\u0254e wo le afi me.\nNudemea:\ncount_up_to => [2,3]\ncount_up_to => [2,3,5,7]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17,19]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17]\n```\n    \"\"\"\n","canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n","test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"}
{"prompt":"\ndef multiply(a, b):\n    \"\"\"Here is the translated sentence in Ewe:\n\nD\u0254\u0256i\u0256igba na \u0192e vi\u0256e si le \u0256eka kple eve \u0192e dzidzime \u0192e nu\u0256o\u0256o\u0256o \u0192e xexl\u1ebdwo \u0192e \u0256e\u0256e\u0256e me. \nGbl\u0254 be nu si w\u00f2\u0256o le eme le dzidzime. \nNudemeviwo:\nmultiply ne \u014but\u0254 \u0256o\u0256oe 16.\nmultiply ne \u014but\u0254 \u0256o\u0256oe 72.\nmultiply ne \u014but\u0254 \u0256o\u0256oe 0.\nmultiply ne \u014but\u0254 \u0256o\u0256oe 20.\n    \"\"\"\n","canonical_solution":"    return abs(a % 10) * abs(b % 10)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"}
{"prompt":"\ndef count_upper(s):\n    \"\"\"\n    Here is the translation of the sentence into Ewe:\n\n\"A\u0256e edzi kple \u014bk\u0254 \u0256e sia \u0256e sia kple s, k\u0254 \u0192u\u0192o a\u0256e si \u0192u \u0192e le \u0256e me \u0192e g\u0254me \u0192e \u0256e\u0256e\u014buna wo le \u0256e\u0256e\u014buna siwo \u0192e \u0256e\u0256e\u014buna \u0192e xoxo g\u0254me \u0192e g\u0254me.\n\n    Eyae:\n    count_upper w\u00f2\u0256e 1\n    count_upper w\u00f2\u0256e 0\n    count_upper w\u00f2\u0256e 0\"\n    \"\"\"\n","canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n","canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"}
{"prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    M\u00e8kp\u0254 n\u0254nyigbawo w\u00f2fiae E\u028begbe. \n\nN\u00e0\u0256u fia kple \u0256eka n, w\u00f2le be w\u00f2na fia\u0256u\u0256u a\u028ba\u0256u n \u0192e k\u0254k\u0254e kple sikpa.\n    Fia\u0256u\u0256u\u0256u\u0256u\u0256u \u0256eka le n sikpa.\n    Sikpa si le fia\u0256u\u0256u\u0256u\u0256u\u0256u si gb\u0254na le le yi:\n        - sikpa n\u025b\u0256e\u0256e \u0256e\u0256e \u0256e\u0256e n\u025b le n le k\u0254k\u0254a\u0256e\u0256e.\n        - sikpa n\u025b\u0256e\u0256e \u0256e\u0256e si le n le k\u0254k\u0254akpl\u025bkpl\u025b.\n    N\u00e0ts\u0254 sikpa si le fia\u0256u\u0256u\u0256u\u0256u\u0256u si gb\u0254na le yia\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\u0256u\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n","canonical_solution":"    return [n + 2*i for i in range(n)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef words_string(s):\n    \"\"\"\n    W\u00f2akp\u0254a a\u0192e a\u0256e si le \u014bk\u0254wo me eye w\u00f2akpa \u0256e nu\u014bu a\u0256e si le \u014bk\u0254wo me. Wo\u0256e asi le w\u0254 nu si nye be w\u00f2abubu a\u0192e la \u0256e \u014bk\u0254wo me eye woak\u0254a nu\u014bl\u0254\u0256iwo domet\u0254 a\u0256ewo \u0192e a\u0192e siwo n\u0254 \u014bk\u0254wo me.\n\nNudeme\u0256e\u0256e:\nwords_string == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nwords_string == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n","canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"}
{"prompt":"\ndef choose_num(x, y):\n    \"\"\"\u0189e sia le E\u028begbe:\n\n\u0192e\u014bu sia dze e\u014bu x kple y, eye w\u00f2ax\u0254 nu si gbegbl\u1ebd le x kple y dome. Nu si gbegbl\u1ebd le x kple y domea nye nu si megbegbl\u1ebd eye w\u00f2gb\u0254. Ne nu si gbegbl\u1ebd me le x kple y dome o la, \u0192e\u014bu sia n\u00e0x\u0254 -1 va.\n\nNufiafia:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n","canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"}
{"prompt":"\ndef rounded_avg(n, m):\n    \"\"\"W\u00f2-n\u0254 anyievi eve a\u0256e n kpl\u00e9 m, eye n\u00e8nye n\u0254 dr\u0254\u0303 a\u0256\u025b si w\u00f2agbl\u0254 be:\n    \u0191le \u014bk\u0254dzesi a\u0256ewo kat\u00e3 si n le asi kpl\u00e9 m.\n    N\u0254 \u014bk\u0254dzesi la \u0256e anyi a\u0256e si le am\u00e9 siwo kat\u00e3, eye na e\u0256e anyi a\u0256e \u0256a eye na e\u0256e k\u0254k\u0254e a\u0256e.\n    Ne n kp\u0254 m g\u0254\u0303 h\u00e3, w\u00f2an\u0254 -1.\n    Nufiala:\n    rounded_avg => \"0b11\"\n    rounded_avg => -1\n    rounded_avg => \"0b1111\"\n    rounded_avg => \"0b11010\"\n    \"\"\"\n","canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"}
{"prompt":"\ndef unique_digits(x):\n    \"\"\"M\u025b woats\u0254 agbal\u1ebdt\u0254wo siwo kat\u00e3 le x me, nunya a\u0256e h\u00e3 be woate \u014but\u0254wo siwo me w\u00f2le nume \u0256eka siwo nye eve \u0256eke o. \n\nNunya: Agbal\u1ebdt\u0254wo siwo woats\u0254 agbl\u0254 be woat\u0254 le gb\u00e3t\u0254k\u0254k\u0254 me. \n\nAnyigba la, w\u00f2ny\u025b n\u025b:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n","canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef by_length(arr):\n    \"\"\"\n    Eyi w\u00f2tr\u0254a nyate\u0192eve \u0192e numer\u0254wo, nyate\u0192eve \u0192e numer\u0254wo siwo le 1 kple 9 me, \n    nu \u0192e numer\u0254woa \u0256eka me, le \u0256eka \u0256e sia me, kple \u0256eka de asi. \n    V\u0254 numer\u0254woe, kple me \u0256e asi, kple w\u00f2\u0256ee am\u025bwo nyate\u0192eve \u0192e dzidz\u0254wo kple \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    Fia nu \u0256e sia me:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      Ne arr la le asi tia, return asi tia:\n      arr = []\n      return []\n    \n      Ne arr la le anyi dzidzoe a\u0256e me, n\u0254 anyi la:\n      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\n","canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"}
{"prompt":"\ndef f(n):\n    \"\"\" Here is the translation of the provided sentence into Ewe:\n\n```\nDze ameha sia f, eye w\u00f2va kple n le nyatakaka,\n    eye w\u00f2ats\u0254 dzesi \u0192e lita si n le nu, eye n\u00e0ts\u0254 anyigba \u0192e \u0192omea m le index i me\n    eye w\u00f2ats\u0254 \u0192e \u0192omea \u0192e \u0192e gboe w\u00f2ats\u0254 \u0256e i dzi gake w\u00f2le be i le nu\n    eye w\u00f2le be dzesi \u0192e lita le index i me nye factorial \u0192e i ne i le nu \u0192e\n    eye w\u00f2le be dzesi \u0192e lita le index i me nye sum \u0192e nuwo \u0192e siwo le 1 kple i me.\n    i si sr\u0254e \u0256e 1.\n    factorial \u0192e i nye dzesi \u0192e nuwo \u0192e siwo le 1 kple i me.\n    Nubabla:\n    f == [1, 2, 6, 24, 15]\n```\n    \"\"\"\n","canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n","test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"}
{"prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    M\u00edets\u0254 \u0192e \u0192e\u0256e sia na E\u028begbe.\n\nNe m\u00edenye \u0256e\u0256e si me n le, nya woa\u0256e nyate\u0192e siwo le n\u0254\u0192e\u014bkeke\u014bkeke eye nyate\u0192e siwo le n\u0254tse\u014bkeke\u014bkeke siwo le nu\u0256u\u0256o me, \u0192e\u0192o\u0192o.\n\n\u0189e\u0256e1:\n\n    \u0191e\u0256e: 3\n    \u0189e\u0256e\u0192o\u0192o:\n    Nusia\u0256e\u014bu:\n    Nyate\u0192e siwo le nu\u0256u\u0256o le 1, 2, 3. w\u00f2 \u0256e wo\u014bkeke\u014bkeke le n\u0254\u0192e\u014bkeke\u014bkeke eye w\u00f2 \u0256e wo\u014bkeke\u014bkeke le n\u0254tse\u014bkeke\u014bkeke.\n\n\u0189e\u0256e2:\n\n    \u0191e\u0256e: 12\n    \u0189e\u0256e\u0192o\u0192o:\n    Nusia\u0256e\u014bu:\n    Nyate\u0192e siwo le nu\u0256u\u0256o le 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. w\u00f2 \u0256e wo\u014bkeke\u014bkeke le n\u0254\u0192e\u014bkeke\u014bkeke eye w\u00f2 \u0256e wo\u014bkeke\u014bkeke le n\u0254tse\u014bkeke\u014bkeke.\n\nNud\u0254\u0256o\u0256owo:\n    1. 1 <= n <= 10^3\n    2. \u0189e\u0256e\u0192o\u0192o si w\u00f2a\u0256e \u0256o le nyate\u0192e siwo le n\u0254\u0192e\u014bkeke\u014bkeke eye n\u0254tse\u014bkeke\u014bkeke.\n    \"\"\"\n","canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Here is the translation of the given sentence into Ewe:\n\nN\u0254 agbal\u1ebd count_nums si le \u0256e\u0256eviwo \u0192e xexl\u1ebdwo me eye w\u00f2ats\u0254 xexl\u1ebdwo siwo \u0192e kpl\u0254nyenye me \u0256e 0 eye w\u00f2akl\u00e3 wo \u0192e xexl\u1ebdwo. Ne xexl\u1ebda \u0192le nu si \u014but\u0254, eye w\u00f2akpl\u0254 \u014but\u0254 si \u014but\u0254 \u0192e dzesi \u014but\u0254 be negative:\ne.g. -123 \u0192e dzesiwo nye -1, 2 kple 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef move_one_ball(arr):\n    \"\"\"M\u00edele be m\u00edaw\u0254kpe 'arr' a\u0256e yi N l\u00e3\u0256i 'arr[1], arr[2], ..., arr[N]'. \nL\u00e3\u0256iwo si le 'arr' me la le \u0256e\u0256e\u0256e\u0256e n\u0254n\u0254. Wo n\u0254\u014bl\u0254 la nye be woana anye nye be \nmiakpl\u0254 l\u00e3\u0256iwo si le 'arr' me la \u0256e \u0256e\u0256e\u0256e kpee\u0256e\u0256e n\u0254n\u0254 \u014bu, ke menyee \na\u0256e siawo le l\u00e3\u0256i la me:\n    M\u00edayi any\u0254ny\u0254 \u0256e woana anye any\u0254 l\u00e3\u0256i la n\u0254 \u0256e dzidz\u0254 s\u0254s\u0254 kple any\u0254ny\u0254 anyi \n    \u0256e dzidz\u0254 me w\u0254a le l\u00e3\u0256i la me le anyi \u0256e dzidz\u0254 me kpekpe.\n    \n    Any\u0254ny\u0254 \u0256e dzidz\u0254 la nye be l\u00e3\u0256iwo kat\u00e3 le l\u00e3\u0256i la me va\u0256o \u0256e dzidz\u0254 \u0256eka \n    \u014bu yi \u0256e dzidz\u0254 si gb\u0254. L\u00e3\u0256i si g\u0254me l\u00e3\u0256i la me la va\u0256o \n    \u0256e dzidz\u0254 \u0192e k\u0254k\u0254 \u0192e dzidz\u0254 si nye 0. \n    \n    Ne w\u0254na anye any\u0254 l\u00e3\u0256i la \u0256e \u0256e\u0256e\u0256e kpee\u0256e\u0256e n\u0254n\u0254 \u0256e dzidz\u0254 kpekpe la, eye \n    ne men\u0254 any\u0254 la, n\u00e0\u0256u True, ke men\u0254 o la, n\u00e0\u0256u False.\n    Ne l\u00e3\u0256i si w\u0254 la nye d\u0254menyo la, n\u00e0\u0256u True.\n\n    N.B: L\u00e3\u0256i si w\u0254 la le l\u00e3\u0256iwo si w\u00f2 le me nye l\u00e3\u0256iwo si gbl\u0254 be wo n\u0254 o.\n\n    \u0189e asi me:\n    \n    move_one_ball==>True\n    Nume\u0256e\u0256ea: Ne any\u0254 2 \u0256e dzidz\u0254 la, l\u00e3\u0256iwo le l\u00e3\u0256i la me va\u0256o \u0256e \n               \u0256e\u0256e\u0256e kpee\u0256e\u0256e n\u0254n\u0254 \u0256e l\u00e3\u0256i la.\n    move_one_ball==>False\n    Nume\u0256e\u0256ea: Men\u0254 any\u0254 l\u00e3\u0256iwo le l\u00e3\u0256i la me va\u0256o \u0256e \n               \u0256e\u0256e\u0256e kpee\u0256e\u0256e n\u0254n\u0254 \u0256e l\u00e3\u0256i la le any\u0254 \u0256e dzidz\u0254 kpekpe o.\n                \n    \"\"\"\n","canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"}
{"prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"M\u025bts\u0254 af\u0254m\u025bka sia yi E\u028begbe me:\n\nE\u0256e m\u0254 d\u0254w\u0254 sia me, w\u00f2anye be n\u00e0ts\u0254 a\u0256u\u0256u siwo kpl\u0254 woate \u014bk\u0254 d\u0254 w\u00f2\u0256u\u0256u siwo \u0256e numea siwo w\u00f2\u0256u\u0256u \u0256e wo me, eye nax\u0254 agbal\u1ebd be ne menye ne woate \u014bu ats\u0254a nu\u014be\u0256ea \u0256e wo me le woate \u014bu ats\u0254a nu\u014be\u0256ea le wo me, eye nax\u0254 anye be ne woate \u014bu ats\u0254a nu\u014be\u0256ea le wo me, eye woate \u014bu ats\u0254a nu\u014be\u0256ea le wo me na\u0256o numea siwo le numea evewo le wo me. Menye ne woate \u014bu ats\u0254a numea siwo le wo me eye woate \u014bu ats\u0254a numea siwo le wo me na\u0256o numea evewo le wo me, n\u00e0\u0256o \u201cYES\u201d. Ne menye ne woate \u014bu ats\u0254a numea siwo le wo me eye woate \u014bu ats\u0254a numea siwo le wo me na\u0256o numea evewo le wo me, n\u00e0\u0256o \u201cNO\u201d. Egbe:\n\nexchange => \u201cYES\u201d\nexchange => \u201cNO\u201d\n\nLe nu sia kple nu si be nax\u0254 nu siwo w\u00f2ats\u0254 le nuwo mes\u0254 anyi.\n    \"\"\"\n","canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"}
{"prompt":"\ndef histogram(test):\n    \"\"\"M\u025bts\u0254 gb\u0254gb\u0254a si le gb\u0254\u0303t\u0254wo me si nye d\u0254w\u0254w\u0254t\u0254wo le \u0256e\u0256e\u0256e ta, na\u0256e anyigba siwo me le ketekete\n    si ke a\u0256e le \u0256e\u0256e\u0256e l\u0254\u0303l\u0254\u0303 kple s\u025bk\u025b siwo le yaka l\u0254\u0303l\u0254\u0303 siwo me. \n    Nenema megbe, na\u0256e anyigba siwo me le ketekete siwo me gb\u0254\u0303a \u0192e d\u0254w\u0254w\u0254wo.\n    \n    Ex\u0254me:\n    histogram == {'a': 1, 'b': 1, 'c': 1}\n    histogram == {'a': 2, 'b': 2}\n    histogram == {'a': 2, 'b': 2}\n    histogram == {'b': 4}\n    histogram == {}\n\n    \"\"\"\n","canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\n```\n\u0189e\u014bu\u014bu\n    W\u00f2anye\u014bu \u0256e nu\u014b\u0254\u014bl\u0254\u0256i eve s kple c, w\u00f2al\u00e9 \u0256e be w\u00f2ats\u0254 nu\u014b\u0254\u014bl\u0254\u0256i ny\u00e9viwo kat\u00e3 w\u0254 s me tso \u0256eviwo kat\u00e3 si le c me \u0256e. \n    Le w\u00f2kpe be nu\u014b\u0254\u014bl\u0254\u0256i si woats\u0254 \u0256e, w\u00f2akp\u0254 be enyi \u0256evi \u0256e edze edzi.\n    Nu\u014b\u0254\u014bl\u0254\u0256i a\u0256e nye enyi \u0256evi \u0256e edze edzi ne e\u014bk\u0254 \u0256evi \u0256e edze edzi eye w\u00f2e\u014bl\u0254 ak\u025b eyata.\n    W\u00f2anye\u014bu av\u0254 tuple si w\u00f2le nu\u014b\u0254\u014bl\u0254\u0256i si w\u00f2ats\u0254 kple g\u0254\u0303me\/\u0256eke g\u0254\u0303me be enyi \u0256evi \u0256e edze edzi.\n    \u0189e\u014bu\u014bu\n    Ne s nye \"abcde\", c nye \"ae\", nu\u014b\u0254\u014bl\u0254\u0256i si w\u00f2ats\u0254 nye\n    Ne s nye \"abcdef\", c nye \"b\"  nu\u014b\u0254\u014bl\u0254\u0256i si w\u00f2ats\u0254 nye\n    Ne s nye \"abcdedcba\", c nye \"ab\", nu\u014b\u0254\u014bl\u0254\u0256i si w\u00f2ats\u0254 nye\n```\n    \"\"\"\n","canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n","test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"}
{"prompt":"\ndef odd_count(lst):\n    \"\"\"M\u00e8ts\u0254 list w\u0254t\u0254wo, be list w\u0254t\u0254wo kat\u00e3 le digitwo kple, ne w\u00f2na list a\u0256e. \n    Egbe y\u0254e me\u0256e le outputa me w\u00f2na \"number of odd elements le stringa i le inputa.\" \n    duk\u0254wo kat\u00e3, iwo ko kat\u00e3 mle w\u00f2na number of odd digitwo le i'th string le inputa me.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n","canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Here is the translated sentence in Ewe:\n\n```\nNe w\u00f2kpl\u0254 anyigba a\u0256e si nye nums kple xexl\u1ebdnyawo le eme, n\u0254 \u0256e nu si w\u00f2agbl\u0254 be w\u00f2avy\u0254 nyuie siwo le sub-array a\u0256e si nye anyigba nums me.\n    \u0189e\u014bu\u0256u:\n    minSubArraySum == 1\n    minSubArraySum == -6\n```\n    \"\"\"\n","canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"}
{"prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Mediasee e\u014bl\u0254 \u0256e E\u028begbe me.\n\nEgbe na kple \u0263eedzi\u0263iwo \u0192e togb\u0254 be w\u00f2anya se \u0263eedzi\u0263iwo \u0192e k\u0254k\u0254e g\u0254me. \u0191e\u0256e\u0256e \u0256e\u0256e e\u0256okuiwo \u0192e k\u0254k\u0254e, eye kple nu\u0256okui k\u0254k\u0254e \u0256okuiwo \u0192e nuwuwu. K\u0254k\u0254e\u0256okuiwo le be yew\u0254 \u0263eedzi\u0263iwo kple wo\u0256ekp\u0254a nu\u0256okui, eye wots\u0254 nu\u0256okuiwo \u0256e \u0263eedzi\u0263iwo me. W\u00f2 \u0256e\u0256e\u0256e be w\u00f2anye se nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo le \u0263eedzi\u0263iwo kple wo\u0256ekp\u0254a nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo, eye nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo w\u0254 nu kple nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo le be yew\u0254 \u0263eedzi\u0263iwo kple wo\u0256ekp\u0254a nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo. \n\nNudola le be w\u00f2anya se k\u0254k\u0254e\u0256okuiwo le be yew\u0254 \u0263eedzi\u0263iwo kple wo\u0256ekp\u0254a nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo, eye w\u00f2\u0256e\u0256ekp\u0254a nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo le be yew\u0254 \u0263eedzi\u0263iwo kple wo\u0256ekp\u0254a nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo. \n\nEgbe n\u0254vi\u0256e\u0256e\u0256e\u0256e:\n    Nusia\u0256am 1:\n        N\u0254vi: \n            \u0263eedzi\u0263i : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            k\u0254k\u0254e\u0256okuiw\u0254nu: 1\n        An\u0254vi: 6\n\n    Nusia\u0256am 2:\n        N\u0254vi: \n            \u0263eedzi\u0263i : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            k\u0254k\u0254e\u0256okuiw\u0254nu: 2\n        An\u0254vi: 5\n    \n    Nusia\u0256am 3:\n        N\u0254vi: \n            \u0263eedzi\u0263i : [[0,0,0], [0,0,0]]\n            k\u0254k\u0254e\u0256okuiw\u0254nu: 5\n        An\u0254vi: 0\n\n    Nud\u0254\u0256okuiwo:\n        * \u0263eedzi\u0263iwo kat\u00e3 le nuwuwuwo kple nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo le nuwuwuwo kple nuwuwuwo \u0192e k\u0254k\u0254e\u0256okuiwo.\n        * 1 <= \u0263eedzi\u0263iwo kat\u00e3 \u0192e nu\u0256okuiwo <= 10^2\n        * 1 <= \u0263eedzi\u0263iwo kat\u00e3 \u0192e nu\u0256okuiwo kple \u0263eedzi\u0263iwo kat\u00e3 \u0192e nu\u0256okuiwo <= 10^2\n        * \u0263eedzi\u0263iwo kat\u00e3 \u0192e nu\u0256okuiwo kple \u0263eedzi\u0263iwo kat\u00e3 \u0192e nu\u0256okuiwo => 0 | 1\n        * 1 <= k\u0254k\u0254e\u0256okuiw\u0254nu <= 10\n    \"\"\"\n","canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n","test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"}
{"prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Esi Kata sia le, w\u00f2kpl\u0254 n\u025b be w\u00f2agbugb\u0254 a\u0256a\u014bu a\u0256e si w\u00f2le non-negative integers, be w\u00f2akpl\u0254 wo na\u0256e x\u0254nwo si w\u00f2le \u0256e \u0256e\u0256e\u0256e le wo\u0192e binary representation me kple \u0192omeviwo. \nNu si w\u00f2akp\u0254 x\u0254n siwo \u0192e nu \u0192omeviwo le \u0192eviwo me, ne\u0256a be w\u00f2akpl\u0254 wo na\u0256e decimal value me.\n\nNye be esime w\u00f2atsi kpakple esime w\u00f2akl\u0254 be:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n","canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef select_words(s, n):\n    \"\"\"Here is the translation of the given text into Ewe:\n\n```\nNe m\u00eda\u0256u \u014bk\u0254 s kple xexl\u1ebdma n, w\u00f2le be n\u00e0\u0256e \u0256e asi \u0256eka a\u0256e eye n\u00e0ts\u0254 n\u00fa sia le esiwo me:\n    nu si w\u00f2le be n\u00e0ts\u0254 \u0192ome kple anyigba a\u0256e siwo le \u014bk\u0254 s me siwo le xexl\u1ebdma n gb\u00e3t\u0254m.\n    Ne \u014bk\u0254 s w\u00f2le afisia la, eye nu si w\u00f2le be n\u00e0ts\u0254 la, nye \u0192ome a\u0256e siwo le afisia me.\n    \u0191e nu si n\u00e0kpl\u0254: w\u00f2anye be n\u00e0gbl\u0254 be \u0256eha sia \u0192e \u014bk\u0254wo nye alekpadada kple tso\u0192eawo \n    \u0192e dz\u0254lawo kple dz\u0254lawo \u0192e dz\u0254lawo.\n    \u014bk\u0254wo:\n    select_words ==> [\"little\"]\n    select_words ==> [\"Mary\", \"lamb\"]\n    select_words ==> []\n    select_words ==> [\"world\"]\n    select_words ==> [\"Uncle\"]\n```\n    \"\"\"\n","canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"}
{"prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Here is the translated sentence in Ewe:\n\n\"Woats\u0254 wo \u0256eviak\u0254wo. Wo\u0192e d\u0254\u0256a nye gake newo\u0256eviak\u0254wo me\u0256e\u014bu a\u028buwo siwo wogbl\u0254e \nak\u0254 g\u0254me\u014bu a\u028buwo w\u00f2kpl\u0254 kple e\u0192e v\u0254wo a\u0256e le kut\u0254\u014but\u0254 me. \n\nA\u028buwo siwo w\u0254a\u0256e gome kple wo\u0256e dzi\u0256e\u0256i\u0256e menye\u0256e\u014bu o. Gbl\u0254 \u0256eviak\u0254 si menye \n\u014but\u0254\u014but\u0254 o ne w\u00f2\u0256e\u014bu a\u028bu siwo kat\u00e3 \u0256e v\u0254wo me.\n\nN\u00e0k\u0254 ne \u0256eviak\u0254 siwo w\u0254a\u0256e English letter \u0256eke le wo\u0192e v\u0254wo me.\"\n\n\"Example:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n","canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n","canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"}
{"prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Here is the translation of the given sentence into Ewe:\n\n```\nNe w\u00f2anya lista yi\u0192e\u014buwo \u0192e nu\u014bl\u0254\u0303 kple dzidz\u0254\u0192e numeri k, m\u00edkp\u0254 anyigba\u0256e kple k \u0192e nu\u014bl\u0254\u0303wo kat\u00e3 le arr me.\n\nNufial\u00e3\u014bl\u0254\u014b:\n\nNe\u0256ea\u014bl\u0254\u014b 1:\n\n    Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\nNe\u0256ea\u014bl\u0254\u014b 2:\n\n    Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\nNe\u0256ea\u014bl\u0254\u014b 3:\n\n    Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\nNutsi:\n\n    1. Anyigba \u0192e nu\u014bl\u0254\u0303wo \u0192e xexl\u1ebd kple \u0192e xexl\u1ebd \u0192e tsi le [1, 1000] me.\n    2. \u0192e nu\u014bl\u0254\u0303wo \u0192e tsi le [-1000, 1000] me.\n    3. 0 <= k <= len\n```\n    \"\"\"\n","canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"}
{"prompt":"\ndef solution(lst):\n    \"\"\"Here is the translation of the sentence into Ewe:\n\nMenye\u014bkeke la, na\u0256u x\u0254x\u0254 si le wo kpl\u0254me. \n\nNufiala\nsolution ==> 12\nsolution ==> 9\nsolution ==> 0\n    \"\"\"\n","canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"}
{"prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    M\u00edets\u0254 \u0256e E\u028begbe le esime n\u00e0ts\u0254 nu siawoe:\n\nM\u00edets\u0254 a\u0256ewo le nu\u014bu\u014blawo me yi k\u0254k\u0254e, kple nu\u014bu\u014blawo le xexl\u1ebdme, eye n\u00e0ts\u0254 nu\u014blawo \u0192e xexl\u1ebdwo kp\u0254m du\u0256uwo \u0192e sum le k \u0192e nu\u014bluime \u0192e nu\u014blawo me.\n\nNust\u0254 Nu\u014blawo:\n\n    Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # sum \u0256e 21 kple 3\n\nNuts\u0254asiwo:\n\n    1. 1 <= len <= 100\n    2. 1 <= k <= len\n    \"\"\"\n","canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    M\u00edase af\u0254f\u0254 nyuie n, de agbal\u1ebd si w\u0254\u0303 le collatz gbes\u1ebd me dzi. \n\n    Collatz conjecture nye az\u0254 le mathemati kple gbes\u1ebd si w\u00f2te \u014bu de nyuie le w\u00f2 dzi be: tso agbal\u1ebd nyuie a\u0256eke kple n. Eya ta gbes\u1ebd sia nu w\u00f2de le w\u00f2va le afi sia be: ne agbal\u1ebd si w\u00f2te \u014bu nyuie, agbal\u1ebd si gb\u00e3 le w\u00f2 nu w\u00f2ta le vov\u0254\u0303 nyuie et\u0254\u0303 le af\u00e3me. Ne agbal\u1ebd si w\u00f2te \u014bu nye agbal\u1ebd kp\u0254, agbal\u1ebd si gb\u00e3 le w\u00f2 nu nye 3 nyuie agbal\u1ebd sia h\u00e3 1. Conjecture sia nye be ne agbal\u1ebd a\u0256eke n le nya, gbes\u1ebd sia va le 1.\n\n    Nu si:\n        1. Collatz nye [1].\n        2. agbal\u1ebd si woade le agbal\u1ebd sia dzi be le w\u00f2va le dzi nyuie.\n\n    Ne eya va le nyui:\n    get_odd_collatz va de [1, 5] # Collatz gbes\u1ebd si w\u0254\u0303 5 n\u025b nye [5, 16, 8, 4, 2, 1], eye agbal\u1ebd kp\u0254 si w\u0254\u0303 le nya nye 1 kple 5.\n    \"\"\"\n","canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef valid_date(date):\n    \"\"\"Mekae asiwo le E\u028begbe:\n\nWots\u0254 anyigba si le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le edzi w\u0254 anyigba siwo le afi ma\u0256e nyui siwo le ed\n    \"\"\"\n","canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"}
{"prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n","canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n","test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"}
{"prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n","canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"}
{"prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Mia\u0256e se nu si le E\u028begbe me:\n\nWo\u0256e woa\u0256u e\u028bia eve,\n    eye e\u028bia kple e\u0256okui eve le e\u028biwo me. Wots\u0254 e\u028bia si le e\u014bu: e\u028bia = =.\n    E\u028biawo si wow\u0254woe yome le e\u014bu, le \u0256e sia \u0256e si nye \u0256e e\u028bia \n    kple dzo kple nu.\n    E\u028bia kple e\u0256okui eve, wots\u0254a wo dzo le nu si wo\u0256e wo\u0256e nu.\n    Wo nu si wo\u0256e wo\u014bl\u0254 nye ne le e\u028bia eve siwo kple, wo\u0256u \u0256a nu si nye\n    \u0256e\u0256e siwo kple o\u0256e e\u014bu nye xexl\u1ebd.\n    Dzi\u0256u\u0256u, e\u028bia kple e\u0256okuiwo si le \u0256e\u0256e, nye\n    eye \u0256e\u0256e si nye 1, eye nya nye xexl\u1ebd o.\n    Ne le \u0256e\u0256e si nye xexl\u1ebd, na\u0256u \"YES\",\n    ke ne le \u0256e\u0256e si nye xexl\u1ebd o, na\u0256u \"NO\".\n    Ne le e\u028bia evewo kple o\u0256i o, na\u0256u \"NO\".\n\n    [nu\/\u014bukpe] \u0256o\u0256owo:\n    kple, ==> \"NO\"\n    kple, ==> \"NO\"\n    kple, ==> \"YES\"\n    \"\"\"\n","canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"}
{"prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Sure, here is the translation of the sentence into Ewe:\n\nW\u00f2ana \u0192e array arr \u0192e integers kple w\u00f2kp\u0254na \u0192e \u0256o\u0256o\n    magnitude \u0256e integers kple \u0256e \u028b\u0254nuwo \u0192e product\n    \u0192e number kple number siawo \u0192e array, \u0192e numberwo \u0192e \u0256o\u0256owo 1, -1 kple 0.\n    Note: gbagbe None kple empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n","canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Here is the translation of the given sentence into Ewe:\n\nMekp\u0254 nu si w\u0254 grid kple N agbal\u1ebd kple N agbal\u1ebdwo kple xexl\u1ebdvi k, \n    agbal\u1ebd a\u0256e si le grid me le g\u0254me. Xexl\u1ebdvi a\u0256e a\u0256e si le \u0256e [1, N * N]\n    me w\u00f2\u0256u\u0256u le agbal\u1ebdwo me.\n\n    N\u00e0\u0256o gbegbl\u1ebd si le na\u0256o nu\u0192o\u0192o a\u0256e si le g\u0254me k le grid me. W\u00f2anye be n\u00e0\u0256e \n    le agbal\u1ebd a\u0256e, eye le g\u0254me a\u0256e siwo le w\u00f2aka kple w\u00f2 g\u0254me agbal\u1ebdwo \n    me, n\u00e0\u0256e kple agbal\u1ebd siwo kata na w\u00f2 g\u0254me a\u0256e siwo le e\u014bu kple w\u00f2 g\u0254me agbal\u1ebdwo\n    me.\n    Ne nyate\u0192e be gbegbl\u1ebd a\u0256e si le g\u0254me k le gbegbl\u1ebd me nye ne n\u00e0\u0256e agbal\u1ebd a\u0256e a\u0256e (w\u00f2nya \n    ne w\u00f2\u0256u\u0256u).\n\n    W\u00f2nyate\u0192e be w\u00f2anye woate g\u0254me grid me.\n    Gbegbl\u1ebd A le g\u0254me gbegbl\u1ebd B ne \n    w\u00f2lekp\u0254 xexl\u1ebdwo si le agbal\u1ebdwo me si A kple B \u0256e agbal\u1ebdwo siwo A kple B \u0256e \n    kple, lst_A le lexicographically kple\n    lst_B, ne nyate\u0192e be le w\u00f2\u0256o xexl\u1ebdvi a\u0256e si le\n    me siwo be lst_A[i] < lst_B[i] eye le w\u00f2\u0256o xexl\u1ebdvi a\u0256e si le \u0256e \n    w\u00f2\u0256e lst_A[j] = lst_B[j].\n    \u0194e\u0256e\u014bu be gbegbl\u1ebd si nye unique.\n    N\u00e0ts\u0254 xexl\u1ebdwo si le agbal\u1ebdwo si gbegbl\u1ebd si le g\u0254me \u0192e g\u0254me me.\n\n    Nuxexl\u1ebdwo:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n","canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"}
{"prompt":"\ndef tri(n):\n    \"\"\"Gbogbo ny\u0254nuwo kat\u00e3 le Fibonacci li\u014bl\u0129\u014b\u0254, eye w\u00f2gbl\u0254 nyuie g\u00e3 akpl\u0254kp\u0254 la \u0192e xexl\u1ebdme\u0192e me le xexl\u1ebdme\u0256eawo \u014bu le ta\u0256odr\u0254\u0303t\u0254wo \u0192e nublanui. Ke megbe be, nyate\u0192e siwo men\u0254 nyuie o ke wu be Tribonacci li\u014bl\u0129\u014b\u0254 la. Tribonacci li\u014bl\u0129\u014b\u0254 la nye li\u014bl\u0129\u014b\u0254 si \u0256e edzi be:\ntri = 3\ntri = 1 + n \/ 2, ne n nye even\ntri = tri + tri + tri, ne n nye odd.\n\nNudeme\u0256ea\u014bl\u0254 si:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n        = 2 + 3 + 3 = 8\nW\u00f2le nono susumakp\u0254\u0256e\u0256e si nye nono si me\u0256e ga kple ga w\u00f2le na, w\u00f2le \u0256e asi na w\u00f2 kpl\u0254 xoxo. Ne m\u00e8\u0256e ga kple ga n\u0254 dzesiwo me na tri be tri + tri + tri. \n\nNudeme\u0256ea\u014bl\u0254 si:\ntri = [1, 3, 2, 8]\n    \"\"\"\n","canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"}
{"prompt":"\ndef digits(n):\n    \"\"\"W\u00f2ts\u0254 n kple gbe n\u0254vi a\u0256e, na\u0256o m\u00ed \u0256e\u014bu a\u0256eke kple a\u0256e\u0256e siwo le eme.\n    Na 0 ne a\u0256eke siwo le eme nye a\u0256eke kple.\n    Ne nyate\u0192e:\n    digits  == 1\n    digits  == 0\n    digits == 15\n    \"\"\"\n","canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"}
{"prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n","canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"}
{"prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Mele sia kple E\u028begbe.\n\n**English:**\nYou are given a list of numbers.\nYou need to return the sum of squared numbers in the given list,\nround each element in the list to the upper int first.\nExamples:\nFor lst = [1,2,3] the output should be 14\nFor lst = [1,4,9] the output should be 98\nFor lst = [1,3,5,7] the output should be 84\nFor lst = [1.4,4.2,0] the output should be 29\nFor lst = [-2.4,1,1] the output should be 6\n\n**Ewe:**\nW\u00f2ats\u0254 a\u028bafia \u0256eka \u0256e w\u00f2 \u014bkume.\nN\u00e0ts\u0254 \u0256e sia \u0256e sia me le a\u028bafia si w\u00f2ats\u0254 la, \nn\u00e0\u0256e a\u028bafia a\u0256eke siwo le a\u028bafia la me dzi kple \u0256eka si le \u014bkeke siwo me.\nNudeme:\nNe lst = [1,2,3] la, \u0256e\u014bu be n\u00e0\u0256i 14\nNe lst = [1,4,9] la, \u0256e\u014bu be n\u00e0\u0256i 98\nNe lst = [1,3,5,7] la, \u0256e\u014bu be n\u00e0\u0256i 84\nNe lst = [1.4,4.2,0] la, \u0256e\u014bu be n\u00e0\u0256i 29\nNe lst = [-2.4,1,1] la, \u0256e\u014bu be n\u00e0\u0256i 6\n    \n\n    \"\"\"\n","canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n","canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef can_arrange(arr):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\nW\u0254 dze\u0256o\u0256o si w\u00f2ak\u00e3 eye w\u00f2ava be w\u00f2ava \u0192e index si kple element si le eme\nMekp\u0254a be menye \u0192u meke o kple element si le eme siwo le eme. Ke menye\nelement biabia sia ny\u0254 na return -1. Array si w\u00f2ado\u0256o abe ye menye element\nbiabiawo kat\u00e3 o.\n\nNya\u0256e\u0256ewo:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n","canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"}
{"prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n","canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"}
{"prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Woanya \u0256e E\u028begbe:\nTso \u0256e nu si le nu g\u0254me.\n\nTs\u0254 wo\u0192e t\u0254tr\u0254 g\u0254me be:\nCreate a function that takes integers, floats, or strings representing real numbers, and returns the larger variable in its given variable type. Return None if the values are equal. Note: If a real number is represented as a string, the floating point might be . or ,\n\ncompare_one \u2192 2.5\ncompare_one \u2192 \"2,3\"\ncompare_one \u2192 \"6\"\ncompare_one \u2192 None\n\n\u0256e nu si le nu g\u0254me be:\nTs\u0254 function si megbl\u0254 na integers, floats, to strings si w\u00f2w\u0254 nu \u0256eka, eye w\u00f2\u0256o nu si le v\u0254v\u0254. Na None me va m\u025b gake nuwo le gome siwo le be wo\u0256e kple. Note: Ne nu \u0256eka le w\u00f2w\u0254 na string, floating point \u0192e asiwo be . to ,.\n\ncompare_one \u00e2 -> 2.5\ncompare_one \u00e2 -> \"2,3\"\ncompare_one \u00e2 -> \"6\"\ncompare_one \u00e2 -> None\n    \"\"\"\n","canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Here is the translated text in Ewe:\n\n```Ewe\nTsi sia le E\u028begbe me:\nKp\u0254 be w\u00f2agbl\u0254 be xexl\u1ebd n le esime woagbl\u0254 be n le sum sia la woaso 4 \u0256eviwo \u0192e v\u0254s\u0129wo \u0192e nu\u014b\u0254\u014bl\u0254 me\n    Nu\u0256u\u0256u\n    is_equal_to_sum_even == M\u00e8dz\u025b\n    is_equal_to_sum_even == M\u00e8dz\u025b\n    is_equal_to_sum_even == Nya\n```\n    \"\"\"\n","canonical_solution":"    return n%2 == 0 and n >= 8\n","test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"}
{"prompt":"\ndef special_factorial(n):\n    \"\"\"Here is the translation of the sentence into Ewe:\n\n```\nBrazil factorial-k\u0254\u014b\u014b\u0254 le e\u014bu kple be:\n    brazilian_factorial = n! *! *! * ... * 1!\n    w\u00f2e n > 0\n\n    Nu ka ta be:\n```\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n","canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"}
{"prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Here is the translation of the given sentence into Ewe:\n\n```\nNe woa\u0256o k\u0254k\u0254evi a\u0256e si be text la, na wots\u0254 anyigba a\u0256ewo kat\u00e3 si le eme la g\u0254me\u0256e\u0256e kple underscores, \n    eye ne k\u0254k\u0254evi a\u0256e le anyigba \u0256eka si me w\u00f2le abe 2 anyigba si kp\u0254kp\u0254 \u0256eka le eme, \n    eye wots\u0254 anyigba \u0256e\u0256ewo kat\u00e3 si kp\u0254kp\u0254 \u0256eka le eme la g\u0254m\u00e9 kple - \n    \n    fix_spaces == \"Example\"\n    fix_spaces == \"Example_1\"\n    fix_spaces == \"_Example_2\"\n    fix_spaces == \"_Example-3\"\n```\n    \"\"\"\n","canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"}
{"prompt":"\ndef file_name_check(file_name):\n    \"\"\"Here is the translation of the given text into Ewe:\n\n```\nW\u0254 d\u0254w\u0254wo w\u0254e si men\u0254a agbal\u1ebdt\u0254\u0303 si w\u00f2n\u0254a \u0256e file si ny\u025be \u0256okuiwo kple, eye w\u00f2ts\u0254a 'Yes' ne file si \u0192e \u0256okui nye v\u0254\u0303, eye w\u00f2ts\u0254a 'No' ne menye v\u0254\u0303 o.\nFile si \u0192e \u0256okui \u0192e v\u0254\u0303t\u0254 nye ne kple ne anyi wo\u014bl\u0254 \u0192e nyatakaka la, nyatakaka siwo kat\u00e3:\n- File \u0192e \u0256okui me nye be adzikpi\u014b\u0254t\u0254\u0303wo adz\u0254dz\u0129a eve o.\n- File \u0192e \u0256okui le af\u00e3a \u0192e dot ' . '\n- Agbal\u1ebdt\u0254\u0303 si le dot me la men\u0254a o, eye w\u00f2\u0256ua agbal\u1ebdt\u0254\u0303 si le latin alphabet me.\n- Agbal\u1ebdt\u0254\u0303 si le dot me kple agbal\u1ebdt\u0254\u0303 si le af\u00e3a \u0192e dot la nye gbe \u0256eka le wo kat\u00e3wo \u0192e ta: ['txt', 'exe', 'dll']\nExamples:\nfile_name_check # => 'Yes'\nfile_name_check # => 'No'\n```\n    \"\"\"\n","canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"}
{"prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\n```\n    \u0192e\u0192e sia \u0192e\u0256e be e\u0256e list nyo\u0192e \u0256eka a\u0256e. Ne list la me \u0256eke le, \u0192e\u0192e la va \u0256i nyo\u0192e la \u0256e \u0256okui \u0256eka ne w\u00f2\u0256u index la xoxo be 3 eye w\u00f2\u0256u nyo\u0192e la \u0256e \u0256okui at\u0254\u0303 ne w\u00f2\u0256u index la xoxo be 4 eye menye xoxo be 3 o. \u0191e\u0192e la menyo nyo\u0192e \u0256e list me si index \u0192e \u0256okui \u0256eke menye 3 kple 4. \u0192e\u0192e la va \u0256e anyi nyo\u0192e siwo kat\u00e3 \u0192e kplea.\n\n    Examples:\n    Ne lst = [1,2,3] la \u0192e\u0256e la \u0256e be 6\n    Ne lst = [] la \u0192e\u0256e la \u0256e be 0\n    Ne lst = [-1,-5,2,-1,-5] la \u0192e\u0256e la \u0256e be -126\n```\n    \"\"\"\n","canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"}
{"prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Here is the translation of the given text into Ewe:\n\n```\nW\u00f2anya nuviwo kat\u00e3 kpl\u0254 nusr\u0254\u0303 le \u014bk\u0254e,\n    nusr\u0254\u0303 la kpl\u0254 nuviwo kat\u00e3 kple \u0256eka \u0256eka,\n    eye w\u00f2ana nuviwo kat\u00e3 kpl\u0254 le nusr\u0254\u0303 \u0192e \u014bk\u0254e,\n    nuviwo siwo \u0192e \u014bg\u0254wo nye \u0192eviwo\u0192e ziwo \u0192e z\u00e3wo kple nu \u0256eka \u0256eka,\n    nu\u0256e siawo n\u0254 nusr\u0254\u0303 la gb\u0254me.\n\n    Nudeme\u0256e\u0256e1:\n        Nusr\u0254\u0303 la: \"This is a test\"\n        Anya: \"is\"\n\n    Nudeme\u0256e\u0256e2:\n        Nusr\u0254\u0303 la: \"lets go for swimming\"\n        Anya: \"go for\"\n\n    Nudoselewo:\n        * 1 <= len <= 100\n        * nusr\u0254\u0303 la kple nya\u0256e\u0256e siwo kat\u00e3 nye ak\u0254b\u0254wo\n```\n    \"\"\"\n","canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"}
{"prompt":"\ndef simplify(x, n):\n    \"\"\"The Ewe translation of the given sentence is:\n\nW\u00f2 agbal\u1ebd nye le be n\u00e0woa \u0254 \u0256e be n\u00e0ts\u0254 \u0256eka le x * n. W\u00f2 agbal\u1ebd \u0192e d\u0254w\u0254e nye be x * n b\u0254, ke \u0256e be x * n n\u00e0ts\u0254 \u0256e a\u0192e d\u0254w\u0254e le adzoe kple \u0256eka. X kple n, nye \u0192e nu\u0256u\u0256ua le ny\u0254nu alo ny\u0254nuwo \u0192e d\u0254w\u0254e la, eye w\u00f2an\u0254 be:\n\n<numerator>\/<denominator> \u0256e le nu\u0256u\u0256ua la, eye le numerator kple denominator, w\u00f2an\u0254 k\u0254k\u0254k\u0254d\u0254w\u0254e. \n\nN\u00e0w\u0254 be x kple n nye ny\u0254nuwo \u0192e d\u0254w\u0254e la, eye w\u00f2an\u0254 be w\u00f2anye d\u0254w\u0254e \u0192e kp\u0254\u0256e\u0256e. \n\nsimplify = Gbl\u1ebd\nsimplify = M\u0254\u0303\nsimplify = M\u0254\u0303\n    \"\"\"\n","canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"}
{"prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Here is the translation of the provided sentence into Ewe:\n\n```\nTs\u0254 a\u028bl\u1ebd si le e\u014b\u0254m \u0192e xexl\u1ebdawo me hena dzidzime n\u025be dzesi \u0256eviwo \u0192e \u0256e\u0256eawo \u0192e xexl\u1ebda ta. \nNote: ne ame siwo kat\u00e3 \u0192e \u0256e\u0256eawo \u0192e xexl\u1ebda nye \u0192u, le esime woy\u0254 e\u014b\u0254m \u0192e ame siwo kat\u00e3 \n\u0192e \u0256e\u0256eawo \u0192e xexl\u1ebda me.\n```\n\nFor example:\n\nHere is a Python function that accomplishes the task described:\n\n```python\ndef sort_by_digit_sum:\n    return sorted for digit in str), lst.index))\n\n# Example usage:\nexample_list = [56, 23, 89, 12, 34]\nsorted_list = sort_by_digit_sum\nprint  # Output: [12, 23, 34, 56, 89]\n```\n\nThis function sorts the given list of integers in ascending order based on the sum of their digits. If there are multiple items with the same sum of their digits, they are ordered based on their original indices in the list.\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef specialFilter(nums):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\n```\nTs\u0254 function bi\u0256i a\u0256eke dze array kple x\u0254lawo le eme eye w\u00f2a\u0256e \n    x\u0254lawo \u0192e kplim kple dzidz\u0254wo \u0192e ameg\u00e3wo le array me wo\u0192e \u0192u w\u00f2wo \n    le \u0256e\u0256e \u0192u \u0256e\u0256e kple didi \u0192e ameg\u00e3 \u0192e \u0192uwo n\u0254 \u0256eka kple wo\u0256i\u0192e.\n    Eg.:\n    specialFilter => 1 \n    specialFilter => 2\n```\n    \"\"\"\n","canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"}
{"prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    M\u00e8 nye wo nuto \u0192\u00e9 si kple nu siwo le E\u028begbe me.\n\nNe nye wo be n\u00e0ts\u0254 n\u00f9\u0256u\u0256u\u0256u n. Woate \u014bu n\u00e0woe \u0256e n\u00f9\u0256u\u0256u\u0256u a si le xexe n.\n    Ne nyate\u0192e i, a[i] = i * i - i + 1.\n    N\u00e0\u0256o n\u00f9\u0256u\u0256uwo at\u0254\u0303 h\u00e3 le a me si i < j < k,\n    eye a[i] + a[j] + a[k] nya \u0256okui \u0256e 3.\n\n    Nufiala:\n        N\u00fat\u00ed: n = 5\n        \u0189\u00e9\u0256\u00e9\u0256\u00e9: 1\n        Nuyina:\n        a = [1, 3, 7, 13, 21]\n        N\u00f9\u0256u\u0256u at\u0254\u0303 si nye w\u0254m be \u0256\u00e9\u0256\u00e9\u0256\u00e9 nya.\n    \"\"\"\n","canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n","test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"}
{"prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n","canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"}
{"prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Here is the translation of the provided sentence into Ewe:\n\nTs\u0254 function si gb\u0254 na\u014bl\u0254 list kple stringwo le \u0256ase\u0256e,\n    yi \u0256e stringwo siwo w\u0254 odd lengths le eme,\n    eye w\u00f2ats\u0254 list si w\u0254 le afisiawo me kple gb\u0254gb\u0254,\n    List la megbl\u0254 o w\u0254 list kple stringwo eye menye array kple \u0192e \u0256e\u014b\u014buwo o,\n    eye w\u00f2ats\u0254 \u0192e \u0256e\u014b\u014buwo me.\n    List la w\u0254 \u0256e ascending le \u0256e\u014b\u014buwo \u0192e anyia \u0256e, eye w\u00f2\n    dze list la w\u0254 gb\u0254gb\u0254 si w\u0254\u014bl\u0254.\n    Ne \u0256eka stringwo w\u0254 \u0256e anyia, w\u00f2ats\u0254 list la w\u0254 alphabetically.\n    Function la w\u0254ts\u0254 list kple stringwo le gb\u0254gb\u0254.\n    W\u00f2ats\u0254 list stringwo w\u0254 le gb\u0254gb\u0254.\n    Eg.:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n\nNote: This translation aims to capture the essence of the given instructions in Ewe. Since it is for a programming-related context, some terms are kept in English for clarity and precision.\n    \"\"\"\n","canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"}
{"prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Here is the translation of the given sentence into Ewe:\n\n**A simple program which should return the value of x if n is a prime number and should return the value of y otherwise.**\n\n**Ewe Translation:**\n\n\u0189e dzi\u0256o\u0256o\u0256o si w\u00f2agbl\u0254 x \u0192e hl\u0254\u0256e alo n nye \u0192e akpedav\u0254w\u0254le kple w\u00f2agbl\u0254 y \u0192e hl\u0254\u0256e \u0256e edzi.\n\n**Examples:**\n\n\u0192e x_or_y == 34\n\u0192e x_or_y == 5\n    \n    \"\"\"\n","canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"}
{"prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n","canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"}
{"prompt":"\ndef compare(game,guess):\n    \"\"\"Mekae be miawo kat\u00e3 kae nyuie be nya w\u0254e si w\u00f2kp\u0254na le nu si w\u00f2do gbe be n\u00e8\u0256e le nu si w\u00f2na be m\u00edets\u0254. Nu siwo woame w\u0254 kpl\u00e9 nyagbl\u0254\u014bl\u0254 siwo w\u00f2am\u025b le \u0263e sia \u0256e nye nu si mel\u0254\u0303 be mle be m\u00e9l\u0254\u0303 kple \u0256o\u0256o be nya esi. Wo taske nye be w\u00f2ana le be ame a\u0256e fiam le be w\u00f2kpl\u0254 nusr\u0254\u0303lia a\u0256eke le game siwo kat\u00e3 w\u0254. W\u00f2ana dua dua score kple guesses a\u0256e\u0256eke siwo w\u0254 le nyate\u0192e, eye dua a\u0256e a\u0256eke nenye game. Woana dua a\u0256e a\u0256eke nenye game siwo w\u0254 le nyate\u0192e be nusr\u0254\u0303lia \u0256e game a\u0256eke \u0256e am\u025b. Ne w\u00f2kpl\u0254na nyuie, nusr\u0254\u0303lia nye 0, ne men\u0254 nyuie o, nusr\u0254\u0303lia nye \u0192e\u0256e\u0192e \u0192e guess kple score siwo w\u0254.\n\nnyuie:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n","canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"M\u025bkpl\u0254 nu si le E\u028begbe me.\n\nWoate \u014bu \u0256e nye \u014bk\u0254 si le \u0192e \u0256eka kple \u0192e \u0256eka \u0192e extensions. \nExtensions siwo le be woado kple klasi la. Ga si le extensions la nye be, kp\u0254 CAP \u0192e \u0192e \u0192e, eye nane \u0191e\u0256e \u0192e \u0192e \u0192e \u0192e \u0192e, strength la nye fraction CAP - SM. \nWoate \u014bu \u0256e extension si le strongest eye na\u0256o \u014bk\u0254 si le \u014bk\u0254 si le: ClassName.StrongestExtensionName.\nNe woate extension eve kple stronger, woate extension si le first le \u0192e \u0256eka.\nKpli be, ne woado \"Slices\" le klasi kple \u0192e \u0256eka extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] eye woate 'Slices.SErviNGSliCes' ke 'SErviNGSliCes' ke strongest extension.\nExample:\nne Strongest_Extension == 'my_class.AA'\n    \"\"\"\n","canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"}
{"prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"W\u00f2anya 2 \u014bk\u0254wo. N\u00e0dzra be \u0192e be \u014bk\u0254 eve si le af\u00e3 \u0192e anyi g\u00e3 le af\u00e3 \u0192e ameg\u00e3 kple e\u0192e ny\u0254ny\u0254wo kat\u00e3 le af\u00e3 \u0192e k\u0254me.\n    cycpattern_check => M\u025btso\n    cycpattern_check => Nudzi\u0192u\n    cycpattern_check => M\u025btso\n    cycpattern_check => Nudzi\u0192u\n    cycpattern_check => M\u025btso\n    cycpattern_check => Nudzi\u0192u\n\n    \"\"\"\n","canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"}
{"prompt":"\ndef even_odd_count(num):\n    \"\"\"**Ewe Translation:**\n\nNe w\u00f2\u0256e n\u00f9m\u025bt\u0254 \u0256eka. Dzra t\u0254pu\u028bu si va g\u00e3 \u0192e n\u0254viwo kple n\u0254viwo siwo ny\u0254nu.\n\n     Nudeme:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n","canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Here is the translation of the given sentence into Ewe:\n\n```\nNe w\u00f2anya n\u00fatsuwo \u0192e \u0256eka, le w\u00f2\u0192le eya gbe y\u00e1 w\u00f2ts\u0254 eya be roman numeral le nyatakaka me,\n    eye w\u00f2va eya le katakp\u0254 he\u0192o\u0192o.\n    \u0191e\u0192eviwo: 1 <= num <= 1000\n\n    M\u00ed\u0256e\u0256eviwo:\n```\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n","canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n","canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"}
{"prompt":"\ndef find_max(words):\n    \"\"\"Ts\u0254 gb\u0254gb\u0254 me be w\u00f2ak\u0254k\u0254 a\u0256e si le list me \u0192e gb\u0254b\u0254wo \u0192e nyatakaka. List la le nyatakaka bubuwo. Na\u0256e nyatakaka si le maximum nyatakaka \u0192e unique characters. Ne nyatakaka bubuwo le maximum nyatakaka \u0192e unique characters, na\u0256e nyatakaka si le dzimevi le lexicographical order.\n\nfind_max == \"string\"\nfind_max == \"enam\"\nfind_max == \"aaaaaaa\"\n    \"\"\"\n","canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"}
{"prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Wo nye agblevi si le \u014bkeke me, eye woate dze anyi \u0256eka alo \u0256eka le anyi siwo w\u00f2\u0256u. Ke men\u0254 nyuie o, woate dze anyi bia ta eye w\u00f2akpe \u0256e asi me le \u014bkeke me. Woaw\u0254 nya be, woate \u0256o \u0256e array si le [ anyi bubu si w\u00f2\u0256u le \u014bkeke me, \u0256e anyi siwo gbe le \u014bkeke me ]. Ne anyi siwo gbe me le, w\u00f2adu anyi siwo gbe, ke men\u0254 nyuie o.\n\nExempla:\n* eat -> [11, 4]\n* eat -> [12, 1]\n* eat -> [11, 0]\n* eat -> [7, 0]\n\nNya siwo kat\u00e3 be:\n@number : integer\n    anyi si w\u00f2\u0256u.\n@need : integer\n    anyi siwo w\u00f2ate \u0256u.\n@remaining : integer\n    anyi siwo gbe le stock me.\n\nKp\u0254kp\u0254:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nN\u0254 nud\u0254wo nye :))\n    \"\"\"\n","canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"}
{"prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Here is the translation of the given text into Ewe:\n\n```\nNe w\u0254na list blibo eve, operator kple operand. List gbadza w\u0254a nu si gb\u0254 na algebra operations, eye list et\u0254\u0303 w\u0254a integers. Na list eve si w\u0254na dze kple dze na w\u0254a algebric expression kpe w\u00f2na result si w\u0254na.\n\nAlgebra operations gbadza:\nAddition\nSubtraction\nMultiplication\nFloor division\nExponentiation\n\nExempla:\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote:\n    \u0191omebia si operator list w\u0254a le operand list n\u00e0\u0256e\u0256e kple ny\u00e9a be operator list le veve si w\u0254na ne operand list w\u0254a le veve bubu alo veve eve. \n    Operand w\u0254a le veve si n\u00e0\u0256e\u0256e w\u0254a non-negative integers.\n    Operator list w\u0254a le \u0256eviwo kple operator, eye operand list w\u0254a le veve eve kple operands eve.\n```\n\n    \"\"\"\n","canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"prompt":"\ndef solve(s):\n    \"\"\"Here is the translation of the sentence into Ewe:\n\nMekae nye sewo n\u0254\u0303 dzesi s.\n    Ne s[i] nye a\u0256e siwo le nu\u014bl\u0254lawo me, me\u0192le e\u0192e nyate\u0192e le xexeme \u0192e anyi me kple xexeme \u0192e anyi me dzi,\n    ke bo\u014bkae, nye e le abe ale siwo le esime.\n    Ne dzesi la me\u0256e nu\u014bl\u0254lae o, me\u0192le dzesi la.\n    Fum la n\u00e0w\u0254 dzesi \u0192e anyi ke.\n    Nyeamewo:\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n","canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"}
{"prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    M\u00e8kp\u0254 text kpl\u0254\u0303a la, w\u00f2ats\u0254 e\u0192e md5 hash kpl\u0254\u0303a va. \n    Ne text kpl\u0254\u0303a nye kpl\u0254\u0303a siwo kat\u00e3 le eme la, w\u00f2ats\u0254 None va.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n","canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    M\u00e8w\u0254 anyigba eve a kple b a\u0256e, mew\u0254 n\u0254vi eve si w\u00f2le a kple b me, eye ne menya wo le dzem le dzem.\n\nN\u00e8nye \u0256e eg\u0254me be:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n","canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
