[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" San hw\u025b s\u025b w\u0254 akyirikyiri a \u025bda mmer\u025b dodow no ho w\u0254 \u025bnhy\u025b ns\u025bm a \u025bda ho so w\u0254 list no mu.\n    D\u025b\u025bb\u025bn:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" In Twi:\n\n\"Nea \u025bda so\u0254 no de\u025b, input k\u0254 function yi mu y\u025b \u025bkwan a \u025bda mu s\u025b string bi a \u025bw\u0254 mu ns\u025bm dodow a \u025bw\u0254 mu parentheses a \u025bda mu. W'adwuma no y\u025b s\u025b, b\u0254 w\u0254n ho b\u0254 mu s\u025b strings a \u025bda mu na san k\u0254 list mu s\u025b w\u0254n. Ns\u025bm a \u025bda mu no y\u025b balanced na w\u0254n mu biara nni mu s\u025b w\u0254de w\u0254n hyehy\u025b\u025b ho. Fa ny\u025b hwee w\u0254 spaces a \u025bw\u0254 input string no mu. \u0190ho nhw\u025bso:\"\n\nNote: This translation preserves the technical context and instructions while adapting to the grammatical and syntactical norms of Twi.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Here is the translation of your English sentence into Twi:\n\n```\nS\u025b w\u0254ma wo apositive floating point n\u0254ma bi a, w\u0254b\u025btumi abubu no mu\n    na \u025by\u025b integer fa ne decimal.\n\n    Ma decimal fa no nko ara nk\u0254.\n    Nkyer\u025bkyer\u025b: \n```\n\nPlease let me know if you need further assistance!\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Wo de deposit ne withdrawal operations list bi w\u0254 bank account so a \u025by\u025b zero balance no. W'adwuma ne s\u025b wob\u025bhwehw\u025b s\u025b bere biara a account no balance b\u025bk\u0254 fam ak\u0254 zero ase no, na s\u025b \u025bba saa a, function no b\u025bsan de True aba. S\u025b \u025bny\u025b saa a, \u025bb\u025bsan de False aba. \n    Mfatoho:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" W\u0254 \u0254pepem a \u025bde n\u0254ma a w\u0254ahy\u025b mu no, k\u0254twa n\u0254ma a \u025bda mu no ho Mean Absolute Deviation. \nMean Absolute Deviation no y\u025b \u0254haw a \u025bda mu no biara ho nhyehy\u025be a w\u0254hw\u025b mu a \u025bma \u025by\u025b a \u025bda mu no hyia no:\nMAD = \u0254haw a \u025bda mu no biara ho nhyehy\u025be | x - x_mean |\nNhw\u025bso:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Fa n\u0254mba 'delimeter' hy\u025b ntam ntam w\u0254 nky\u03b5n mmer\u025b so w\u0254 de\u025b \u025bda h\u0254 no 'numbers' mu.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" \u0190kwan a w\u0254de ma saa dwumadie yi y\u025b k\u0254w a \u025bda ho adi s\u025b \u025by\u025b nhyehy\u025be\u025b bebree a w\u0254de kyer\u025b\u025b mfutuw a \u025bw\u0254 mu a w\u0254ab\u0254 ho nkutoo\u0254 na \u025by\u025b mfutuw a \u025bda ho adi mu. \n    Ma \u025bho as\u025bm biara, y\u025by\u025b ayie\u025b no a \u025by\u025b mfutuw a \u025bda ho adi mu no, bue mfutuw a \u025bda ho adi mu no ho s\u025b ewie\u025b. \n    S\u025b nhw\u025bso:) w\u0254 mfe\u025b mmienu w\u0254 ayie\u025b mu \u025bber\u025b a)) w\u0254 mfe\u025b mmi\u025bnsa.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Sie mfuturu bi a \u025bw\u0254 input list no mu k\u0254gyae\u025b a \u025bw\u0254 bi a w\u0254w\u0254 given substring no mu.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" W\u0254 \u0254l\u025bsu bi a \u025bw\u0254 mu nkonta, san bra bio ka sum ne product no a \u025bw\u0254 \u0254l\u025bsu no mu nyinaa w\u0254 tuple bi mu. Sum a \u025bda h\u0254 a emu nni h\u0254 no \u025by\u025b 0 na product a \u025bda h\u0254 a emu nni h\u0254 no \u025by\u025b 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Fi akyinnye biara a w\u0254de maa wo, b\u0254 akyinnye a \u025bda mu s\u025bnea \u025bb\u025by\u025b a \u025bda so na \u025by\u025b k\u025bse koraa w\u0254 bere a w\u0254de maa wo no mu.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" S\u0254 hw\u025b s\u025b s\u025bnea w\u0254de \u025bk\u0254\u0254 so no y\u025b palindrome. \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" The Twi translation for the given sentence is:\n\n\"Ahy\u025bde\u025b no y\u025b mmea ns\u025bm abien a na b a \u025bw\u0254 1 ne 0 nkutoo.\n    Di binary XOR so w\u0254 mmea ns\u025bm yi so na san fa as\u025bm no s\u025b as\u025bm.\"\n\nPlease note that some technical terms like \"binary XOR\" might not have a direct translation in Twi and are typically used as is.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Y\u025b w'ahyehy\u025b mu no, fa kyer\u025bwde a \u025by\u025b tenten paa no bra. Sane no fa de\u025b edi kan mu s\u025b \u025bk\u0254ba s\u025b kyer\u025bwde bebree w\u0254 tenten koro. Fa baako biara nni h\u0254 s\u025b \u025bk\u0254ba s\u025b w'ahyehy\u025b no mu y\u025b danee.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" San akenkan a \u025by\u025b k\u025bse a \u025bka nsa a \u025by\u025b k\u025bse a \u025bka nsa a \u025bka nsa a y\u025bka nsa a ne b.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" San bra ne\u025b \u025bda ho s\u025b \u0254y\u025b list \u025bw\u0254 mu a \u025by\u025b \u0254twer\u025b firi aky\u025bde\u025b a \u025by\u025b tenten k\u0254si ne\u025b \u025by\u025b tenten no.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" San ka as\u025bm yi k\u0254 Twi mu: \"San bra ns\u025bnt\u025bn bi a \u025bw\u0254 nnumer\u025b a \u025by\u025b space-delimited a \u025bfi 0 k\u0254si n inclusive mu.\"\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" S\u025b w\u0254de nhoma tiaa bi ma wo a, hwehw\u025b s\u025bnea \u025bb\u025by\u025b a wob\u025bhunu s\u025b nhoma tiaa no mu ns\u025bmfua a \u025bda ho y\u025b s\u025bn.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input no saa dwuma yi y\u025b \u025btwer\u025b a \u025bkyer\u025b nnwom ns\u025bm w\u0254 ASCII format titiriw mu.\n    Wo dwuma ne s\u025b wob\u025bkyekyere saa \u025btwer\u025b yi na wob\u025bsan de \u025bkan ahorow a \u025bfa s\u025b \n    nnwom no biara y\u025b ahe na \u025bda k\u0254.\n\n    \u0190ha na \u025bkyer\u025b ne:\n    'o' - Foforo note, \u025bda nan beatsi\n    'o|' - Fa note, \u025bda nnan beatsi\n    '.|' - Anan note, \u025bda baako beatsi\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Hu s\u025b wob\u025btumi ahu mp\u025bn a \u025bk\u025bse biara w\u0254 as\u025bmfua no mu. Ka mp\u025bn a \u025bto so.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Here is the translated sentence in Twi:\n\n\"Mfa nky\u025bmu a \u025by\u025b mmer\u025b ne mmer\u025b akyiri a w\u0254de 'zero' kosi 'nine' ne 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' ne 'nine' y\u025b valid. San fa nky\u025bmu no de nkyer\u025b nky\u025bmu a \u025bk\u0254 fi aky\u025bse k\u0254 aky\u025bse titiriw de kyer\u025b.\"\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Firi nkyer\u025bw nkyer\u025base a w\u0254de no b\u025bma w'ano yi mmienu a \u025bb\u025bn ho paa na fa ky\u025bre w\u0254n w\u0254 w\u0254n mmienu mu s\u025bnea \u025bne: nketewa no na \u025bto so kan, k\u025bse no nso na \u025bto so akyi.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" \u0190nn\u025b a y\u025bde wo y\u025b biribi a, \u025bs\u025b s\u025b wo de \u025bhy\u025b linear transform ma, \u025bno de \u025bns\u025b s\u025b \u025bt\u0254 so s\u025b \u0254no k\u025bse no b\u025by\u025b 1 na ak\u025bse no b\u025by\u025b 0.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Fa python list no mu na yi nno\u0254ma a \u025by\u025b integer nkutoo.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" San ma me tenten akenkan no.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Ma nsa adidi mu no, hwehw\u025b n ketewaa a \u025by\u025b k\u025bse sen n a \u025bb\u025btumi ab\u0254 no mu p\u025bp\u025b\u025bp\u025b.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" San bra nkyeky\u025bmu a \u025bda mu ns\u025bso no mu a \u025bfiri mu ketewaa kosi mu k\u025bse\u025b. \n    \u0190s\u025b s\u025b nkyeky\u025bmu biara w\u0254 h\u0254 \u025bso dodow a \u025bda ho adi s\u025bnea \u025bda w\u0254 nkyeky\u025bmu no mu.\n    Nhyira a w\u0254de no b\u025by\u025b nkyeky\u025bmu a \u025by\u025b mmer\u025b mu p\u025bp\u025b\u025bp\u025b.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Fi list \u025bmu a \u025bw\u0254 integer no mu, yi biribiara a \u025bba mp\u025bn pii. \n    Ma \u0254k\u0254mfo\u0254 a \u025bda h\u0254 no s\u025bnea \u025bda input no mu.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Ma \u025bde\u025b w\u0254 de\u025b \u025bw\u0254 h\u0254 no, s\u0254 nkyer\u025bwee a \u025bw\u0254 ase no ma \u025by\u025b k\u025bse na \u025bw\u0254 k\u025bse no ma \u025by\u025b ase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" B\u0254 ahy\u025bde\u025b no mu akenkanfo\u0254 b\u025by\u025b mmoa mmenmu akenkanfo\u0254 b\u0254 mu nnwom.\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Sie akyirede a wode hy\u025b nsa so no mu de hy\u025b ma akyerekyer\u025b no.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"San nne\u025bma a \u025by\u025b nsonsonso\u0254 a \u025bw\u0254 list no mu nko ara.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"San no s\u025b \u025by\u025b nokware s\u025b adadekyee biara y\u025b prime, na s\u025b \u025bny\u025b saa a \u025by\u025b atoro.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Hw\u025b polynomial a \u025bw\u0254 coefficients xs w\u0254 point x.\n    san s\u025b: xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"\u0190y\u025b\u025b dwumadie yi gye l list no na \u025bma l' list a \u025bte saa:\n    l' y\u025b p\u025bp\u025b\u025bp\u025b s\u025b l w\u0254 indexes a w\u0254mfa w\u0254n ky\u025b mmi\u025bnsa ho.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"San bra ns\u025bm a w\u0254ahyehy\u025b na w\u0254asiesie no w\u0254 krataa mu bi.\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"San bra \u025bleminiti a \u025bso sen biara w\u0254 list no mu.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"San n\u0254ma no a \u025bkyer\u025b s\u025b n\u0254ma 7 no hy\u025b n\u0254ma biara mu a \u025bkyer\u025b soro n k\u0254 so k\u0254si s\u025b \u025by\u025b n\u0254ma a \u025bkyer\u025b 11 anaa 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"\u0190y\u025b adwuma yi gye aky\u025bde l bi na \u025bma aky\u025bde l' bi a \u025bte s\u025b\u025b:\n    l' y\u025b p\u025bp\u025b\u025bp\u025b te s\u025b l w\u0254 nkyeky\u025bm a \u025by\u025b mfimfini, na \u025bnna ne nkor\u0254fo w\u0254 nkyeky\u025bm a \u025by\u025b ntwatoso y\u025b p\u025b te s\u025b nkor\u0254fo w\u0254 ntwatoso nkyeky\u025bm l mu, nanso w\u0254 ab\u0254 mu p\u025b.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    ma ns\u025bnt\u025bns yi ase w\u0254 Twi mu: \"de ns\u025bnt\u025bns tiaa a w\u0254de nkyer\u025bwee ns\u025bm nansa b\u0254 mu.\"\n\nPlease note that the translation might not capture every technical nuance due to language differences. If you need a more specific or technical translation, providing additional context might help!\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib ma n-nso\u0254 n\u0254ma a \u025by\u025b Fibonacci n\u0254ma na \u025by\u025b prime nso.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    `triples_sum_to_zero y\u025b s\u025b \u0254de integer ahodo\u0254 ho list bi y\u025b input.\n    \u025bde\u025b no b\u025bma nokware s\u025b \u025bw\u0254 ns\u025bntitiri a \u025by\u025b ns\u025bnhy\u025br\u025b mmi\u025bnsa a w\u0254de w\u0254n ho b\u025bk\u0254 zero, na \u025bde\u025b \u025bny\u025b no de\u025b b\u025bma atoro.`\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Enim s\u025b \u0254kwantenten bi te s\u025b \u0254kwantenten a \u025bk\u0254 p\u025b\u025b na \u025bnni awiei.\nn kar a w\u0254redi fi nifa k\u0254 benkum; \u025bnna bere koro no ara so, n kar foforo a aka no\nredi fi benkum k\u0254 nifa. Nsoromma abien yi fi akyirikyiri ho ho no.\nKar nyinaa tu fam w\u0254 saa nt\u025bm ara. Kar abien b\u025bka s\u025b kar a \u025bredi fi nifa k\u0254 benkum beti kar a \u025bredi fi benkum k\u0254 nifa.\nNanso, kar no y\u025b duru na w\u0254n mu y\u025b den; enti, w\u0254to fam s\u025b nea w\u0254n mu biara ank\u0254ka.\n\nSaa dwumadie yi de \u025bho as\u025bm no ba s\u025b w\u0254aka ak\u0254ka.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"San list no ma nsafoa ahy\u025b mu 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero gye nkyer\u025base\u025b no mu a \u025by\u025b n\u0254ma dodow biara.\n\n\u0190de\u025b y\u025b no mu s\u025b \u025bw\u0254 s\u025b nne\u025bma mmienu a \u025bnso\u0254 \u0254no mu no sum y\u025b d\u0254n no, na \u025by\u025b nokware, na s\u025b \u025bny\u025b saa a \u025by\u025b atoro.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Sesa \u025bnam mu ns\u025bns\u025bnee so na \u025bda x adwumay\u025b de no w\u0254 base so.\n    san de \u025bdan nkyer\u025base\u025b b\u0254\u0254 mu mp\u025bns\u025bns\u025bn so.\n    s\u025b \u025bnam mu ns\u025bns\u025bnee no so base nn\u0254ma no y\u025b nkyer\u025b 10 ase.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"S\u025b w\u0254de nky\u025bmu a \u025bw\u0254 \u025bpono \u025bnum ne ne tenten a \u025bkor\u0254so de y\u025b ns\u025bso\u0254 a \u025bw\u0254 mfirihyia mu ma \u025bpono \u025bnan.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 no\u0254ma nkanee y\u025b nkanee a \u025bte s\u025b Fibonacci nkanee no na \u025bda s\u025b\u025b:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    Mesr\u025b wo, kyer\u025bw y\u025b\u025bb\u0254 a \u025bde\u025b b\u025bhyehy\u025b n-\u025bdi mu fib4 no\u0254ma nkanee no. \u0190ns\u025b s\u025b wode nhyia.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"San ma median no mu mfi mu l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Hw\u025b s\u025b \u025bde\u025b w\u0254de\u025b ama no y\u025b palindrome.\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"San 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    y\u025b as\u025bm k\u0254so a \u025bde akyer\u025bwde biara nkyer\u025bwee so 5 w\u0254 \u025bw\u0254fon mu.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    \"remove_vowels y\u025b adwuma bi a \u025bfa ns\u025bm na \u025bde ns\u025bm a \u025bnni nwomaa no ma.\"\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"San True s\u025b nsa ano n\u0254ma biara w\u0254 l no nyinaa sua sen t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Ka nnomu mmienu x ne y ho.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Hw\u025b s\u025b \u025by\u025b \u025bs\u025b s\u025b ns\u025bm mmienu no w\u0254 nkyer\u025base biako p\u025b.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"San bra n-\u025b Fibonacci n\u0254ma no.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Brackets y\u025b nkyer\u025bwee bi a \u025bw\u0254 \"<\" ne \">\". \n    San bra nokware s\u025b \u025bb\u025by\u025b s\u025b \u025bbr\u025b biara a \u025bbue no w\u0254 nea \u025btoto mu.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"San k\u0254 So\u025b s\u025b \u025bda no adi pefee s\u025b \u0254ko so k\u0254 soro anaa \u0254k\u0254 fam.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"San de ns\u025bm a \u025bw\u0254 mu biako a w\u0254totoo no fi mmer\u025bw a \u025by\u025b mmienu no mu.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"San de n k\u025bse\u025b a \u025by\u025b prime factor no. Fa no s\u025b n > 1 na \u025bny\u025b prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n y\u025b adwuma a \u025bbo\u0254 nn\u0254ma fi 1 kosi n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" \"brackets y\u025b s\u025bnkanee a \u025bw\u0254 ''.\n    San bra nokware s\u025b s\u025bnkanee biara a \u025bda mu no w\u0254 ne ho s\u025bnkanee a \u025bto mu.\"\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs y\u025b polynomial no so nkitahodi.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Fa nkitahodi a \u025by\u025b polynomial no ho abisade\u025b ma no w\u0254 saa nhyehy\u025be no mu.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"FibFib adaho\u0254 ahy\u025base\u025b y\u025b adaho\u0254 a \u025bte s\u025b Fibbonacci adaho\u0254 a \u025bkyer\u025b s\u025b:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Mesr\u025b wo, kyer\u025bw dwumadi a \u025bb\u025btumi de n-ad\u0254e\u025b no fra FibFib adaho\u0254 no mu yiye.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nKa ns\u025bm foforo ho.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"K\u0254 so k\u0254 so kyinkyini n\u0254ma a \u025bw\u0254 integer x mu no, kyinkyini n\u0254ma no k\u0254 nifa na san de baa y\u025b adwenkyer\u025b.\nS\u025b shift no so sen n\u0254ma dodow a \u025bw\u0254 h\u0254 a, san n\u0254ma no akyiri.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Translate the following sentence into Twi.\n\n```plaintext\nTask\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153\n```\n\n```plaintext\nAdwuma\n    Kyer\u025bw dwumadi bi a \u025bb\u025bfa nkyer\u025bw ns\u025bntitiriw s\u025b input na \u025bde nkyer\u025bw ns\u025bntitiriw a \u025bw\u0254 ab\u0254din titiriw nkutoo no\n    ASCII kyer\u025bwde ho ns\u025bm akyiwade.\n\n    Nkyer\u025bkyer\u025bmu:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153\n```\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Y\u025bnhw\u025b adwuma yi mu, wobenya \u025bkas\u025bmfua a \u025bkyer\u025b ab\u025b so ne ankaa so \n    a w\u0254de ahy\u025b aboa no mu. Aboa yi mu w\u0254 ab\u025b, ankaa ne mango nn\u0254bae. \n    S\u025b w\u0254ma wo \u025bkas\u025bmfua a \u025bkyer\u025b ab\u025b so ne ankaa so nyinaa \n    ne \u025bho nkyer\u025base a \u025bkyer\u025b nn\u0254bae nyinaa a \u025bw\u0254 aboa no mu a, \n    san fa \u025bho nkyer\u025base a \u025bkyer\u025b nn\u0254bae nyinaa a \u025bw\u0254 aboa no mu ma mango nn\u0254bae a \u025bw\u0254 aboa no mu.\n    s\u025b nhw\u025bso:\n    fruit_distribution ->19 - 5 - 6 = 8\n    fruit_distribution -> 3 - 0 - 1 = 2\n    fruit_distribution -> 100 - 2 - 3 = 95\n    fruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    Eyi ne Twi kasa kyer\u025bw ho nkyer\u025bmu:\n\n```\nS\u025b w\u0254de array a \u025bkyer\u025b dua no b\u025bn a \u025bw\u0254 nn\u0254bae\u025b a \u025by\u025b integer a \u025bny\u025b negetiv w\u0254 so ma wo a,\n    w'adwuma ne s\u025b w'ayi baako a \u025bw\u0254 nn\u0254bae\u025b no mu na bra.\n    Nn\u0254bae\u025b a w'ayi no b\u025by\u025b nea \u025bw\u0254 nketewa a \u025by\u025b p\u025b\u025b value no mu.\n    S\u025b nn\u0254bae\u025b bebree w\u0254 nketewa \u025bp\u025b\u025b value no a, yi nea \u025bw\u0254 nketewa index no mu.\n\n    Nn\u0254bae\u025b a w'ayi no b\u025by\u025b w\u0254 list mu, [ nketewa_value, ne index ],\n    S\u025b \u025bnni p\u025b\u025b value anaas\u025b array a w\u0254de maa wo no y\u025b \u0254br\u025b no a, ma [].\n\n    Mfatoho1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Adi ho adanse\u025b: 2 w\u0254 nketewa p\u025b\u025b value no, na 2 w\u0254 nketewa index no mu.\n\n    Mfatoho2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Adi ho adanse\u025b: 2 w\u0254 nketewa p\u025b\u025b value no, na 2 w\u0254 nketewa index no mu.\n\n    Mfatoho3:\n        Input: []\n        Output: []\n    \n    Mfatoho4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Adi ho adanse\u025b: 0 y\u025b nketewa value no, nanso zero abien w\u0254 h\u0254,\n                     enti y\u025bb\u025byi nea edi kan no, a \u025bw\u0254 nketewa index no mu.\n\n    Ahintas\u025bm:\n        * 1 <= nn\u0254bae\u025b.dodow <= 10000\n        * 0 <= nn\u0254bae\u025b.value\n```\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Di as\u025bm yi k\u0254 Twi mu:\n\nS\u025b w\u0254de arr a \u025by\u025b n\u0254ma n\u0254ma ahorow b\u0254 mu, hwehw\u025b n\u0254ma ahorow a \u025by\u025b kakra koraa a \u025bs\u025b s\u025b wosakra de ma array no b\u025by\u025b palindromic. Palindromic array y\u025b array a wotumi kenkan no fi n'ase k\u0254 no so ne fi no so k\u0254 n'ase saa ara. W\u0254 sakra baako mu, wotumi sakra n\u0254ma baako de y\u025b n\u0254ma foforo biara.\n\nS\u025b nhw\u025bso:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Kyer\u025bw dwumadi bi a \u025bb\u025bma nokware s\u025b nkyer\u025bwde a w\u0254de mae no y\u025b mpr\u025bko mpr\u025bnsa a \u025by\u025b prime ab\u025by\u025b so\nna atoro a \u025bny\u025b saa.\n\u0190ho nimde\u025b s\u025b y\u025b nea \u025bka ho 100 ho.\nNs\u025bmfua:\nis_multiply_prime == Nokware\n30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Wo adwuma ne s\u025b wode nhyehy\u025b\u025b bi b\u025bkyer\u025b a, \u025bb\u025bsan de \"true\" ba s\u025b n\u0254ma bi x y\u025b n' nk\u025bse a \u025by\u025b eenvoudige tumi na s\u025b \u025by\u025b nwonwa a \u025bb\u025bkyer\u025b \"false\".\nx y\u025b n' nk\u025bse a \u025by\u025b eenvoudige tumi s\u025b n**int=x\nS\u025b nhw\u025bso:\nis_simple_power => true\nis_simple_power => true\nis_simple_power => true\nis_simple_power => false\nis_simple_power => false\nis_simple_power => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"You have been tasked to translate the following sentence into Twi:\n\nW\u0254de adwuma no ahy\u025b wo s\u025b kyer\u025bw afunction a \u025bb\u025btumi agye hexadecimal n\u0254ma bi s\u025b string na aka n\u0254ma a \u025by\u025b hexadecimal a \u025by\u025b prime.\nHexadecimal n\u0254ma y\u025b 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers y\u025b 2, 3, 5, 7, 11, 13, 17,...\nEnti \u025bs\u025b s\u025b wode n\u0254ma yi hohoro: 2, 3, 5, 7, B, D.\nNote: wubetumi agye s\u025b input no y\u025b nokware anaa \u025by\u025b empty string, na ns\u025bmfua A,B,C,D,E,F y\u025b uppercase daa.\nNs\u025bmfua:\nS\u025b num = \"AB\" a output no b\u025by\u025b 1.\nS\u025b num = \"1077E\" a output no b\u025by\u025b 2.\nS\u025b num = \"ABED1A33\" a output no b\u025by\u025b 4.\nS\u025b num = \"123456789ABCDEF0\" a output no b\u025by\u025b 6.\nS\u025b num = \"2020\" a output no b\u025by\u025b 2.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Wob\u025bnya n\u0254ma bi w\u0254 decimal mu na w'adesua ne s\u025b w'aky\u025b no ak\u0254 binary format mu. \u0190s\u025b s\u025b dwumadie no ma string a, \u025bkwan biara mu a \u025by\u025b binary n\u0254ma. \u0190kwan biara mu w\u0254 string no mu b\u025by\u025b '0' anaa '1'.\n\n\u0190b\u025by\u025b s\u025b \u025bb\u025by\u025b ad\u0254m nkrataa 'db' w\u0254 fapem ne awiee\u025b no mu. Ad\u0254m nkrataa no w\u0254 h\u0254 de b\u025bboa format no.\n\nNhwehw\u025bmu:\ndecimal_to_binary   # ma \"db1111db\"\ndecimal_to_binary   # ma \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"Wo de\u025b w\u0254ma wo ns\u025bnt\u025bns s.\nWo adwuma ne s\u025b hw\u025b s\u025b ns\u025bnt\u025bns no y\u025b anigye anaa \u025bny\u025b anigye.\nNs\u025bnt\u025bns bi y\u025b anigye s\u025b ne tenten y\u025b dodo ara 3 na akyer\u025bwde 3 biara a \u025bda h\u0254 no nyinaa y\u025b f\u025bf\u025b\u025bf\u025b.\nS\u025b nhw\u025bso no:\nis_happy => \u0190ny\u025b anigye\nis_happy => \u0190ny\u025b anigye\nis_happy => \u0190y\u025b anigye\nis_happy => \u0190ny\u025b anigye\nis_happy => \u0190y\u025b anigye\nis_happy => \u0190ny\u025b anigye\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u0190y\u025b semester no awiee\u025b da k\u025bse no, na kyer\u025bkyer\u025bfo\u0254 no w\u0254 s\u025b \u0254de adwuma no ma sukuufo\u0254. Kyer\u025bkyer\u025bfo\u0254 no y\u025b ne ho afiri de y\u025b n'adwumay\u025b. Ns\u025bm a \u025bda so no ne s\u025b, \u0254w\u0254 kode\u025b a \u0254de y\u025b adwumay\u025b no. \u0186de mo ama sukuufo\u0254 no list of GPA na mo w\u0254 s\u025b mob\u025bkyer\u025bw nhyehy\u025b\u025b a \u025bb\u025btumi de \u025bma list of letter grades de \u025bde\u025b k\u025bse\u025b yi:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Nw\u025bns\u025bm:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Here is the translation of the given sentence into Twi:\n\n```\nKyer\u025bw afidie bi a \u025bfa \u025bkyer\u025bwde bi na \u025bma nokware s\u025b \u025bkyer\u025bwde no tenten y\u025b n\u0254ma a \u025by\u025b k\u025bse anaas\u025b atoro s\u025b \u025bnte saa\n    Ns\u025bm a \u025by\u025b nhw\u025bso\n    prime_length == True\n    prime_length == True\n    prime_length == True\n    prime_length == False\n```\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    S\u025b w\u0254maa n a \u025by\u025b namba a \u025by\u025b k\u025bse, san bra na ka n-digit namba a \u025by\u025b k\u025bse a \u025bfiri anaa \u025by\u025b nea edi kan 1 no dodow.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Mm\u0254 N y\u025b integer a \u025bda h\u0254 a \u0254y\u025b positive, ky\u025bmu sum a \u025by\u025b n'ahorow no nyinaa w\u0254 binary mu.\n\n    Nn\u025b\u025bma ho nhw\u025bso\n        Ma y\u025bnka s\u025b N = 1000 a, n'ahorow no sum b\u025by\u025b 1 a \u025bbaa no so no \u025by\u025b \"1\".\n        Ma y\u025bnka s\u025b N = 150 a, n'ahorow no sum b\u025by\u025b 6 a \u025bbaa no so no \u025by\u025b \"110\".\n        Ma y\u025bnka s\u025b N = 147 a, n'ahorow no sum b\u025by\u025b 12 a \u025bbaa no so no \u025by\u025b \"1100\".\n    \n    Ns\u025bm:\n        @N integer\n             Ahy\u025bde: 0 \u2264 N \u2264 10000.\n    Output:\n         \u025by\u025b string a \u025by\u025b binary n\u0254ma\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"\u0190ma wo w\u0254 list bi a \u025bw\u0254 integer nkitahodie a \u025bny\u025b h\u0254 kwa biara, lst. Fa \u025bho mfa \u025blem\u025bnt a \u025by\u025b k\u0254k\u0254\u0254 nanso \u025bda odd indices so ka ho.\n\n\n    Nkyer\u025bkyer\u025bbea:\n        add ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Translate the following sentence into Twi:\n\n```\nKyer\u025bw nhyehy\u025b a \u025bfa \u025bt\u025b a \u025btwa \u025bt\u025b no na \u025bde\u025b no k\u0254 nkane\u025b so.\n    \u0186nhyehy\u025b a \u025bt\u025b no, y\u025b \u025bt\u025b a \u025bt\u025b no w\u0254 h\u0254 a \u025bnne\u025b \u025by\u025b s\u025bde\u025b \u025bt\u025b a \u025btete \n    w\u0254 \u025by\u025b ns\u025bm biara no y\u025b \u025bt\u025b foforo a \u025bt\u025b no \n    w\u0254 h\u0254 a \u025by\u025b s\u025b \u025bnne\u025b \u025btete w\u0254 \u025bt\u025b no w\u0254 h\u0254 s\u025bde\u025b \u025by\u025b s\u025b \u025by\u025b s\u025b \u025bnne\u025b \u025btete \n    w\u0254 n'ase\u025b no so w\u0254 \u025bt\u025b no mu. \n    Note: \u0190s\u025b s\u025b w'\u0254y\u025b ns\u025bm biara no y\u025b \u025bt\u025b no w\u0254 h\u0254 na \u025bnso \u025by\u025b \u025bt\u025b a \u025btete \n    w\u0254 \u025by\u025b ns\u025bm biara no mu.\n\n    S\u025b nhw\u025bso\u0254:\n    anti_shuffle fa 'Hi'\n    anti_shuffle fa 'ehllo'\n    anti_shuffle fa 'Hello !!!Wdlor'\n```\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    W\u0254de data a \u025bw\u0254 dim\u025bns\u025bn abien ama wo, s\u025b \u025by\u025b akyade a \u025bda ho h\u0254,\n    a \u025bte s\u025b matriks, nanso \u025bnky\u025b matriks no,\n    \u025bho beae biara betumi adi nkuro a \u025bw\u0254 columns ho.\n    W\u0254de lst, ne integer x no de, hwehw\u025b integers x w\u0254 list no mu,\n    na san de akyade a \u025by\u025b tuples, [, ...] ma so\n    s\u025b akyade biara y\u025b coordinate -, fi 0 no so.\n    Sort coordinates no a edi kan w\u0254 rows mu w\u0254 ascending order mu.\n    Bio, sort coordinates a \u025bw\u0254 row mu w\u0254 columns mu w\u0254 descending order mu.\n\n    Mfatoho:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [,,,,]\n    get_row == []\n    get_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    S\u025b w\u0254de array bi a \u025bw\u0254 integers a \u025bny\u025b b\u0254ne biara mae no, san fa array no ho akyire h\u0254 na y\u025by\u025b sorting,\n    wode array a w\u0254de mae no b\u025by\u025b sorting w\u0254 ascending order mu s\u025b sum y\u025b odd,\n    anaas\u025b wode b\u025by\u025b sorting w\u0254 descending order mu s\u025b sum y\u025b even.\n\n    As\u025bmti:\n    * nnsesa array a w\u0254de mae no.\n\n    Nkyer\u025base:\n    * sort_array => []\n    * sort_array => [5]\n    * sort_array => [0, 1, 2, 3, 4, 5]\n    * sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Kyer\u025bw dwumadi bi a \u025bde encrypt de a \u025bb\u025bfa ns\u025bntitiriw s\u025b anaa \u025by\u025b argument\n    na \u025bde ns\u025bntitiriw a \u025bda ho so b\u025bsan mu. Alphabet no b\u025bsan mu w\u0254\n    kwan bi mu a \u025bte s\u025b s\u025bnkyer\u025bnne no b\u025bt\u0254 so w\u0254 nky\u025bmu abien a \u025bka abien ho.\n    Nkyer\u025bmu no:\n    encrypt b\u025bsan 'lm'\n    encrypt b\u025bsan 'ewhjklnop'\n    encrypt b\u025bsan 'kj'\n    encrypt b\u025bsan 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    W\u0254de akontaa a \u025bw\u0254 nkyer\u025bmu ahodo\u0254 b\u025bma wo.\n    Twer\u025b \u0254som a w\u0254fr\u025b no next_smallest a \u025bb\u025bsan de akyire no abien a \u025bso ketewaa w\u0254 akontaa no mu.\n    San de None s\u025b akyire no biara nni h\u0254.\n    \n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Wob\u025bma wo ns\u025bm bi, na wo adwuma ne s\u025b woka boredoms no dodow. \u0190b\u0254d\u0254m y\u025b as\u025bm a \u025bfi ase ka s\u025b \"Me\". Ns\u025bm no mu y\u025b ' . ', ' ? ' anaa ' ! '.\n\n\u0190ho nhw\u025bso:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Kyer\u025bde\u025b a \u025bda ho adi s\u025bnkyer\u025bnne w\u0254 Twi mu. \n\n```\nS\u025b wop\u025b s\u025b wode dwumadi biara kyer\u025bw a, wode saa dwumadi yi b\u025bk\u0254 so a, \u025bno de\u025b \u025by\u025b s\u025b \u025bb\u025bkyinkyim \u025bda ho adi a \u025bda ho adi s\u025b \u025bb\u025btwam aky\u025bde\u025b no mu a \u025bb\u025by\u025b s\u025b \u025bde adane \u025bnky\u025bde\u025b no mu a \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b \u025bda ho adi s\u025b\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Wo w\u0254 akyinkyinii bi a \u025bw\u0254 nkyer\u025bwee mu.\n    Wob\u025bhwehw\u025b \u0254som k\u025bse a \u025by\u025b prime na san de ne mf\u025bnsere sum ka ho.\n\n    Nkyer\u025bkyer\u025bw:\n    S\u025b \u025by\u025b lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] a, nea \u025bfiri mu b\u025by\u025b 10\n    S\u025b \u025by\u025b lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] a, nea \u025bfiri mu b\u025by\u025b 25\n    S\u025b \u025by\u025b lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] a, nea \u025bfiri mu b\u025by\u025b 13\n    S\u025b \u025by\u025b lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] a, nea \u025bfiri mu b\u025by\u025b 11\n    S\u025b \u025by\u025b lst = [0,81,12,3,1,21] a, nea \u025bfiri mu b\u025by\u025b 3\n    S\u025b \u025by\u025b lst = [0,8,1,2,1,7] a, nea \u025bfiri mu b\u025by\u025b 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    S\u025b w\u0254de dikanari b\u0254 wo ho a, fa no s\u025b nokware s\u025b \u025bk\u0254 no so s\u025b nwoma nyinaa y\u025b ns\u025bmfua a \u025bw\u0254 ase\u025b k\u025bse\u025b anaas\u025b nyinaa y\u025b ns\u025bmfua a \u025bw\u0254 t\u025bkr\u025bma k\u025bse\u025b, s\u025b \u025bnte saa a fa no s\u025b atoro. \u0190s\u025b s\u025b dwumadie no bu s\u025b atoro s\u025b w\u0254de dikanari a \u025bda h\u0254 no y\u025b mpanins\u025bm.\nNhw\u025bso\u0254:\ncheck_dict_case \u025bs\u025b s\u025b \u025bma nokware.\ncheck_dict_case \u025bs\u025b s\u025b \u025bma atoro.\ncheck_dict_case \u025bs\u025b s\u025b \u025bma atoro.\ncheck_dict_case \u025bs\u025b s\u025b \u025bma atoro.\ncheck_dict_case \u025bs\u025b s\u025b \u025bma nokware.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Y\u025b implementi afunction a \u025bk\u0254fa \u0254d\u0254\u0254so a \u025bny\u025b \u0254haw biara na \u025bde san bra array a \u025bda kan n integer a \u025by\u025b prime numbers na \u025by\u025b nsen n.\nNhw\u025bso bi:\ncount_up_to => [2,3]\ncount_up_to => [2,3,5,7]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17,19]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"W\u0254\u0254so dwumadie a \u025bfa nwer\u025b abien ho na \u025bde w\u0254n nsa nk\u0254mfa ho.\n    Fa y\u025b adwuma no s\u025b \u025by\u025b betumi a \u025bda mu daara.\n    Nn\u025bkyer\u025b:\n    nhyehy\u025be b\u025bsane 16.\n    nhyehy\u025be b\u025bsane 72.\n    nhyehy\u025be b\u025bsane 0.\n    nhyehy\u025be b\u025bsane 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Here is the translation of the sentence into Twi:\n\nY\u025b de \u025bde\u025b s, kan no mu adikanfo\u025b titiriw a \u025bw\u0254 \u025bho mu ns\u025bmfua\u025b titiriw w\u0254 anantuo\u025b nkyekyemu mu.\n\n    S\u025b nhw\u025bso\u025b:\n    count_upper ma y\u025bnya 1\n    count_upper ma y\u025bnya 0\n    count_upper ma y\u025bnya 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    S\u025b w\u0254de y\u025b din krataa n a, \u025bs\u025b s\u025b wode n mp\u0254ns\u0254 y\u025b \u0254botan mp\u0254ns\u0254 n d\u0254m.\n    \u0190d\u0254m a edi kan no w\u0254 n mp\u0254ns\u0254.\n    Mp\u0254ns\u0254 a \u025bda ho w\u0254 d\u0254m a edi h\u0254 no y\u025b:\n        - mp\u0254ns\u0254 a \u025bdidi so, s\u025b n y\u025b \u0254p\u025b\u025b.\n        - mp\u0254ns\u0254 a \u025bdidi so, s\u025b n y\u025b \u0254k\u025bse\u025b.\n    Fa mp\u0254ns\u0254 a \u025bda d\u0254m biara mu ka ho w\u0254 krataa mu, baabi a \u025bda no kyer\u025b mp\u0254ns\u0254 a \u025bw\u0254 d\u0254m no.\n\n    Mfatoho:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Wob\u025bnya ns\u025bm a w\u0254akyehy\u025b w\u0254 ns\u025bm a \u025bkyer\u025b mu ne \u025bkyer\u025b mu a \u025bgye ns\u025bm. Wo dwumadi ne s\u025b wob\u025bkyeky\u025b ns\u025bm no mu na woasan de ns\u025bm no b\u025by\u025b ns\u025bnkyer\u025bnne a \u025bw\u0254 ns\u025bm no mu.\n\n\u0190ho nhw\u025bso:\nwords_string == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nwords_string == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Saa dwumadie yi gye mmarima baanu a \u025by\u025b ho\u0254den na \u025bde k\u025bse\u025b a \u025by\u025b p\u025bn namba a \u025bda [x, y] mu no san de ma. S\u025b \u025bnni namba biara a \u025bte saa a, \u025bnne\u025b dwumadie no b\u025bsan de -1.\n\n\u0190ho nhw\u025bso\u0254:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"W\u0254de mp\u025bn mp\u025bn abien bi a \u025by\u025b n ne m ama wo, na w\u2019adwuma ne s\u025b wobenya\n    mp\u025bn no nyinaa mu dodow a \u025bda n ne m no ho\n    dodow no nyinaa ho nsiesie ho. \n    B\u0254 ho nsusu sie ho na fa to a\u025by\u025b nso s\u025b \u0254de\u025b ho. S\u025b n kyea m a, fa -1.\n    Ad\u025bn:\n    rounded_avg => \"0b11\"\n    rounded_avg => -1\n    rounded_avg => \"0b1111\"\n    rounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Mmom list bi a \u025bda ho a \u025bw\u0254 positive integers x. San ma list foforo a \u025by\u025b sorted a \u025bda ho nyinaa \n    nni biara a \u025bw\u0254 even digit biara.\n\n    Nota: List a w\u0254ama no no \u025bs\u025b s\u025b \u025by\u025b sorted w\u0254 nketenkete mu.\n\n    Mm\u025bso:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    S\u025b w\u0254de array bi a \u025bw\u0254 mmer\u025b ne\u025b nnumer\u025b no mu rehw\u025b, s\u025be nnumer\u025b a \u025bw\u0254 ntam y\u025b 1 ne 9 mu, \n    hwehw\u025b nnumer\u025b no ho s\u025bnea \u025bda \u025bh\u0254 yiye, na fa ky\u025b array no ho y\u025b nky\u025bnky\u025bn, na de biara nky\u025bnky\u025bn no \n    y\u025b ne din a \u025bfiri \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    \u0190ho nhw\u025bso:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> hwehw\u025b arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> ky\u025b arr ho -> [8, 5, 4, 3, 2, 2, 1, 1]\n      san bra [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      S\u025b array no y\u025b dinn a, san bra array a \u025by\u025b dinn:\n      arr = []\n      san bra []\n    \n      S\u025b array no w\u0254 nnum\u025bn a \u025by\u025b\u025b b\u0254k\u0254\u0254 y\u025b no:\n      arr = [1, -1 , 55] \n            -> hwehw\u025b arr -> [-1, 1, 55]\n            -> ky\u025b arr ho -> [55, 1, -1]\n      san bra = ['One']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Implement f no a \u025bfa n s\u025b parameter,\n    na \u025bde nkyer\u025bwde\u025b a ne k\u025bse y\u025b n ba, s\u025bde\u025b \u025bho value w\u0254 index i so y\u025b i factorial s\u025b i y\u025b p\u025b\n    anaa sum of numbers fi 1 k\u0254si i w\u0254 ho.\n    i fi 1 fi ase.\n    i factorial y\u025b multiplication of the numbers fi 1 k\u0254si i.\n    \u0190ho nhw\u025bso:\n    f == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    S\u025b w\u0254ma wo adadekyee n a \u025by\u025b \u0254fata, san fa tuple a \u025bw\u0254 n\u0254ma a \u025by\u025b mmienu ne nkanee integer palindrome a \u025bda range mu, biara a \u025bka ho no.\n\nNhw\u025bso1:\n\n    Input: 3\n    Output:\n    Nkyer\u025bmu: \n    Integer palindrome no ne 1, 2, 3. \u0190mu baako y\u025b mmienu, na mmienu no y\u025b nkanee.\n\nNhw\u025bso2:\n\n    Input: 12\n    Output:\n    Nkyer\u025bmu:\n    Integer palindrome no ne 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u0190mu nan y\u025b mmienu, na nsia no y\u025b nkanee.\n\nNota:\n    1. 1 <= n <= 10^3\n    2. Tuple a w\u0254asan de no w\u0254 n\u0254ma a \u025by\u025b mmienu ne nkanee integer palindrome a \u025bda ho no.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Translate the following sentence into Twi:\n\n\"Write a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.\"\n\nHere is the translation in Twi:\n\n\"Kyer\u025b dwumadi bi a w\u0254fr\u025b no count_nums a \u025bfa nkyer\u025base\u025b a \u025bw\u0254 mu nn\u0254m\u025b a \u025by\u025b integers na \u025bde dodo\u0254 no k\u0254 w'akyi a \u025bw\u0254 ho a \u025bw\u0254 sum of digits > 0. S\u025b \u0254mmer\u025b bi y\u025b \u0254ha a \u025by\u025b negative, \u025bno de, \u025bdi \u025bdikan a \u025by\u025b signed digit b\u025by\u025b negative: s\u025b \u025by\u025b -123 a \u025bw\u0254 signed digits -1, 2, ne 3.\"\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Y\u025bw\u0254 'arr' a \u025by\u025b N a \u025by\u025b nkyer\u025bwde\u025b arr[1], arr[2], ..., arr[N]. Nn\u0254bae\u025b a \u025bw\u0254 nkyer\u025bwde\u025b no mu b\u025by\u025b s\u025b w\u0254ahy\u025b w\u0254n mu ara p\u025b. Wo adwuma no ne s\u025b w'anya so s\u025b \u025bb\u025by\u025b d\u025bn na w'anya nkyer\u025bwde\u025b a \u025bw\u0254 nhyehy\u025be\u025b mu w\u0254 non-decreasing order w\u0254\u025b performing \u025by\u025b\u025b operation yi w\u0254 \u025bnkyer\u025bwde\u025b a w\u0254de maa wo no so:\n    \n    Wob\u025btumi ay\u025b right shift operation no \u025bny\u025b\u025b dodow biara.\n\n    One right shift operation kyer\u025b s\u025b \u025by\u025b shift nkyer\u025bwde\u025b no nyinaa k\u0254 baako so w\u0254 right direction. Nkyer\u025bwde\u025b a \u025bda \u025bky\u025bmu no b\u025bk\u0254 nky\u025bmu a \u025bdi kan w\u0254 nkyer\u025bwde\u025b no mu, s\u025b\u025b a \u025bne 0th index.\n\n    S\u025b \u025by\u025b d\u025b \u025bb\u025by\u025b s\u025b \u025bb\u025btumi anya nkyer\u025bwde\u025b a w\u0254ahy\u025b no mu w\u0254 non-decreasing order w\u0254\u025b performing ns\u025bm a w\u0254ka ho \u025bb\u025by\u025b s\u025b\u025b de\u025b w\u0254ka no s\u025b \u025by\u025b nokwa a na \u025by\u025b True, \u025bnna s\u025b \u025bny\u025b de\u025b \u025by\u025b False.\n    S\u025b nkyer\u025bwde\u025b a \u025bde maa wo no y\u025b h\u0254 a \u025by\u025b kwa a na \u025by\u025b True.\n\n    Note: Nkyer\u025bwde\u025b a w\u0254de maa wo no w\u0254 unique elements no mu.\n\n    \u0190ho nhw\u025bso\u0254:\n\n    move_one_ball==>True\n    Nkyer\u025bkyer\u025b: S\u025b w\u0254y\u025b\u025b 2 right shift operations a, non-decreasing order b\u025btumi aba w\u0254 nkyer\u025bwde\u025b a w\u0254de maa wo no so.\n    \n    move_one_ball==>False\n    Nkyer\u025bkyer\u025b: \u0190ny\u025b d\u025b \u025bb\u025btumi anya non-decreasing order w\u0254 nkyer\u025bwde\u025b a w\u0254de maa wo no so de\u025b w\u0254y\u025b\u025b right shift operations biara.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"\u0190w\u0254 as\u025bm yi mu, wob\u025by\u025b dwumadi bi a wob\u025bfa mmienu a \u025bw\u0254 nkyer\u025bwee no mu,\nna wub\u025btumi ahu s\u025b \u025by\u025b yiye s\u025b wob\u025by\u025b nsakrae\u025b bi w\u0254 af\u00e3 a \u025bw\u0254 mu\nde ama lst1 ay\u025b af\u00e3 a \u025bw\u0254 \u025bho a \u025by\u025b ahemmer\u025bw nko ara.\n\u0190nni h\u0254 kwan biara w\u0254 nsakrae\u025b no mu af\u00e3 a \u025bw\u0254 mu w\u0254 lst1 ne lst2 ntam.\nS\u025b \u025by\u025b yiye s\u025b wob\u025by\u025b nsakrae\u025b no de ama lst1 af\u00e3 nyinaa ay\u025b ahemmer\u025bw,\nafoa y\u025b \"YES\".\nS\u025b \u025bny\u025b yiye a, afoa y\u025b \"NO\".\nS\u025b nhw\u025bso\u0254:\nexchange => \"YES\"\nexchange => \"NO\"\n\u0190y\u025b k\u025bsey\u025b s\u025b \u025bw\u0254 h\u0254 s\u025b af\u00e3 a \u025bw\u0254 mu w\u0254 nkyer\u025bwee no mu b\u025by\u025b af\u00e3 a \u025bnni h\u0254 biara.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Maa \u0254kas\u025bm yi k\u0254 Twi mu:\n\n    S\u025b w\u0254ma \u025bt\u025bkr\u025bma bi a \u025bkyer\u025b nkyer\u025base a \u025bhy\u025b ns\u025bm a \u025bw\u0254 ase\u025b h\u0254, san br\u025b\u025b\u025b krataa a \u025bw\u0254 ns\u025bnkyer\u025b biako biako mu na \u025bw\u0254 k\u0254nt\u025b\u025b ho.\n    S\u025b \u025by\u025b s\u025b \u025bt\u025bkr\u025bma bebree w\u0254 saa ns\u025bnkyer\u025b no mu a, san br\u025b\u025b\u025b w\u0254n nyinaa.\n    \n    Nkyer\u025base:\n    histogram == {'a': 1, 'b': 1, 'c': 1}\n    histogram == {'a': 2, 'b': 2}\n    histogram == {'a': 2, 'b': 2}\n    histogram == {'b': 4}\n    histogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Adwuma\n    W\u0254de nkyer\u025bkyer\u025b mmienu s ne c ama wo. Wob\u025btumi ayi nkyer\u025bkyer\u025b nyinaa a \u025bw\u0254 s mu a \u025btete s\u025b biara a \u025bw\u0254 c mu.\n    Afei hw\u025b s\u025b \u025bsian yi akyi nkyer\u025bkyer\u025b yi b\u025by\u025b palindrome anaa.\n    Nkyer\u025bkyer\u025b bi y\u025b palindrome s\u025b \u025bkenkan k\u0254 anim ne k\u0254 akyi no y\u025b p\u025b.\n    Wob\u025bsan de tuple a \u025bw\u0254 nkyer\u025bkyer\u025b yi ne nokware\/anokwa nkyer\u025bkyer\u025b w\u0254 ho b\u025bsan.\n    Nkyer\u025bkyer\u025b\n    S\u025b s = \"abcde\", c = \"ae\", na \u025bsian yi akyi no \u025bb\u025by\u025b\n    S\u025b s = \"abcdef\", c = \"b\" na \u025bsian yi akyi no \u025bb\u025by\u025b\n    S\u025b s = \"abcdedcba\", c = \"ab\", na \u025bsian yi akyi no \u025bb\u025by\u025b\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"\u0190ma no s\u025b w\u0254de nhoma ahorow de ay\u025b adwuma, a \u025bmu biara y\u025b mfuo nkutoo, san fa nhoma biara mu. \n    Nhoma biara a \u025bda mu i s\u025b \u025by\u025b \"mfuo a \u025bnni h\u0254 dodow w\u0254 nhoma no mu i.\" a \u025bho nhoma no i nyinaa y\u025b mfuo dodow \n    a \u025bw\u0254 nhoma no mu i a w\u0254de de y\u025b adwuma no.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    S\u025b w\u0254de nkitahodi a \u025bw\u0254 mu y\u025b nums no ma wo a, hwehw\u025b sub-array biara a \u025bny\u025b h\u0254 a \u025bw\u0254 nums no mu a \u025bw\u0254 sum ketewa paa.\n\nAd\u025bnkrabea\nminSubArraySum == 1\nminSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Wo w\u0254 atade\u025b a \u025by\u025b rectangle a w\u0254de \u025bho w\u0254 \u025bho. \u0190k\u0254 biara gyina h\u0254 ma ofie biako,\n    na \u025bk\u0254 biara a \u025bw\u0254 \u025bk\u0254 no gyina h\u0254 ma \u025bk\u0254 baako.\n    Ofie biara w\u0254 ab\u0254ntene a \u025btumi de nsuo afi mu,\n    na ab\u0254ntene nyinaa w\u0254 tumi k\u0254.\n    W'adwuma ne s\u025b, fa ab\u0254ntene no gye nsuo no fi ofie no mu.\n    Yi so\u025b de\u025b \u025bk\u0254 ap\u0254w a \u025bs\u025b s\u025b wode ab\u0254ntene no k\u0254.\n\n    Nkyerekyer\u025b1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Nkyerekyer\u025b2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Nkyerekyer\u025b3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Nkwankyer\u025b:\n        * Ofie nyinaa w\u0254 \u025bkwan tenten b\u025by\u025b p\u025b\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Here's the translation of the given sentence into Twi:\n\n```\nW\u0254 Kata yi mu, \u025bs\u025b s\u025b wosiesie array a \u025bw\u0254 non-negative integers no s\u025bnea w\u0254n binary representation mu nnipa no dodow w\u0254 ascending order mu.\nS\u025b nnipa dodow no y\u025b p\u025b a, a na \u025bs\u025b s\u025b wosiesie w\u0254n w\u0254 decimal value so.\n\n\u0190s\u025b s\u025b w\u0254y\u025b saa ara:\n```\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Woanya nhyehy\u025b s\u025b wode mfa \u025bkwan biara a \u025bw\u0254 h\u0254 ny\u025b adwuma no, na \u025by\u025b adwuma a \u025bde akyiri, na \u025bb\u025bma w\u0254n a w\u0254w\u0254 h\u0254 no ahy\u025b w\u0254n ho so. \n    S\u025b wop\u025b s\u025b woma wo ho so a, \u025bb\u025by\u025b s\u025b wode nwoma a \u025bw\u0254 h\u0254 nyinaa ab\u0254 mu. \n    S\u025b nwoma no ho y\u025b kwa a, \u025bb\u025by\u025b s\u025b wode nwoma no ho ahy\u025b mu. \n    Kae s\u025b: wonya ho kwan s\u025b \u025bk\u0254 so na \u025bba s\u025b nwoma no y\u025b b\u0254ne na \u025by\u025b kwa ara kwa. \n    Nne\u025bma: \n    select_words ==> [\"little\"]\n    select_words ==> [\"Mary\", \"lamb\"]\n    select_words ==> []\n    select_words ==> [\"world\"]\n    select_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Wo de\u025b nsa b\u0254 wo twer\u025b. Wo adwuma ne s\u025b fa \u025bnkyer\u025bnne a \u025bw\u0254 ntam a \u025bda nkyer\u025bnne mmienu a \u025bw\u0254 nifa so a \u025by\u025b nt\u025bm no ho.\n\nNs\u025bm a \u025bda mfiase ne awiei no nni h\u0254. San k\u0254 \u0254nkyer\u025bnne a \u025bda ho s\u025b wo nnyaa \u0254nkyer\u025bnne a \u025bda saa asetena mu no.\n\nWob\u025btumi agye adi s\u025b \u025btwer\u025b a w\u0254de ama wo no w\u0254 bor\u0254fo kasa nkutoo mu.\n\nNhw\u025bso\u0254:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    S\u025b w\u0254de arr a \u025by\u025b integers \u025bne k a \u025by\u025b positive integer de br\u025b wo a, san de k \u025bne k\u025bse\u025b a \u025bda mu no ky\u025b arr ho ma.\n\n    Ad\u025bsua1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Ad\u025bsua2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Ad\u025bsua3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Nhwehw\u025bmu:\n        1. Arr no tenten b\u025by\u025b [1, 1000].\n        2. Arr no nni mu b\u025by\u025b [-1000, 1000].\n        3. 0 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"S\u025b w\u0254de nhyehy\u025be a \u025bny\u025b p\u0254tee a \u025bw\u0254 integers b\u025bma wo a, san bra sum no nyinaa a \u025by\u025b odd elements a w\u0254w\u0254 even positions mu.\n\n    Mfatoho\n    solution ==> 12\n    solution ==> 9\n    solution ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    S\u025b w\u0254de array a \u025bw\u0254 integer nn\u0254ma arr na \u025bnni hwee k\u025bse sen \u0254ha na integer k ba ho a, san de k element a edi kan no mu nn\u0254ma a w\u0254n ho nni sen nnw\u0254twe nko ara k\u0254t\u0254 sum a, san de k element a edi kan no mu nn\u0254ma a w\u0254n ho nni sen nn\u0254twe nko ara b\u0254 sum no.\n\n    Nkyer\u025bmu:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Nhyehy\u025be:\n        1. 1 <= arr nn\u0254ma dodow <= 100\n        2. 1 <= k <= arr nn\u0254ma dodow\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    S\u025b w\u0254de adadekyee n a \u025by\u025b \u0254ho\u0254so\u0254 b\u025bma wo a, san de nkyer\u025bwee a w\u0254akokyin w\u0254 Collatz ns\u025bmfua no mu b\u025bma wo.\n\n    Collatz ns\u025bmfua no y\u025b ns\u025bmfua bi a \u025bw\u0254 mm\u025b\u025bk\u00e3 mu a \u025bka s\u025b wode adadekyee biara n b\u025bhy\u025b ho. \u0190no na, ns\u025bm biara a \u025bb\u025bba no fi ns\u025bm a \u025bdi kan no ho s\u025b: s\u025b ns\u025bm a \u025bdi kan no y\u025b p\u025b, ns\u025bm a \u025bb\u025bba no y\u025b ne fa mu baako. S\u025b ns\u025bm a \u025bdi kan no y\u025b \u0254ho\u0254so\u0254 a, ns\u025bm a \u025bb\u025bba no y\u025b ne mpr\u025bnsa ne baako ka ho. Ns\u025bmfua no hy\u025b s\u025b \u025by\u025b adadekyee biara n a, ns\u025bmfua no b\u025bk\u0254 so ara k\u0254si s\u025b \u025bb\u025bk\u0254 1 mu.\n\n    Kae:\n        1. Collatz y\u025b [1].\n        2. nkyer\u025bwee a w\u0254de b\u025bma no y\u025b nea \u025bk\u0254 so w\u0254 sorok\u0254 mu.\n\n    Nhw\u025bso\u0254:\n    get_odd_collatz ma y\u025b [1, 5] # Collatz ns\u025bmfua no ma 5 y\u025b [5, 16, 8, 4, 2, 1], nti \u0254ho\u0254so\u0254 no nko ara y\u025b 1 ne 5.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Wo w\u0254 s\u025b wode dwumadie kyer\u025bw a \u025bb\u025bhw\u025b s\u025b da a w\u0254de maa no y\u025b nokware a \u025bnna \u025bde nokware b\u025bsan bio s\u025b da no y\u025b nokware, na s\u025b \u025bny\u025b nokware a \u025bde nkontompo b\u025bsan bio. Da no y\u025b nokware s\u025b mmara yi nyinaa y\u025b nokware:\n\n1. Da a w\u0254de maa no y\u025b nyam.\n2. Da no nn\u0254bae\u025b nni h\u0254 a \u025by\u025b ketewaa sen 1 anaa \u025by\u025b k\u025bse sen 31 nna w\u0254 bosome 1, 3, 5, 7, 8, 10, 12. Na da no nn\u0254bae\u025b nni h\u0254 a \u025by\u025b ketewaa sen 1 anaa \u025by\u025b k\u025bse sen 30 nna w\u0254 bosome 4, 6, 9, 11. Na da no nn\u0254bae\u025b nni h\u0254 a \u025by\u025b ketewaa sen 1 anaa \u025by\u025b k\u025bse sen 29 nna w\u0254 bosome 2.\n3. Bosome no ny\u025b ketewaa sen 1 anaa \u025by\u025b k\u025bse sen 12.\n4. Da no w\u0254 s\u025b \u025bda ho te s\u025b: mm-dd-yyyy\n\nS\u025b nhw\u025bso\u0254 bi:\nvalid_date => True\n\nvalid_date => False\n\nvalid_date => False\n\nvalid_date => True\n\nvalid_date => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"W\u0254ma wo mp\u025bn abien,\n    a mp\u025bn biara y\u025b ahorow abien a \u025by\u025b integer. \u0190kyer\u025b s\u025b, mp\u025bn no y\u025b =.\n    Mp\u025bn a w\u0254de ama no mu y\u025b mm\u0254toh\u0254 a \u025bkyer\u025b s\u025b mp\u025bn\n    ka mfitiase ne awiei ho nyinaa.\n    Mp\u025bn biara a w\u0254de ama no, \u025by\u025b adwene s\u025b ne mfitiase y\u025b s\u025bnea \u025bs\u025b ne ne awiei.\n    W'adwuma ne s\u025b wubetumi ahu s\u025b mp\u025bn abien yi ne ntam b\u0254 no tenten y\u025b prime n\u0254ma.\n    \u0190ho nhw\u025bso, mp\u025bn ne ne ntam b\u0254 no y\u025b\n    na ne tenten y\u025b 1, a \u025bny\u025b prime n\u0254ma.\n    S\u025b mp\u025bn no ne ntam b\u0254 no tenten y\u025b prime n\u0254ma a, y\u025b \"YES\",\n    na s\u025b \u025bnte saa a, y\u025b \"NO\".\n    S\u025b mp\u025bn abien no ny\u025b ntam b\u0254 a, y\u025b \"NO\".\n\n    [\u025bho nhw\u025bso] samples:\n    mp\u025bn ntam b\u0254,) ==> \"NO\"\n    mp\u025bn ntam b\u0254,) ==> \"NO\"\n    mp\u025bn ntam b\u0254,) ==> \"YES\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    W\u0254de array bi a ne din de arr a \u025bw\u0254 nkrataa dodow bebree ama wo na \u025bs\u025b s\u025b wosan de:\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, a \u025bda ho adi s\u025b 1, -1 anaa 0.\n    Nkyer\u025b: s\u025b array no y\u025b h\u0254 a, san de None.\n\n    Nkyer\u025base:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns and a positive integer k,\n    \u025bb\u025bn \u025bfiri a \u025bw\u0254 ahoma biara. Baako a \u025bw\u0254 \u025bd\u0254m k\u025bse bi, \u025bw\u0254 s\u025b \u025by\u025b nea \u025bw\u0254 \u025bd\u0254m k\u025bse.\n    w\u0254so\u025b \u025bgyina so a \u025by\u025b \u025bb\u025bn biara \u025bnn\u025b. \u025by\u025b s\u025b \u025by\u025b \u025bnna \u025by\u025b \u025bd\u0254n biara \u025bnn\u025b \u025by\u025b \u025bde\u025b \u025bw\u0254 \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bde\u025b \u025bw\u0254 \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bde\u025b \u025bw\u0254 \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bde\u025b \u025bw\u0254 \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025by\u025b \u025bd\u0254n \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025bnn\u025b \u025b\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Obiara nim Fibonacci seqw\u025bn no, na \u025by\u025b\u025b adwuma w\u0254 ho yiye w\u0254 nipa a w\u0254y\u025b nkyer\u025base ho ade mu afeha kakra a atwam no mu. Nanso, nea nnipa nnim ne Tribonacci seqw\u025bn no.\nTribonacci seqw\u025bn no y\u025b\u025b s\u025b\u025b:\ntri = 3\ntri = 1 + n \/ 2, s\u025b n y\u025b p\u025b\u025b.\ntri = tri + tri + tri, s\u025b n y\u025b \u0254k\u0254nt\u0254n.\nNea \u025bkyer\u025b no:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n         = 2 + 3 + 3 = 8 \nW\u0254de \u0254d\u0254\u0254so a \u0254nnim ho hwee a \u025by\u025b n b\u025bma wo, na wo ne s\u025b\u025b soa w\u0254n a w\u0254di kan n + 1 amanne\u025b no w\u0254 Tribonacci seqw\u025bn no mu.\nNkyer\u025base:\ntri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Maa \u0254hafo\u0254 n, san bra no \u0254y\u025b ns\u025bm anaa \u0254y\u025b ns\u025bm mu no \u0254y\u025b aky\u025bde\u025b b\u0254ne no.\nSan bra 0 s\u025b ns\u025bm no nyinaa y\u025b ns\u025bm pa.\n\u0190ho nhw\u025bso\u0254:\ndigits == 1\ndigits == 0\ndigits == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Wo de w\u0254n krataa a \u025bw\u0254 mu ns\u025bm a \u025by\u025b mfonini.\n\nW\u0254de w'adwene ho b\u025bfre wo s\u025b wosan b\u025bka ns\u025bm a \u025bw\u0254 krataa no mu bio w\u0254 Twi kasa mu:\n\nWo de krataa a \u025bw\u0254 mu ns\u025bm a \u025by\u025b mfonini.\n\u0190s\u025b s\u025b w'asan b\u025bka ns\u025bm a \u025bw\u0254 krataa no mu,\nna \u025bs\u025b s\u025b wo ka ns\u025bm a \u025bw\u0254 krataa no ho w\u0254 Twi kasa mu.\n\nNs\u025bm nhyehy\u025be:\nS\u025b krataa no y\u025b [1,2,3] a, nea \u025bb\u025by\u025b ne 14.\nS\u025b krataa no y\u025b [1,4,9] a, nea \u025bb\u025by\u025b ne 98.\nS\u025b krataa no y\u025b [1,3,5,7] a, nea \u025bb\u025by\u025b ne 84.\nS\u025b krataa no y\u025b [1.4,4.2,0] a, nea \u025bb\u025by\u025b ne 29.\nS\u025b krataa no y\u025b [-2.4,1,1] a, nea \u025bb\u025by\u025b ne 6.\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Here is the translation of the provided sentence into Twi:\n\nB\u0254 dwumadi bi a \u025bb\u025bsan de ns\u025bmfua titiriw a \u025bny\u025b k\u025bse anaa \u025bny\u025b s\u025bnea \u025bda ho soronko w\u0254 ho. S\u025b ns\u025bmfua biara nni ho a \u025bte saa a, san de -1. Ns\u025bmfua no b\u025by\u025b\u025b d\u025b \u025bny\u025b ns\u025bmfua a \u025bda ho soronko.\n\nNne\u025bma ho nhw\u025bso:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Y\u025bsr\u025b wo s\u025b b\u0254 function bi a \u025bb\u025bgye integers, floats, anaa strings a \u025bkyer\u025b real numbers, na \u025bde k\u025bse no a \u025bda mu variable type no mu b\u025bba. Sane no ma s\u025b values no y\u025b p\u025b a, fa None. \nKae s\u025b: S\u025b real number no w\u0254 string mu a, floating point no betumi ay\u025b . anaa ,\n\ncompare_one \u00e2 -> 2.5\ncompare_one \u00e2 -> \"2,3\"\ncompare_one \u00e2 -> \"6\"\ncompare_one \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"S\u0254 hw\u025b s\u025b \u025by\u025b a \u025bho b\u025by\u025b s\u025b \u025bde n dodo no s\u025b \u025bb\u025btumi ahy\u025b aduanan positive dodo no mu\n    Mfatoho\n    is_equal_to_sum_even == Daabi\n    is_equal_to_sum_even == Daabi\n    is_equal_to_sum_even == Aane\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Brazil nyansakyer\u025b no w\u0254 h\u0254 s\u025b:\n    brazil nyansakyer\u025b = n! *! *! * ... * 1!\n    s\u025b n > 0\n\n    S\u025b nhw\u025bso:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    \u0190de\u025b \u025by\u025b s\u025b\u025b, kyer\u025bw as\u025bm yi k\u0254 Twi mu:\n\nS\u025b w\u0254ma wo kyer\u025bw ns\u025bntitiriw bi a, susuw s\u025bnea \u025bb\u025by\u025b a wob\u025bsesa nsanmu nyinaa w\u0254 mu de underscored\u025b\u025b besi mu,\n    na s\u025b kyer\u025bw ns\u025bntitiriw no w\u0254 nsanmu a \u025bboro mmi\u025bnsa a \u025bda ho, \n    \u025bno de\u025b, \u025by\u025b a wob\u025bsesa nsanmu nyinaa de - besi mu.\n    \n    fix_spaces == \"Example\"\n    fix_spaces == \"Example_1\"\n    fix_spaces == \"_Example_2\"\n    fix_spaces == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Here is the translation of the given sentence into Twi:\n\n```plaintext\nB\u0254 dwumadi bi a \u025bb\u025bfa string a \u025bda file din no ho na \u025bde 'Yes' b\u025bsan,\n    s\u025b file din no y\u025b papa a, na \u025bde 'No' b\u025bsan, s\u025b \u025bny\u025b papa.\n    File din no y\u025b papa s\u025b na s\u025bnea \u025by\u025b\u025b no yiara:\n    - Enni s\u025b mmer\u025bns\u025bn mmi\u025bnsa b\u025bt\u0254 file din no mu.\n    - File din no w\u0254 p\u025b\u025b dot '.' baako.\n    - Substring a \u025bda dot no anim no nni h\u0254 kwa, na \u025bfi krataa bi a \u025bw\u0254 latin alphabet mu ase.\n    - Substring a \u025bda dot no akyi no b\u025by\u025b baako w\u0254 saa yi mu: ['txt', 'exe', 'dll']\n    Nkyer\u025bmu:\n    file_name_check # => 'Yes'\n    file_name_check # => 'No'\n```\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\u0190y\u025b as\u025bm yi k\u0254 Twi mu.\n\n\"\u0190y\u025b\u025b\u025b amansan yi b\u025b gye abodin adidibea. Ma \u0254m\u025b k\u0254 abodin no mu, \u0254y\u025b\u025b\u025b\u025b amansan yi b\u025b twa abodin no mpr\u025b w\u0254 y\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025b\u025bn\u025b\u025b\u025b\u025b\u025b\u025b\u025b\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    W\u0254ma wo \u025bnkanee a \u025bkyer\u025b as\u025bm bi,\n    as\u025bm no w\u0254 ns\u025bm kakra a w\u0254ky\u025b w\u0254 \u025bky\u025bmu a \u025by\u025b s\u0254.\n    Na \u025bs\u025b s\u025b wosan de \u025bnkanee a \u025bw\u0254 ns\u025bm no mu,\n    a \u025bns\u025bm no tenten y\u025b prime numbers,\n    \u025bk\u0254so no ns\u025bm w\u0254 \u025bnkanee foforo no mu b\u025by\u025b saa ara s\u025b \u0254no de\u025b a \u025bda h\u0254 kan.\n\n    Example1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Ns\u025bm bi a w\u0254de ka ho:\n        * 1 <= \u025bnkanee tenten <= 100\n        * \u025bnkanee no w\u0254 nkyer\u025bwee nko ara.\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Sure, here is the translation of the sentence into Twi:\n\nWo adwuma ne s\u025b wode dwumadie bi b\u025by\u025b a \u025bb\u025bma nk\u0254m\u0254m\u0254 no\n    x * n. Dwumadie no b\u025bma Nokware s\u025b x * n y\u025b adadekuw na \u025bnte saa a \u025bb\u025bma Atoro.\n    X ne n nyinaa, y\u025b mfonini a \u025bkyer\u025b adadekuw, na w\u0254y\u025b\u025b bi s\u025b\u025b,\n    <numerator>\/<denominator> no \u025by\u025b\u025b adadekuw a \u025bb\u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw a \u025by\u025b adadekuw.\n\n    Wobetumi agye di s\u025b x, ne n y\u025b adadekuw a \u025by\u025b adadekuw, na wonni hwee a \u025by\u025b adadekuw.\n\n    simplify = Nokware\n    simplify = Atoro\n    simplify = Atoro\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Here is the translation of the sentence into Twi:\n\n```\nKyer\u025bw afum\u0254de\u025b bi a \u025bb\u025btumi asiesie \u0254k\u025bse\u025b a w\u0254de maa wo no \u025bw\u0254 \u0254kwan so s\u025b \u025bb\u025by\u025b s\u025b \u025bka w\u0254n ns\u025bm ho.\n```\n\nHowever, translating technical terms such as \"function\" and \"list of integers\" might not be straightforward as Twi typically does not have direct equivalents for these terms. These terms are often used in English even in a Twi-speaking context. \n\nWould you like to proceed with more detailed or technical parts of your request in English, or would you prefer more general assistance in Twi?\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"\u0190kyer\u025b nwoma a w\u0254de b\u025by\u025b adwuma a \u0254gye nhwehw\u025bmu a \u025bw\u0254 mu a \u025by\u025b \u0254kwan biara a w\u0254de k\u0254 so. Na \u025bde w\u0254n ho adwene a \u025bw\u0254 mu ba s\u025b nn\u0254bae\u025b a \u025bw\u0254 nhwehw\u025bmu no biara a \u025by\u025b k\u025bse\u025b sen 10 na \u0254no nso ne \u0254dikanfo\u0254 ne \u0254twafo\u0254 nkyer\u025bmu biara y\u025b k\u025bse\u025b.\n\n\u0190ho nhw\u025bso\u0254:\nspecialFilter => 1 \nspecialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    W\u0254ma wo n dodow a \u025by\u025b mpositive integer. W\u0254s\u025b wohy\u025b integer array a a ne tenten y\u025b n.\n        Ma i, a[i] no ne ani\u025b: a[i] = i * i - i + 1.\n        San ma no mu mmi\u025bnsa a \u025bw\u0254 a no mu a i < j < k,\n    na a[i] + a[j] + a[k] y\u025b 3 nson.\n\n    Nhwehw\u025bmu:\n        Input: n = 5\n        Output: 1\n        Nkyer\u025bkyer\u025bmu: \n        a = [1, 3, 7, 13, 21]\n        Mmi\u025bnsa koro p\u025b a \u025bfata ne.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Kyer\u025b func\u025b bi a \u025bb\u025bgye strings a \u025bw\u0254 list mu s\u025b parameter,\n    yi strings a w\u0254n tenten y\u025b odd fi mu,\n    na san de list a \u025bw\u0254 mu s\u025bde\u025b \u025btwam no san ma,\n    List no \u025by\u025b strings list na \u025bny\u025b numbers array da,\n    na \u025bb\u025btumi ahy\u025b duplicates mu.\n    List no \u025by\u025b ascending s\u025bde\u025b \u025btenten tenten w\u0254 mu, na wo\n    b\u025bsan de list no s\u025bde\u025b w\u0254y\u025b no san ma.\n    S\u025b ns\u025bm mmienu w\u0254 tenten tenten koro a, kyer\u025b list no s\u025bde\u025b \u025by\u025b alphabetically.\n    Func\u025b no b\u025bma strings list bi a w\u0254y\u025b sort s\u025bde\u025b \u025bb\u025by\u025b.\n    Wob\u025btumi agye s\u025b ns\u025bm nyinaa b\u025by\u025b tenten tenten koro.\n    \u0190ho nhw\u025bso:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Kyer\u025bwtoh\u0254 bi a \u025by\u025b mmer\u025b a \u025bb\u025bsan de x ani\u025b h\u0254 s\u025b n y\u025b \n    n\u0254ma a \u025by\u025b prime na \u025bb\u025bsan de y ani\u025b h\u0254 s\u025b \u025bny\u025b saa.\n\n    Ns\u025bmfua:\n    s\u025b x_or_y == 34\n    s\u025b x_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"M\u025bgye di s\u025b y\u025bn nyinaa kae saa ahos\u025bp\u025b s\u025bnea \u025bte\u025b no bere a y\u025bde n\u2019akyi kyere\n    ns\u025bm a y\u025batw\u025bn aky\u025b no, \u025bba da h\u0254 yiye. Ahos\u025bp\u025b ne adwene a wonya saa bere no y\u025b\n    ade\u025b a \u025bs\u025b s\u025b wode si kan na wototo ho.\n    Wo \u0254dwa ne s\u025b wubehu s\u025b obi te\u025b\u025b a \u025bda ho adi s\u025bnea \u025bda no p\u025b.\n    W\u0254de array mmienu a \u025bw\u0254 scores ne guesses w\u0254 ne tenten a \u025by\u025b p\u025b a, \u025bda ho adi s\u025b match biara w\u0254 baabiara.\n    Fa array bi a \u025bw\u0254 tenten p\u025b de kyer\u025b s\u025bnea \u025bda ho adi s\u025b \u025by\u025b p\u025b te s\u025b s\u025bnea \u025bte no. S\u025b wotetee a \u025by\u025b p\u025b a,\n    value no y\u025b 0, na s\u025b \u025bny\u025b saa a, value no y\u025b absolute difference w\u0254 guess ne score no ntam.\n\n    \n    nhw\u025bso\u0254:\n\n    compare -> [0,0,0,0,3,3]\n    compare -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Wob\u025bnya din s\u025b\u0301 \u025by\u025b k\u0254las ne krataa a \u025bkyer\u025b krataa biara a wob\u025bde hy\u025b k\u0254las no mu. Krataa yi de b\u025bhy\u025b k\u0254las no ho adwuma. Din a \u025bw\u0254 k\u0254las no mu tumi y\u025b d\u025b\u025b\u025b yi: Ma CAP y\u025b n\u0254ma a \u025bw\u0254 k\u0254las no din mu, na ma SM y\u025b n\u0254ma a \u025bw\u0254 krataa no din mu, \u025btumi a \u025bw\u0254 din no y\u025b CAP - SM. Wo b\u025bhwehw\u025b k\u0254las a \u025bw\u0254 tumi k\u025bse ne s\u025b\u025b: ClassName.StrongestExtensionName. S\u025b \u025bw\u0254 krataa bebree a \u025bw\u0254 tumi k\u025bse no, wo b\u025byi nea edi kan w\u0254 krataa no mu. S\u025b woma \"Slices\" s\u025b k\u0254las ne krataa a \u025bw\u0254: ['SErviNGSliCes', 'Cheese', 'StuFfed'] a, \u025bnde wob\u025bka s\u025b 'Slices.SErviNGSliCes' efis\u025b 'SErviNGSliCes' y\u025b krataa a \u025bw\u0254 tumi k\u025bse. S\u025b:\n    Strongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Wop\u025b ma wo nsa nsanso m\u025by\u025b Twi kyer\u025bwde no yiye. W\u0254 Twi, \u025bb\u025by\u025b s\u025b\u025b:\n\nW\u0254de ns\u025bm mmienu maa wo. Wo ne s\u025b wunp\u025b s\u025b \u025bs\u025b s\u025b as\u025bm a \u025bt\u0254 so abien no, anaa ne biribiara a \u025by\u025b ne s\u025bso b\u025by\u025b as\u025bmfua w\u0254 as\u025bm a \u025bt\u0254 so kan no mu:\n\n    cycpattern_check => Dabida\n    cycpattern_check => Nokware\n    cycpattern_check => Dabida\n    cycpattern_check => Nokware\n    cycpattern_check => Dabida\n    cycpattern_check => Nokware\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Here is the sentence translated into Twi:\n\nFa n\u0254ma a \u025by\u025b n\u0254ma baako p\u025b. San de n'awiei to\u0254 mu \u025by\u025b tuple a \u025bw\u0254 n\u0254ma a \u025by\u025b even ne odd n\u0254ma no.\n\n     Mfatoho:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Here is the translation of the given sentence into Twi:\n\n\"Fa n\u0254ma a \u025by\u025b n\u0254ma pa biara, nya ne roman n\u0254ma a \u025bfa ho s\u025b \u025by\u025b ns\u025bm,\n    na san de ma w\u0254 ns\u025bm asefo.\n    Ahy\u025bde: 1 <= n\u0254ma <= 1000\n\n    Mfatoho:\"\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Translate the following sentence into Twi.\n\nKyer\u025bw afidie a \u025bb\u025btumi agye nwoma a edidi so. \nNwoma no w\u0254 ns\u025bm a \u025bs\u025be. San de ns\u025bm a \u025bw\u0254 nky\u025bmu a \u025bd\u0254\u0254so ne ho ns\u025bm. \nS\u025b ns\u025bm dodow no ara w\u0254 nky\u025bmu a \u025bd\u0254\u0254so a, fa nea \u025bdi kan w\u0254 nkrataa mu.\n\nfind_max == \"ns\u025bm\"\nfind_max == \"edina\"\nfind_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Wo y\u025b \u0254k\u0254de a \u0254w\u0254 \u0254k\u0254m, na woadi aduan biara. Nanso, afei wo hia s\u025b wo b\u025bdi aduan pii aby\u025b \u025bda no mu aduan mu. \u0190s\u025b s\u025b wo san de array yi [ aduan a woadi no nyinaa w\u0254 \u025bda no mu,\n                                    aduan a \u025bka ho w\u0254 \u025bda no mu ]\n    s\u025b \u025bda mu aduan no nn\u0254 wo ho a, \u025bb\u025bma wo di \u025bda mu aduan no nyinaa, nanso \u025bno de wo b\u025bda so aw\u0254 \u0254k\u0254m.\n\n    \u0190ho nhw\u025bso\u0254:\n    * di -> [11, 4]\n    * di -> [12, 1]\n    * di -> [11, 0]\n    * di -> [7, 0]\n    \n    Ns\u025bmfua:\n    @number : number\n        aduan a woadi.\n    @need : number\n        aduan a wo hia s\u025b wudi.\n    @remaining : number\n        aduan a \u025bda h\u0254 no\n    \n    \u0186haw:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Di agor\u0254! :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Mfa mmienu yi to Twi mu:\n\nS\u025b w\u0254de mmienu a w\u0254de hy\u025b dwumadie no, ne dwumadiefo\u0254 no. Mmienu a edi kan no w\u0254 adwuma bi a w\u0254de y\u025b algebra mu, na \n    mmienu a \u025bt\u0254 so mmienu no y\u025b integers a \u025bw\u0254 list mu. Fa mmienu mmienu a w\u0254de hy\u025b dwumadie no y\u025b algebra mu adwuma \n    na san fa dwumadie no y\u025b adwuma na fa so tua dwumadie no.\n\n    Adwuma a w\u0254de y\u025b algebra mu:\n    Ka ho \n    Tutu ho \n    Bo so \n    Fa ho \n    Fa ho \n\n    Mfatoho:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Kae:\n        Dwumadiefo\u0254 no tenten y\u025b hy\u025b dwumadie no tenten minus baako.\n        Operand y\u025b list a w\u0254akyer\u025bw integers a \u025bny\u025b negative.\n        Dwumadiefo\u0254 no w\u0254 \u025bdi\u025b at\u0254 so baako, na hy\u025b dwumadie no w\u0254 \u025bdi\u025b abien so.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"W\u0254de \u025bk\u0254d\u025bn s maa wo.\n    S\u025b s[i] y\u025b nkrataa a, sesa n'ade\u025b ne ho wiase, fi ase k\u0254 sor\u0254 anaas\u025b sor\u0254 k\u0254 ase,\n    s\u025b \u025bny\u025b saa a, ma no s\u025bnea \u025bte no.\n    S\u025b \u025bk\u0254d\u025bn no nni nkrataa biara a, sesa \u025bk\u0254d\u025bn no.\n    \u0190y\u025b adwuma no mu, \u025bs\u025b s\u025b \u025bde as\u025bm a \u025bfiri mu no ma.\n    Nkyer\u025bmu\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    S\u025b w\u0254ma wo string 'text', ma no md5 hash a \u025bb\u025by\u025b ne ho dwoodwoo. \n    S\u025b 'text' no y\u025b pr\u025bko p\u025b a, ma No.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    S\u025b w\u0254de nnommum abien a \u025by\u025b a ne b, ma nkanea a \u025bw\u0254 a ne b ntam, \u025bka ho s\u025b w\u0254y\u025b mmienu, w\u0254 y\u025bnso\u025bgyina.\n\n\u0186kwan foforo:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]