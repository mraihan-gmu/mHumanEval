[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Here is the translation of the given sentence into Sango:\n\n\"Lengbani s\u00f4 kwana ti mbari na mo, na s\u00f4 ayeke w\u00e2nda t\u00ee nyen\u00ee \u00fbse s\u00f4 ayeke ngangu ti m\u00fb t\u00ee nyen\u00ee na threshold s\u00f4.\"\n\nNote that Sango is a language spoken in the Central African Republic and some surrounding regions. If you have a specific example to translate as well, feel free to provide it!\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Mb\u00eand\u00e2 na ngangu t\u00ee y\u00e2ng\u00e2 zo y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea gb\u00fbngbi. Mot\u00f4 t\u00ee y\u00e2ng\u00e2 na gb\u00fbngbi na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea gb\u00fbngbi t\u00ee y\u00e2ng\u00e2, na y\u00e2ng\u00e2 t\u00ee z\u00eeng\u00e2 t\u00ee gb\u00fbngbi m\u00fb gb\u00fbngbi na ngangu na y\u00e2ng\u00e2. Gb\u00fbngbi h\u00eeng\u00ea na mb\u00eand\u00e2 h\u00ee ng\u00e2 t\u00ee m\u00fb gb\u00fbngbi na gb\u00fbngbi na y\u00e2ng\u00e2 \u00e2zo. M\u00fb gb\u00fbngbi na gb\u00fbngbi h\u00eeng\u00ea na ngangu h\u00eeng\u00ea na is\u00f4 h\u00eeng\u00ea, na y\u00e2ng\u00e2 t\u00ee gb\u00fbngbi na gb\u00fbngbi h\u00eeng\u00ea na mb\u00eand\u00e2 na ngangu na gb\u00fbngbi h\u00eeng\u00ea na ngangu. T\u00eer\u00ee na y\u00e2ng\u00e2 t\u00ee ngangu na ngangu. Exanp\u00e2:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Here is the translation of the given sentence into Sango:\n\nS\u00ea t\u00ee da v\u00fbnd\u00fb t\u00ee gb\u00f4mb\u00f4 hor\u00eezon, a yeke songo na y\u00e2ng\u00e2 t\u00ee gb\u00f4mb\u00f4 t\u00ee k\u00eanga na nd\u00e2 t\u00ee gb\u00f4mb\u00f4 t\u00ee w\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00eanga na mbongo t\u00ee gb\u00f4mb\u00f4 t\u00ee ngbonga.\n\nZia nd\u00e2 t\u00ee gb\u00f4mb\u00f4 t\u00ee ngbonga t\u00ee k\u00eanga na mbongo t\u00ee gb\u00f4mb\u00f4 t\u00ee ngbonga.\n\nMb\u00ea t\u00ee:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" A la koua ti mo gbegere na mo ka na mo ko na nzoni na mo ka na yeke na nzoni na mo so k\u00e9t\u00e9 na somo na somo na konto na hinda ti z\u00e9ro. Mo hiri ti yeke sara na nzoni, s\u00f4 na konto k\u00e9t\u00e9 na hinda ti z\u00e9ro, na mo yeke sara \u00e9 na True. S\u00f4 konto k\u00e9t\u00e9 na hinda ti z\u00e9ro ti yeke ti so, na mo yeke sara \u00e9 na False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Sorry, but I can't provide a translation for that sentence into Sango.\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Here is the sentence translated into Sango:\n\n\"Yeke na da na ngangu 'delimeter' a kodro ti nyen na nyen ti `numbers`\"\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Here is the translation of the sentence into Sango:\n\n\"Input ti lo kod\u00eb ti mbi l\u00e0ng\u00f6 na string lo yeke mbi multiple groups lo mbi yeke nested parentheses lo mbi yeke separ\u00e9 na spaces.\n    Ti mbi yeke group k\u00e9t\u00e9, output ti mbi deepest level ti lo nesting ti mbi parentheses.\n    E.g.) awe maximum mbi two levels ti lo nesting awe)) awe three.\"\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" S\u00e9l\u00e9ni ti mbeti ti y\u00e2ng\u00e2 t\u00ee gb\u00fbng\u00fb k\u00e2 t\u00ee y\u00e2ng\u00e2 mo gb\u00fbng\u00fb k\u00e2 \u00e2nda y\u00e2ng\u00e2 t\u00ee y\u00e2ng\u00e2 mo.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Here is the translation of the given sentence into Sango:\n\n\"Ng\u00e2 t\u00ee fal\u00eenga t\u00ee t\u00f6ngana, k\u00fb\u00e8 na so y\u00e2 t\u00ee dagb\u00e8 na y\u00e2 t\u00ee v\u00fb t\u00ee t\u00f6ngana ahon\u00ee. Dagb\u00e8 t\u00ee fal\u00eenga t\u00ee g\u00efg\u00ef n\u00ee k\u00f6mbeni na 0 na v\u00fb t\u00ee fal\u00eenga t\u00ee g\u00efg\u00ef n\u00ee k\u00f6mbeni na 1.\"\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Here is the translation of the given sentence into Sango:\n\n```\nE yeke ti nzoni ti integer, yeke ti nzoni ti maximum a yeke ti nzoni na k\u00e9t\u00e9 a yeke ti nzoni ti t\u00eengbi.\n```\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" T\u00e9la s\u00f4 k\u00f6d\u00f6r\u00f4 t\u00ee mb\u00e9ni na k\u00f4zo na k\u00f4zo. \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Here is the translation of the given sentence into Sango:\n\n\"Ko t\u00ee \u0253\u00eati a na b gb\u00ea ti 1 na 0 m\u00f4 gb\u00ea ti. \n    Lingbi binary XOR mbi \u0253\u00eati-\u00ee na ala na yeke \u0253\u00eati m\u00f4.\"\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Kozo ti k\u00e9t\u00e9 na strings, zia lengba na gbanga ti mo. Zia ti leka na mo na ngangu ti gbanga mo sengese ti yeke na lengba. Zia None kozo mo ini ti k\u00e9t\u00e9 so yeke na ngangu.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" K\u00e9t\u00e9 na ndris\u00f4 t\u00ee mo na mo b\u00e2a na gb\u00fbngb\u00fbngb\u00fbng t\u00ee mo na mo.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Zia ti kangu ti so k\u00eeri k\u00eeri ti ab\u00e2 na k\u00f4zo ti \u00e2la na gb\u00fbngbi.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Gbenge na string ti yeke ti y\u00e2ng\u00e2 ti ming\u00e2 ti a ti 0 ti mb\u00ean\u00ee n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Nga t\u00eengb\u00ef ti mbi, n\u00eeng\u00ee ti wama na mb\u00ean\u00ee na lo kod\u00ea t\u00ee mo na lo y\u00ea.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input ti mbi ti lo kodro ni yeke string ase mbi ti musical notes na ASCII format ayeke.\n\n    Kar ti mo ti mbi ti yeke mbata string na mbi ti yeke list ti ndako ti integers ti mbi ti nd\u00e8 mbi ti yeke beats ti notes ti mbi ti yeke.\n\n    Na ayeke ti mbi:\n    'o' - whole note, ti mbi lasts four beats\n    'o|' - half note, ti mbi lasts two beats\n    '.|' - quarter note, ti mbi lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Tene ti mbi yeke k\u00e9t\u00e9 mingi na ng\u00e2 ti sango so gbanga ke na sango so ni. T\u00eer\u00ee ti mbi yeke k\u00e9t\u00e9 mbi t\u00eer\u00ee ti yeke na gbanga so ni.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Here is the translation of your sentence into Sango:\n\nL\u00e2nda na y\u00e2ng\u00e2 t\u00ee nomboro k\u00fb\u00e9 nz\u00f6n\u00ee na 'zero' ti 'nine'.\n    D\u00e2 t\u00ee y\u00e2ng\u00e2 k\u00fb\u00e9 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' na 'nine'.\n    L\u00e2nda na y\u00e2ng\u00e2 t\u00ee nomboro t\u00ee a kodro t\u00ee kp\u00e2p\u00e2 na k\u00fb\u00e9 ti monz\u00ea na monz\u00ea.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" A silini ti gbeni t\u00eer\u00ee k\u00eat\u00ea gbanga na z\u00eea na m\u00fb gb\u00fbngbi na gb\u00fbngbi na z\u00eea na m\u00fb na w\u00fbso.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Here is the translated sentence in Sango:\n\n```\nS\u00ease ti nzoni ti mingi, a yeke na maboko ti nzoni ti a, na la nzoni na ndobo ti a yeke 0 na nzoni na k\u00e9t\u00e9 ti a yeke 1.\n```\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" S\u00e9l\u00e9ka list\u00e9 ti python ti yeke kodoro na mo ombeni ti integers mb\u00e9ni.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Zia mbeti wa likundu a lingbi.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Sango: Na t\u00ee nzoni gb\u00ea n, z\u00fba nzoni gb\u00ea na mbi yeke d\u00eegbi n ti mbi k\u00fb\u00ea na, na nzoni gb\u00ea na mbi nzoni n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Here is the translation of the given sentence into Sango:\n\n\"H\u00eeng\u00ee na t\u00ee nzegere na yeke na nzoni na nzoni a yeke ng\u00e2 na yeke. Nzegere na yeke a tene na yeke t\u00ee mbi ni yeke na nzoni na nzoni. T\u00eeng\u00f6 t\u00ee nzoni a debe t\u00ee s\u00f4 t\u00ee s\u00f4 ng\u00e2.\"\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Sortu na y\u00e2ng\u00e2 t\u00ee mingi, bal\u00ea elem\u00e8ni s\u00f3 a yeke mbi mb\u00e8n\u00ee k\u00f4zo y\u00e2ng\u00e2 nd\u00e2. \n    T\u00eeri elem\u00e8ni s\u00f3 a yeke t\u00ee na mo y\u00e2ng\u00e2 k\u00f4zo y\u00e2ng\u00e2.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Po ti kodoro ti mbi, ke kodoro ti mbi a k\u00e9t\u00e9 ti mbi ga mbi mo kodoro ti mbi k\u00e9t\u00e9 ga mbi mo kodoro ti mbi ga k\u00e9t\u00e9.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" B\u00ea ti zo siriri ti na mb\u00e2 ti mo gbata na mbi siriri \u00e9k\u00e8.\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Funga zo kwe na mbata t\u00ee nzoni zo t\u00ee y\u00e2ng\u00e2 na liko t\u00ee y\u00e2ng\u00e2 na k\u00fb\u00ea t\u00ee liko.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Zia mbi na nzoni mo na lisiti k\u00e9t\u00e9.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Bal\u00e8 na ye t\u00ee mo kue lo nd\u00f6, na t\u00ee yeke nd\u00f6 kue lo ng\u00e2y\u00e9.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial na coefficients ti xs na point ti x.\n    a yeke kpesa xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Funkson ti mbi na nz\u00f6n\u00ee yeke l na gb\u00eenz\u00f6n\u00ee yeke l' na\n    l' a lingbi na l na nz\u00f6n\u00ee mo b\u00e2a so lingbi na ndaro na nd\u00e2 t\u00ee t\u00e2ta, nz\u00f6n\u00ee mo b\u00e2a so lingbi na ndaro na nd\u00e2 t\u00ee t\u00e2ta a lingbi na gb\u00eenz\u00f6n\u00ee ye t\u00ee l, na l\u00eengbi na ndaro.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"D\u00e9d\u00e9 ti \u00e9lement mbi b\u00fbngbi na nd\u00f6r\u00f6 n\u00ee.\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Here is the translation of \"Return maximum element in the list\" into Sango:\n\n\"Zia elemene na mbi kotoro na nzoni na lisiti.\"\n\nNote: Sango is a creole language spoken in the Central African Republic. The translation may vary depending on regional dialects and usage.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Zia na nginza ti yeke 7 a yeke na nzoni a nga boto n gbene 11 na 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"This function ka ti yeke na walaka l na a zia na walaka l' na ti mbi\n    l' ye na walaka l na nduru na be ti siriri k\u00e9t\u00e9, fe ti mo ti so\n    na be ti siriri ti walaka l, le na ti gbagbara.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    Ala na ni kod\u00f4ro y\u00e2ng\u00e2 na kp\u00eeri t\u00e2-\u00e2-t\u00e2 y\u00e2ng\u00e2.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib ape na n-zia de ti Fibonacci na ni ti yeke prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero a-zu \u00e9 list ti leng\u00f6zo ti i n\u00ee ti al\u00eengbi. \n    A yeke na y\u00e9 yeke na mbi ti mbi ni mo a-t\u00e2ta ti mo na yeke na,\n    mbi a-s\u00e2ra z\u00e9ro, na mbi mo na yeke na ti mbi na.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Imaginez na za na yeke nzoni ti moto so ala na moto so ni ngangu na yeke nzoni ti k\u00e9t\u00e9 so a yeke ndjala ti mass\u00e9. Na yeke k\u00e9t\u00e9 n ti moto so ala na yeke gasa ti mwa na ngangu; na k\u00e9t\u00e9 n ti moto wamba a yeke gasa ti mwa na k\u00e9t\u00e9. Ala moto so ni yeke t\u00f6n na yeke mbeti na k\u00e9t\u00e9 ti k\u00e9t\u00e9. Moto mingi ala yeke mwa na nzoni so ike yeke nd\u00f6. Moto wamba, moto mingi ala yeke mwa na k\u00e9t\u00e9 ti k\u00e9t\u00e9. Moto mingi ala yeke mwa na k\u00e9t\u00e9 ti k\u00e9t\u00e9. Moto mingi ala yeke mwa na k\u00e9t\u00e9 ti k\u00e9t\u00e9.\n\nMoto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9.\n\nMoto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9.\n\nMoto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9.\n\nMoto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9.\n\nMoto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9. Moto mingi ala na yeke nzoni ti k\u00e9t\u00e9 ti k\u00e9t\u00e9, moto mingi ala na yeke nzoni ti k\u00e9t\u00e9.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Sango: Kumb\u00e2 t\u00ee y\u00e2ng\u00e2 na y\u00e2ng\u00e2 t\u00ee y\u00e2ng\u00e2 k\u00fb\u00e9 na 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero a-ye ti lo kodoro t\u00ee mo-mbumb\u00f9 na k\u00e9t\u00e9-gbata. \n    A-zia na True s\u00f4 oko y\u00e9k\u00e9 k\u00e9t\u00e9-gbata na lo kodoro a-zo na t\u00ee y\u00e2ng\u00e2 zero, \n    na False oko s\u00f4 t\u00ee mbi.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Change ti lo kodro ti mo x na kodro mo base.\n    wuhinga ye ti mo gozo na nzoni ka na yeke kodro.\n    kodro na ngaiza na nzi 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Kou \u00e9 leng\u00f6 ti mbata na lo ti k\u00e9t\u00e9 so a zia na nd\u00f6 ti triangul\u00e9.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n**Fib4 y\u00e4ba na y\u00e4ba ayeke ti Fibbonacci t\u00ee mbi asu n\u00ee:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    S\u00fbka ti yeke funzu na tene ti mbi ayeke n\u00ee ti fib4 y\u00e4ba ti n-zo. Yeke ti ga na ko ti yeke na gbanga.**\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Zia mo londo ti kodro na maboko na l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    \"Aw\u00e8 s\u00f4 \u00e9 tongana s\u00f4 a yeke palindrome\"\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Zia 2^n na yeke modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    A kodri ti siriri na zia kod\u00ea na y\u00e2ng\u00e2 ti 5 na y\u00e2ng\u00e2 ti alfab\u00eati.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels ala na ye fonkson ti ala na kpanga t\u00ee lo na t\u00ee lingbi t\u00ee lo na t\u00ee kodoro t\u00ee lo na t\u00ee ng\u00e2 t\u00ee kp\u00eenga.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"A la k\u00fb\u00ea na, s\u00f4 nd\u00e2 t\u00ee mo m\u00fb t\u00e2r\u00ee t\u00ee l gb\u00fb t\u00ee t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Kete nzoni na y\u00e2ng\u00e2 mb\u00ean\u00ee x na y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    D\u00e9d\u00e9 ti y\u00e9k\u00e9 s\u00f4 si gbegbe na mo na.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Kumb\u00e2 n-nd\u00e2 na Fibonacci.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Here is the translation of the sentence into Sango:\n\nBrackets ye string ti \"<\" na \">\".\n    Zia ti mbi yeke na wa True s\u00f4 mingui na mingui ke t\u00ee kpunga b\u00fbku kp\u00f4ng\u00f4 t\u00ee kpunga b\u00fbku t\u00ee s\u00f4 s\u00e2ra l\u00e2.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Kumb\u00e4t\u00ef \"True\" s\u00f4 t\u00ee gb\u00eeg\u00fb t\u00ee lo na yeke na m\u00fb t\u00ee ngangu k\u00fb\u00e9 na k\u00fb\u00e9 k\u00fb\u00ea na l\u00eengbi l\u00ea na l\u00ea.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Tomb\u00e2 mb\u00ean\u00ee ti mo t\u00eer\u00ee t\u00ee nz\u00f6n\u00ee t\u00ee ngangu t\u00ee nz\u00f6n\u00ee t\u00ee gb\u00fbr\u00fb.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Zia ti mbi ngangu k\u00eat\u00ea so a yeke n. Kpu n > 1 na a yeke k\u00eat\u00ea te ti ngangu.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n yeke fungsi na yeke s\u00f4 k\u00eat\u00ea ti 1 ti n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Here is the translation of the sentence into Sango:\n\n**brackets yeke libongo ti \"\". \n    Mbi yeke h\u00eeng\u00ee na \"True\" s\u00f4 k\u00e8t\u00eab\u00e8 ti gbanga libongo na k\u00e8t\u00eab\u00e8 ti z\u00fba libongo.**\n\nPlease note that the translation might not capture the technical nuance perfectly, as Sango is not as widely used in technical contexts.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" Here is the translation of the given sentence into Sango:\n\n```plaintext\nxs ti kodoro na kodoro t\u00ee na ni.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    T\u00eengb\u00ee k\u00fbgb\u00ean\u00ee t\u00ee na ni na kodoro t\u00ee na ni k\u00fb\u00ea na nd\u00e2 t\u00ee na ni.\n```\n\nNote that Sango translations may vary slightly in expression, especially for technical terms.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"The FibFib number sequence ti yeke s\u00e9quence so a yeke s\u00e9quence na ngangu na Fibbonacci s\u00e9quence so a zia ti mo si k\u00f4zo:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    S'il vous pla\u00eet, y\u00e9 ti gonda ti kod\u00e9 so a matanga ti k\u00fb\u00ea n-zo ti fibfib s\u00e9quence na nduru.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nGb\u00e9ngb\u00e9ng li ti k\u00eat\u00ea so k\u00eat\u00ea.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Here is the translation of the sentence into Sango:\n\n\"Y\u00e9k\u00e9 ti y\u00e9ng\u00f6 kodoro ti nombra k\u00e9t\u00e9 x, y\u00e9k\u00e9 kodoro awoko na k\u00e9t\u00e9 na kotara kodoro na ndakata na nd\u00f6 k\u00e9t\u00e9. S\u00f4 shift awoko kodoro ti y\u00e9k\u00e9, s\u00f4 nd\u00f4 kodoro ti r\u00e9.\"\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Sure, here is the translation of the sentence into Sango:\n\n`S\u00eanga\n    Vund\u00f4 t\u00ee kw\u00ee t\u00ee mbi y\u00e2ng\u00e2 t\u00ee kp\u00e2ngb\u00e2 na y\u00e2ng\u00e2 k\u00fb\u00ea t\u00ee mbi na y\u00e2ng\u00e2 kod\u00ea ASCII t\u00ee mb\u00ean\u00ee t\u00ee za na kpata.\n\n    D\u00ea t\u00ee y\u00e2ng\u00e2:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153`\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Na lingbi t\u00ee ala, mo yeke ti m\u00f4 na likundu k\u00fb\u00ea t\u00ee k\u00f4nd\u00f4ro na mabenda ngangu yangana b\u00fbku na likundu t\u00ee k\u00f4nd\u00f4ro. Likundu k\u00fb\u00ea a yeke na k\u00f4nd\u00f4ro, mabenda, na mango. Mo yeke ti m\u00f4 na likundu k\u00fb\u00ea t\u00ee mabenda na k\u00f4nd\u00f4ro na mbi ti m\u00f4 na k\u00f4nd\u00f4ro na mango na likundu. \n\nDuh\u00fb na m\u00f4 lingbi k\u00fb\u00ea:\nfruit_distribution -> 19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    Here is the translation of the provided text into Sango:\n\n\"D\u00e9 ti yeke na arr\u00e9 ti kodro ti mbi ti mbi ti yeke ti nadro-ndro na gbanga na mbi \n    mo ti yeke ti o ti kodro ti mbi mo yeke ti mbi ti mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi mbi\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Na nzoni arr ti mingi, zia minzoni wa ti ruf\u00e2 na arr k\u00eat\u00ea na zia minzoni wa ti arr s\u00f4 a t\u00ee palindromic. Arr ti palindromic, linga a yeke arr t\u00ee w\u00f4 a s\u00e2ra nd\u00e2 na nd\u00e2 t\u00ee kue na nd\u00e2 t\u00ee gbu. Na zia minzoni \u00f4ko, mo kue na zia minzoni wa \u00f4ko na minzoni wa \u00e2zo.\n\nNa ng\u00e2 n\u00ee:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n\"Yeke na k\u00e9t\u00e9 so a yeke na zia la ngangu ape mbi na yeke na zia la nd\u00f6ng\u00f6 na nd\u00f6ng\u00f6 na nd\u00f6ng\u00f6 na p\u00eape. Ala vo yeke gbiange 100. K\u00f3d\u00f6r\u00f6:\nis_multiply_prime yeke ngangu\n30 = 2 * 3 * 5\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"K\u00f6d\u00f6r\u00f6 t\u00ee mo gb\u00eean\u00ee t\u00ee t\u00eer\u00ee y\u00e2ng\u00e2 t\u00ee yeke na ni \u00e2s\u00ea na ni x \u00e2zo t\u00ee n\u00eeng\u00f6 n\u00ee n na y\u00e2ng\u00e2 t\u00ee \u00e2s\u00ea na ni.\n\nx \u00e2zo t\u00ee n\u00eeng\u00f6 n\u00ee n s\u00f4 n**int=x.\n\nNg\u00e2 t\u00ee \u00e2s\u00ea:\nis_simple_power => t\u00eengbi\nis_simple_power => t\u00eengbi\nis_simple_power => t\u00eengbi\nis_simple_power => mb\u00eea\nis_simple_power => mb\u00eea\nis_simple_power => mb\u00eea\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Moto na kue nzoni na yeke ti kugara na mbeti ti mo, ti yeke kodro \n    na mbeti ti hexadecimal na yeke na string na kanga ngangu ti \n    bangui hexadecimal na yeke na primes (prime number, ti yeke prime, \n    ti yeke number na gbanga na 1 ti na yeke na gbanga ti mo na nde ti \n    to na yeke na kue ti bangui ti mo na ndoko na yeke ti mo).\n    Bangui hexadecimal na yeke 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Bangui primes na yeke 2, 3, 5, 7, 11, 13, 17,...\n    Alongo so, mo yeke ti kodro bangui na yeke na digits na moto ti 2, 3, 5, 7, \n    B, D.\n    Note: mo yeke na assume ti na input na yeke correct ti \n    empty string, na symbols A,B,C,D,E,F na yeke na uppercase.\n    Examples:\n    Ti num = \"AB\" ti output na yeke 1.\n    Ti num = \"1077E\" ti output na yeke 2.\n    Ti num = \"ABED1A33\" ti output na yeke 4.\n    Ti num = \"123456789ABCDEF0\" ti output na yeke 6.\n    Ti num = \"2020\" ti output na yeke 2.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n\"Mbi na yeke na mbi ti yeke na ngangu ti se na decimal, na ti mbi na mbi ti se na binary. Fungisi ti mbi na mbi ti h\u00fb na string, na yeke na kara ti k\u00e9t\u00e9 ti binary. Kara ti string na yeke '0' ou '1'.\n\nNa yeke na kara ti 'db' na k\u00f4zo na na ti string na k\u00f4zo na na ti string.\nKara ti 'db' na yeke na y\u00e2 ti gonda na format.\n\nD\u00f4ko:\ndecimal_to_binary   # na h\u00fb 'db1111db'\ndecimal_to_binary   # na h\u00fb 'db100000db'\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"B\u00ea ti yeke li t\u00ee s.\n\nT\u00eer\u00eeng\u00f6 k\u00fb\u00ea t\u00ee y\u00ea n\u00ee nd\u00e2 t\u00ee na t\u00ee s\u00fbng\u00f6 b\u00ea ti yeke na mb\u00ean\u00ee mo.\n\nB\u00ea ti yeke na mb\u00ean\u00ee mo s\u00f4 ayeke l\u00ea ti 3 na li t\u00ee b\u00e2a t\u00ee b\u00ea ti yeke na y\u00e2ng\u00e2 t\u00ee 3 na b\u00ea ti b\u00ea ti yeke na ndoyi.\n\nD\u00ee t\u00ee b\u00e2a:\n\nis_happy => D\u00e2\nis_happy => D\u00e2\nis_happy => B\u00ea\nis_happy => D\u00e2\nis_happy => B\u00ea\nis_happy => D\u00e2\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Yeke na sem\u00e8n\u00ee na ya skol\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee na ti yeke na sem\u00e8n\u00ee\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n**Kw\u00e9ti na mo gb\u00e2 ti \u00e2la k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee nzoni na zia ti nzoni \u00e2la \n    sara mingi y\u00e2ng\u00e2 ayeke ti y\u00e2ng\u00e2 kp\u00eane na t\u00eeng\u00f6 na yang\u00e2 mingi da k\u00fb\u00ea na t\u00eeng\u00f6 na p\u00eape.**\n    **Exemples**\n    **prime_length == Nd\u00e2**\n    **prime_length == Nd\u00e2**\n    **prime_length == Nd\u00e2**\n    **prime_length == P\u00eape**\n\nNote: Sango does not have an extensive technical vocabulary akin to English, so some terms are approximated or borrowed as necessary.\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Na yeke nzoni nzo n, zia na yeke kutuko na mo na nzoni-njene na yeke nzoni.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n```\nNa N ti mbi yeke na nd\u0254r\u0254ng\u0254 na kozo k\u00e9t\u00e9, mbi yeke na zia ti mbirini e ti mbeti ti N na lingbi.\n\n    Lond\u0254\n        Na N = 1000, zia ti mbirini e ti mbeti lo yeke 1, lengana ti mbi yeke na \"1\".\n        Na N = 150, zia ti mbirini e ti mbeti lo yeke 6, lengana ti mbi yeke na \"110\".\n        Na N = 147, zia ti mbirini e ti mbeti lo yeke 12, lengana ti mbi yeke na \"1100\".\n    \n    Variables:\n        @N kozo k\u00e9t\u00e9\n             Constraints: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000.\n    Lengana:\n         yeke ti lingbi na binary.\n```\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Here is the translation of the sentence into Sango:\n\n```\nMo na kozo t\u00ee nzoni t\u00ee n\u00eeng\u00f6, na r\u00eean\u00ee na nzoni t\u00ee b\u00fbngbi k\u00fb\u00ea n\u00ee ti-m\u00eengi k\u00eat\u00ea na m\u00f4g\u00f4 t\u00ee nzoni k\u00eat\u00ea na \u00e2la.\n\n    D\u00e2kp\u00ee:\n        na ==> 2\n``` \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Here's the translation of the given sentence into Sango:\n\n\"Y\u00e9k\u00e9 lik\u00f3ngo ti so k\u00f9\u00e9 so s\u00e9ng\u00e9 na nz\u00f6nzi na wa ni s\u00e9ng\u00e9 so s\u00e9ng\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti k\u00e9t\u00e9 k\u00e9t\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so nz\u00f6nzi a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi, na nz\u00f6nzi na nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi. \n\nNa ni: B\u00e9 ti nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi na nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi a y\u00e9k\u00e9 na nz\u00f6nzi na nz\u00f6nzi so a y\u00e9k\u00e9 na nz\u00f6nzi so a y\u00e9k\u00e9 ti nz\u00f6nzi.\n\nNa ni:\n\nanti_shuffle y\u00e9k\u00e9 'Hi'\nanti_shuffle y\u00e9k\u00e9 'ehllo'\nanti_shuffle y\u00e9k\u00e9 'Hello !!!Wdlor'\"\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Here is the translation of the given sentence into Sango:\n\n\"Mbi bal\u00eeka mo na data na mbi ti 2 dimensio, na list ti mbi ti zo t\u00eer\u00ee,\n    ape b\u00eea t\u00ee matrix, k\u00e2 mo, ape lo ti matrices,\n    k\u00e9t\u00e9ng\u00e9 ti goro na gb\u00e2 t\u00ee lo na l\u00e2 t\u00ee columns difo-difo.\n    S\u00f4 ti mbi lst, na integer x, mbi s\u00e2ra integers x na list,\n    na mbi l\u00e2 list ti tuples, [, ...] so k\u00e9t\u00e9ng\u00e9\n    tuple k\u00e9t\u00e9ng\u00e9 ti coordinate -, so mo y\u00ea na 0.\n    Mbi s\u00e2ra coordinates na row na l\u00e2 k\u00e9t\u00e9ng\u00e9 na k\u00eat\u00ea t\u00ee ti m\u00f4 na l\u00e2.\n    D\u00eeko, mbi s\u00e2ra coordinates ti row na l\u00e2 na columns na l\u00e2 t\u00ee m\u00f4 na l\u00e2.\n    \n    S\u00eamb\u00easo:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [,,,,]\n    get_row == []\n    get_row == []\"\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Donn\u00ee ti nz\u00f6n\u00ee ti mbi n\u00ee na S\u00e4ng\u00f6:\n\nS\u00f4 k\u00f6t\u00e4 t\u00ee mo y\u00ea t\u00ee nz\u00f6n\u00ee ng\u00e2 nz\u00f6n\u00ee ti gb\u00fbngbi, mo ga y\u00ea gb\u00fbngbi t\u00ee nz\u00f6n\u00ee n\u00ee na \u00e2mb\u00ean\u00ee, m\u00f4 yeke \u00eer\u00ee nz\u00f6n\u00ee n\u00ee na funga na funga na l\u00e2 t\u00ee mo e s\u00f4 sum\u00e2 yeke y\u00e2ng\u00e2, na \u00e2mb\u00ean\u00ee m\u00f4 yeke \u00eer\u00ee nz\u00f6n\u00ee n\u00ee na gb\u00e2ngou na gb\u00e2ngou na l\u00e2 t\u00ee mo e s\u00f4 sum\u00e2 yeke v\u00fbngbi.\n\nNgb\u00e2nzi:\n* Yeke z\u00e2 nz\u00f6n\u00ee n\u00ee s\u00f4 t\u00ee mo n\u00ee.\n\nNge t\u00ee g\u00f4 t\u00ee nz\u00f6n\u00ee:\n* sort_array => []\n* sort_array => [5]\n* sort_array => [0, 1, 2, 3, 4, 5]\n* sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n\"F\u00e2 t\u00ee kod\u00earo na yeke yere t\u00ee gbegbi na \u00e2la yeke kod\u00earo t\u00ee mo, kod\u00earo na \u00e2la gbegbi mo na \u00e2la kod\u00earo na gbegbi na kod\u00earo t\u00ee t\u00eer\u00ee na mo. T\u00eer\u00ee na mo gbegbi na \u00e2la kod\u00earo na yeke kod\u00earo na yeke gbegbi na kod\u00earo na gbegbi gbegbi na \u00e2la kod\u00earo na gbegbi na \u00e2la gbegbi gbegbi na gbegbi na \u00e2la gbegbi gbegbi na \u00e2la gbegbi gbegbi na t\u00ee gbegbi. Na kod\u00earo kod\u00earo f\u00e2:\n\nencrypt gbegbi 'lm'\nencrypt gbegbi 'ewhjklnop'\nencrypt gbegbi 'kj'\nencrypt gbegbi 'ix'\"\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Ala na ti mbi t\u00ee lo, \u00e9 pi mbi t\u00ee ngb\u00e2 t\u00ee mo leng\u00f6 t\u00ee s\u00f4 e ti mbi t\u00ee s\u00f4 t\u00ee \"boredoms.\" Boredom \u00e2zo \u00e9 yeke ti s\u00f4 k\u00eat\u00ea ti n\u00ee \"I.\" Ng\u00e2b\u00fb k\u00eat\u00ea \u00e9 yeke ti s\u00e2ra na '.', '?' na '!'.\n\nD\u00fba:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Here's the translation of the given sentence into Sango:\n\n\"S\u00eande ti kaki ti \u00e2la lo, kod\u00ea lo na mbi ngangu ti \u00e2la lo ngangu ti \u00e2la lo na kangbi na so \u00e2la lo ti n\u00ee, kod\u00ea lo na mbi ngangu ti \u00e2la lo na kangbi na so \u00e2la lo ti n\u00ee, kod\u00ea lo na mbi ngangu ti \u00e2la lo na kangbi na so \u00e2la lo ti n\u00ee, kod\u00ea lo na mbi ngangu ti \u00e2la lo na kangbi na so \u00e2la lo ti n\u00ee ti \u00e2la lo na kangbi na so \u00e2la lo ti n\u00ee.\"\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"\u0164\u00ee yeke ti zo g\u00efr\u00ef ti ngangu. \n    Zo yeke fa nz\u00f6n\u00ee ti mbi na m\u00fbgb\u00fbnga ti mbi ere ti ng\u00e2.\n\n    Z\u00eea:\n    Na nz\u00f6n\u00ee = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] mbi yeke h\u00ee 10\n    Na nz\u00f6n\u00ee = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] mbi yeke h\u00ee 25\n    Na nz\u00f6n\u00ee = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] mbi yeke h\u00ee 13\n    Na nz\u00f6n\u00ee = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] mbi yeke h\u00ee 11\n    Na nz\u00f6n\u00ee = [0,81,12,3,1,21] mbi yeke h\u00ee 3\n    Na nz\u00f6n\u00ee = [0,8,1,2,1,7] mbi yeke h\u00ee 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    T\u00eengbi na Sango:\n\nT\u00eengbi dictionary, z\u00eea True s\u00f4 k\u00fb\u00ea t\u00ee na m\u00f4to k\u00eat\u00ee t\u00ee k\u00f4zo b\u00e2a strings na y\u00e2ng\u00e2 t\u00ee k\u00eat\u00ee strings na ng\u00fb t\u00ee y\u00e2ng\u00e2, na nd\u00f6 b\u00e2a, z\u00eea False. Fungusu ni z\u00eea False s\u00f4 dictionary ni k\u00eat\u00ea t\u00ee y\u00e2ng\u00e2.\nExemples:\ncheck_dict_case ni z\u00eea True.\ncheck_dict_case ni z\u00eea False.\ncheck_dict_case ni z\u00eea False.\ncheck_dict_case ni z\u00eea False.\ncheck_dict_case ni z\u00eea True.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\nImplement\u00e8 ti k\u025bd\u025b t\u00ee gbanga na y\u00e2ng\u00e2 t\u00ee y\u00e2ng\u00e2 t\u00ee y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 t\u00ee k\u00fb\u00ea na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2 k\u00fb\u00e9 na y\u00e2ng\u00e2\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Here is the sentence translated into Sango:\n\n**Termin\u00e9z\u00e9 kod\u00e9 ti y\u00e9 na so aw\u00e9 ti k\u00e9t\u00e9 mbi ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9 ti y\u00e9 na so aw\u00e9\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Here is the translation of the given sentence into Sango:\n\n**Kozo na lingbi sango s, k\u00e9t\u00e9 nzoni y\u00e9 ngangu t\u00ee mb\u00eand\u00e8 t\u00ee gb\u00e2 t\u00ee mo na nduru na t\u00ee ng\u00e2ng\u00e0 t\u00ee lo na even indices.**\n\n    \n    **Mbi fa y\u00e2ng\u00e2:\n    count_upper na t\u00ee y\u00e2 1\n    count_upper na t\u00ee y\u00e2 0\n    count_upper na t\u00ee y\u00e2 0**\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Doni na ti nzoni n ti mbi kodro na Sango:\n\nKozo aw\u00e8 ti mo yeke na k\u00e9t\u00e9 n, mo sango ti b\u00fbku na n ti k\u00e9t\u00e9 na mbata ti wadere.\n    - K\u00e9t\u00e9 ti mbata ni na n ti wadere.\n    - Nzoni ti wadere na k\u00e9t\u00e9 na ngunda ni:\n        - ni nzoni ti wadere na odd ni ko n ni odd.\n        - ni nzoni ti wadere na even ni ko n ni even.\n    - Furu ti wadere na k\u00e9t\u00e9 ni ni na lisiti ni, oko ti lisiti i ni nzoni ti wadere na k\u00e9t\u00e9.\n\n    Ngangu:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Mo yeke na mo leng\u00f6 ngangu ti mo ti tii k\u00e9t\u00e9 na koma o na ti mbi. Mo ti soro zo ti g\u00e9ng\u00e9 ngangu a ti yeke ti tii k\u00e9t\u00e9 na mbi.\n\nDuti ti mo:\n\n- Z\u00e4ng\u00f6 ngangu a\n- Kanga lo na mbi ti ngangu.\n\nDuti ti mo ti na:\n\n- Mo ti tii ngangu \"Hi, my name is John\" na mbi [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n- Mo ti tii ngangu \"One, two, three, four, five, six\" na mbi [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Fungbi t\u00ee gbegolo na awi k\u00eat\u00ea t\u00ee b\u00fbngi ni x na y na \u00e2s\u00eengbi ni\n    z\u00eea t\u00ee gbegolo t\u00ee y\u00e2ng\u00e2 na y\u00e2ng\u00e2 yang\u00e2 t\u00ee kp\u00eel\u00ee na y\u00e2ng\u00e2 yang\u00e2 t\u00ee n\u00ee [x, y] \u00e2s\u00eeng\u00ea. S\u00f4 k\u00fb\u00ea t\u00ee gbegolo a y\u00ea na, fungbi t\u00ee gbegolo a y\u00ea -1.\n\n    Na m\u00f4 gb\u00eal\u00ea:\n    choose_num = 14\n    choose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"A la ti mbi gbenge gbata kodoro n na m, na ti mbi ga zia ti mbi tombo kodoro n na m. \nKpe ti mbi a kanga ni ti mbi na zia kodoro ni ti mbi yeke na ni ti mbi na yeke ni kodoro. \nSoko na n ti mbi ga fonga na m, ti mbi ga da -1.\nDongo:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Here's the translation of the given sentence into Sango:\n\n\"S\u00ease ti yeke ngangu t\u00ee ti z\u00eeng\u00fb t\u00ee y\u00e2ng\u00e2 t\u00ee y\u00e2ng\u00e2. B\u00e9 ti f\u00e2ti ngangu t\u00ee y\u00e2ng\u00e2 t\u00ee nga f\u00e2a ngangu t\u00ee g\u00fbng\u00fb t\u00ee ng\u00e2 n\u00ee d\u00eeng\u00eal\u00ea t\u00ee k\u00eat\u00ea. \n\nNgbanga: Ngangu t\u00ee y\u00e2ng\u00e2 t\u00ee b\u00e2a s\u00f4 n\u00ee ti b\u00e2a na k\u00eat\u00ea t\u00ee s\u00f4 t\u00ee y\u00e2ng\u00e2.\n\nT\u00ee na nga t\u00ee:\"\n\nPlease note that Sango, being a language spoken by a relatively small population in the Central African Republic, might not have direct translations for all technical or mathematical terms, and the structure and form may vary depending on the context and usage.\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Mb\u00ean\u00ee ti ng\u00fbb\u00ea ti m\u00f4k\u00f4-nd\u00fbk\u00fb, n\u00eeng\u00ee ng\u00fbb\u00ea ti m\u00f4k\u00f4-nd\u00fbk\u00fb na t\u00ee 1 na 9, t\u00ee sir\u00eeng\u00ee na mb\u00ean\u00ee, na t\u00ee k\u00fb\u00ea t\u00ee sir\u00eeng\u00ee na mb\u00ean\u00ee, na t\u00ee z\u00fb\u00e2 ng\u00fbb\u00ea na m\u00f4 mbi \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\nD\u00fbk\u00fb t\u00ee ng\u00fbb\u00ea:\n  arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n        -> n\u00eeng\u00ee arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n        -> k\u00fb\u00ea arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n  retour [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n  S\u00f4 arr \u00e2zo t\u00ee nzoni, retour mb\u00ean\u00ee t\u00ee nzoni:\n  arr = []\n  retour []\n\n  S\u00f4 arr \u00e2zo t\u00ee m\u00f4k\u00f4 b\u00e2 t\u00ee nzoni b\u00e2 t\u00ee sir\u00ee, b\u00e2 ti b\u00e2 t\u00ee l\u00e2k\u00fb\u00e2:\n  arr = [1, -1 , 55] \n        -> n\u00eeng\u00ee arr -> [-1, 1, 55]\n        -> k\u00fb\u00ea arr -> [55, 1, -1]\n  retour ['One']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Here is the translation of the given sentence into Sango:\n\n**Sango:**\n\n```\nS\u00eango ti kodoro f na a\u2013z\u00fba n na ni k\u00fb\u00ea,\n    na z\u00eea s\u00e2ra n\u00eeng\u00f6 a n\u00ee, na k\u00fb\u00ea na \u00e2la na k\u00eeri n\u00ee na k\u00fb\u00ea,\n    na mbeni ti \u00e2la na \u00eer\u00ef na i na factorial ti i s\u00f4 i na 2,\n    na n\u00ee na kp\u00e2l\u00ea ti t\u00eeng\u00f6 na 1 na i na s\u00ebni.\n    i na t\u00eeng\u00f6 na 1.\n    factorial ti i na z\u00eea na kodoro na mb\u00ean\u00ee na 1 na i.\n    K\u00eat\u00ea na:\n    f == [1, 2, 6, 24, 15]\n```\n\nNote: Sango is a language with a limited number of technical terms, so some programming-specific concepts might be explained in a more descriptive manner.\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Here is the translation of the given sentence into Sango:\n\nTi yeke na nginza ti ngangu  n, zia mbeti ti k\u00e9t\u00e9 yeke na nginza ti ngangu ti yeke na nginza ti k\u00f6ng\u00f6 na ngangu ti yeke na yeke na k\u00f6ng\u00f6 na ngangu ti ngangu ti palindromes ti yeke na ngangu ti yeke na yeke na k\u00f6ng\u00f6 na ngangu ti yeke na k\u00f6ng\u00f6 na ngangu ti yeke na k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti yeke na yeke na k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu.\n\nD\u00f6fa 1:\n\n    Engbara: 3\n    Zia:\n    Ko mbeti:\n    Ngangu ti palindrome yeke ti 1, 2, 3. Yeke ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu.\n\nD\u00f6fa 2:\n\n    Engbara: 12\n    Zia:\n    Ko mbeti:\n    Ngangu ti palindrome yeke ti 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Yeke ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu.\n\nNd\u00e9k\u00e9:\n    1. 1 <= n <= 10^3\n    2. Mbeti ti yeke na nginza ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu ti k\u00f6ng\u00f6 na ngangu.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Here is the translation of the given sentence into Sango:\n\n\"Vara ti yeke ti count_nums lo yeke array ti integers na yeke na\n    na nzoni ti elements mo na t\u00e9r\u00e9 sum ti digits > 0.\n    Sango lo yeke negatif, mo na t\u00e9r\u00e9 signed digit na negatif:\n    e.g. -123 na signed digits lo -1, 2, na 3.\"\n\nIf you need any further assistance, feel free to ask!\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"We na arr 'arr' ti N integers arr[1], arr[2], ..., arr[N]. Mere ti so arr gbegbe ti b\u00eeara so. K\u00f6d\u00f6r\u00f6 k\u00eat\u00ea ti mo so ni na, na yeke t\u00ee m\u00f4 ye na arr ti non-decreasing order ng\u00e2 t\u00ee k\u00f6m\u00f4 a ke na kodoro:\n\n    Mo yeke t\u00ee k\u00f6m\u00f4 na right shift operation ti mo so k\u00eat\u00ea ti ng\u00e2.\n\n    Right shift operation k\u00eat\u00ea so ni na, k\u00f6m\u00f4 t\u00ee k\u00eat\u00ea t\u00ee mo so ng\u00e2 t\u00ee position t\u00ee na kono t\u00ee right. Na k\u00eat\u00ea t\u00ee na arr na na k\u00f6m\u00f4 t\u00ee position t\u00ee na 0th index.\n\n    S\u00f4 k\u00eat\u00ea so ni na yeke ti m\u00f4 ye na arr ti non-decreasing order ng\u00e2 t\u00ee k\u00f6m\u00f4 a ke na kodoro, \u00e2l\u00ee ti m\u00f4 yeke ti s\u00eang\u00ea. S\u00f4 k\u00eat\u00ea t\u00ee na arr so ni t\u00ee nd\u00f4, \u00e2l\u00ee ti m\u00f4 yeke ti s\u00eang\u00ea.\n\n    Note: arr so ni yeke t\u00ee uniqueness k\u00eat\u00ea ti k\u00eat\u00ea.\n\n    Ex\u00e2mbre:\n\n    move_one_ball==>S\u00eang\u00ea\n    Explanation: K\u00eat\u00ea ti 2 right shift operations, yeke ti m\u00f4 ye na arr t\u00ee non-decreasing order.\n    \n    move_one_ball==>Nd\u00f4 s\u00eang\u00ea\n    Explanation: Mbi t\u00ee m\u00f4 yeke t\u00ee na arr t\u00ee non-decreasing order ng\u00e2 t\u00ee k\u00f6m\u00f4 a ke na kodoro, \u00e2l\u00ee ti m\u00f4 yeke ti s\u00eang\u00ea.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Na nduru zia, mo ti ko kanga ti mbi na nduru ti mo ti ga tene na mo na mbi na ti mo tene ti mbi na nduru mo ti nduru ti mbi ti mbi na ti mbi na ti mbi ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi ti mbi na ti mbi na ti mbi na ti mbi ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi \u043d\u0430 ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na ti mbi na\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\nNa k\u00e9t\u00e9 t\u00ee mo b\u00e2a t\u00ee mbeti na kati t\u00ee let\u00e4 kod\u00eb-ko y\u00e2ng\u00e2, kang\u00e4 t\u00ee t\u00eer\u00ee na maboko t\u00ee let\u00e4 gb\u00fbngbi na kod\u00eb gb\u00fbngbi na y\u00e2ng\u00e2 t\u00ee h\u00eenga. S\u00f4 t\u00f6m\u00ee ye let\u00e4 mingi y\u00e2ng\u00e2, kang\u00e4 t\u00ee t\u00eer\u00ee na maboko t\u00ee nz\u00f6n\u00ee mingi.\n\nM\u00eengi:\n\nhistogram == {'a': 1, 'b': 1, 'c': 1}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'b': 4}\nhistogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"T\u00e2l\u00ea\n    Ba ti yeke s\u00f4 k\u00fb\u00ea c\u00eeng\u00e2 t\u00ee s na c, mo yeke ti l\u00e2ng\u00f4ko nzoni n\u00ee, mo ti kode l\u00e2mbi z\u00eea t\u00ee s k\u00fb\u00ea b\u00e2 f\u00e2 t\u00ee k\u00f4zo na n\u00eeng\u00e2 t\u00ee c.\n    Mo ti y\u00e2ng\u00e2 na ko y\u00ea t\u00ee yeke s\u00f4 t\u00eer\u00ee n\u00ee na palindrom.\n    Nzoni t\u00eer\u00ee palindrom na y\u00ea ti z\u00eea \u00e2 k\u00f4zo na \u00e2k\u00f4zo s\u00ease s\u00eal\u00ea-k\u00f4zo na s\u00eal\u00ea-k\u00f4zo.\n    Mo ti y\u00e2ng\u00e2 na y\u00ea y\u00e2ng\u00e2 ti t\u00eer\u00ee na tuple gb\u00e2 t\u00eer\u00ee na y\u00ea s\u00f4 t\u00eer\u00ee n\u00ee na palindrom.\n    Example\n    S\u00f4 t\u00ee s = \"abcde\", c = \"ae\", y\u00ea na t\u00eer\u00ee.\n    S\u00f4 t\u00ee s = \"abcdef\", c = \"b\" y\u00ea na t\u00eer\u00ee.\n    S\u00f4 t\u00ee s = \"abcdedcba\", c = \"ab\", y\u00ea na t\u00eer\u00ee.\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\nK\u00e9 na mbi so kodoro ti strings, okozo na kodoro azo ayeke ti digits mo gb\u00fbng\u00fb, koko na mbi so kodoro. Kodoro okozo na mbi so ayeke \"nomb\u00f4 ti kodoro ti digits na mb\u00e9ni na kodoro i ti kodoro na mbi so.\" okozo na i okozo na mb\u00ef ye na nomb\u00f4 ti digits na mb\u00e9ni na kodoro i ti kodoro na mbi so.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Ala na mo b\u00eean\u00ee ti kodoro nums, y\u00e9k\u00e9 ti mo d\u00eeng\u00f6 nd\u00f6 ti mbi mbi nz\u00f6n\u00ee ti ayeke kodoro nums.\n\nExemple\nminSubArraySum == 1\nminSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Oko min mo na ngangu ti wells ti ngalango. S\u00eati ti ngangu na nzoni. S\u00eati t\u00ee 1 na nzoni na n\u00ee na ndri t\u00ee ngangu ti kodoro. S\u00eati ti ngangu na nzoni na ndri bucket na ndri ndri ti ngangu, bucket k\u00fbe na ka kapacit\u00e9 ti ndri. Mo na yeke ti bucket so ti ndresse ngangu na ngalango. Mbi na yeke ti toko n\u00ee na mo so ti yeke ti bucket so ti mbagba na ngalango.\n\nD\u00ea ti na nd\u00e2:\n\n    D\u00ea ti 1:\n        Input: \n            ngangu : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            kapacit\u00e9 ti bucket : 1\n        Output: 6\n\n    D\u00ea ti 2:\n        Input: \n            ngangu : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            kapacit\u00e9 ti bucket : 2\n        Output: 5\n\n    D\u00ea ti 3:\n        Input: \n            ngangu : [[0,0,0], [0,0,0]]\n            kapacit\u00e9 ti bucket : 5\n        Output: 0\n\n    K\u00eat\u00ea t\u00ee ngangu:\n        * ngangu k\u00fbe na ndri ti ngi\n        * 1 <= ngangu.length <= 10^2\n        * 1 <= ngangu[:,1].length <= 10^2\n        * ngangu[i][j] -> 0 | 1\n        * 1 <= kapacit\u00e9 <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Ingu ti Kata, mo yeke sala ti lo bango ti non-negative integers na nd\u00f6 ti mo t\u00ee lingbi ti binary na kp\u00f6ngi ti mo t\u00ee nd\u00f6. \nS\u00f4 lingbi ti nd\u00f6 na y\u00e2ng\u00e2, mo yeke sala lo na decimal value.\n\nA yeke sala l\u00e2s\u00f4:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n\"Ng\u00e2 ape na k\u00e9t\u00e9 s na ot\u00e2 n, mo so yeke ti g\u00e2p\u00eeng\u00ee na y\u00e2ng\u00e2 t\u00ee mo t\u00ee t\u00eer\u00ee \u00f4ko \nt\u00ee y\u00e2ng\u00e2 k\u00e9t\u00e9 t\u00ee y\u00e2ng\u00e2 k\u00e9t\u00e9 s ni na ape m\u00f4 na gb\u00fbng\u00fb n\u00ee t\u00ee aw\u00e2, na m\u00f4 y\u00e2ng\u00e2 k\u00e9t\u00e9 t\u00ee \ny\u00e2ng\u00e2 k\u00e9t\u00e9 s. Na s ni l\u00e2i na k\u00e9t\u00e9 ng\u00e2, y\u00e2ng\u00e2 t\u00ee mo so yeke t\u00ee g\u00e2p\u00eeng\u00ee na tii na k\u00e9t\u00e9 ng\u00e2. \nL\u00e2s\u00f4: mo so s\u00f4k\u00f4 na k\u00e9t\u00e9 ni na l\u00eatr\u00ea na d\u00ee na k\u00f4zo na gb\u00fbng\u00fb. \nL\u00e2s\u00f4:\nselect_words ==> [\"little\"]\nselect_words ==> [\"Mary\", \"lamb\"]\nselect_words ==> []\nselect_words ==> [\"world\"]\nselect_words ==> [\"Uncle\"]\"\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word.\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    get_closest_vowel ==> \"u\"\n    get_closest_vowel ==> \"U\"\n    get_closest_vowel ==> \"\"\n    get_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Here is the translation of the given text into Sango:\n\nNa yeke ti na arr ti bangui na kpi ti gobo na ti kue k, kumbite na tenena ti kpepe na \n    ti k na yeke na ti bangui kpepe na ti yeke na arr.\n\n    Example1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Noti:\n        1. Yeke ti arr ke yeke na ti ke na nzoni ti [1, 1000].\n        2. Kpepe ti na arr ke yeke na ti ke na nzoni ti [-1000, 1000].\n        3. 0 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\nNa s\u00f4 k\u00e8 na t\u00ee y\u00e2ng\u00e2 t\u00ee mo m\u00fb n\u00ee, m\u00e8 y\u00e2ng\u00e2 t\u00ee mo na t\u00ee m\u00fb na mbi t\u00ee mb\u00ean\u00ee mb\u00ean\u00ee k\u00eat\u00ea t\u00ee mo m\u00fb n\u00ee.\n\nNd\u00e2-am\u00e2:\n\nsolution ==> 12\nsolution ==> 9\nsolution ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Given na arr\u00e9 non-vide ti integers arr na integer k, zia\n    sombe ti elements a yeke na mata mb\u00e9ni na mata mbala ti zo na k\u00e9t\u00e9 ti k elements ti arr.\n\n    Exempeli:\n\n        Input: arr = [111, 21, 3, 4000, 5, 6, 7, 8, 9], k = 4\n        Output: 24 # sombe ti 21 + 3\n\n    Constraints:\n        1. 1 <= len <= 100\n        2. 1 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Here is the translation of the given sentence into Sango:\n\nNgambiri n na k\u00e9t\u00e9 t\u00ee mo, zo yeke zia lisiti yeke ngbanga na yeke ng\u00e2 se ti yeke k\u00eat\u00ea ti Collatz.\n\n    La conjecture de Collatz na mbeni conjecture na matemati ti yeke ngbanga na t\u00ee la s\u00e9quence na yeke k\u00fb\u00ea h\u00e2la t\u00ee la ti k\u00eat\u00ea na y\u00ea. Zia na yeke ng\u00e2 se t\u00ee yeke k\u00eat\u00ea na y\u00ea. T\u00ee zo yeke gb\u00ea t\u00ee la t\u00e8r\u00e8, si yeke k\u00eat\u00ea na y\u00ea yeke ng\u00e2 se t\u00ee yeke k\u00eat\u00ea na y\u00ea. Si yeke k\u00eat\u00ea na y\u00ea yeke y\u00e2ng\u00e2, k\u00eat\u00ea yeke l\u00e2k\u00fb\u00e2 t\u00ee yeke k\u00eat\u00ea na y\u00ea yeke t\u00ee t\u00ee yeke b\u00e2 t\u00ee la yeke k\u00eat\u00ea na y\u00ea. Si yeke b\u00e2 yeke ng\u00e2 se t\u00ee yeke k\u00eat\u00ea na y\u00ea yeke b\u00e2 t\u00ee 3 t\u00ee yeke k\u00eat\u00ea na y\u00ea plus 1. La conjecture yeke na si yeke k\u00eat\u00ea na y\u00ea b\u00e2 t\u00ee 1.\n\n    Note:\n        1. Collatz yeke [1].\n        2. lisiti yeke ngbanga na yeke ng\u00e2 se t\u00ee yeke y\u00e2ng\u00e2 na y\u00e2ng\u00e2.\n\n    Par exemple:\n    get_odd_collatz yeke [1, 5] # La s\u00e9quence de collatz pour 5 yeke [5, 16, 8, 4, 2, 1], donc yeke ng\u00e2 se yeke b\u00e2 t\u00ee 1, et 5.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Mo yeke ti ku fa ore na ti yeke ti validate lo date string ti a na,\n    mo yeke ti ngbanga True soko na date a yeke valid, soko te False.\n    Date a yeke valid soko na ni ala ti yeke zo:\n    1. Date string a yeke ngangu.\n    2. Tene ti yeke soko na 1 te soko na 31 tene ti yeke 1,3,5,7,8,10,12. Na tene ti yeke soko na 1 te soko na 30 tene ti yeke 4,6,9,11. Na tene ti yeke soko na 1 te soko na 29 tene ti yeke 2.\n    3. Tene ti yeke soko na 1 te soko na 12.\n    4. Date a yeke be format ti: mm-dd-yyyy\n\n    mbeti ti:\n    valid_date => True\n\n    valid_date => False\n\n    valid_date => False\n\n    valid_date => True\n\n    valid_date => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\nA la ti yeke zo kozo na k\u00e9t\u00e9 gb\u00e9ni,\n    na kozo eko ngangu ki k\u00e9t\u00e9 na mbanda. Na yeke ti ngangu ke, kozo = =.\n    Kozo eko ti gb\u00e9ni e yeke zo kozo ngangu ki a n\u00ee nga vw\u00e2 na b\u00eean\u00ee.\n    Na kozo eko ti yeke ngangu, a la yeke ti ngangu ti vw\u00e2 ke na b\u00eean\u00ee.\n    L\u00e2 gonda na kozo eko ti yeke ngangu, a yeke ti vw\u00e2 la yeke na nd\u00e2 b\u00eean\u00ee.\n    T\u00ee y\u00e2 gonda, t\u00ee yeke ti tongana s\u00f4 y\u00e9 ti nzoni ngangu ti zo kozo eko\n    ti yeke so k\u00e9t\u00e9 gb\u00e9ni na yeke zo mbeti.\n    Na yeke ti ngangu, nzoni ti kozo, na yeke\n    so y\u00e9 ti k\u00ead\u00e8 na yeke 1, so a yeke so, a la yeke mbeti.\n    S\u00f4 y\u00e9 ti k\u00ead\u00e8 ti nzoni ngangu a yeke zo mbeti, am\u00e2 \"YES\",\n    am\u00e2, \"NO\".\n    S\u00f4 kozo eko ti gb\u00e9ni la yeke zo nzoni, am\u00e2 \"NO\".\n\n    [mbongo\/sango] na la ti b\u00e2:\n    kozo,) ==> \"NO\"\n    kozo,) ==> \"NO\"\n    kozo,) ==> \"YES\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the array, represented by 1, -1 or 0. Note: return None for empty arr.\n\nIn Sango:\n\nAla na gango ti ayeke arr ti mingi na mo na mo yeke muana suma ti magnitudes ti mingi na mo ti muana na product ti signs nzo a mingi na arr, ti zo representations 1, -1 ni 0. Note: muana None ke ala arr ti zo so ke nda.\n\nExample:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Here is the translation of the given sentence into Sango:\n\nDoni na ng\u00fbmb\u00f4 na N mbeti na N mbeti na ng\u00e2 n\u00ee k\u00fbw\u00e2 t\u00e2 mbi, mbeti k\u00fbw\u00e2 na ng\u00e2 k\u00fbi. Mb\u00ean\u00ee ng\u00e2 na k\u00f4d\u00f6r\u00f6 [1, N * N] k\u00fbw\u00e2 ng\u00e2 y\u00e9 mbi t\u00e2 mbi na mbeti ng\u00fbmb\u00f4.\n\nMbi m\u00f4 y\u00ea ti k\u00fby\u00ea nd\u00e2 ti ng\u00e2 mb\u00e2 t\u00e2 mbi k\u00fbi k na ng\u00fbmb\u00f4. Mbi m\u00f4 y\u00ea ti y\u00ea na mbeti k\u00fbi k\u00fbe, na b\u00e2si mbi m\u00f4 y\u00ea ti s\u00f4 na mbeti k\u00fbi, mbi m\u00f4 ti ga na mbeti k\u00fbi b\u00ea na b\u00e2ti na mbeti mbi y\u00ea na l\u00e2 mbi.\n\nMbi m\u00f4 l\u00e2 ti mbi m\u00f4 b\u00e2si na ng\u00fbmb\u00f4. Nd\u00e2 A ti b\u00e2ti na nd\u00e2 B s\u00f2, la b\u00e2ti na nd\u00e2 ti ng\u00e2 na mbeti ti A na B b\u00e2ti na, lst_A ti b\u00e2ti na lst_B mb\u00ean\u00ee nd\u00e2 ti b\u00e2ti na lst_B, na m\u00f4 b\u00e2ti na ng\u00e2 na index i s\u00f2 lst_A[i] < lst_B[i] na mbi m\u00f4 b\u00e2ti na ng\u00e2 na j lst_A[j] = lst_B[j].\n\nNa m\u00f4 b\u00e2ti na ng\u00e2 ti b\u00e2ti na y\u00ea.\n\nReturne nd\u00e2 ti mbeti ng\u00e2 na k\u00fbi na nd\u00e2 ti k\u00fbi k.\n\nB\u00e2ng\u00e2:\n\nInput: ng\u00fbmb\u00f4 = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\nOutput: [1, 2, 1]\n\nInput: ng\u00fbmb\u00f4 = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\nOutput: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n\"S\u00eanga ala ye na mo t\u00ee Fibonacci, da nzo n\u00ee na h\u00fbnb\u00e2 na mab\u00fbku na y\u00e2ng\u00e2 t\u00ee matem\u00e2t\u00eek\u00ee na mbi t\u00e2r\u00ee k\u00eat\u00ea-k\u00eat\u00ea. Be, na k\u00eat\u00ea-k\u00eat\u00ea ti y\u00e2ng\u00e2, mo b\u00e2a y\u00e2 t\u00ee Tribonacci. Tribonacci gb\u00e2 t\u00ee y\u00e2ng\u00e2 na s\u00f4:\n\ntri = 3\ntri = 1 + n \/ 2, s\u00f4 n gb\u00e2 t\u00ee m\u00f4k\u00f4.\ntri = tri + tri + tri, s\u00f4 n gb\u00e2 t\u00ee m\u00f4k\u00f4.\n\nD\u00e2 na s\u00ean\u00ee:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n          = 2 + 3 + 3 = 8\n\nMo b\u00e2a \u00ear\u00ea na m\u00f4k\u00f4 t\u00ee m\u00f4 n\u00ee na p\u00eape, mo b\u00e2a y\u00ea l\u00e2s\u00f4 t\u00ee t\u00ee y\u00e2ng\u00e2 na gb\u00fbng\u00fb t\u00ee n + 1 n\u00ee na Tribonacci. \nD\u00e2 na s\u00ean\u00ee:\ntri = [1, 3, 2, 8]\"\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Ok, here is the translation of the given sentence into Sango:\n\nKeba mo na nza ya ti nzoni kue, yeke na mbeti ti nzoni na nzoni. \n    Yeke na 0 soko mo nzoni ti mbi a zo kue. \n    Ndakisa:\n    digits  == 1\n    digits  == 0\n    digits == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\nA yeke kodoro ti nomboro.\nA yeke h\u00fb na lo kodoro ti nomboro na nzoni ti nomboro na yeke kodoro,\n    k\u00eat\u00ea na kodoro ti yeke na bong\u00f4 ti mbi ti nzoni t\u00eer\u00ea na mbi ti k\u00eat\u00ea.\n    Nd\u00e2 t\u00ee k\u00eat\u00ea:\n    S\u00f4 kodoro = [1,2,3] fa lo yeke 14\n    S\u00f4 kodoro = [1,4,9] fa lo yeke 98\n    S\u00f4 kodoro = [1,3,5,7] fa lo yeke 84\n    S\u00f4 kodoro = [1.4,4.2,0] fa lo yeke 29\n    S\u00f4 kodoro = [-2.4,1,1] fa lo yeke 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\nT\u00eengbi m\u00f4 k\u00e2ti b\u00e2a ti mbi t\u00e2mbi gb\u00fbngbi na gbeg\u00e2 t\u00ee gango n\u00ee azo k\u00fb\u00ea n\u00ee a y\u00ea t\u00ee t\u00e2 t\u00e2mbi na mbi t\u00e2mbi gb\u00fbngbi na yang\u00e2 n\u00ee a g\u00eel\u00ee na mbi t\u00e2mbi na y\u00e2ng\u00e2 n\u00ee a t\u00e2. S\u00f4 n\u00ee azo n\u00ee a y\u00ea t\u00ee t\u00e2 \u00e2la n\u00ee a y\u00e2ng\u00e2, mbi t\u00e2mbi -1. Gb\u00e2 t\u00e2ngana n\u00ee a t\u00e2 ng\u00e2 na mbi b\u00e2a n\u00ee a t\u00e2 k\u00fb\u00ea ti t\u00e2gbo.\n\nD\u00ea t\u00e2ngana:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Here is the translation of the given sentence into Sango:\n\n**Sango:**\n\n\"Libanda na k\u00eat\u00ea t\u00ee gbata k\u00fb\u00ea t\u00ee y\u00e2ng\u00e2, ng\u00fbbi, d\u00ea ng\u00e2 t\u00ee y\u00e2ng\u00e2 t\u00ee zo t\u00ee t\u00eer\u00ee k\u00ea, na yeke t\u00ee b\u00e2a gbata k\u00fb\u00ea gb\u00fbngbi na k\u00eat\u00ea t\u00ee s\u00f4 a s\u00e8mb\u00ea na gb\u00fbngbi. \nYeke t\u00ee b\u00e2a 'None' s\u00f4 d\u00f4 t\u00ee y\u00e2ng\u00e2 a s\u00e8mb\u00ea na k\u00eat\u00ea t\u00ee y\u00e2ng\u00e2 s\u00f4 a s\u00e8mb\u00ea na gbata k\u00fb\u00ea.\n\nMb\u00ean\u00ee: S\u00f4 ng\u00fbbi t\u00ee y\u00e2ng\u00e2 a s\u00e8mb\u00ea na d\u00ea, gb\u00fbngbi t\u00ee ng\u00fbbi a s\u00e8mb\u00ea . d\u00f4 , \n\ncompare_one \u00e2 -> 2.5\ncompare_one \u00e2 -> \"2,3\"\ncompare_one \u00e2 -> \"6\"\ncompare_one \u00e2 -> None\"\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Here is the translation of the sentence into Sango:\n\n\"Tene s\u00f4 ndoyi n m\u00f4 k\u00fb\u00ea ti mbi \u00e2la zo s\u00eangi t\u00ee 4 zo s\u00eangi t\u00ee ngangu s\u00eangi.\"\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial = n! *! *! * ... * 1!\n    where n > 0\n\n    For example:\n\nIn Sango:\n\nFactorial ti Brazilia a h\u00eeng\u00ee na:\n    brazilian_factorial = n! *! *! * ... * 1!\n    na n ga mbi 0\n\n    Na ngangu:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Here is the translation of the sentence into Sango:\n\nSi t\u00eengb\u00ef t\u00eengb\u00ef text, gbet\u00e9 tuku na z\u00eando na underscor\u00e9,\nna s\u00ef t\u00eengb\u00ef a yeke kp\u00e2 t\u00ee 2 tuku z\u00eando na ekand\u00e9,\nmbeni gbet\u00e9 tuku z\u00eando na ekand\u00e9 na -.\n\nfix_spaces == \"Example\"\nfix_spaces == \"Example_1\"\nfix_spaces == \"_Example_2\"\nfix_spaces == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Here's the translation of the given sentence into Sango:\n\nKp\u1ecdngbi na f\u01ddn ti angb\u01dd nzoni ti s\u01ddng\u01dd-nd\u01ddng\u01dd na k\u01dd yeke gb\u01ddnza nzoni ti s\u01ddng\u01dd-nd\u01ddng\u01dd, lo yeke k\u01ddr\u01dd 'Yes' s\u01ddng\u01dd-nd\u01ddng\u01dd na a mbeti, lo yeke k\u01ddr\u01dd 'No' s\u01ddng\u01dd-nd\u01ddng\u01dd na a mbeti t\u01ddn\u01dd. Nzoni ti s\u01ddng\u01dd-nd\u01ddng\u01dd na a mbeti s\u01ddng\u01dd t\u01ddn\u01dd s\u01ddng\u01dd a yeke na k\u01ddr\u01dd t\u01ddn\u01dd:\n- S\u01ddng\u01dd yeke kod\u01dd k\u01ddta t\u01ddngi t\u01ddm\u01dd na t\u01ddng\u025br\u025b na nzoni ti s\u01ddng\u01dd-nd\u01ddng\u01dd.\n- Nzoni ti s\u01ddng\u01dd-nd\u01ddng\u01dd yeke kod\u01dd na t\u01ddngi t\u01dd m\u0254ng\u0254 ' . '\n- Nzoni ti s\u01ddng\u01dd-nd\u01ddng\u01dd na t\u01ddngi ' . ' t\u01ddn\u01dd a yeke kod\u01dd a mbeti, lo a yeke k\u01ddt\u01ddr\u01dd na nzapa ti alfab\u025b.\n- Nzoni ti s\u01ddng\u01dd-nd\u01ddng\u01dd na t\u01ddngi ' . ' t\u01ddn\u01dd a yeke kod\u01dd a mbeti, lo a yeke k\u01ddt\u01ddr\u01dd na nzapa ti alfab\u025b.\nNgbaraz\u0254:\nfile_name_check # => 'Yes'\nfile_name_check # => 'No'\n\nNote: Sango is a trade language spoken in the Central African Republic and it may not have direct translations for some technical terms.\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\n\"Fa na k\u00fbta ti mbi na y\u00e2ng\u00e2 t\u00ee mingi ti m\u00f4k\u00f4. K\u00eat\u00ea t\u00ee y\u00e2ng\u00e2 k\u00fbta na k\u00fbta-n\u00ee, fa na mbi y\u00e2ng\u00e2 k\u00fbta m\u00f4k\u00f4 so na index t\u00ee l\u00e2 na k\u00eat\u00ea t\u00ee 3, na mbi k\u00fbta m\u00f4k\u00f4 so na index t\u00ee l\u00e2 na k\u00eat\u00ea t\u00ee 4 na na k\u00eat\u00ea t\u00ee 3. Fa na mbi y\u00e2ng\u00e2 k\u00fbta so na index t\u00ee l\u00e2 na k\u00eat\u00ea t\u00ee 3 na 4. Fa na mbi y\u00e2ng\u00e2 t\u00ee mbi na mbi y\u00e2ng\u00e2 t\u00ee mbi k\u00eat\u00ea t\u00ee mbi.\n\nExemple:\nFa y\u00e2ng\u00e2 t\u00ee lst = [1,2,3] fa y\u00e2ng\u00e2 t\u00ee mbi na 6\nFa y\u00e2ng\u00e2 t\u00ee lst = [] fa y\u00e2ng\u00e2 t\u00ee mbi na 0\nFa y\u00e2ng\u00e2 t\u00ee lst = [-1,-5,2,-1,-5] fa y\u00e2ng\u00e2 t\u00ee mbi na -126\"\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len <= 100\n        * sentence contains only letters\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Here's a function in Python that will simplify the expression `x * n` and determine if it evaluates to a whole number. The function assumes that `x` and `n` are strings representing fractions in the form `<numerator>\/<denominator>`.\n\n```python\nfrom fractions import Fraction\n\ndef simplify:\n    # Convert the string representation of fractions to Fraction objects\n    frac_x = Fraction\n    frac_n = Fraction\n    \n    # Multiply the fractions\n    result = frac_x * frac_n\n    \n    # Check if the result is a whole number\n    return result.denominator == 1\n\n# Test cases\nprint)  # True\nprint)  # False\nprint)  # False\n```\n\n### Explanation:\n1. **Fraction Conversion**: The `Fraction` class from Python's `fractions` module is used to convert the string representations of the fractions into `Fraction` objects.\n2. **Multiplication**: The two `Fraction` objects are multiplied.\n3. **Whole Number Check**: The resulting `Fraction` object is checked to see if its denominator is 1, which indicates that the fraction is a whole number.\n\n### Test Cases:\n- `simplify` returns `True`: \\ which is a whole number.\n- `simplify` returns `False`: \\ which is not a whole number.\n- `simplify` returns `False`: \\ which is not a whole number.\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Sorry, but I can't generate a translation for that text into Sango.\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Here is the translated sentence in Sango:\n\nSoko na k\u00fbnda ti yeke na mbeti ti mo na yeke na ab\u00e2 ti mo na yeke na n\u00ee ti \u00e2ng\u00e2 ti nz\u00f6n\u00ee ti yeke na 10 na kuma ng\u00e2 t\u00ee k\u025b na k\u025b t\u00ee nz\u00f6n\u00ee na nd\u00e2 na yeke na 1, 3, 5, 7, 9. Na k\u00f4zo na: specialFilter => 1 specialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Here is the translation of the given sentence into Sango:\n\nMoto mo yeke na mo yeke na ti n. Mo yeke na nga na integer array a ti gou n.\n    Tene ake i, tene ti a[i] = i * i - i + 1.\n    Mbi yeke na mo yeke na bele ti triples ti a na yeke i < j < k,\n    na a[i] + a[j] + a[k] na yeke na multiple ti 3.\n\n    Ngangu:\n        Kete: n = 5\n        Ngangu: 1\n        L\u00e2nda ngangu:\n        a = [1, 3, 7, 13, 21]\n        Triples ti yeke na s\u00f4 \u00e9.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Tere ti na funzo t\u00ee na akepe na y\u00e2ng\u00e2 mbeni ti lo,\n    l\u00e2 zar\u00e2 y\u00e2ng\u00e2 t\u00ee mo gbeganga y\u00e2 y\u00e2ng\u00e2 na mo,\n    na \u00e2kpunga y\u00e2ng\u00e2 t\u00ee lo gbeganga na nd\u00e2 mb\u00ean\u00ee,\n    Y\u00e2ng\u00e2 t\u00ee lo na y\u00e2ng\u00e2 t\u00ee mbeni na mwa na y\u00e2ng\u00e2 t\u00ee mo,\n    na lo yeke na y\u00e2ng\u00e2 t\u00ee nduli t\u00ee mo k\u00fb\u00ea.\n    K\u00eat\u00ea na y\u00e2ng\u00e2 t\u00ee lo na b\u00e2 t\u00ee nd\u00e2 na nd\u00e2 t\u00ee gbeganga t\u00ee mo,\n    na mo yeke \u00e2kpunga y\u00e2ng\u00e2 t\u00ee lo gbeganga na nd\u00e2 mb\u00ean\u00ee na nd\u00e2 t\u00ee b\u00ea y\u00e2ng\u00e2 t\u00ee mo.\n    S\u00f4 t\u00ee nd\u00e2 y\u00e2ng\u00e2 b\u00eean\u00ee yeke na y\u00e2ng\u00e2 t\u00ee mo, gbeganga y\u00e2ng\u00e2 t\u00ee lo na mwa na mwa.\n    Funzo t\u00ee mo yeke \u00e2kpunga y\u00e2ng\u00e2 t\u00ee mbeni na nd\u00e2 mb\u00ean\u00ee.\n    Mo yeke ny\u00e2ng\u00e2 na y\u00e2ng\u00e2 n\u00ee na y\u00e2ng\u00e2 \u00e2k\u00f4k\u00f4.\n    Mo yeke na:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Here is the translation of the sentence into Sango:\n\n\"Kozo na mbeti so a la na kpanga x s\u00f4 nzo n gbanga t\u00ee \n    ngangu na a la na kpanga y m\u00f4.\"\n\n    \"K\u00eat\u00ea-k\u00eat\u00ea:\n    mbeti za y\u00e2ng\u00e2 7, 34, 12 so a la kpanga 34\n    mbeti za y\u00e2ng\u00e2 15, 8, 5 so a la kpanga 5\"\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Na t\u00eengbi na yeke mbi ala k\u00eat\u00ea t\u00ee gb\u00f4nda na wal\u00ee na zo y\u00ea na t\u00eer\u00ee likundu, k\u00eat\u00ea t\u00ee nzoni y\u00e2ng\u00e2 t\u00ee na long\u00f4ko t\u00ee likundu. Na long\u00f4ko na na t\u00eengbi na y\u00ea, da yeke na nd\u00e2nzi na y\u00e2ng\u00e2 mb\u00ean\u00ee na mb\u00ean\u00ee.\n\nMo nd\u00e2 ti mo na ni y\u00ea na nd\u00e2 t\u00ee na yeke t\u00ee nd\u00e2 t\u00ee na y\u00ea t\u00ee likundu t\u00ee match mingi. Mo yeke t\u00ee r\u00eer\u00ee mab\u00f4ko 2 t\u00ee scores na guesses t\u00ee match mingi, na maboko ti y\u00e2ng\u00e2 na match mingi. Mo yeke t\u00ee kp\u00e4ng\u00f6 maboko na match mingi, na match mingi. S\u00f4, s\u00f4 \u00e2 na guesses na y\u00ea t\u00ee match mingi, \u00e2 lingbi \u00e2 na 0. S\u00f4 \u00e2 na guesses na y\u00ea t\u00ee match mingi, \u00e2 lingbi \u00e2 na.\n\nD\u00f4 yeke t\u00ee nd\u00e2 t\u00ee na long\u00f4ko t\u00ee match mingi na guesses t\u00ee match mingi.\n\nexemple:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Here is the translation of the provided sentence into Sango:\n\n```\nE ti ga h\u00fbku na ng\u00e2 t\u00e2ngana ti klass\u00ea na mbeti ti extension. \nMbeti ti extension ti yeke ga m\u00een\u00ee na klass\u00ea k\u00f4zo. \nL\u00e2s\u00f4 ti extension a h\u00fbku na k\u00f4zo a yeke ng\u00ee, fa CAP a yeke m\u00fb na t\u00e2ngana ti lettr\u00ea ti ng\u00fbbi na t\u00e2ngana ti extension, na fa SM a yeke m\u00fb na t\u00e2ngana ti lettr\u00ea ti ng\u00fbngi na t\u00e2ngana ti extension, l\u00e2s\u00f4 ti yeke CAP - SM. \nE ti ga kp\u00eal\u00ee extension ti ng\u00ee na ga kp\u00eal\u00ee t\u00e2ngana k\u00f4zo na format k\u00f4zo: ClassName.StrongestExtensionName.\nS\u00f4 e ti tene mbeti ti extension ti ng\u00ee na l\u00e2s\u00f4 ti yeke l\u00e2s\u00f4 s\u00f4 e yeke na ng\u00e2, e ti ga yeke na l\u00e2s\u00f4 s\u00f4 a yeke na lege ti mbeti.\nNg\u00e2, s\u00f4 e yeke na \"Slices\" na klass\u00ea na mbeti ti extension: ['SErviNGSliCes', 'Cheese', 'StuFfed'], e ti ga yeke 'Slices.SErviNGSliCes' fa 'SErviNGSliCes' a yeke extension ti ng\u00ee.\nNg\u00e2:\nS\u00f4 Strongest_Extension == 'my_class.AA'\n```\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Oko na yeke 2 ngangu. Mo yeke na ala ifo ti ngangu na iyeke na k\u00e9t\u00e9 ti yeke ngangu na k\u00e9t\u00e9 na awali ti ngangu na yeke k\u00e9t\u00e9 na zo na yeke ngangu na yeke k\u00e9t\u00e9.\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Here is the sentence translated into Sango:\n\n\"Na ni koko na yeke na ni, kodro na koko na yeke na mbi na kodro na koko na yeke na mbi.\"\n\n     Example:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Na yeke ti yeke na nd\u0254r\u0254 yeke, mbi yeke romani numeri ye na string,\n    na mbi gbenge na a ni na ti ni na nd\u0254r\u0254.\n\n    Bokilo: 1 <= num <= 1000\n\n    Nzoni nzoni:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"T\u00eengbi na t\u00eer\u00eengbi ti na yeke lis\u00e4 ti mo t\u00ee k\u00fb\u00ease ti y\u00e2ng\u00e2.\n    Lis\u00e4 a yeke mo t\u00ee k\u00fb\u00ease ti mbi\u00e2ng\u00f6. K\u00fb\u00ease na nz\u00f6n\u00ee t\u00ee mo t\u00ee y\u00e2ng\u00e2\n    t\u00ee gb\u00fbngbi t\u00ee nz\u00f6n\u00ee ti \u00e2b\u00fbng\u00f6-y\u00e2ng\u00e2. S\u00f4k\u00ee na mo t\u00ee gb\u00fbngbi t\u00ee nz\u00f6n\u00ee ti \u00e2b\u00fbng\u00f6-y\u00e2ng\u00e2,\n    a f\u00e2 k\u00fb\u00ease na y\u00e2ng\u00e2 na mb\u00ean\u00ee t\u00ee \u00e2b\u00fbng\u00f6-y\u00e2ng\u00e2 na lis\u00e4.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    A la Sango, la phrase traduite serait :\n\nOzo yeke ng\u00fbb\u00e2 t\u00ee y\u00e2ng\u00e2 t\u00ee k\u00fbku, na mo b\u00e2a r\u00e2 mo yeke s\u00f4 k\u00fbku mingi,\nk\u00e2 na mo yeke s\u00f4 k\u00fbku mingi t\u00ee k\u00fb\u00e9 t\u00ee l\u00eas\u00f4 t\u00ee na.\nMo yeke b\u00e2a h\u00fbnda na [ mo b\u00e2a s\u00f4 k\u00fbku na l\u00eas\u00f4 t\u00ee na,\n                        k\u00fbku mingi t\u00ee b\u00e2a na l\u00eas\u00f4 t\u00ee na ]\ns\u00f4 k\u00fbku mingi t\u00ee b\u00e2a na mo yeke b\u00e2a k\u00fbku mingi t\u00ee b\u00e2a, k\u00e2 mo yeke b\u00e2a ng\u00fbb\u00e2.\n\nD\u00e8ng\u00f6:\n* k\u00fbe -> [11, 4]\n* k\u00fbe -> [12, 1]\n* k\u00fbe -> [11, 0]\n* k\u00fbe -> [7, 0]\n\nVariables:\n@number : integer\n    k\u00fbku mingi t\u00ee mo b\u00e2a s\u00f4.\n@need : integer\n    k\u00fbku mingi t\u00ee mo yeke s\u00f4.\n@remaining : integer\n    k\u00fbku mingi t\u00ee b\u00e2a na mo yeke b\u00e2a na ng\u00fbnda t\u00ee k\u00fbku\n\nD\u00fbng\u00f6:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nBara mb\u00ean\u00ee! :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    T\u00eengbi na y\u00e2ng\u00e2 t\u00ee y\u00e2ng\u00e2 t\u00ee \u00e2s\u00eer\u00ee na operand. Y\u00e2ng\u00e2 t\u00ee y\u00e2ng\u00e2 t\u00ee \u00e2s\u00eer\u00ee gb\u00eean\u00ee ayeke na mo t\u00ee siriri t\u00ee algebra k\u00eat\u00ea, na y\u00e2ng\u00e2 t\u00ee operand gb\u00eean\u00ee ayeke na mo t\u00ee nz\u00f6n\u00ee t\u00ee kir\u00eeri. Z\u00eea y\u00e2ng\u00e2 t\u00ee \u00e2s\u00eer\u00ee na y\u00e2ng\u00e2 t\u00ee operand t\u00ee g\u00fblu t\u00ee siriri t\u00ee algebra na f\u00e2 t\u00ee h\u00eeng\u00ee t\u00ee siriri na yeke na t\u00ee z\u00eea k\u00fb\u00ea t\u00ee h\u00eeng\u00ee na.\n\nSiriri t\u00ee algebra k\u00eat\u00ea:\nT\u00eemb\u00fb\nK\u00eer\u00ee\nN\u00eag\u00eal\u00ea\nDivisi\u00f4n t\u00ee b\u00e2d\u00f4\nExponenti\u00e2ti\u00f4n\n\nNg\u00e2:\n\u00e2s\u00eer\u00ee['+', '*', '-']\narray = [2, 3, 4, 5]\nh\u00eeng\u00ee = 2 + 3 * 4 - 5\n=> h\u00eeng\u00ee = 9\n\nNg\u00e2 t\u00ee n\u00ee:\n    Ng\u00e2 t\u00ee y\u00e2ng\u00e2 t\u00ee \u00e2s\u00eer\u00ee ayeke k\u00eat\u00ea na ng\u00e2 t\u00ee y\u00e2ng\u00e2 t\u00ee operand t\u00ee b\u00e2d\u00f4 k\u00eat\u00ea.\n    Operand ayeke y\u00e2ng\u00e2 t\u00ee kir\u00eeri t\u00ee b\u00e2d\u00f4-s\u00ee.\n    Y\u00e2ng\u00e2 t\u00ee \u00e2s\u00eer\u00ee ayeke na \u00e2s\u00eer\u00ee k\u00eat\u00ea na y\u00e2ng\u00e2 t\u00ee operand ayeke na kir\u00eeri k\u00eat\u00ea.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Here is the translation of the given sentence into Sango:\n\nA la yeke nzoni s.\n    si s[i] nye t\u00ee na, t\u00e9ng\u00e4 t\u00ee na k\u00eat\u00ea t\u00ee mbi t\u00ee nd\u00e2k\u00f4ro na k\u00eat\u00ea t\u00ee mbi t\u00ee nd\u00e2, \n    ala y\u00e2ngi nga mbi t\u00ee tene.\n    Si nzoni a yeke na t\u00ee na, t\u00e9ng\u00e4 nzoni.\n    Fini a la yeke soro nzoni t\u00ee t\u00e9ng\u00e4.\n    D\u00f6n\u00ee t\u00ee ngangu\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Sango: \n\nSe lo na leng\u00f6 'text', t\u00eengana kodoro nd\u00ea md5 t\u00ee 'text'.\n    Se lo na leng\u00f6 'text' kodoro gb\u00fbngbi, z\u00eea None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Donni mo ti yeke k\u00e9t\u00e9 k\u00e9t\u00e9 a na b ti mo, mo ti yeke kpanga mbi ti k\u00e9t\u00e9 k\u00e9t\u00e9 na mo ti yeke yeke na a na b, lo yeke ngangu.\n\nNa mo ti yeke na:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]