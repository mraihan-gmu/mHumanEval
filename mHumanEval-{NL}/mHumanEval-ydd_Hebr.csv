prompt,canonical_solution,test
"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" פֿאַרזיכערן אויב אין דער געגעבן ליסטע פון נומערן זענען צוויי נומערן נענטער צו יעדער אַנדערער ווי דער געגעבן שוועל.
    בײַשפּיל:
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

"
"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" די איינגעבן צו דער פונקציע איז אַ שטריקל וואָס אַנטהאַלט מערערע גרופּעס פֿון נעסטעד פּאַרענטהעסעס. דיין ציל איז צו
    צעטיילן די גרופּעס אין באַזונדערע שטריקלעך און צוריקגעבן אַ ליסטע פֿון די.
    באַזונדערע גרופּעס זענען באַלאַנסט און נישט נעסטעד איינער אין דעם אַנדערן.
    איגנאָרירן אַלע ספּייסעס אין דער איינגעבן שטריקל.
    ביישפּיל:
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    """"""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
"
"

def truncate_number(number: float) -> float:
    """""" געגעבן אַ positive floating point נומער, קען מען עס אָפּטיילן אין אַ גאַנץ טייל און די דעצימאַלן.

צוריקגעבן די דעצימאַלן טייל פון דעם נומער.
ביישפּיל:
    >>> truncate_number(3.5)
    0.5
    """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
"
"from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" איר זענט געגעבן אַ רשימה פון דיפּאַזיט און אָפּנעמונג אָפּעראַציעס אויף אַ באַנק אַקאַונט וואָס הייבט זיך אָן מיט 
    נול באַלאנס. אייער אַרבעט איז צו דעטעקטירן אויב אין קיין פונט די באַלאנס פון דעם אַקאַונט געפאַלן אונטער נול, און
    אין יענעם פונט זאָל דער פאַנגקשאַן צוריקקומען אמת. אַנדערש זאָל עס צוריקקומען פאַלש.
    ביישפּיל:
    >>> below_zero([1, 2, 3])
    False
    >>> below_zero([1, 2, -4, 5])
    True
    """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
"
"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" פֿאַר אַ געגעבן רשימה פֿון אַרײַנגעבנדיקע נומערן, רעכענען די מיטל אַבסאָלוטע אָפּווייכונג
    אַרום דעם דורכשניט פֿון דעם דאַטאַ-זאַמלונג.
    מיטל אַבסאָלוטע אָפּווייכונג איז דער דורכשניט פֿון די אַבסאָלוטע דיפערענצן
    צווישן יעדן עלעמענט און אַ צענטערפּונקט:
    MAD = דורכשניט | x - x_mean |
    בײַשפּיל:
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

"
"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" אײַנפֿירן אַ נומער 'delimiter' צווישן יעדע צוויי נאָכפאָלגיקע עלעמענטן פֿון דער אַרײַנגעבענער ליסטע `numbers'
    >>> intersperse([], 4)
    []
    >>> intersperse([1, 2, 3], 4)
    [1, 4, 2, 4, 3]
    """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
"
"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" די אריינגאַבע צו דער פֿונקציע איז אַ שטריקל וואָס רעפּרעזענטירט מערערע גרופעס פֿאַר נעסטעד פּאַרענטהעסעס צעשיידט דורך ספּייסעס.
    פֿאַר יעדער גרופּע, געבן די טיף פון דער העכסטער נעסטינג פון פּאַרענטהעסעס.
    למשל) האָט די מאַקסימום פון צוויי לעוועלן פון נעסטינג בשעת)) האָט דריי.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
"
"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" פֿילטער אַן אַרײַנלייגן רשימה פון שטריקלעך נאָר פֿאַר די וואָס אַנטהאַלטן אַ געגעבן סובסטרינג
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
"
"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" פֿאַר אַ געגעבן ליסטע פון ​​גאַנץ נומערן, צוריקקומען אַ טאָפּל באַשטייענדיק פון אַ סך און אַ פּראָדוקט פון אַלע די גאַנץ נומערן אין דער ליסטע.
    אַ ליידיק סך זאָל זיין גלייך צו 0 און אַ ליידיק פּראָדוקט זאָל זיין גלייך צו 1.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
"
"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" פֿון אַ געגעבן רשימה פון גאַנץ נומערן, דזשענערירן אַ רשימה פון ראָלינג מאַקסימום עלעמענט געפֿונען ביז דעם געגעבן מאָמענט אין דער סיקוואַנס.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    [1, 2, 3, 3, 3, 4, 4]
    """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
"
"

def is_palindrome(string: str) -> bool:
    """""" פּרוּוו צו זען צי די געגעבן שטריק איז אַ פּאַלינדראָם """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    ''
    >>> make_palindrome('cat')
    'catac'
    >>> make_palindrome('cata')
    'catac'
    """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
"
"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" די אַרײַננעמען זענען צוויי שטריקלען ""a"" און ""b"" וואָס באַשטייען בלויז פֿון ""1"" און ""0"".
    דורכפירן ביינערי XOR אויף די אַרײַננעמען און געבן צוריק דעם רעזולטאַט אויך ווי אַ שטריקל.
    >>> string_xor('010', '110')
    '100'
    """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
"
"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" אויס דער רשימה פֿון שטרענגלעך, צוריקקומען דעם לענגסטן. צוריקקומען דעם ערשטן אין פאַל פון מערערע שטרענגלעך מיט דער זעלבער לענג. צוריקקומען קיין איין אין פאַל די אַרײַנפֿיר רשימה איז ליידיק.
    >>> longest([])

    >>> longest(['a', 'b', 'c'])
    'a'
    >>> longest(['a', 'bb', 'ccc'])
    'ccc'
    """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
"
"

def greatest_common_divisor(a: int, b: int) -> int:
    """""" צוריקגעבן אַ גרעסטע געמיינזאַמע דיביזאָר פון צוויי אינטעדזשערס אַ און ב
    >>> greatest_common_divisor(3, 5)
    1
    >>> greatest_common_divisor(25, 15)
    5
    """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
"
"from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Here is the translation of the sentence into Eastern Yiddish:

צוריקגעבן אַ ליסטע פֿון אַלע פאָרווערטס פֿון קיצער צו לענגער פֿון דער אַרײַנשרײַב סטרינג
    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
"
"

def string_sequence(n: int) -> str:
    """""" צוריקגעבן אַ שטריק וואָס אַנטהאַלט נומערן באַשיידן מיט פּלאַץ, אָנהייבנדיק פון 0 אַרויף צו n אַרײַנגערעכנט.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
"
"

def count_distinct_characters(string: str) -> int:
    """""" געגעבן אַ שטריק, געפֿינען וויפֿל באַזונדערע אותיות עס באַשטייט פון.
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
"
"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Here is the translation of the given sentence into Eastern Yiddish:

די אַרייַנשרייַב פֿאַר דער פאַנגקציע איז אַ שטריקל וואָס רעפּרעזענטירט מוזיקאַלישע נאָטן אין אַ ספּעציעלן אַסקי פֿאָרמאַט.
    אײַער אַרבעט איז צו פּאַרסירן דעם שטריקל און צוריקגעבן אַ ליסטע פֿון גאַנץ צאָלן וואָס קאָראַספּאָנדירן צו ווי פֿיל ביץ יעדער נאָט אַנהאַלט.

    דאָ איז אַ לעגענדע:
    'o' - גאַנצע נאָט, האַלט אַרבע ביץ
    'o|' - האַלב נאָט, האַלט צוויי ביץ
    '.|' - קוואַרט נאָט, האַלט איין ביץ

    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """"""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
"
"

def how_many_times(string: str, substring: str) -> int:
    """""" געפֿינען ווי פילע מאָל אַ געgebn substring קען gefunen ווערן אין דער אָריגינעל string. ציילן oiberlapndike פאַלן.
    >>> how_many_times('', 'a')
    0
    >>> how_many_times('aaa', 'a')
    3
    >>> how_many_times('aaaa', 'aa')
    3
    """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Here's the translation of the given sentence into Eastern Yiddish:

אײַנפֿיר איז אַ פּלאַץ-געטיילט סטרינג פֿון נומעראַלן פֿון 'נול' ביז 'נײַן'.
    גילטיק אָפּציעס זענען 'נול', 'אײנס', 'צװײ', 'דרײַ', 'פֿיר', 'פֿינף', 'זעקס', 'זיבן', 'אַכט' און 'נײַן'.
    צוריקגעבן די שטריקל מיט נומערן סאָרטירט פֿון קלענסטער ביז גרעסטער.

Please note that transliterations and translations can vary slightly depending on regional dialects and spelling conventions in Yiddish.
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" פֿון אַ געגעבן רשימה פֿון נומערן אויסקלויבן און צוריקגעבן צוויי וואָס זענען די נענטסטע צו יעדער אנדערער און צוריקגעבן זיי אין סדר.
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

"
"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" געגעבן אַ ליסטע פון נומערן, אָנווענד אַ לינעאַרע טראַנספאָרם צו דער ליסטע, אַז דער קלענסטער נומער וועט ווערן 0 און דער גרעסטער וועט ווערן 1.
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
"
"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" פֿילטערט די געgebene ליסטע פֿון קיין פּייטער ווערטן נאָר פֿאַר גאַנץ נומערן.
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
"
"

def strlen(string: str) -> int:
    """""" צוריק געבן די לענג פון דער געגעבן שטריקל
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
"
"

def largest_divisor(n: int) -> int:
    """""" פֿאַר אַ געגעבן נומער n, געפֿינען דעם גרעסטער נומער וואָס צעטיילט n גלייַך, קלענערער ווי n
    >>> largest_divisor(15)
    5
    """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
"
"from typing import List


def factorize(n: int) -> List[int]:
    """""" Here is the translation of the given sentence into Eastern Yiddish:

גיט אַ רשימה פון פּרימע פאַקטאָרן פון דער געגעבן צאָל אין דער אָרדענונג פֿון קלענסטער צו גרעסטער.
יעדער פון די פאַקטאָרן זאָל ווערן געוויזן אַזוי פיל מאָל ווי ער קומט פֿאַר אין דער פאַקטאָריזאַציע.
דער אַרײַננעמען צאָל זאָל זיין גלייך צו דער פּראָדוקט פון אַלע פאַקטאָרן.
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
"
"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" פֿון אַ ליסטע פֿון גאַנץ נומערן, אַוועקנעמען אַלע עלעמענטן וואָס קומען פֿאָר מער ווי איינמאָל.
האַלטן די אָרדענונג פֿון די איבערגעבליבענע עלעמענטן די זעלבע ווי אין די אַרײַנשרײַב.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
"
"

def flip_case(string: str) -> str:
    """""" פֿאַר אַ געגעבן שטריקל, קער קליינע אותיות צו גרויסע און גרויסע צו קליינע.
    >>> flip_case('Hello')
    'hELLO'
    """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
"
"from typing import List


def concatenate(strings: List[str]) -> str:
    """""" צונויפֿשטעלן אַ ליסטע פון שטריקלעך אין אַ איין שטריק
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
"
"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" פֿילטער אַ אַרײַנלייגן רשימה פֿון סטרונגען נאָר פֿאַר די וואָס הייבן זיך אָן מיט אַ געגעבן פּרעפֿיקס.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
"
"

def get_positive(l: list):
    """"""רוקן נאָר פּאָזיטיווע נומערן אין די ליסטע.
    >>> get_positive([-1, 2, -4, 5, 6])
    [2, 5, 6]
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    [5, 3, 2, 3, 9, 123, 1]
    """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

"
"

def is_prime(n):
    """"""גיב צוריק אמת אויב אַ געגעבן נומער איז אַ פּריים, און פֿאַלש אַנדערש.
    >>> is_prime(6)
    False
    >>> is_prime(101)
    True
    >>> is_prime(11)
    True
    >>> is_prime(13441)
    True
    >>> is_prime(61)
    True
    >>> is_prime(4)
    False
    >>> is_prime(1)
    False
    """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

"
"import math


def poly(xs: list, x: float):
    """"""
    Evaluירט פּאָלינאָם מיט קאָעפֿיציענטן xs ביי פונט x.
    צוריקקומען xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"

def sort_third(l: list):
    """"""די פֿונקציע נעמט אַ ליסטע ל און גיט צוריק אַ ליסטע ל' וואָס איז אידענטיש צו ל אין די אינדיצעס וואָס זענען נישט צעטיילט בײַ דרײַ, בשעת אירע ווערטן בײַ די אינדיצעס וואָס זענען צעטיילט בײַ דרײַ זענען גלײַך צו די ווערטן פֿון די פֿאַרבונדענע אינדיצעס פֿון ל, נאָר זיינען אָרדענונגסווייז געשטעלט.
    >>> sort_third([1, 2, 3])
    [1, 2, 3]
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    [2, 6, 3, 4, 8, 9, 5]
    """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

"
"

def unique(l: list):
    """"""צוריקגעבן סאָרטירטע ייחודדיקע עלעמענטן אין אַ ליסטע
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

"
"

def max_element(l: list):
    """"""צוריקגעבן דעם גרעסטן עלעמענט אין דער ליסטע.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
"
"

def fizz_buzz(n: int):
    """"""Returning די צאָל מאל וואס דער ציפער 7 ערשיינט אין גאַנצע נומערן ווייניקער ווי n וואָס זענען צעטיילט דורך 11 אָדער 13.
    >>> fizz_buzz(50)
    0
    >>> fizz_buzz(78)
    2
    >>> fizz_buzz(79)
    3
    """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

"
"

def sort_even(l: list):
    """"""די פֿונקציע נעמט אַ ליסטע \ און צוריקגעבט אַ ליסטע \ אַזאַ אַז
    \ איז אידענטיש צו \ אין די אומגעראַדע אינדעקסן, בשעת די ווערטער אויף די גלײַכע אינדעקסן זענען גלײַך
    צו די ווערטער פון די גלײַכע אינדעקסן אין \, אָבער סאָרטירט.
    >>> sort_even([1, 2, 3])
    [1, 2, 3]
    >>> sort_even([5, 6, 3, 4])
    [3, 6, 5, 4]
    """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

"
"

def encode_cyclic(s: str):
    """"""
    פֿאַרקערט די שטריקל דורך קרייזן גרופּעס פֿון דריי אותיות.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

"
"

def prime_fib(n: int):
    """"""
    prime_fib באַקומט צוריק דעם n-טן נומער וואָס איז אַ פֿיבאָנאַצי נומער און עס איז אויך פּריים.
    >>> prime_fib(1)
    2
    >>> prime_fib(2)
    3
    >>> prime_fib(3)
    5
    >>> prime_fib(4)
    13
    >>> prime_fib(5)
    89
    """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

"
"

def triples_sum_to_zero(l: list):
    """"""
    טריפּאַלז_צונויִף_צו_נול נעמט אַ ליסטע פון גאַנצע נומערן ווי אַן אַריינגאַבע.
    עס גיט צוריק אמת אויב עס זענען דריי באַזונדערע עלעמענטן אין דער ליסטע וואָס
    צונויפֿנעמען צו נול, און פֿאַלש אַנדערש.

    >>> triples_sum_to_zero([1, 3, 5, 0])
    False
    >>> triples_sum_to_zero([1, 3, -2, 1])
    True
    >>> triples_sum_to_zero([1, 2, 3, 7])
    False
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    True
    >>> triples_sum_to_zero([1])
    False
    """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

"
"

def car_race_collision(n: int):
    """"""
    שטעל זיך פאָר אַ וועג וואָס איז אַ גאַנץ גלייַך אומענדיק לאַנג ליניע.
נ קאַרס פֿאָרן פֿון לינקס צו רעכט; אין דער זעלבער צייט, אַ אַנדערע גרופּע פֿון נ קאַרס פֿאָרן פֿון רעכט צו לינקס. די צוויי גרופּעס פֿון קאַרס הייבן אָן צו זיין זייער ווייַט פֿון
איינער דעם אנדערן. אַלע קאַרס פֿאָרן מיט דער זעלבער גיכקייט. צוויי קאַרס ווערן געזאָגט אַז זיי האָבן זיך צוזאַמענגעשטויסן ווען אַ קאַר וואָס פֿאָרט פֿון לינקס צו רעכט שלאָגט אַן קאַר וואָס פֿאָרט פֿון רעכט צו לינקס.
אָבער, די קאַרס זענען אומענדיק שטאַרק און האַרט; אינעם רעזולטאַט, זיי פאָרזעצן צו פֿאָרן אויף זייער טרייעקטאָריע ווי אויב זיי האָבן זיך נישט צוזאַמענגעשטויסן.

די פֿונקציע גיט אַרויס די צאָל פֿון אַזעלכע צוזאַמענשטויסן.
    """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

"
"

def incr_list(l: list):
    """"""צוריקגעבן אַ רשימה מיט עלעמענטן וואָס זענען פאַרגרעסערט מיט 1.
    >>> incr_list([1, 2, 3])
    [2, 3, 4]
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [6, 4, 6, 3, 4, 4, 10, 1, 124]
    """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

"
"

def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero נעמט אַ ליסטע פון גאַנץ צאָלן ווי אַ אַריינגאַבע.
    עס גיט צוריק אמת אויב עס זענען צוויי אַנדערש עלעמענטן אין די ליסטע וואָס
    צוזאַמען רעכענען צו נול, און פאלש אַנדערש.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

"
"

def change_base(x: int, base: int):
    """"""בײַטן די נומערישע באַזע פון דער אַרײַנמיש נומער x צו דער נייַער באַזע.
    צוריקגעבן אַ שטריקל-פֿאַרטרעטונג נאָך דער איבערפֿירונג.
    די באַזע נומערן זענען ווייניקער ווי 10.
    >>> change_base(8, 3)
    '22'
    >>> change_base(8, 2)
    '1000'
    >>> change_base(7, 2)
    '111'
    """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

"
"

def triangle_area(a, h):
    """"""געגעבן די לענג פון אַ זייט און די הייך, צוריקקומען די שטח פון אַ דריי־עק.
    >>> triangle_area(5, 3)
    7.5
    """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

"
"

def fib4(n: int):
    """"""די Fib4 נומער סיקוואַנס איז אַ סיקוואַנס ענלעך צו דער פיבאָנאַטשי סיקוואַנס וואָס איז דעפֿינירט ווי פאלגנד:
    fib4 -> 0
    fib4 -> 0
    fib4 -> 2
    fib4 -> 0
    fib4 -> fib4 + fib4 + fib4 + fib4.
    ביטע שרייב אַ פונקציע צו עפעקטיוו רעכענען דעם n-טן עלעמענט פון דער Fib4 נומער סיקוואַנס.  ניצ נישט רעקורסיע.
    >>> fib4(5)
    4
    >>> fib4(6)
    8
    >>> fib4(7)
    14
    """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

"
"

def median(l: list):
    """"""צוריקגעבן די מידיאַן פון עלעמענטן אין דער ליסטע l.
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

"
"

def is_palindrome(text: str):
    """"""
    פּרüפֿט אױב די געgebענער שטריק איז אַ פּאַלינדראָמע
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

"
"

def modp(n: int, p: int):
    """"""צוריקגעבן 2^n מאָדולאָ p.
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

"
"

def encode_shift(s: str):
    """"""
    גיט צוריק אַן קאָדירטע שטריקל דורך שיפן יעדן כאַראַקטער מיט 5 אין דעם אַלף-בית.
    """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""
    takes as input string encoded with encode_shift function. Returns decoded string.
    """"""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

"
"

def remove_vowels(text):
    """"""
    remove_vowels איז אַ פֿונקציע וואָס נעמט אַ שטריק און גיט צוריק אַ שטריק אָן קלאַנגען.
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"

def below_threshold(l: list, t: int):
    """"""גיב צוריק אמת אויב אַלע נומערן אין דער ליסטע ל זענען נידעריקער ווי דער גרענעץ t.
    >>> below_threshold([1, 2, 4, 10], 100)
    True
    >>> below_threshold([1, 20, 4, 10], 5)
    False
    """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

"
"

def add(x: int, y: int):
    """"""צולייג צוויי נומערן x און y
    >>> add(2, 3)
    5
    >>> add(5, 7)
    12
    """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

"
"

def same_chars(s0: str, s1: str):
    """"""
    פּרüף אויב צוויי ווערטער האָבן די זעלבע אותיות.
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
    True
    >>> same_chars('abcd', 'dddddddabc')
    True
    >>> same_chars('dddddddabc', 'abcd')
    True
    >>> same_chars('eabcd', 'dddddddabc')
    False
    >>> same_chars('abcd', 'dddddddabce')
    False
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
    False
    """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

"
"

def fib(n: int):
    """"""צוריקגעבן די נ-טע פיבאָנאַטשי נומער.
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

"
"

def correct_bracketing(brackets: str):
    """""" ברעקעטס איז אַ קייט פון ""<"" און "">"". 
    צוריקקומען אמת אויב יעדער עפֿענונג ברעקעט האט אַ קאָרעספּאָנדירנדיק פאַרמאַכונג ברעקעט.

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"

def monotonic(l: list):
    """"""צוּריקגעבן אמת אויב די עלעמענטן פון דער ליסטע זענען מאָנאָטאָניש העכערנדיק אָדער נידעריגנדיק.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

"
"

def common(l1: list, l2: list):
    """"""צוריקגעבן סאָרטירטע ייחידיגע געמיינזאמע עלעמענטן פאר צוויי ליסטעס.
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

"
"

def largest_prime_factor(n: int):
    """"""גיט צוריק דעם גרעסטן פּרימען פאַקטאָר פון n. נעמט אָן אַז n > 1 און איז נישט אַ פּרימען.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

"
"

def sum_to_n(n: int):
    """"""sum_to_n איז אַ פֿונקציע וואָס צוזאַמענרעכנט נומערן פֿון 1 ביז n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

"
"

def correct_bracketing(brackets: str):
    """""" ברעקעטס זענען אַ שטריקל פון """".
    צוריקקומען אמת אויב יעדער עפֿענונג ברעקעט האט אַ קאָררעספּאָנדירנדיק קלאָוזינג ברעקעט.

    >>> correct_bracketing(""("")
    False
    >>> correct_bracketing(""()"")
    True
    >>> correct_bracketing(""(()())"")
    True
    >>> correct_bracketing("")(()"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

"
"

def derivative(xs: list):
    """""" xs באַדייטן קאָעפֿיציענטן פֿון אַ פּאָלינאָם.
    xs[0] + xs[1] * x + xs[2] * x^2 + ....
     צוריקגעבן די אַבגעלייטע פֿון דעם פּאָלינאָם אין דער זעלבער פֿאָרעם.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

"
"

def fibfib(n: int):
    """"""דער פֿיבפֿיב נומער סאַקווענס איז אַ סאַקווענס ענלעך צו דער פֿיבאָנאַטשי סאַקווענס וואָס איז דעפֿינירט ווי קומט:
    פֿיבפֿיב == 0
    פֿיבפֿיב == 0
    פֿיבפֿיב == 1
    פֿיבפֿיב == פֿיבפֿיב + פֿיבפֿיב + פֿיבפֿיב.
    ביטע שרייַבן אַ פֿונקציע צו עפעקטיוו רעכענען דעם ן-טן עלעמענט פון דער פֿיבפֿיב נומער סאַקווענס.
    >>> fibfib(1)
    0
    >>> fibfib(5)
    4
    >>> fibfib(8)
    24
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

"
"
FIX = """"""
פאַרגרעסער די צאָל טעסטן.
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count(""abcde"")
    2
    >>> vowels_count(""ACEDY"")
    3
    """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def circular_shift(x, shift):
    """"""איבערדרייען די ציפערן פונעם גאַנץ נומער x, שיף די ציפערן רעכט דורך שיף
    און צוריקגעבן די רעזולטאט ווי אַ שטריקל.
    אויב שיף > צאָל ציפערן, צוריקגעבן די ציפערן איבערגעקערט.
    >>> circular_shift(12, 1)
    ""21""
    >>> circular_shift(12, 2)
    ""12""
    """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def digitSum(s):
    """"""Here's the translated sentence in Eastern Yiddish:

""אויפגאַבע 
שרייב אַ פֿונקציע וואָס נעמט אַ שטריקל ווי אַרײַנשרײַב און גיט צוריק דעם סך פון די אַסקי קאָדן פון בלויז די גרויסע אותיות.""

Be aware that the technical terminology and code-related terms might not have direct translations in Yiddish, so maintaining the original terms is important for clarity.
    """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

"
"
def fruit_distribution(s,n):
    """"""
    אין דעם טאַסק, איר וועט באַקומען אַ שטריקל וואָס רעפּרעזענטירט אַ נומער פון עפּל און מאַראַנצן 
    וואָס זענען פאַרשפּרייט אין אַ קאָרב פון פרוכט. דער קאָרב כּולל 
    עפּל, מאַראַנצן, און מאַנגאָ פרוכטן. גיוון די שטריקל וואָס רעפּרעזענטירט די גאַנץ נומער פון 
    די מאַראַנצן און עפּל און אַ גאַנץ נומער וואָס רעפּרעזענטירט די גאַנץ נומער פון די פרוכטן 
    אין דעם קאָרב, צוריקקומען די נומער פון די מאַנגאָ פרוכטן אין דעם קאָרב.
    למשל:
    fruit_distribution -> 19 - 5 - 6 = 8
    fruit_distribution -> 3 - 0 - 1 = 2
    fruit_distribution -> 100 - 2 - 3 = 95
    fruit_distribution -> 120 - 100 - 1 = 19
    """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
"
"
def pluck(arr):
    """"""
    Here is the translation of the given sentence into Eastern Yiddish:

""געגעבן אַ אַרייַ, וואָס רעפּרעזענטירט אַ צווייג פֿון אַ בוים מיט ניט-נעגאַטיווע גאַנצע נאָדן,
    אײַער אַרבעט איז צו צאַפּן איינער פֿון די נאָדן און צוריקגעבן עס.
    דער צאַפּטער נאָד זאָל זײַן דער נאָד מיט דעם קלענסטן גראַד אונדזער ווערט.
    אויב עס געפֿינען זיך מערערע נאָדן מיט דער זעלבער קלענסטער גראַד אונדזער ווערט, צוריקגעבן דעם נאָד וואָס האָט דעם קלענסטן אינדעקס.

    דער צאַפּטער נאָד זאָל צוריקגעגעבן ווערן אין אַ ליסטע, [ קלענסטער_ווערט, זײַן אינדעקס ],
    אויב עס זענען נישטאָ קיין גראַד אונדזער ווערטן אָדער דער געגעבן אַרייַ איז ליידיק, צוריקגעבן [].

    בײַשפּיל1:
        אַרײַנגעבן: [4,2,3]
        אַרויסגעבן: [2, 1]
        ערקלערונג: 2 האָט די קלענסטע גראַד אונדזער ווערט, און 2 האָט די קלענסטע אינדעקס.

    בײַשפּיל2:
        אַרײַנגעבן: [1,2,3]
        אַרויסגעבן: [2, 1]
        ערקלערונג: 2 האָט די קלענסטע גראַד אונדזער ווערט, און 2 האָט די קלענסטע אינדעקס.

    בײַשפּיל3:
        אַרײַנגעבן: []
        אַרויסגעבן: []

    בײַשפּיל4:
        אַרײַנגעבן: [5, 0, 3, 0, 4, 2]
        אַרויסגעבן: [0, 1]
        ערקלערונג: 0 איז דער קלענסטער ווערט, אָבער עס זענעןאָ צוויי נולן,
                     אַזוי מיר וועלן אויסקלײַבן דעם ערשטן נול, וואָס האָט דעם קלענסטן אינדעקס.

    באדינגונגען:
        * 1 <= nodes.length <= 10000
        * 0 <= node.value""
    """"""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

"
"
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

"
"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"
def smallest_change(arr):
    """"""
    געגעבן אַן אַרײַ פון גאַנץ צאָלן, געפֿינען די מינימאַלע צאָל עלעמענטן וואָס דאַרפֿן צו ווערן געענדערט כּדי צו מאַכן די אַרײַ פאלינדראָמיש. אַן אַרײַ וואָס איז פאלינדראָמיש איז אַן אַרײַ וואָס לייענט זיך די זעלבע צוריק און פֿאָרויס. אין איין ענדערונג, קען מען טוישן איין עלעמענט צו קיין אַנדערן עלעמענט.

פֿאַר בײַשפּיל:
smallest_change == 4
smallest_change == 1
smallest_change == 0
    """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

"
"
def total_match(lst1, lst2):
    '''
    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.

    Examples
    total_match([], []) â -> []
    total_match(['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi']
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin']
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi']
    total_match(['4'], ['1', '2', '3', '4', '5']) â -> ['4']
    '''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

"
"
def is_multiply_prime(a):
    """"""שרײַבט אַ פֿונקציע וואָס אָפּגעבן אמת אויב דער געגעבן נומער איז די מאַלטיפּליקאַציע פון 3 פּריימ נומערן
    און פאַלש אַנדערש.
    וויסנדיק אַז איז ווייניקער ווי 100.
    בײַשפּיל:
    is_multiply_prime == אמת
    30 = 2 * 3 * 5
    """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

"
"
def is_simple_power(x, n):
    """"""אייער אַרבעט איז צו שרייַבן אַ פֿונקציע וואָס געבט צוריק אמת אויב אַ נומער x איז אַ פּשוטער מאַכט פֿון n און פֿאַלש אין אַנדערע פאַלן.
    x איז אַ פּשוטער מאַכט פֿון n אויב n**int=x
    צום ביישפּיל:
    is_simple_power => אמת
    is_simple_power => אמת
    is_simple_power => אמת
    is_simple_power => פֿאַלש
    is_simple_power => פֿאַלש
    is_simple_power => פֿאַלש
    """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

"
"
def hex_key(num):
    """"""איר האָט באַקומען די אָפּלייג צו שרייבן אַ פֿונקציע וואָס נעמט אַ העקסאַדעצימאַלע נומער ווי אַ שטריקל און ציילט די צאָל העקסאַדעצימאַלע ציפֿער וואָס זענען פּריימז.
העקסאַדעצימאַלע ציפֿער זענען 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.
פּראַיים נומערן זענען 2, 3, 5, 7, 11, 13, 17,...
אַזוי איר דאַרפֿט באַשטימען אַ צאָל פֿון די פֿאָלגנדיקע ציפֿער: 2, 3, 5, 7, B, D.
נאָטיץ: איר מעגט אָנווײַזן אַז דער אַרײַנפֿיר איז שטענדיק ריכטיק אָדער אַ ליידיק שטריקל, 
און סימבאָלן A,B,C,D,E,F זענען שטענדיק גרויסע.
בײַשפּילן:
פֿאַר נומער = ""AB"" זאָל דער רעזולטאַט זײַן 1.
פֿאַר נומער = ""1077E"" זאָל דער רעזולטאַט זײַן 2.
פֿאַר נומער = ""ABED1A33"" זאָל דער רעזולטאַט זײַן 4.
פֿאַר נומער = ""123456789ABCDEF0"" זאָל דער רעזולטאַט זײַן 6.
פֿאַר נומער = ""2020"" זאָל דער רעזולטאַט זײַן 2.
    """"""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

"
"
def decimal_to_binary(decimal):
    """"""איר וועט באַקומען אַ נומער אין דעצימאַל פאָרם און אייער אַרבעט איז עס צו קאָנווערטירן אין בינאַריש פֿאָרמאַט. די פֿונקציע זאָל צוריקגעבן אַ שטריקל, מיט יעדער כאַראַקטער רעפּרעזענטירנדיק אַ בינאַרישן נומער. יעדער כאַראַקטער אין דעם שטריקל וועט זײַן '0' אָדער '1'.

עס וועלן זײַן אַ פּאָר עקסטרע כאַראַקטערן 'db' אין דער אָנהייב און אין דער ענדע פונעם שטריקל. די עקסטרע כאַראַקטערן זענען דאָ צו העלפֿן מיטן פֿאָרמאַט.

ביישפּילן:
decimal_to_binary   # גיט צוריק ""db1111db""
decimal_to_binary   # גיט צוריק ""db100000db""
    """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def is_happy(s):
    """"""איר ווערן געגעבן אַ שטריקל s.
    אייער אַרבעט איז צו קאָנטראָלירן צי די שטריקל איז פריילעך אָדער נישט.
    א שטריקל איז פריילעך אויב זײַן לענג איז בייַ מינדסטער 3 און יעדער 3 נאָכפאָלגנדיקע אותיות זענען אַנדערש.
    צום בייַשפּיל:
    is_happy => נישט
    is_happy => נישט
    is_happy => יא
    is_happy => נישט
    is_happy => יא
    is_happy => נישט
    """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
"
"
def numerical_letter_grade(grades):
    """"""די לעצטע וואָך פון דעם סעמעסטער און דער לערער דאַרף געבן די גראַדעס צו די סטודענטן. דער לערער האָט געמאכט איר אייגענע אַלגערידם פֿאַר גראַדינג. דער איינציקער פּראָבלעם איז, זי האָט פֿאַרלוירן דעם קאָד וואָס זי האָט גענוצט פֿאַר גראַדינג. זי האָט דיר געגעבן אַ ליסטע פון GPAס פֿאַר עטלעכע סטודענטן און דו דאַרפסט שרייבן אַ פֿונקציע וואָס קען אויסגעבן אַ ליסטע פון בריוו גראַדעס ניצנדיק די פֿאלגנדע טאַבלע:
             GPA       |    בריוו גראַד
              4.0                A+
            > 3.7                A 
            > 3.3                A- 
            > 3.0                B+
            > 2.7                B 
            > 2.3                B-
            > 2.0                C+
            > 1.7                C
            > 1.3                C-
            > 1.0                D+ 
            > 0.7                D 
            > 0.0                D-
              0.0                E

    בײַשפּיל:
    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']
    """"""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def prime_length(string):
    """"""שרייב אַ פֿונקציע וואָס נעמט אַ שטריק און געבט צוריק אמת אויב די לענג פון דעם שטריק איז אַ פּריים נומער אָדער פֿאַלש אַנדערש.
ביישפילן:
prime_length == אמת
prime_length == אמת
prime_length == אמת
prime_length == פֿאַלש
    """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

"
"
def starts_one_ends(n):
    """"""
    געגעבן אַ פּאָזיטיווע גאַנצער נומער n, צוריקקומען די ציילונג פון די נומערן פון n-ציפֿער פּאָזיטיווע גאַנץ נומערן וואָס הייבט זיך אן אָדער ענדיקט זיך מיט 1.
    """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def solve(N):
    """"""געבן אַ positive גאַנץ N, צוריקקומען די גאַנץ סאַכאַקל פון זײַנע ציפֿערן אין בּינאַר.

    בײַשפּיל
        פֿאַר N = 1000, די סאַכאַקל פֿון ציפֿערן וועט זײַן 1, די רעזולטאַט זאָל זײַן ""1"".
        פֿאַר N = 150, די סאַכאַקל פֿון ציפֿערן וועט זײַן 6, די רעזולטאַט זאָל זײַן ""110"".
        פֿאַר N = 147, די סאַכאַקל פֿון ציפֿערן וועט זײַן 12, די רעזולטאַט זאָל זײַן ""1100"".
    
    וועריאַבלן:
        @N גאַנץ נומער
             באַגרענעצונגען: 0 ≤ N ≤ 10000.
    רעזולטאַט:
         אַ שטריקל פֿון אַ בּינאַר נומער
    """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

"
"
def add(lst):
    """"""געגעבן אַ ניט-ליידיק ליסטע פון גאנצע נומערן lst. צוגעבן די פּאַריקע עלעמענטן וואָס זענען אויף אוד נומערן.

    ביישפילן:
        add ==> 2 
    """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
"
"
def anti_shuffle(s):
    """"""
    Here is the translation of the sentence into Eastern Yiddish:

שרײַב אַ פֿונקציע וואָס נעמט אַ שטריק און גיט אַ באַשטעלט ווערסיע פֿון אים.
    באַשטעלט ווערסיע פֿון שטריק איז אַ שטריק וווּ אַלע ווערטער
    ווערן פֿאַרבײַט מיט אַ נײַ וואָרט וווּ אַלע די אותיות זענען אָראַנזשירט אין
    העכערנדיקער סדר לויטן אַסציי ווערט.
    באַמערקונג: דו זאָלסט האַלטן דעם סדר פֿון ווערטער און ליידיקע פּלאַץ אין דער זאַץ.

    למשל:
    anti_shuffle גיט צוריק 'Hi'
    anti_shuffle גיט צוריק 'ehllo'
    anti_shuffle גיט צוריק 'Hello !!!Wdlor'
    """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def get_row(lst, x):
    """"""
    איר זענט געגעבן צוויי דימענסיאָנאַלע דאטן, ווי גענעסטעטע ליסטעס,
    וואָס איז ענלעך צו אַ מאַטריץ, אָבער אַנדערש ווי מאַטריצן,
    יעדער ריי קען אַנטהאַלטן אַ אַנדערע צאָל פון שפאלטן.
    געגעבן ליסטע, און אַ גאַנץ נומער x, געפֿינען גאַנץ נומערן x אין דער ליסטע,
    און צוריקקומען אַ ליסטע פון טאָפּלען, [, ...] אַזוי אַז
    יעדער טאָפּל איז אַ קאָאָרדינאַט -, אָנהייבנדיק פון 0.
    סאָרטירט די קאָאָרדינאַטן ערשט דורך רייען אין אַסענדינג סדר.
    אויך, סאָרטירט די קאָאָרדינאַטן פון דער ריי דורך שפאלטן אין דעסענדינג סדר.
    
    ביישפילן:
    get_row([
      [1,2,3,4,5,6],
      [1,2,3,4,1,6],
      [1,2,3,4,5,1]
    ], 1) == [,,,,]
    get_row == []
    get_row == []
    """"""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def sort_array(array):
    """"""
    געגעבן אַן אָרייַ פון נישט-נעגאַטיווע גאַנץ נומערן, צוריקגעבן אַ קאָפּיע פון דעם געגעבן אָרייַ נאָך סאָרטירן.
    איר וועט סאָרטירן דעם געגעבן אָרייַ אין אויפשטייגנדיקער סדר אויב די סך איז אָדד,
    אָדער סאָרטירן עס אין אַבשטייגנדיקער סדר אויב די סך איז עווען.

    באמערקונגען:
    * טו נישט טוישן דעם געגעבן אָרייַ.

    ביישפילן:
    * sort_array => []
    * sort_array => [5]
    * sort_array => [0, 1, 2, 3, 4, 5]
    * sort_array => [6, 5, 4, 3, 2, 1, 0]
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"
def encrypt(s):
    """"""שאַפֿן אַ פונקציע ""encrypt"" וואָס נעמט אַ שטריקל ווי אַ טענה און
    צוריקגעבן אַ שטריקל פאַרקריפּט מיט דעם אַלף-בית וואָס איז ראָוטייטיד. 
    דער אַלף-בית זאָל זיין ראָוטייטיד אויף אַ וועג אַז די אותיות 
    שיפט אַראָפּ מיט צוויי געמולטיפּלiziert צו צוויי ערטער.
    צום בײַשפּיל:
    encrypt צוריקגעבט 'lm'
    encrypt צוריקגעבט 'ewhjklnop'
    encrypt צוריקגעבט 'kj'
    encrypt צוריקגעבט 'ix'
    """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def next_smallest(lst):
    """"""
    איר האָט אַ ליסטע פֿון גאַנץ-צאָלן.
שרייב אַ פֿונקציע next_smallest וואָס געבט צוריק דעם צווייטן קלענסטן עלעמענט פֿון דער ליסטע.
געב צוריק None אויב עס איז נישטאָ אַזאַ עלעמענט.

next_smallest == 2
next_smallest == 2
next_smallest == None
next_smallest == None
    """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def is_bored(S):
    """"""
    איר וועט באַקומען אַ שטריק פון ווערטער, און אייער אַרבעט איז צו ציילן די נומער פון נודניסן. אַ נודניס איז אַ זאַץ וואָס הייבט זיך אָן מיטן וואָרט ""איך"". זאצן ווערן אָפּגעטיילט דורך '.', '?' אָדער '!'.

פֿאַר בײַשפּיל:
    >>> is_bored(""Hello world"")
    0
    >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
    1
    """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def any_int(x, y, z):
    '''
    Create a function that takes 3 numbers.
    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
    Returns false in any other cases.
    
    Examples
    any_int(5, 2, 7) â -> True
    
    any_int(3, 2, 2) â -> False

    any_int(3, -2, 1) â -> True
    
    any_int(3.6, -2.2, 2) â -> False
  

    
    '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

"
"
def encode(message):
    """"""
    שרײַבן אַ פֿונקציע וואָס נעמט אַ מעסעדזש און קאָדירט עס אַזוי אַז עס טוישט די קאַסע פון אַלע אותיות, און פאַרבײַט אַלע וואָקאַלן אין דעם מעסעדזש מיט די אות וואָס איז 2 ערטער פאָרויס פון דעם וואָקאַל אין דעם ענגלישן אַלפאַבעט.
נעמט אָן בלויז אותיות.

בײַשפּילן:
    >>> encode('test')
    'TGST'
    >>> encode('This is a message')
    'tHKS KS C MGSSCGG'
    """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def skjkasdkd(lst):
    """"""איר האָט אַ רשימה פון אינטעגערס.
איר דאַרפֿן צו געפֿינען די גרעסטע פּריים ווערט און צוריקקומען דער סומע פון ​​זיינע ציפערן.

ביישפילן:
פֿאַר ליסט = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] די רעזולטאַט זאָל זיין 10
פֿאַר ליסט = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] די רעזולטאַט זאָל זיין 25
פֿאַר ליסט = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] די רעזולטאַט זאָל זיין 13
פֿאַר ליסט = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] די רעזולטאַט זאָל זיין 11
פֿאַר ליסט = [0,81,12,3,1,21] די רעזולטאַט זאָל זיין 3
פֿאַר ליסט = [0,8,1,2,1,7] די רעזולטאַט זאָל זיין 7
    """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
"
"
def check_dict_case(dict):
    """"""
    געגעבן אַ ווערטערבוך, אומקערן אמת אויב אַלע שליסלען זענען סטרונעס אין נידעריקער פאַל אָדער אַלע שליסלען זענען סטרונעס אין העכער פאַל, אַנדערש אומקערן פאַלש.
די פֿונקציאָנירן זאָל אומקערן פאַלש אויב די געגעבן ווערטערבוך איז ליידיק.
ביישפילן:
check_dict_case זאָל אומקערן אמת.
check_dict_case זאָל אומקערן פאַלש.
check_dict_case זאָל אומקערן פאַלש.
check_dict_case זאָל אומקערן פאַלש.
check_dict_case זאָל אומקערן אמת.
    """"""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

"
"
def count_up_to(n):
    """"""אויספירן אַ פונקציע וואָס נעמט אַ נישט-נעגאַטיוון גאַנץ צאָל און צוריקגעבן אַ עריי פון די ערשטע n
    גאַנץ צאָלן וואָס זענען פּריים נומערן און ווייניקער ווי n.
    פֿאַר בייַשפּיל:
    ציילן_ביז => [2,3]
    ציילן_ביז => [2,3,5,7]
    ציילן_ביז => []
    ציילן_ביז => [2,3,5,7,11,13,17,19]
    ציילן_ביז => []
    ציילן_ביז => [2,3,5,7,11,13,17]
    """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

"
"
def multiply(a, b):
    """"""פֿאַרענדיקן די פֿונקציע וואָס נעמט צוויי אינטיגערס און גיט צוריק 
    די פּראָדוקט פֿון זייערע איינס-ציפֿער.
    נעמט אָן אַז די אַרײַנגעבן איז שטענדיק גילטיק.
    ביישפּילן:
    multiply זאָל צוריקגעבן 16.
    multiply זאָל צוריקגעבן 72.
    multiply זאָל צוריקגעבן 0.
    multiply זאָל צוריקגעבן 20.
    """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

"
"
def count_upper(s):
    """"""
    פֿאַראַן אַ שטריק s, צייל די נומער פון גרויס-אותיות וואָקאַלן אויף גלײַכע אינדעקסן.

    צום בײַשפּיל:
    count_upper געבט צוריק 1
    count_upper געבט צוריק 0
    count_upper געבט צוריק 0
    """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def closest_integer(value):
    '''
    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Examples
    >>> closest_integer(""10"")
    10
    >>> closest_integer(""15.3"")
    15

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For Exampleclosest_integer(""14.5"") should
    return 15 and closest_integer(""-14.5"") should return -15.
    '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

"
"
def make_a_pile(n):
    """"""
    געגעבן אַ positive גאַנץ נומער n, דו מוזסט מאַכן אַ באַרג פון n לעוועלס פון שטיינער.
    דער ערשטער לעוועל האָט n שטיינער.
    די נומער פון שטיינער אין דער ווייַטער לעוועל איז:
        - דער ווייַטער אָדדער נומער אויב n איז אָדדער.
        - דער ווייַטער אַפֿילו נומער אויב n איז אַפֿילו.
    צוריקקומען די נומער פון שטיינער אין יעדער לעוועל אין אַ ליסטע, וווּ עלעמענט ביי אינדעס i רעפּראַזענטירט די נומער פון שטיינער אין דער לעוועל.

    ביישפּילן:
    >>> make_a_pile(3)
    [3, 5, 7]
    """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def words_string(s):
    """"""
    איר וועט באַקומען אַ שטריק פון ווערטער צעשיידט דורך קאָמאס אָדער ספּייסאַז. אייער אַרבעט איז 
צו צעטיילן דעם שטריק אין ווערטער און צוריקגיין אַ אַרויסווייַז פון די ווערטער.

פֿאַר בייַשפּיל:
words_string == [""Hi"", ""my"", ""name"", ""is"", ""John""]
words_string == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

"
"
def choose_num(x, y):
    """"""די פֿונקציע נעמט צוויי positive נומערן x און y און גיט צוריק דעם גרעסטן geraden integer נומער וואָס איז אין דער ראַנגע [x, y] אַרײַנגערעכנט. אויב עס איז נישטאָ אַזאַ נומער, דאַן זאָל די פֿונקציע צוריקגעבן -1.

פֿאַר בייַשפּיל:
choose_num = 14
choose_num = -1
    """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

"
"
def rounded_avg(n, m):
    """"""איר זענען געגעבן צוויי positive integers n און m, און אייער אַרבעט איז צו רעכענען די דורכשניטלעך פון די integers פון n דורך m. רונד די ענטפער צו דער ניראַסט גאַנצער נומער און קאָנווערט דעם צו בינאַר. אויב n איז גרעסער ווי m, צוריקקומען -1.
     בייַשפּיל:
     rounded_avg => ""0b11""
     rounded_avg => -1
     rounded_avg => ""0b1111""
     rounded_avg => ""0b11010""
    """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

"
"
def unique_digits(x):
    """"""געגעבן אַ ליסטע פון פּאָזיטיווע אינטעגערס x. צוריקגעבן אַ סאָרטירטע ליסטע פון אַלע עלעמענטן וואָס האָבן ניט קיין גלײַכן ציפֿער.

באַמערקונג: די צוריקגעגעבענע ליסטע זאָל זײַן סאָרטירט אין אַוואַנסירנדיקער אָרדענונג.

פֿאַר בײַשפּיל:
    >>> unique_digits([15, 33, 1422, 1])
    [1, 15, 33]
    >>> unique_digits([152, 323, 1422, 10])
    []
    """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def by_length(arr):
    """"""
    געגעבן אַ עריי פון גאַנץ נומערן, סאָרט די גאַנץ נומערן וואָס זענען צווישן 1 און 9 אַרייַנגערעכנט,
דרייען צוריק די עריי וואָס איז דער רעזולטאַט, און דאַן פאַרבײַטן יעדער ציפער מיט זײַן נאָמען וואָס קומט פֿון
""עין"", ""צוויי"", ""דריי"", ""פיר"", ""פֿינף"", ""זעקס"", ""זיבן"", ""אַכט"", ""ניין"".

פֿאר בײשפיל:
  עריי = [2, 1, 1, 4, 5, 8, 2, 3]   
        -> סאָרט די עריי -> [1, 1, 2, 2, 3, 4, 5, 8] 
        -> דרייען צוריק די עריי -> [8, 5, 4, 3, 2, 2, 1, 1]
  צוריקגעבן [""אַכט"", ""פֿינף"", ""פיר"", ""דריי"", ""צוויי"", ""צוויי"", ""עין"", ""עין""]
    
  אויב די עריי איז ליידיק, צוריקגעבן אַ ליידיקע עריי:
  עריי = []
  צוריקגעבן []
    
  אויב די עריי האָט קיין מאָדנע נומער, איגנאָרירן עס:
  עריי = [1, -1 , 55] 
        -> סאָרט די עריי -> [-1, 1, 55]
        -> דרייען צוריק די עריי -> [55, 1, -1]
  צוריקגעבן = ['עין']
    """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

"
"
def f(n):
    """""" אויספירן די פֿונקציע \ וואָס נעמט \ ווי אַ פּאַראַמעטער,
    און צוריקקומען אַ ליסטע פון גרייס \, אַז דער ווערט פון דעם עלעמענט אין אינדעקס \ איז דער פֿאַקטאָריאַל פון \ אויב \ איז גלייך,
    אָדער די סך פון נומערן פון 1 צו \ אַנדערש.
    \ הייבט אָן פון 1.
    דער פֿאַקטאָריאַל פון \ איז די מאַלטיפּליקאַציע פון די נומערן פון 1 צו \).
    ביישפּיל:
    \ == [1, 2, 6, 24, 15] \)
    """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
"
"
def even_odd_palindrome(n):
    """"""
    געגעבן אַ פּאַזיטיווע גאַנץ צאָל \, צוריקקומען אַ פּאָר וואָס האָט די נומער פון גערעכטע און אומגערעכטע גאַנץ צאָל פּאַלינדראָמען וואָס פאַלן אין דער ראַנגע), אַרײַנגערעכנט.

    בײַשפּיל 1:

        אַרײַנלייג: 3
        אַרויסלייג:
        דערקלערונג:
        גאַנץ צאָל פּאַלינדראָמען זײַנען 1, 2, 3. איינער פֿון זיי איז גערעכט, און צוויי פֿון זיי זײַנען אומגערעכט.

    בײַשפּיל 2:

        אַרײַנלייג: 12
        אַרויסלייג:
        דערקלערונג:
        גאַנץ צאָל פּאַלינדראָמען זײַנען 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. פיר פֿון זיי זײַנען גערעכט, און 6 פֿון זיי זײַנען אומגערעכט.

    באַמערקונגען:
        1. \
        2. דער צוריקגעקומענער פּאָר האָט די נומער פון גערעכטע און אומגערעכטע גאַנץ צאָל פּאַלינדראָמען רעספּעקטיוו.
    """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def count_nums(arr):
    """"""
    שרייב אַ פֿונקציע count_nums וואָס נעמט אַן אַרײַננעמונג פֿון אַ רעק פֿאַר אינטעגערס און גיט צוריק
    די צאָל פון עלעמענטן וואָס האָבן אַ זומער פון ציפֿערן > 0.
    אויב אַ נומער איז נעגאַטיוו, דעמאָלט זיין ערשטע ציפֿער וועט זײַן נעגאַטיוו:
    למשל -123 האָט ציפֿערן -1, 2, און 3.
    >>> count_nums([]) == 0
    >>> count_nums([-1, 11, -11]) == 1
    >>> count_nums([1, 1, 2]) == 3
    """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def move_one_ball(arr):
    """"""מיר האָבן אַ רעק 'arr' פון N גאַנץ צאָלן arr[1], arr[2], ..., arr[N]. די נומערן אין דער רעק וועלן זיין צופֿעליק אָרדענונג. אײַער אַרבעט איז צו באַשליסן צי עס איז מעגלעך צו באַקומען אַ רעק אָרדענונג אין אַ נישט-אַבנעמענדיק סדר דורך דורכפֿירן די נאָכפֿאָלגנדיקע אָפּעראַציע אויף דער געgebener רעק:
איר זײַט ערלויבט צו דורכפֿירן אַן אָפּעראַציע פון רעכט שיפט קיין גרענעץ מאָל.

אַ רעכט שיפט אָפּעראַציע מיינט שיפטן אַלע עלעמענטן פון דער רעק דורך איין שטעלן אין דער רעכטדיקער ריכטונג. דער לעצטער עלעמענט פון דער רעק וועט ווערן געצויגן צו די אָנהייב שטעלע אין דער רעק, ד.ה. 0-טער אינדעקס.

אויב עס איז מעגלעך צו דערגרייכן די אָרדענונגער רעק דורך דורכפֿירן די אויבנדערמאָנטע אָפּעראַציע, דעמאָלט צוריקגעבן אמת, אַנדערש ליג. אויב די געגעבן רעק איז ליידיק, דעמאָלט צוריקגעבן אמת.

באַמערקונג: די געגעבן ליסטע איז געראַנטירט צו האָבן יינציקע עלעמענטן.

פֿאַר בײַשפּיל:

move_one_ball==>אמת
באַשרײַבונג: דורך דורכפֿירן 2 רעכט שיפט אָפּעראַציעס, נישט-אַבנעמענדיק סדר קען ווערן דערגרייכט פֿאַר דער געגעבן רעק.
move_one_ball==>ליג
באַשרײַבונג: עס איז נישט מעגלעך צו באַקומען נישט-אַבנעמענדיק סדר פֿאַר דער געגעבן רעק דורך דורכפֿירן קיין גרענעץ רעכט שיפט אָפּעראַציעס.
                
    """"""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
"
"
def exchange(lst1, lst2):
    """"""אין דעם פּראָבלעם, וועט איר ימפּלאַמענטירן אַ פֿונקציע וואָס נעמט צוויי ליסטעס פֿון נומערן, 
און באַשטעטיקט צי עס איז מעגלעך צו אויסטוישן עלעמענטן צווישן זיי צו מאַכן ליסט1 אַ ליסטע פֿון בלויז גלײַכע נומערן. 
עס איז קיין באַגרענעצונג אויף די צאָל אויסגעטוישטע עלעמענטן צווישן ליסט1 און ליסט2. 
אויב עס איז מעגלעך צו אויסטוישן עלעמענטן צווישן ליסט1 און ליסט2 צו מאַכן אַלע עלעמענטן פֿון ליסט1 גלײַך, צוריק ""יאָ"". 
אויב נישט, צוריק ""ניין"". 
פֿאַר בײַשפּיל:
אַוסטוישן => ""יאָ""
אַוסטוישן => ""ניין""
מען נעמט אָן אַז די אַרײַנגעבנדיקע ליסטעס וועלן זײַן נישט-ליידיק.
    """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

"
"
def histogram(test):
    """"""געגעבן אַ שטריקל וואָס רעפּרעזענטירט פּלאַץ צעשיידעט קליין אותיות, צוריקקומען אַ ווערטערבוך
פון די אות מיט די מערסט איבערחזרונג און כּולל די קאָראַספּאַנדינג ציילן.
אויב עטלעכע אותיות האָבן די זעלבע אויפֿטרעטן, צוריקקומען אַלע פון זיי.

בײַשפּיל:
היסטאָגראַם == {'a': 1, 'b': 1, 'c': 1}
היסטאָגראַם == {'a': 2, 'b': 2}
היסטאָגראַם == {'a': 2, 'b': 2}
היסטאָגראַם == {'b': 4}
היסטאָגראַם == {}

    """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

"
"
def reverse_delete(s,c):
    """"""מיר האָבן צוויי סטרונעס s און c, איר דאַרפֿן אויסמעקן אַלע די אותיות אין s וואָס זענען גלייַך צו קיין אות אין c
דאַן טשעק אויב די רעזולטאַט סטרונע איז אַ פּאַלינדראָמע.
אַ סטרונע איז גערופן אַ פּאַלינדראָמע אויב עס לייענט די זעלבע צוריק ווי פאָרויס.
איר זאָל צוריקקומען אַ טאָפּל כּולל די רעזולטאַט סטרונע און אמת/פאַלש פֿאַר די טשעק.
בייַשפּיל
פֿאַר s = ""abcde"", c = ""ae"", דער רעזולטאַט זאָל זיין
פֿאַר s = ""abcdef"", c = ""b"" דער רעזולטאַט זאָל זיין
פֿאַר s = ""abcdedcba"", c = ""ab"", דער רעזולטאַט זאָל זיין
    """"""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
"
"
def odd_count(lst):
    """"""געגעבן אַ ליסטע פון סטרונגען, וווּ יעדער סטרונג באַשטייט בלויז פון ציפערן, קערט צוריק אַ ליסטע.
    יעדער עלעמענט i פון דער אויסגאַבע זאָל זײַן ""די נומער פון אָד-עלעמענטן אין דער סטרונג i פון דער אַרײַנגעבער.""
    וווּ אַלע i'ס זאָלן ווערן פאַרבײַטן מיט דעם נומער פון אָד-ציפערן אין דער i'טער סטרונג פון דער אַרײַנגעבער.

    >>> odd_count(['1234567'])
    [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
    >>> odd_count(['3',""11111111""])
    [""the number of odd elements 1n the str1ng 1 of the 1nput."",
     ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
    """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def minSubArraySum(nums):
    """"""
    געגעבן אַן אַרי פון גאַנץ נומערן `nums`, געפֿינען די מינימאַלע סום פון קיין ניט-ליידיק אונטער-אַרי פון `nums`.
    ביישפּיל:
    minSubArraySum == 1
    minSubArraySum == -6
    """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
"
"
def max_fill(grid, capacity):
    import math
    """"""
    איר זענט געגעבן אַ רעקטאַנגגיאַלער גריד פון קוועלן. יעדער ריי רעפּראַזענץ אַ איין קוועל, און יעדער ""1"" אין אַ ריי רעפּראַזענץ אַ איין אַפּאַראַט פון וואַסער. יעדער קוועל האָט אַ קאָרעספּאָנדירנדיקע עמער וואָס קען ווערן גענוצט צו אויסנעמען וואַסער פֿון אים, און אַלע עמערן האָבן דער זעלביקער קאַפּאַציטעט. אייער אַרבעט איז צו נוצן די עמערן צו ליידיקן די קוועלן. ארויסגעבן די נומער פון מאָל איר דאַרפֿן צו אַראָפּלאָזן די עמערן.

ביישפּיל 1:
    אַרייַנשרייַב: 
        גריד: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]
        עמער קאַפּאַציטעט: 1
    ארויסגעבן: 6

ביישפּיל 2:
    אַרייַנשרייַב: 
        גריד: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]
        עמער קאַפּאַציטעט: 2
    ארויסגעבן: 5

ביישפּיל 3:
    אַרייַנשרייַב: 
        גריד: [[0,0,0], [0,0,0]]
        עמער קאַפּאַציטעט: 5
    ארויסגעבן: 0

באַגרענעצונגען:
    * אַלע קוועלן האָבן דער זעלביקער לענג
    * 1 <= גריד.לענג <= 10^2
    * 1 <= גריד[:,1].לענג <= 10^2
    * גריד[i][j] -> 0 | 1
    * 1 <= קאַפּאַציטעט <= 10
    """"""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

"
"
def sort_array(arr):
    """"""
    אין דעם קאַטאַ, דאַרף מען סאָרטירן אַ עריי פון ניט-נעגאַטיווע אינטעגערס לויט די צאָל איינס אין זייער בינאַרישער רעפּרעזענטאַציע אין העכערנדיקער סדר.
פֿאַר ענלעכע צאָל פון איינס, סאָרטירן לויטן דעצימאַלן ווערט.

עס דאַרף זיין אימפּלאַמענטירט אזוי:
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def select_words(s, n):
    """"""געגעבן אַ שטריק s און אַ נאַטירלעך נומער n, איר זענט פאַראַנטוואָרטלעך צו ימפּלאַמענטירן אַ פֿונקציע וואָס צוריקקומען אַ ליסטע פון אַלע ווערטער פון שטריק s וואָס אַנטהאַלטן פּונקט n קאָנסאָנאַנץ, אין די סדר ווי די ווערטער דערשייַנען אין שטריק s.
אויב דער שטריק s איז ליידיק, דאַן די פֿונקציע זאָל צוריקקומען אַ ליידיק ליסטע.
באַמערקונג: איר קענט אָננעמען אַז דער ארײַנשרײַב שטריק כּולל בלויז אותיות און ספּייסאַז.
בײַשפּילן:
select_words ==> [""little""]
select_words ==> [""Mary"", ""lamb""]
select_words ==> []
select_words ==> [""world""]
select_words ==> [""Uncle""]
    """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

"
"
def get_closest_vowel(word):
    """"""Here is the translation of the given sentence into Eastern Yiddish:

איר זענט געגעבן אַ וואָרט. אייער אַרבעט איז צו געפֿינען די נאָענטסטע וואָקאַל וואָס שטייט צווישן 
צוויי קאָנסאָנאַנטן פֿון דער רעכטער זײַט פֿון דעם וואָרט.

וואָקאַלן אין אָנהייב און סוף נעמען נישט אין חשבון. צוריקקומען אַ ליידיקן שטריקל אויב איר האָט נישט געפֿונען קיין וואָקאַל וואָס באַגעגנט די אויבן דערמאָנטע צושטאַנד.

איר קענט נעמען אָן אַז דער געגעבן שטריקל כּולל ענגלישע אותיות בלויז.

ביישפּיל:
get_closest_vowel ==> ""u""
get_closest_vowel ==> ""U""
get_closest_vowel ==> """"
get_closest_vowel ==> """"
    """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

"
"
def maximum(arr, k):
    """"""
    געגעבן אַ עריי arr פון גאַנץ נומערן און אַ positive גאַנץ n k, אומקערן אַ סאָרטעד רשימה 
    פון לענג k מיט די מאַקסימום k נומערן אין arr.

    בייַשפּיל1:

        אַרייַנשרייַב: arr = [-3, -4, 5], k = 3
        רעזולטאַט: [-4, -3, 5]

    בייַשפּיל2:

        אַרייַנשרייַב: arr = [4, -4, 4], k = 2
        רעזולטאַט: [4, 4]

    בייַשפּיל3:

        אַרייַנשרייַב: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1
        רעזולטאַט: [2]

    באמערקונג:
        1. די לענג פון די עריי וועט זיין אין די קייט פון [1, 1000].
        2. די עלעמענטן אין די עריי וועט זיין אין די קייט פון [-1000, 1000].
        3. 0 <= k <= len
    """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

"
"
def solution(lst):
    """"""געגעבן אַ ניט-ליידיק ליסטע פון ​​אינטידזשערז, צוריקקומען דעם סכום פון אַלע די אָרעמע עלעמענטן וואָס זענען אין גלייַך פּאַזישאַנז.

ביישפילן:
לייזונג ==> 12
לייזונג ==> 9
לייזונג ==> 0
    """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

"
"
def add_elements(arr, k):
    """"""
    געגעבן אַ נישט-ליידיגער אַרריי פון גאַנץ-צאָלן arr און אַ גאַנץ-צאָל k, צוריקגעבן
    דעם סומע פון די עלעמענטן מיט נישט מער ווי צוויי ציפערן פון די ערשטע k עלעמענטן פון arr.

    ביישפּיל:

        אַרײַנגעבן: arr = [111,21,3,4000,5,6,7,8,9], k = 4
        צוריקגעבן: 24 # סומע פון 21 + 3

    באַגרענעצונגען:
        1. 1 <= לענג <= 100
        2. 1 <= k <= לענג
    """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def get_odd_collatz(n):
    """"""
    געגעבן אַ פּאָזיטיווע גאַנץ נומער ן, צוריקקומען אַ סאָרטעד רשימה וואָס האָט די אוד נומערן אין די קאָללאַץ סיקוואַנס.

    די קאָללאַץ קאָנקעטור איז אַ קאָנקעטור אין מאַטהעמאַטיקס וואָס קאַנסערנס אַ סיקוואַנס דיפיינד
    ווי ווייַטער: אָנהייב מיט קיין positive גאַנץ נומער ן. דעמאָלט יעדער טערמין ווערט דערגרייכט פון די 
    פריערדיקע טערמין ווי ווייַטער: אויב דער פריערדיקער טערמין איז פּאַר, דער ווייַטער טערמין איז האַלב פון 
    דער פריערדיקער טערמין. אויב דער פריערדיקער טערמין איז אוד, דער ווייַטער טערמין איז 3 מאָל די פריערדיקע
    טערמין פּלוס 1. די קאָנקעטור איז אַז נישט קיין חילוק וואָס ווערט פון ן, די סיקוואַנס וועט שטענדיק דערגרייכן 1.

    באַמערקונג: 
        1. Collatz איז [1].
        2. צוריקגעקערטער רשימה איז סאָרטעד אין אינקריסינג סדר.

    למשל:
    get_odd_collatz צוריקקומען [1, 5] # די קאָללאַץ סיקוואַנס פֿאַר 5 איז [5, 16, 8, 4, 2, 1], אַזוי די אוד נומערן זענען נאָר 1 און 5.
    """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def valid_date(date):
    """"""איר דאַרפֿן צו שרײַבן אַ פֿונקציע וואָס װאַלידירט אַ געגעבן דאַטע־שטריק און
    צוריקגעבן אמת אויב די דאַטע איז גילטיק, אַנדערש פֿאַלש.
    די דאַטע איז גילטיק אויב אַלע פֿון די פֿאָלגנדיקע כּללים זײַנען מקיים:
    1. דער דאַטע־שטריק איז נישט ליידיק.
    2. די נומער פֿון טעג איז נישט ווייניקער פֿון 1 און נישט העכער פֿון 31 טעג פֿאַר די חדשים 1,3,5,7,8,10,12. און די נומער פֿון טעג איז נישט ווייניקער פֿון 1 און נישט העכער פֿון 30 טעג פֿאַר די חדשים 4,6,9,11. און, די נומער פֿון טעג איז נישט ווייניקער פֿון 1 און נישט העכער פֿון 29 פֿאַר דעם חודש 2.
    3. די חדשים זאָלן נישט זײַן ווייניקער פֿון 1 אָדער העכער פֿון 12.
    4. די דאַטע זאָל זײַן אין דעם פֿאָרמאַט: mm-dd-yyyy

    למשל:
    valid_date => אמת

    valid_date => פֿאַלש

    valid_date => פֿאַלש

    valid_date => אמת

    valid_date => פֿאַלש
    """"""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
"
"
def split_words(txt):
    '''
    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    Examples
    split_words(""Hello world!"") â -> [""Hello"", ""world!""]
    split_words(""Hello,world!"") â -> [""Hello"", ""world!""]
    split_words(""abcdef"") == 3 
    '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
"
"
def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) â -> True
    is_sorted([1, 2, 3, 4, 5]) â -> True
    is_sorted([1, 3, 2, 4, 5]) â -> False
    is_sorted([1, 2, 3, 4, 5, 6]) â -> True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) â -> True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) â -> False
    is_sorted([1, 2, 2, 3, 3, 4]) â -> True
    is_sorted([1, 2, 2, 2, 3, 4]) â -> False
    '''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

"
"
def intersection(interval1, interval2):
    """"""איר זענט געגעבן צוויי ינטערוואַלן, 
    וווּ יעדער ינטערוואַל איז אַ פּאָר פון אינטעגערס. צום בייַשפּיל, ינטערוואַל = =.
    די געגעבן ינטערוואַלן זענען פארמאכט וואָס מיינט אַז דער ינטערוואַל
    כולל ביידע אָנהייב און סוף.
    פֿאַר יעדער געגעבן ינטערוואַל, עס איז אָנגענומען אַז זיין אָנהייב איז ווייניקער אָדער גלייך צו זיין סוף.
    אייער אַרבעט איז צו באַשליסן צי די לענג פון די ינטערסעקשאַן פון די צוויי 
    ינטערוואַלן איז אַ פּריים נומער.
    צום ביישפּיל, די ינטערסעקשאַן פון די ינטערוואַלן, איז
    וואָס זיין לענג איז 1, וואָס איז נישט אַ פּריים נומער.
    אויב די לענג פון די ינטערסעקשאַן איז אַ פּריים נומער, צוריקקומען ""יאָ"",
    אַנדערש, צוריקקומען ""ניין"".
    אויב די צוויי ינטערוואַלן טאָן ניט ינטערסעקט, צוריקקומען ""ניין"".

    [איינשרײַב / אויסשרײַב] ביישפילן:
    ינטערסעקשאַן,) ==> ""ניין""
    ינטערסעקשאַן,) ==> ""ניין""
    ינטערסעקשאַן,) ==> ""יאָ""
    """"""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

"
"
def prod_signs(arr):
    """"""
    איר זענט געגעבן אַ מאַטריץ arr פון גאַנץ נומערן און איר דאַרפֿן צוריקצוגעבן
    די סכום פון די גרייסן פון די גאַנץ נומערן, מאַלטיפּלייזד מיט 
    דעם פּראָדוקט פון אַלע די צייכנס פון יעדער נומער אין דער מאַטריץ, 
    רעפּרעזענטירט דורך 1, -1 אָדער 0.
    באַמערקונג: צוריקצוגעבן קיינער פֿאַר אַ ליידיק arr.

    ביישפּיל:
    >>> prod_signs([1, 2, 2, -4]) == -9
    >>> prod_signs([0, 1]) == 0
    >>> prod_signs([]) == None
    """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def minPath(grid, k):
    """"""
    Here's the translation of the given text into Eastern Yiddish:

געגעבן אַ גריד מיט N רייען און N שפאלטן און אַ פּאָזיטיווער גאַנצער נומער k, 
    יעדער צעל אין דעם גריד אַנטהאַלט אַ ווערט. יעדער גאַנצער נומער אין דער ראַנגע [1, N * N]
    ינקלוסיווע ערשיינט פּונקט איינמאָל אויף די צעלן פון דעם גריד.

    איר דאַרפט געפֿינען דעם מינימאַלן וועג פון לענג k אין דעם גריד. איר קענט אָנהייבן
    פון קיין צעל, און אין יעדער שריט קענט איר זיך באַוועגן צו קיין פון די שכנים צעלן,
    מיט אַנדערע ווערטער, איר קענט גיין צו צעלן וואָס טיילן אַ ברעג מיט אייער איצטיקער
    צעל.
    ביטע באמערקן אַז אַ וועג פון לענג k מיינט באַזוכן פּונקט k צעלן.
    איר קענט נישט גיין אויס פון דעם גריד.
    אַ וועג A ווערט באטראכט ווייניקער ווי אַ וועג B אויב
    נאָך צוזאַמענשטעלן די אָרדענונגדיקע ליסטעס פון די ווערטלעך אויף די צעלן וואָס A און B גייען
    דורכגיין, איז ליסט_A לעקסיקאָגראַפֿיש ווייניקער
    ווי ליסט_B, מיט אַנדערע ווערטער, עס עקזיסטירט אַן גאַנצער אינדעקס i
    אַז ליסט_A[i] איז ווייניקער ווי ליסט_B[i] און פֿאַר קיין j האָבן מיר
    ליסט_A[j] = ליסט_B[j].
    עס איז געראַנטירט אַז דער ענטפער איז יוניק.
    צוריקגעבן אַן אָרדנונגדיקע ליסטע פון די ווערטלעך אויף די צעלן וואָס דער מינימאַלן וועג גייט דורכגיין.

    ביישפילן:

        אריינגאבע: גריד = [ [1,2,3], [4,5,6], [7,8,9]], k = 3
        רעזולטאַט: [1, 2, 1]

        אריינגאבע: גריד = [ [5,9,3], [4,1,6], [7,8,2]], k = 1
        רעזולטאַט: [1]
    """"""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

"
"
def tri(n):
    """"""אַלע ווייסן די פיבאָנאַטשי סיקוואַנס, עס איז געווען טיף געלערנט דורך מאַטעמאַטיקער אין די לעצטע פּאָר סענטשעריז. אָבער, וואָס מענטשן טאָן ניט וויסן איז די טריבאָנאַטשי סיקוואַנס.
די טריבאָנאַטשי סיקוואַנס איז דעפֿינירט דורך די רעקאָררענס:
tri = 3
tri = 1 + n / 2, אויב n איז אַפֿילו.
tri = tri + tri + tri, אויב n איז אָד.
פֿאַר בייַשפּיל:
tri = 1 + = 2
tri = 3
tri = tri + tri + tri
           = 2 + 3 + 3 = 8 
איר זענט געגעבן אַ ניט-נעגאַטיוו גאַנץ צאָל n, איר דאַרפֿן צוריקצוגעבן אַ רשימה פון די ערשטע n + 1 נומערן פון די טריבאָנאַטשי סיקוואַנס.
ביישפילן:
tri = [1, 3, 2, 8]
    """"""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
"
"
def digits(n):
    """"""Here is the translation of the provided sentence into Eastern Yiddish:

געגעבן אַ פּאָזיטיווער גאַנץ נומער \, צוריקגעבן דעם פּראָדוקט פון די אומגראד ציפערן.
    צוריקגעבן 0 אויב אַלע ציפערן זענען גראַד.
    צום ביישפּיל:
    ציפערן == 1
    ציפערן == 0
    ציפערן == 15
    """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

"
"
def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') â -> True
    is_nested('[]]]]]]][[[[[]') â -> False
    is_nested('[][]') â -> False
    is_nested('[]') â -> False
    is_nested('[[][]]') â -> True
    is_nested('[[]][[') â -> True
    '''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

"
"

def sum_squares(lst):
    """"""איר זענט געגעבן אַ ליסטע פֿון נומערן.
איר דאַרפֿט צוריקגעבן דעם סכום פֿון קוואַדראַטירט נומערן אין דער געגעבןער ליסטע,
וועלן ערשט רונדן יעדער עלעמענט אין דער ליסטע צו דער אויבערשטער גאַנץ צאָל.
בײַשפּילן:
פֿאַר ליסטע = [1,2,3] זאָל די אויסגאַבע זײַן 14
פֿאַר ליסטע = [1,4,9] זאָל די אויסגאַבע זײַן 98
פֿאַר ליסטע = [1,3,5,7] זאָל די אויסגאַבע זײַן 84
פֿאַר ליסטע = [1.4,4.2,0] זאָל די אויסגאַבע זײַן 29
פֿאַר ליסטע = [-2.4,1,1] זאָל די אויסגאַבע זײַן 6
    

    """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def check_if_last_char_is_a_letter(txt):
    '''
    Create a function that returns True if the last character
    of a given string is an alphabetical character and is not
    a part of a word, and False otherwise.
    Note: ""word"" is a group of characters separated by space.

    Examples:
    check_if_last_char_is_a_letter(""apple pie"") â -> False
    check_if_last_char_is_a_letter(""apple pi e"") â -> True
    check_if_last_char_is_a_letter(""apple pi e "") â -> False
    check_if_last_char_is_a_letter("""") â -> False 
    '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def can_arrange(arr):
    """"""שאַפֿן אַ פֿונקציע וואָס טרעט צוריק דעם גרעסטן אינדעקס פון אַ עלעמענט וואָס איז נישט גרעסער אָדער גלייך צו דעם עלעמענט גלייך פֿריִערדיקן אים. אויב אַזאַ עלעמענט עקזיסטירט נישט, דאַן טרעט צוריק -1. די געgebענע אַרטיקל וועט נישט אַנטהאַלטן דופּליקאַט ווערטן.

בײַשפּילן:
can_arrange = 3
can_arrange = -1
    """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

"
"
def largest_smallest_integers(lst):
    '''
    Create a function that returns a tuple (a, b), where 'a' is
    the largest of negative integers, and 'b' is the smallest
    of positive integers in a list.
    If there is no negative or positive integers, return them as None.

    Examples:
    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)
    largest_smallest_integers([]) == (None, None)
    largest_smallest_integers([0]) == (None, None)
    '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
"
"
def compare_one(a, b):
    """"""
    שאַפֿן אַ פֿונקציע וואָס נעמט איינס-רעקענונגען, פֿלאָץ, אָדער שטריקלען וואָס רעפּרעזענטירן רעאַלע נומערן, און גיט צוריק די גרעסערע בײַם געגעבןען באַריאַבל טיפּ.
    געבן צוריק קיין זאַך אויב די ווערטלעך זענען גלײַך.
    באַמערקונג: אויב אַ רעאַלער נומער איז רעפּרעזענטירט ווי אַ שטריקל, דער פלאָטן פּונקט קען זײַן . אָדער ,

    compare_one â -> 2.5
    compare_one â -> ""2,3""
    compare_one â -> ""6""
    compare_one â -> קיין זאַך
    """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def is_equal_to_sum_even(n):
    """"""אויסשאַצן צי די געgebn נומער n קען ווערן געשריבן אלס דער סכום פון פּונקט 4 positive geraden נומערן
    ביישפּיל
    is_equal_to_sum_even == False
    is_equal_to_sum_even == False
    is_equal_to_sum_even == True
    """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
"
"
def special_factorial(n):
    """"""דער בראַזיליאַנער פֿאַקטאָריאַל איז דעפֿינירט ווי:
    brazilian_factorial = n! *! *! * ... * 1!
    וווּ n > 0

    למשל:
    >>> special_factorial(4)
    288

    The function will receive an integer as input and should return the special
    factorial of this integer.
    """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

"
"
def fix_spaces(text):
    """"""
    געגעבן אַ שטריק טעקסט, פאַרבייַטן אַלע ספּייסאַז אין אים מיט אונטערשטרייכן,
און אויב אַ שטריק האט מער ווי 2 קאַנסעקוטיוו ספּייסאַז,
דאַן פאַרבייַטן אַלע קאַנסעקוטיוו ספּייסאַז מיט -

fix_spaces == ""Example""
fix_spaces == ""Example_1""
fix_spaces == ""_Example_2""
fix_spaces == ""_Example-3""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

"
"
def file_name_check(file_name):
    """"""שאַפֿן אַ פֿונקציע וואָס נעמט אַ שטריקל וואָס רעפּרעזענטירט אַ טעקע'ס נאָמען, און צוריקגעבן 'יאָ' אויב דער טעקע'ס נאָמען איז גילטיק, און צוריקגעבן 'ניין' אַנדערש.
    אַ טעקע'ס נאָמען איז נחשבּ צו זיין גילטיק אויב און בלויז אויב אַלע די פֿאלגנדע באדינגונגען זענען מקוים:
    - עס זאָל נישט זיין מער ווי דריי ציפֿערן אין דער טעקע'ס נאָמען.
    - דער טעקע'ס נאָמען האָט פּונקט איין פּונקט '.'
    - די אונטערשטריקל איידער דעם פּונקט זאָל נישט זיין ליידיק, און עס הייבט זיך אָן מיט אַ בריוו פון די לאַטינישע אַלפאַבעט.
    - די אונטערשטריקל נאָך דעם פּונקט זאָל זיין איינע פון די: ['txt', 'exe', 'dll']
    ביישפּילן:
    file_name_check # => 'יאָ'
    file_name_check # => 'ניין'
    """"""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

"
"


def sum_squares(lst):
    """"""די פֿונקציע וועט נעמען אַ ליסטע פֿון גאַנץ צאָלן. פֿאַר אַלע פּאָזיציעס אין דער ליסטע, וועט די פֿונקציע קוואַדראַטירן דעם גאַנץ צאָל אויב זײַן אינדעקס איז אַ מערפעך פֿון 3 און וועט קיובירן דעם גאַנץ צאָל אויב זײַן אינדעקס איז אַ מערפעך פֿון 4 און נישט אַ מערפעך פֿון 3. די פֿונקציע וועט נישט טוישן די פּאָזיציעס אין דער ליסטע וואָס זייער אינדעקס איז נישט אַ מערפעך פֿון 3 אָדער 4. דערנאָך וועט די פֿונקציע צוריקגעבן דעם סכום פֿון אַלע פּאָזיציעס.

ביישפילן:
פֿאַר ליסטע = [1,2,3] זאָל דער רעזולטאַט זײַן 6
פֿאַר ליסטע = [] זאָל דער רעזולטאַט זײַן 0
פֿאַר ליסטע = [-1,-5,2,-1,-5] זאָל דער רעזולטאַט זײַן -126
    """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
"
"
def words_in_sentence(sentence):
    """"""
    איר זענט געגעבן אַ שטריקל וואָס רעפּראַזענטירט אַ זאַץ,
    דער זאַץ כּולל עטלעכע ווערטער באַזונדער דורך אַ פּלאַץ,
    און איר דאַרפֿן צוריקצושטעלן אַ שטריקל וואָס כּולל די ווערטער פון דעם אָריגינעל זאַץ,
    וועמענס לענג איז פּריים נומערן,
    דער סדר פון די ווערטער אין דער נייַ שטריקל זאָל זיין די זעלבע ווי דער אָריגינעלער.

    בייַשפּיל 1:
        אַרייַנשרייַב: זאַץ = ""דאָס איז אַ פּרוב""
        רעזולטאַט: ""איז""

    בייַשפּיל 2:
        אַרייַנשרייַב: זאַץ = ""לאָמיר גיין פֿאַר שווימען""
        רעזולטאַט: ""גיין פֿאַר""

    באַגרענעצונגען:
        * 1 <= len <= 100
        * זאַץ כּולל בלויז אותיות
    """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

"
"
def simplify(x, n):
    """"""Here's the translation of the given sentence into Eastern Yiddish:

דיין אַרבעט איז צו דורכפירן אַ פֿונקציע וואָס וועט פאַריינfachן די אויסדרוק
    x * n. די פֿונקציע וועט צוריקקומען אמת אויב x * n איז אַ גאַנץ נומער און פאַלש
    אַנדערש. ביידע x און n זענען סטרינג רעפּרעזענטאַציעס פון אַ בראָש, און האָבן די ווייַטערדיקע פֿאָרמאַט,
    <צעלער>/<נעמער> ווו ביידע צעלער און נעמער זענען positive גאַנץ נומערן.

    איר קענט אָנכאַפּן אַז x, און n זענען גילטיק בראָשן, און האָבן נישט נול ווי נעמער.

    simplify = אמת
    simplify = פאַלש
    simplify = פאַלש
    """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

"
"
def order_by_points(nums):
    """"""
    שרײַבט אַ פֿונקציע וואָס סאָרטירט די געgebene ליסטע פֿון גאַנץ צאָלן
    אין אַ אויפֿשטייגנדיקער סדר לויט דעם סך פֿון זייערע ציפֿערן.
    באַמערקונג: אויב זענען דאָ עטלעכע עלעמענטן מיט אַ ענלעכן סך פֿון זייערע ציפֿערן,
    זאָל מען זיי אָרדענען לויט זייער אינדעקס אין דער אָריגינעלער ליסטע.

    למשל:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def specialFilter(nums):
    """"""שרײַבט אַ פֿונקציע וואָס נעמט אַן אַרײַננעמונג פון אַ רעכענונג פון נומערן און גיט צוריק די צאָל עלעמענטן אין דער רעכענונג וואָס זענען גרעסער װי 10 און בײדע, דער ערשטער און דער לעצטער ציפֿער פון אַ נומער, זענען אומגעראַדע.
פֿאַר אַ בײַשפּיל:
specialFilter => 1 
specialFilter => 2
    """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

"
"
def get_max_triples(n):
    """"""
    איר זענט געגעבן אַ positive גאַנץ נומער n. איר דאַרפֿן צו שאַפֿן אַ גאַנץ אַרייַ a פון לענג n.
        פֿאַר יעדער i, די ווערט פון a[i] איז i * i - i + 1.
        צוריקקומען די נומער פון דרייַפאַכיקייטן פון a ווו i < j < k,
    און a[i] + a[j] + a[k] איז אַ קייפל פון 3.

    בייַשפּיל:
        אַרייַנשרייַב: n = 5
        רעזולטאַט: 1
        דערקלערונג: 
        a = [1, 3, 7, 13, 21]
        דער איינציקער גילטיקער דרייַפאַך איז.
    """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
"
"
def bf(planet1, planet2):
    '''
    There are eight planets in our solar system: the closerst to the Sun 
    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    Uranus, Neptune.
    Write a function that takes two planet names as strings planet1 and planet2. 
    The function should return a tuple containing all planets whose orbits are 
    located between the orbit of planet1 and the orbit of planet2, sorted by 
    the proximity to the sun. 
    The function should return an empty tuple if planet1 or planet2
    are not correct planet names. 
    Examples
    bf(""Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"")
    bf(""Earth"", ""Mercury"") ==> (""Venus"")
    bf(""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"")
    '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

"
"
def sorted_list_sum(lst):
    """"""שרייב אַ פֿונקציע וואָס נעמט אַ רשימה פֿון שטריקלען ווי אַ פּאַראַמעטער,
    וואָס מעקט אויס די שטריקלען וואָס האָבן אָן-צאָל לענג פֿון דער,
    און צוריקגעבן די רעזולטאַט־רשימה מיט אַ סאָרטירטער סדר.
    די רשימה איז שטענדיק אַ רשימה פון שטריקלען און קיינמאָל אַ עריי פֿון נומערן,
    און זי קען אַנטהאַלטן דופליקאַטן.
    דער סדר פֿון דער רשימה זאָל זײַן העכערנדיק לויט דער לענג פֿון יעדן וואָרט, און איר
    זאָלט צוריקגעבן די רשימה סאָרטירט לויט דעם רעגול.
    אויב צוויי ווערטער האָבן די זעלבע לענג, סאָרטירט די רשימה אַלף-בעטיש.
    די פֿונקציע זאָל צוריקגעבן אַ רשימה פֿון שטריקלען אין סאָרטירטער סדר.
    איר קענט אָננעמען אַז אַלע ווערטער וועלן האָבן די זעלבע לענג.
    למשל:
    assert list_sort => [""aa""]
    assert list_sort => [""ab"", ""cd""]
    """"""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

"
"
def x_or_y(n, x, y):
    """"""א פּשוטער פּראָגראַם וואָס זאָל צוריקגעבן די ווערט פון x אויב n איז אַ פּריים נומער און זאָל צוריקגעבן די ווערט פון y אַנדערש.

ביישפילן:
פֿאַר x_אָדער_y == 34
פֿאַר x_אָדער_y == 5
    
    """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

"
"
def double_the_difference(lst):
    '''
    Given a list of numbers, return the sum of squares of the numbers
    in the list that are odd. Ignore numbers that are negative or not integers.
    
    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10
    double_the_difference([-1, -2, 0]) == 0
    double_the_difference([9, -2]) == 81
    double_the_difference([0]) == 0  
   
    If the input list is empty, return 0.
    '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

"
"
def compare(game,guess):
    """"""איך מײן אַלע געדענקען דעם פֿילן ווען דער רעזולטאַט פֿון אַ לאַנג-געווארטע געשעעניש איז ענדלעך באַקאַנט. די געפילן און געדאַנקען וואָס איר האָט אין דעם מאָמענט זענען זיכער ווערט צו באַמערקן און פאַרגלײכן.

אײַער אָפּגאַבע איז צו באַשטימען צי אַ מענטש האָט ריכטיק געטראַכט די רעזולטאַטן פֿון אַ צאָל שפילן. איר באַקומען צוויי ערייז פֿון סקאָרן און טראַכטן פֿון גלײַכן לענג, וווּ יעדער אינדעקס ווייזט אַ שפּיל. צוריקגעבן אַן עריי פֿון דער זעלבער לענג וואָס ווייזט ווי ווײַט יעדער טראַכט איז אָפּ. אויב זיי האָבן ריכטיק געטראַכט, איז די ווערט 0, און אויב ניט, איז די ווערט די אַבסאָלוטע חילוק צווישן דער טראַכט און דער סקאָר.

בײַשפּיל:

compare -> [0,0,0,0,3,3]
compare -> [4,4,1,0,0,6]
    """"""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def Strongest_Extension(class_name, extensions):
    """"""איר וועט באַקומען דעם נאָמען פון אַ קלאַס און אַ רשימה פון עקסטענסיאָנס.
די עקסטענסיאָנס זאָלן ווערן גענוצט צו לאָודן נאָך קלאַסן צו דעם קלאַס. די שטאַרקייט פון דער עקסטענסיאָן איז אַזאַ: לאָזן CAP זיין די נומער פון די הויפּטשטאָט אותיות אין דעם עקסטענסיאָן'ס נאָמען, און לאָזן SM זיין די נומער פון קליין אותיות אין דעם עקסטענסיאָן'ס נאָמען, די שטאַרקייט איז געגעבן דורך די בראָכצאָל CAP - SM. איר זאָל געפֿינען די שטאַרקסטע עקסטענסיאָן און צוריקקומען אַ שטריקל אין דעם פֿאָרמאַט: ClassName.StrongestExtensionName. אויב עס זענען צוויי אָדער מער עקסטענסיאָנס מיט דער זעלביקער שטאַרקייט, איר זאָל קלייַבן די וואָס קומט ערשטער אין דער רשימה.
פֿאַר בייַשפּיל, אויב איר זענען געגעבן ""Slices"" ווי דער קלאַס און אַ רשימה פון די עקסטענסיאָנס: ['SErviNGSliCes', 'Cheese', 'StuFfed'] דאַן איר זאָל צוריקקומען 'Slices.SErviNGSliCes' זינט 'SErviNGSliCes' איז די שטאַרקסטע עקסטענסיאָן.
בייַשפּיל:
פֿאַר Strongest_Extension == 'my_class.AA'
    """"""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
"
"
def cycpattern_check(a , b):
    """"""איר גיט צוויי ווערטער. איר דאַרפֿן צוריקקומען אמת אויב דאָס צווייטע וואָרט אָדער קיין פון די ראָוטיישאַנז איז אַ סאַבסטרינג אין די ערשטע וואָרט.
    cycpattern_check => False
    cycpattern_check => True
    cycpattern_check => False
    cycpattern_check => True
    cycpattern_check => False
    cycpattern_check => True

    """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

"
"
def even_odd_count(num):
    """"""The following sentence translated into Eastern Yiddish:

געגעבן אַ גאַנץ נומער. שלאָגן צוריק אַ טאָפּל וואָס האָט די נומער פון גלײַכע און אומגלײַכע ציפֿערן.

     בײַשפּיל:
        even_odd_count ==>
        even_odd_count ==>
    """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def int_to_mini_roman(number):
    """"""
    Here is the translation of the sentence into Eastern Yiddish:

געגעבן אַ פּאַזיטיוון גאַנץ צאָל, באַקומען זײַן רוימישער נומער ווי אַ שטריקל,
    און צוריקגעבן דאָס אין קליינעם בוכשטאַבן.
    באַגרענעצונגען: 1 <= נומער <= 1000

    ביישפילן:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

"
"
def find_max(words):
    """"""שרײַבט אַ פֿונקציע וואָס נעמט אַ ליסטע פֿון שטריקן.
    די ליסטע אַנטהאַלט פאַרשידענע ווערטער. צוריקגעבן דאָס וואָרט מיט די מערסטע איינציקע כאַראַקטערן.
    אויב מערערע שטריקן האָבן די מערסטע איינציקע כאַראַקטערן, צוריקגעבן דאָס וואָס קומט ערשט אין לעקסיקאָגראפֿישער אָרדענונג.

    find_max == ""string""
    find_max == ""enam""
    find_max == ""aaaaaaa""
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"
def eat(number, need, remaining):
    """"""
    דו ביסט אַ הונגעריקער האַז, און דו האָסט שוין געגעסן אַ געוויסע צאָל קעראָטן,
    אָבער איצט דאַרפסטו עסן מער קעראָטן צו פאַרענדיקן די טאָגס מאָלצײַטן.
    דו זאָלסט צוריקגעבן אַ אַרײַ פון [ די גאַנץ צאָל געגעסענע קעראָטן נאָך דײַנע מאָלצײַטן,
                                      די צאָל קעראָטן וואָס בלײַבן נאָך דײַנע מאָלצײַטן ]
    אויב עס זענען נישט גענוג איבערגעבליבענע קעראָטן, וועסטו עסן אַלע איבערגעבליבענע קעראָטן, אָבער וועסט נאָך אײַנז נאָכוועגן הונגעריק בלײַבן.
    
    בײַשפּיל:
    * עסן -> [11, 4]
    * עסן -> [12, 1]
    * עסן -> [11, 0]
    * עסן -> [7, 0]
    
    וועריאַבלעס:
    @צאָל : גאַנצער נומער
        די צאָל קעראָטן וואָס דו האָסט געגעסן.
    @דאַרף : גאַנצער נומער
        די צאָל קעראָטן וואָס דו דאַרפסט עסן.
    @איבערגעבליבענע : גאַנצער נומער
        די צאָל איבערגעבליבענע קעראָטן וואָס עקזיסטירן אין לאַגער
    
    באַגרענעצונג:
    * 0 <= צאָל <= 1000
    * 0 <= דאַרף <= 1000
    * 0 <= איבערגעבליבענע <= 1000

    האָבן שפּאַס :)
    """"""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

"
"
def do_algebra(operator, operand):
    """"""
    געגעבן צוויי ליסטעס: אָפּעראַטאָר און אָפּעראַנד. די ערשטע ליסטע האָט גרונטלעכע אַלגעבראַ אָפּעראַציעס, און די צווייטע ליסטע איז אַ ליסטע פון גאַנץ צאָלן. נוץ די צוויי געגעבן ליסטעס צו בויען די אַלגעבראַישע אויסדרוק און צוריקגעבן די עוואַלואַציע פֿון דעם אויסדרוק.

די גרונטלעכע אַלגעבראַ אָפּעראַציעס:
צוגאָב 
איבּערציע 
מולטיפּליקאַציע 
פלאָר דיװיזיע 
אקספּאָנענטיאַציע 

ביישפּיל:
אָפּעראַטאָר['+', '*', '-']
אַררייַ = [2, 3, 4, 5]
רעזולטאַט = 2 + 3 * 4 - 5
=> רעזולטאַט = 9

באַמערקונג:
    די לענג פֿון דער אָפּעראַטאָר ליסטע איז גלייך צו דער לענג פֿון דער אָפּעראַנד ליסטע מינוס איינס.
    אָפּעראַנד איז אַ ליסטע פֿון ניט-נעגאַטיווע גאַנץ צאָלן.
    די אָפּעראַטאָר ליסטע האָט לפּחות איין אָפּעראַטאָר, און די אָפּעראַנד ליסטע האָט לפּחות צוויי אָפּעראַנדן.

    """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def solve(s):
    """"""Here is the translation of the given sentence into Eastern Yiddish:

איר באַקומען אַ שטריק s.
    אויב s[i] איז אַ בריוו, דרייען זיין פאַל פֿון נידעריק צו אויבער אָדער פאַרקערט,
    אַנדערש האַלטן עס ווי עס איז.
    אויב דער שטריק כּולל ניט קיין אותיות, דרייען דעם שטריק.
    די פֿונקציע זאָל צוריקקומען דעם רעזולטאַט שטריק.
    ביישפילן
    סאַלווד = ""4321""
    סאַלווד = ""AB""
    סאַלווד = ""#A@c""

Note: Transliteration from Yiddish to Latin characters can vary, and some words or technical terms might not have a direct equivalent in Yiddish.
    """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
"
"
def string_to_md5(text):
    """"""
    געגעבן אַ שטריק 'טעקסט', צוריקגעבן זיין md5 האַש עקוויוואַלענט שטריק. 
    אויב 'טעקסט' איז אַ ליידיק שטריק, צוריקגעבן גאָרנישט.

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def generate_integers(a, b):
    """"""
    געגעבן צוויי positive אינטעגערס א און ב, צוריקקומען די גלייך ציפערן צווישן א
און ב, אין אויפשטייגנדיקן סדר.

פֿאַר בייַשפּיל:
generate_integers => [2, 4, 6, 8]
generate_integers => [2, 4, 6, 8]
generate_integers => []
    """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
