[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Zkontrolujte, zda jsou v dan\u00e9m seznamu \u010d\u00edsel n\u011bjak\u00e1 dv\u011b \u010d\u00edsla bl\u00ed\u017ee k sob\u011b ne\u017e dan\u00fd pr\u00e1h.\nP\u0159\u00edklad:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Vstupem do t\u00e9to funkce je \u0159et\u011bzec obsahuj\u00edc\u00ed v\u00edce skupin vno\u0159en\u00fdch z\u00e1vorek. Va\u0161\u00edm c\u00edlem je\n    odd\u011blit tyto skupiny do samostatn\u00fdch \u0159et\u011bzc\u016f a vr\u00e1tit seznam t\u011bchto \u0159et\u011bzc\u016f.\n    Odd\u011blen\u00e9 skupiny jsou vyv\u00e1\u017een\u00e9 a nejsou vz\u00e1jemn\u011b vno\u0159en\u00e9.\n    Ignorujte jak\u00e9koli mezery ve vstupn\u00edm \u0159et\u011bzci.\n    P\u0159\u00edklad:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Vzhledem k pozitivn\u00edmu \u010d\u00edslu s plovouc\u00ed desetinnou \u010d\u00e1rkou, m\u016f\u017ee b\u00fdt rozlo\u017eeno na\n    celou \u010d\u00e1st a desetinnou \u010d\u00e1st.\n\n    Vra\u0165te desetinnou \u010d\u00e1st \u010d\u00edsla.\n    P\u0159\u00edklad:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Dostanete seznam vkladov\u00fdch a v\u00fdb\u011brov\u00fdch operac\u00ed na bankovn\u00edm \u00fa\u010dtu, kter\u00fd za\u010d\u00edn\u00e1 s nulov\u00fdm z\u016fstatkem. Va\u0161\u00edm \u00fakolem je zjistit, zda se n\u011bkdy z\u016fstatek na \u00fa\u010dtu dostane pod nulu, a v tom okam\u017eiku by funkce m\u011bla vr\u00e1tit True. Jinak by m\u011bla vr\u00e1tit False.\nP\u0159\u00edklad:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Pro dan\u00fd seznam vstupn\u00edch \u010d\u00edsel vypo\u010d\u00edtejte pr\u016fm\u011brnou absolutn\u00ed odchylku\n    kolem pr\u016fm\u011bru t\u00e9to datov\u00e9 sady.\n    Pr\u016fm\u011brn\u00e1 absolutn\u00ed odchylka je pr\u016fm\u011brn\u00e1 absolutn\u00ed rozd\u00edlnost mezi ka\u017ed\u00fdm\n    prvkem a st\u0159edov\u00fdm bodem:\n    MAD = pr\u016fm\u011br | x - x_pr\u016fm\u011br |\n    P\u0159\u00edklad:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Vlo\u017ete \u010d\u00edslo 'delimeter' mezi ka\u017ed\u00fd dva po sob\u011b jdouc\u00ed prvky vstupn\u00edho seznamu `numbers`.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Vstupem t\u00e9to funkce je \u0159et\u011bzec p\u0159edstavuj\u00edc\u00ed v\u00edce skupin pro vno\u0159en\u00e9 z\u00e1vorky odd\u011blen\u00e9 mezerami.\n    Pro ka\u017edou skupinu vypi\u0161te nejhlub\u0161\u00ed \u00farove\u0148 vno\u0159en\u00ed z\u00e1vorek.\n    Nap\u0159.) m\u00e1 maxim\u00e1ln\u011b dv\u011b \u00farovn\u011b vno\u0159en\u00ed, zat\u00edmco)) m\u00e1 t\u0159i.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filtrovat vstupn\u00ed seznam \u0159et\u011bzc\u016f pouze pro ty, kter\u00e9 obsahuj\u00ed dan\u00fd pod\u0159et\u011bzec.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Pro dan\u00fd seznam cel\u00fdch \u010d\u00edsel vra\u0165te dvojici, kter\u00e1 se skl\u00e1d\u00e1 ze sou\u010dtu a sou\u010dinu v\u0161ech \u010d\u00edsel v seznamu.\n    Pr\u00e1zdn\u00fd sou\u010det by m\u011bl b\u00fdt roven 0 a pr\u00e1zdn\u00fd sou\u010din by m\u011bl b\u00fdt roven 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Z dan\u00e9ho seznamu cel\u00fdch \u010d\u00edsel vytvo\u0159te seznam postupn\u00fdch maxim\u00e1ln\u00edch prvk\u016f nalezen\u00fdch a\u017e do dan\u00e9ho okam\u017eiku v sekvenci.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Otestujte, zda je dan\u00fd \u0159et\u011bzec palindrom. \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Vstupem jsou dva \u0159et\u011bzce a a b, kter\u00e9 se skl\u00e1daj\u00ed pouze z 1 a 0. Prove\u010fte bin\u00e1rn\u00ed operaci XOR na t\u011bchto vstupech a vra\u0165te v\u00fdsledek tak\u00e9 jako \u0159et\u011bzec.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Z seznamu \u0159et\u011bzc\u016f vra\u0165te ten nejdel\u0161\u00ed. V p\u0159\u00edpad\u011b v\u00edce \u0159et\u011bzc\u016f stejn\u00e9 d\u00e9lky vra\u0165te ten prvn\u00ed. Vra\u0165te None, pokud je vstupn\u00ed seznam pr\u00e1zdn\u00fd.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Vr\u00e1tit nejv\u011bt\u0161\u00ed spole\u010dn\u00fd d\u011blitel dvou cel\u00fdch \u010d\u00edsel a a b.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Vr\u00e1tit seznam v\u0161ech p\u0159edpon od nejkrat\u0161\u00ed po nejdel\u0161\u00ed ze vstupn\u00edho \u0159et\u011bzce.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Vr\u00e1tit \u0159et\u011bzec obsahuj\u00edc\u00ed \u010d\u00edsla odd\u011blen\u00e1 mezerami, za\u010d\u00ednaj\u00edc\u00ed od 0 a\u017e po n v\u010detn\u011b.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Vzhledem k \u0159et\u011bzci zjist\u011bte, z kolika r\u016fzn\u00fdch znak\u016f se skl\u00e1d\u00e1.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Vstupem do t\u00e9to funkce je \u0159et\u011bzec p\u0159edstavuj\u00edc\u00ed hudebn\u00ed noty ve speci\u00e1ln\u00edm ASCII form\u00e1tu.\nVa\u0161\u00edm \u00fakolem je analyzovat tento \u0159et\u011bzec a vr\u00e1tit seznam cel\u00fdch \u010d\u00edsel odpov\u00eddaj\u00edc\u00edch po\u010dtu \u00fader\u016f, kter\u00e9 jednotliv\u00e9 noty trvaj\u00ed.\n\nZde je legenda:\n'o' - cel\u00e1 nota, trv\u00e1 \u010dty\u0159i \u00fadery\n'o|' - p\u016flov\u00e1 nota, trv\u00e1 dva \u00fadery\n'.|' - \u010dtvr\u0165ov\u00e1 nota, trv\u00e1 jeden \u00fader\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Najd\u011bte, kolikr\u00e1t lze dan\u00fd pod\u0159et\u011bzec naj\u00edt v p\u016fvodn\u00edm \u0159et\u011bzci. Po\u010d\u00edtejte p\u0159ekr\u00fdvaj\u00edc\u00ed se p\u0159\u00edpady.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Vstupem je \u0159et\u011bzec \u010d\u00edsel odd\u011blen\u00fdch mezerami od 'nula' do 'dev\u011bt'.\n    Platn\u00e9 mo\u017enosti jsou 'nula', 'jedna', 'dva', 't\u0159i', '\u010dty\u0159i', 'p\u011bt', '\u0161est', 'sedm', 'osm' a 'dev\u011bt'.\n    Vra\u0165te \u0159et\u011bzec s \u010d\u00edsly se\u0159azen\u00fdmi od nejmen\u0161\u00edho po nejv\u011bt\u0161\u00ed.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Z dodan\u00e9ho seznamu \u010d\u00edsel vyberte a vra\u0165te dv\u011b, kter\u00e1 jsou si nejbl\u00ed\u017ee, a vra\u0165te je v po\u0159ad\u00ed.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Vzhledem k seznamu \u010d\u00edsel aplikujte na tento seznam line\u00e1rn\u00ed transformaci, \ntak, aby nejmen\u0161\u00ed \u010d\u00edslo bylo 0 a nejv\u011bt\u0161\u00ed bylo 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filtrovat dan\u00fd seznam jak\u00fdchkoliv hodnot Pythonu pouze pro cel\u00e1 \u010d\u00edsla\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Vr\u00e1tit d\u00e9lku dan\u00e9ho \u0159et\u011bzce\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Pro dan\u00e9 \u010d\u00edslo n najd\u011bte nejv\u011bt\u0161\u00ed \u010d\u00edslo, kter\u00e9 n beze zbytku d\u011bl\u00ed a je men\u0161\u00ed ne\u017e n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Vr\u00e1cen\u00fd seznam prvo\u010d\u00edseln\u00fdch faktor\u016f dan\u00e9ho cel\u00e9ho \u010d\u00edsla v po\u0159ad\u00ed od nejmen\u0161\u00edho po nejv\u011bt\u0161\u00ed.\n    Ka\u017ed\u00fd z faktor\u016f by m\u011bl b\u00fdt uveden tolikr\u00e1t, kolikr\u00e1t se vyskytuje ve faktorizaci.\n    Vstupn\u00ed \u010d\u00edslo by m\u011blo b\u00fdt rovno sou\u010dinu v\u0161ech faktor\u016f.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Ze seznamu cel\u00fdch \u010d\u00edsel odstra\u0148te v\u0161echny prvky, kter\u00e9 se vyskytuj\u00ed v\u00edce ne\u017e jednou.\n    Zachovejte po\u0159ad\u00ed zb\u00fdvaj\u00edc\u00edch prvk\u016f stejn\u00e9 jako v\u00a0p\u016fvodn\u00edm vstupu.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Pro dan\u00fd \u0159et\u011bzec p\u0159evra\u0165te mal\u00e1 p\u00edsmena na velk\u00e1 a velk\u00e1 p\u00edsmena na mal\u00e1.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Spojit seznam \u0159et\u011bzc\u016f do jednoho \u0159et\u011bzce\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filtrovat vstupn\u00ed seznam \u0159et\u011bzc\u016f pouze pro ty, kter\u00e9 za\u010d\u00ednaj\u00ed danou p\u0159edponou.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Vr\u00e1tit pouze kladn\u00e1 \u010d\u00edsla v seznamu.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Vra\u0165te true, pokud je dan\u00e9 \u010d\u00edslo prvo\u010d\u00edslo, a false v opa\u010dn\u00e9m p\u0159\u00edpad\u011b.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Vyhodnot\u00ed polynom s koeficienty xs v bod\u011b x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Tato funkce p\u0159ij\u00edm\u00e1 seznam l a vrac\u00ed seznam l', kter\u00fd je \nidentick\u00fd se seznamem l na indexech, kter\u00e9 nejsou d\u011bliteln\u00e9 t\u0159emi, zat\u00edmco jeho hodnoty na indexech, kter\u00e9 jsou d\u011bliteln\u00e9 t\u0159emi, jsou rovny \nhodnot\u00e1m odpov\u00eddaj\u00edc\u00edch index\u016f seznamu l, ale set\u0159\u00edd\u011bn\u00e9.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Vr\u00e1tit se\u0159azen\u00e9 unik\u00e1tn\u00ed prvky v seznamu\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Vr\u00e1tit maxim\u00e1ln\u00ed prvek v seznamu.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Vr\u00e1t\u00ed po\u010det v\u00fdskyt\u016f \u010d\u00edslice 7 v cel\u00fdch \u010d\u00edslech men\u0161\u00edch ne\u017e n, kter\u00e1 jsou d\u011bliteln\u00e1 11 nebo 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Tato funkce bere seznam l a vrac\u00ed seznam l', takov\u00fd, \u017ee\n    l' je toto\u017en\u00fd s l na lich\u00fdch indexech, zat\u00edmco jeho hodnoty na sud\u00fdch indexech jsou stejn\u00e9\n    jako hodnoty na sud\u00fdch indexech l, ale se\u0159azen\u00e9.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    vrac\u00ed zak\u00f3dovan\u00fd \u0159et\u011bzec cyklov\u00e1n\u00edm skupin po t\u0159ech znac\u00edch.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib vrac\u00ed n-t\u00e9 \u010d\u00edslo, kter\u00e9 je Fibonacciho \u010d\u00edslo a z\u00e1rove\u0148 prvo\u010d\u00edslo.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    `triples_sum_to_zero` bere jako vstup seznam cel\u00fdch \u010d\u00edsel. Vrac\u00ed hodnotu True, pokud jsou v seznamu t\u0159i r\u016fzn\u00e9 prvky, jejich\u017e sou\u010det je nula, a False v opa\u010dn\u00e9m p\u0159\u00edpad\u011b.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    P\u0159edstavte si silnici, kter\u00e1 je dokonale rovn\u00e1 a nekone\u010dn\u011b dlouh\u00e1 \u010d\u00e1ra.\n    n aut jede zleva doprava; sou\u010dasn\u011b jin\u00e1 sada n aut\n    jede zprava doleva. Tyto dv\u011b sady aut za\u010d\u00ednaj\u00ed velmi daleko od sebe.\n    V\u0161echna auta se pohybuj\u00ed stejnou rychlost\u00ed. \u0158\u00edk\u00e1 se, \u017ee dv\u011b auta se sraz\u00ed,\n    kdy\u017e auto, kter\u00e9 jede zleva doprava, naraz\u00ed do auta, kter\u00e9 jede zprava doleva.\n    Auta jsou v\u0161ak nekone\u010dn\u011b pevn\u00e1 a siln\u00e1; v d\u016fsledku toho pokra\u010duj\u00ed ve sv\u00e9 trajektorii, jako by se nesrazila.\n\n    Tato funkce vypo\u010d\u00edt\u00e1 po\u010det takov\u00fdch koliz\u00ed.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Vr\u00e1tit seznam s prvky zv\u00fd\u0161en\u00fdmi o 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    `pairs_sum_to_zero` bere jako vstup seznam cel\u00fdch \u010d\u00edsel.\nVrac\u00ed True, pokud jsou v seznamu dva r\u016fzn\u00e9 prvky, jejich\u017e sou\u010det je nula, a False v opa\u010dn\u00e9m p\u0159\u00edpad\u011b.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Zm\u011b\u0148 \u010d\u00edselnou z\u00e1kladnu vstupn\u00edho \u010d\u00edsla x na z\u00e1kladnu.\n    vra\u0165 \u0159et\u011bzcovou reprezentaci po konverzi.\n    z\u00e1kladn\u00ed \u010d\u00edsla jsou men\u0161\u00ed ne\u017e 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Vzhledem k d\u00e9lce strany a v\u00fd\u0161ce vypo\u010d\u00edtejte plochu troj\u00faheln\u00edku.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"\u010c\u00edseln\u00e1 posloupnost Fib4 je posloupnost podobn\u00e1 Fibbonacciho posloupnosti, kter\u00e1 je definov\u00e1na n\u00e1sledovn\u011b:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    Pros\u00edm napi\u0161te funkci, kter\u00e1 efektivn\u011b vypo\u010d\u00edt\u00e1 n-t\u00fd prvek \u010d\u00edseln\u00e9 posloupnosti fib4. Nepou\u017e\u00edvejte rekurzi.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Vr\u00e1tit medi\u00e1n prvk\u016f v seznamu l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Kontroluje, zda je dan\u00fd \u0159et\u011bzec palindrom.\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Vra\u0165te 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    vr\u00e1t\u00ed zak\u00f3dovan\u00fd \u0159et\u011bzec posunut\u00edm ka\u017ed\u00e9ho znaku o 5 m\u00edst v abeced\u011b.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels je funkce, kter\u00e1 bere \u0159et\u011bzec a vrac\u00ed \u0159et\u011bzec bez samohl\u00e1sek.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Vr\u00e1t\u00ed True, pokud v\u0161echna \u010d\u00edsla v seznamu l jsou pod prahem t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Se\u010dt\u011bte dv\u011b \u010d\u00edsla x a y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Zkontrolujte, zda dv\u011b slova maj\u00ed stejn\u00e9 znaky.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Vr\u00e1tit n-t\u00e9 Fibonacciho \u010d\u00edslo.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Z\u00e1vorky jsou \u0159et\u011bzec z \"<\" a \">\". \n    Vra\u0165te True, pokud ka\u017ed\u00e1 otev\u00edrac\u00ed z\u00e1vorka m\u00e1 odpov\u00eddaj\u00edc\u00ed zav\u00edrac\u00ed z\u00e1vorku.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Vra\u0165te True, pokud jsou prvky seznamu monot\u00f3nn\u011b rostouc\u00ed nebo klesaj\u00edc\u00ed.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Vr\u00e1tit se\u0159azen\u00e9 jedine\u010dn\u00e9 spole\u010dn\u00e9 prvky pro dva seznamy.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Vr\u00e1tit nejv\u011bt\u0161\u00edho prvo\u010dinitele \u010d\u00edsla n. P\u0159edpokl\u00e1dejte, \u017ee n > 1 a nen\u00ed prvo\u010d\u00edslo.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n je funkce, kter\u00e1 s\u010d\u00edt\u00e1 \u010d\u00edsla od 1 do n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Z\u00e1vorky jsou \u0159et\u011bzec \"\". Vra\u0165te hodnotu True, pokud ka\u017ed\u00e1 otev\u00edrac\u00ed z\u00e1vorka m\u00e1 odpov\u00eddaj\u00edc\u00ed uzav\u00edrac\u00ed z\u00e1vorku.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs p\u0159edstavuj\u00ed koeficienty polynomu.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ...\n    Vra\u0165te derivaci tohoto polynomu ve stejn\u00e9m tvaru.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"Posloupnost \u010d\u00edsel FibFib je posloupnost podobn\u00e1 Fibonacciho posloupnosti, kter\u00e1 je definov\u00e1na n\u00e1sledovn\u011b:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Pros\u00edm, napi\u0161te funkci pro efektivn\u00ed v\u00fdpo\u010det n-t\u00e9ho prvku posloupnosti \u010d\u00edsel FibFib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nP\u0159idejte v\u00edce testovac\u00edch p\u0159\u00edpad\u016f.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Posu\u0148te \u010d\u00edslice cel\u00e9ho \u010d\u00edsla x, posu\u0148te \u010d\u00edslice doprava o shift a vra\u0165te v\u00fdsledek jako \u0159et\u011bzec. Pokud shift > po\u010det \u010d\u00edslic, vra\u0165te \u010d\u00edslice obr\u00e1cen\u011b.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"\u00dakol\n    Napi\u0161te funkci, kter\u00e1 vezme jako vstup \u0159et\u011bzec a vr\u00e1t\u00ed sou\u010det ASCII k\u00f3d\u016f pouze velk\u00fdch p\u00edsmen.\n\n    P\u0159\u00edklady:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    V tomto \u00fakolu v\u00e1m bude poskytnut \u0159et\u011bzec, kter\u00fd p\u0159edstavuje po\u010det jablek a pomeran\u010d\u016f, kter\u00e9 jsou rozd\u011bleny v ko\u0161\u00edku s ovocem. Tento ko\u0161\u00edk obsahuje jablka, pomeran\u010de a mango. Na z\u00e1klad\u011b \u0159et\u011bzce, kter\u00fd p\u0159edstavuje celkov\u00fd po\u010det pomeran\u010d\u016f a jablek, a celkov\u00e9ho po\u010dtu ovoce v ko\u0161\u00edku, vra\u0165te po\u010det mango v ko\u0161\u00edku.\nNap\u0159\u00edklad:\nfruit_distribution -> 19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \u201eVzhledem k poli p\u0159edstavuj\u00edc\u00edmu v\u011btev stromu, kter\u00e9 m\u00e1 nez\u00e1porn\u00e9 celo\u010d\u00edseln\u00e9 uzly,\nva\u0161\u00edm \u00fakolem je vybrat jeden z uzl\u016f a vr\u00e1tit ho.\nVybran\u00fd uzel by m\u011bl b\u00fdt uzel s nejmen\u0161\u00ed sudou hodnotou.\nPokud se najde v\u00edce uzl\u016f se stejnou nejmen\u0161\u00ed sudou hodnotou, vra\u0165te uzel, kter\u00fd m\u00e1 nejmen\u0161\u00ed index.\n\nVybran\u00fd uzel by m\u011bl b\u00fdt vr\u00e1cen v seznamu, [nejmen\u0161\u00ed_hodnota, jej\u00ed index].\nPokud nejsou \u017e\u00e1dn\u00e9 sud\u00e9 hodnoty nebo je dan\u00e9 pole pr\u00e1zdn\u00e9, vra\u0165te [].\n\nP\u0159\u00edklad1:\n    Vstup: [4,2,3]\n    V\u00fdstup: [2, 1]\n    Vysv\u011btlen\u00ed: 2 m\u00e1 nejmen\u0161\u00ed sudou hodnotu a 2 m\u00e1 nejmen\u0161\u00ed index.\n\nP\u0159\u00edklad2:\n    Vstup: [1,2,3]\n    V\u00fdstup: [2, 1]\n    Vysv\u011btlen\u00ed: 2 m\u00e1 nejmen\u0161\u00ed sudou hodnotu a 2 m\u00e1 nejmen\u0161\u00ed index.\n\nP\u0159\u00edklad3:\n    Vstup: []\n    V\u00fdstup: []\n\nP\u0159\u00edklad4:\n    Vstup: [5, 0, 3, 0, 4, 2]\n    V\u00fdstup: [0, 1]\n    Vysv\u011btlen\u00ed: 0 je nejmen\u0161\u00ed hodnota, ale jsou tam dv\u011b nuly,\n                tak vybereme prvn\u00ed nulu, kter\u00e1 m\u00e1 nejmen\u0161\u00ed index.\n\nOmezen\u00ed:\n    * 1 <= d\u00e9lka_uzl\u016f <= 10000\n    * 0 <= hodnota_uzlu\u201c\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Vzhledem k poli cel\u00fdch \u010d\u00edsel arr najd\u011bte minim\u00e1ln\u00ed po\u010det prvk\u016f, kter\u00e9 je t\u0159eba zm\u011bnit, aby se pole stalo palindromick\u00fdm. Palindromick\u00e9 pole je takov\u00e9 pole, kter\u00e9 se \u010dte stejn\u011b pozp\u00e1tku i pop\u0159edu. P\u0159i jedn\u00e9 zm\u011bn\u011b m\u016f\u017eete zm\u011bnit jeden prvek na jak\u00fdkoli jin\u00fd prvek.\n\nNap\u0159\u00edklad:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Napi\u0161te funkci, kter\u00e1 vr\u00e1t\u00ed true, pokud je dan\u00e9 \u010d\u00edslo n\u00e1sobkem 3 prvo\u010d\u00edsel, a false v opa\u010dn\u00e9m p\u0159\u00edpad\u011b.\n    V\u011bd\u011bt, \u017ee je men\u0161\u00ed ne\u017e 100.\n    P\u0159\u00edklad:\n    is_multiply_prime == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Va\u0161\u00edm \u00fakolem je napsat funkci, kter\u00e1 vr\u00e1t\u00ed true, pokud je \u010d\u00edslo x jednoduchou mocninou n, a false v ostatn\u00edch p\u0159\u00edpadech.\n    x je jednoduchou mocninou n, pokud n**int = x\n    Nap\u0159\u00edklad:\n    is_simple_power => true\n    is_simple_power => true\n    is_simple_power => true\n    is_simple_power => false\n    is_simple_power => false\n    is_simple_power => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Byli jste pov\u011b\u0159eni naps\u00e1n\u00edm funkce, kter\u00e1 p\u0159ij\u00edm\u00e1 \nhexadecim\u00e1ln\u00ed \u010d\u00edslo jako \u0159et\u011bzec a po\u010d\u00edt\u00e1 po\u010det hexadecim\u00e1ln\u00edch \n\u010d\u00edslic, kter\u00e9 jsou prvo\u010d\u00edsly (prvo\u010d\u00edslo je p\u0159irozen\u00e9 \u010d\u00edslo \nv\u011bt\u0161\u00ed ne\u017e 1, kter\u00e9 nen\u00ed sou\u010dinem dvou men\u0161\u00edch p\u0159irozen\u00fdch \u010d\u00edsel).\nHexadecim\u00e1ln\u00ed \u010d\u00edslice jsou 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrvo\u010d\u00edsla jsou 2, 3, 5, 7, 11, 13, 17,...\nTak\u017ee mus\u00edte ur\u010dit po\u010det n\u00e1sleduj\u00edc\u00edch \u010d\u00edslic: 2, 3, 5, 7, \nB, D.\nPozn\u00e1mka: m\u016f\u017eete p\u0159edpokl\u00e1dat, \u017ee vstup je v\u017edy spr\u00e1vn\u00fd nebo pr\u00e1zdn\u00fd \u0159et\u011bzec,\na symboly A, B, C, D, E, F jsou v\u017edy velk\u00e1 p\u00edsmena.\nP\u0159\u00edklady:\nPro num = \"AB\" by m\u011bl b\u00fdt v\u00fdsledek 1.\nPro num = \"1077E\" by m\u011bl b\u00fdt v\u00fdsledek 2.\nPro num = \"ABED1A33\" by m\u011bl b\u00fdt v\u00fdsledek 4.\nPro num = \"123456789ABCDEF0\" by m\u011bl b\u00fdt v\u00fdsledek 6.\nPro num = \"2020\" by m\u011bl b\u00fdt v\u00fdsledek 2.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Bude v\u00e1m d\u00e1no \u010d\u00edslo v des\u00edtkov\u00e9 soustav\u011b a va\u0161\u00edm \u00fakolem bude p\u0159ev\u00e9st ho do bin\u00e1rn\u00edho form\u00e1tu. Funkce by m\u011bla vr\u00e1tit \u0159et\u011bzec, kde ka\u017ed\u00fd znak p\u0159edstavuje bin\u00e1rn\u00ed \u010d\u00edslo. Ka\u017ed\u00fd znak v \u0159et\u011bzci bude '0' nebo '1'.\n\nNa za\u010d\u00e1tku a na konci \u0159et\u011bzce budou nav\u00edc dva znaky 'db'. Tyto znaky jsou tam, aby pomohly s form\u00e1tem.\n\nP\u0159\u00edklady:\ndecimal_to_binary   # vrac\u00ed \"db1111db\"\ndecimal_to_binary   # vrac\u00ed \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"D\u00e1n v\u00e1m \u0159et\u011bzec s.\nVa\u0161\u00edm \u00fakolem je zjistit, zda je \u0159et\u011bzec \u0161\u0165astn\u00fd nebo ne.\n\u0158et\u011bzec je \u0161\u0165astn\u00fd, pokud m\u00e1 d\u00e9lku alespo\u0148 3 a ka\u017ed\u00e9 3 po sob\u011b jdouc\u00ed znaky jsou r\u016fzn\u00e9.\nNap\u0159\u00edklad:\nis_happy => False\nis_happy => False\nis_happy => True\nis_happy => False\nis_happy => True\nis_happy => False\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Je posledn\u00ed t\u00fdden semestru a u\u010ditel mus\u00ed d\u00e1t zn\u00e1mky student\u016fm. U\u010ditelka vytvo\u0159ila sv\u016fj vlastn\u00ed algoritmus pro hodnocen\u00ed. Jedin\u00fd probl\u00e9m je, \u017ee ztratila k\u00f3d, kter\u00fd pou\u017eila pro hodnocen\u00ed. Dala v\u00e1m seznam GPA n\u011bkter\u00fdch student\u016f a vy mus\u00edte napsat funkci, kter\u00e1 m\u016f\u017ee vydat seznam p\u00edsmenov\u00fdch zn\u00e1mek podle n\u00e1sleduj\u00edc\u00ed tabulky:\n\n             GPA       |    P\u00edsmenov\u00e1 zn\u00e1mka\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    P\u0159\u00edklad:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Napi\u0161te funkci, kter\u00e1 bere \u0159et\u011bzec a vr\u00e1t\u00ed True, pokud je d\u00e9lka \u0159et\u011bzce prvo\u010d\u00edslo, nebo False v opa\u010dn\u00e9m p\u0159\u00edpad\u011b.\nP\u0159\u00edklady:\nprime_length == True\nprime_length == True\nprime_length == True\nprime_length == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Je-li d\u00e1n kladn\u00fd cel\u00e9 \u010d\u00edslo n, vra\u0165te po\u010det n-cifern\u00fdch kladn\u00fdch \u010d\u00edsel, kter\u00e1 za\u010d\u00ednaj\u00ed nebo kon\u010d\u00ed jedni\u010dkou.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Vzhledem k kladn\u00e9mu cel\u00e9mu \u010d\u00edslu N, vra\u0165te celkov\u00fd sou\u010det jeho \u010d\u00edslic v bin\u00e1rn\u00ed soustav\u011b.\n\n    P\u0159\u00edklad\n        Pro N = 1000 bude sou\u010det \u010d\u00edslic 1 a v\u00fdstup by m\u011bl b\u00fdt \"1\".\n        Pro N = 150 bude sou\u010det \u010d\u00edslic 6 a v\u00fdstup by m\u011bl b\u00fdt \"110\".\n        Pro N = 147 bude sou\u010det \u010d\u00edslic 12 a v\u00fdstup by m\u011bl b\u00fdt \"1100\".\n    \n    Prom\u011bnn\u00e9:\n        @N cel\u00e9 \u010d\u00edslo\n             Omezen\u00ed: 0 \u2264 N \u2264 10000.\n    V\u00fdstup:\n         \u0159et\u011bzec bin\u00e1rn\u00edho \u010d\u00edsla\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Vzhledem k nepr\u00e1zdn\u00e9mu seznamu cel\u00fdch \u010d\u00edsel lst. se\u010dt\u011bte sud\u00e9 prvky, kter\u00e9 jsou na lich\u00fdch indexech.\n\n    P\u0159\u00edklady:\n        add ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Napi\u0161te funkci, kter\u00e1 p\u0159ijme \u0159et\u011bzec a vr\u00e1t\u00ed jeho se\u0159azenou verzi.\n    Se\u0159azen\u00e1 verze \u0159et\u011bzce je takov\u00e1, kde v\u0161echna slova\n    jsou nahrazena nov\u00fdm slovem, ve kter\u00e9m jsou v\u0161echny znaky uspo\u0159\u00e1d\u00e1ny\n    vzestupn\u011b podle ASCII hodnoty.\n    Pozn\u00e1mka: M\u011bli byste zachovat po\u0159ad\u00ed slov a pr\u00e1zdn\u00fdch mezer ve v\u011bt\u011b.\n\n    Nap\u0159\u00edklad:\n    anti_shuffle vr\u00e1t\u00ed 'Hi'\n    anti_shuffle vr\u00e1t\u00ed 'ehllo'\n    anti_shuffle vr\u00e1t\u00ed 'Hello !!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    M\u00e1te dvourozm\u011brn\u00e1 data ve form\u011b vno\u0159en\u00fdch seznam\u016f, \n    kter\u00e1 jsou podobn\u00e1 matici, ale na rozd\u00edl od matic \n    m\u016f\u017ee ka\u017ed\u00fd \u0159\u00e1dek obsahovat r\u016fzn\u00fd po\u010det sloupc\u016f.\n    S ohledem na lst a cel\u00e9 \u010d\u00edslo x, najd\u011bte cel\u00e1 \u010d\u00edsla x v seznamu\n    a vra\u0165te seznam n-tic, [, ...] tak, aby ka\u017ed\u00e1 n-tice\n    byla sou\u0159adnice -, za\u010d\u00ednaj\u00edc\u00ed od 0.\n    Se\u0159a\u010fte sou\u0159adnice nejprve podle \u0159\u00e1dk\u016f vzestupn\u011b.\n    Tak\u00e9 se\u0159a\u010fte sou\u0159adnice v \u0159\u00e1dku podle sloupc\u016f sestupn\u011b.\n    \n    P\u0159\u00edklady:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [,,,,]\n    get_row == []\n    get_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Vzhledem k poli nenegativn\u00edch cel\u00fdch \u010d\u00edsel vra\u0165te kopii dan\u00e9ho pole po se\u0159azen\u00ed,\n    pole se\u0159ad\u00edte vzestupn\u011b, pokud sou\u010det je lich\u00fd,\n    nebo ho se\u0159ad\u00edte sestupn\u011b, pokud sou\u010det je sud\u00fd.\n\n    Pozn\u00e1mka:\n    * nem\u011b\u0148te dan\u00e9 pole.\n\n    P\u0159\u00edklady:\n    * sort_array => []\n    * sort_array => [5]\n    * sort_array => [0, 1, 2, 3, 4, 5]\n    * sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Vytvo\u0159te funkci encrypt, kter\u00e1 p\u0159ijme \u0159et\u011bzec jako argument a vr\u00e1t\u00ed \u0159et\u011bzec za\u0161ifrovan\u00fd s rotac\u00ed abecedy. Abeceda by m\u011bla b\u00fdt oto\u010dena tak, aby se p\u00edsmena posunula o \u010dty\u0159i m\u00edsta dol\u016f. \nNap\u0159\u00edklad:\nencrypt vr\u00e1t\u00ed 'lm'\nencrypt vr\u00e1t\u00ed 'ewhjklnop'\nencrypt vr\u00e1t\u00ed 'kj'\nencrypt vr\u00e1t\u00ed 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Dostanete seznam cel\u00fdch \u010d\u00edsel.\nNapi\u0161te funkci next_smallest, kter\u00e1 vr\u00e1t\u00ed 2. nejmen\u0161\u00ed prvek seznamu.\nVra\u0165te None, pokud takov\u00fd prvek neexistuje.\n\nnext_smallest == 2\nnext_smallest == 2\nnext_smallest == None\nnext_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Dostanete \u0159et\u011bzec slov a va\u0161\u00edm \u00fakolem bude spo\u010d\u00edtat po\u010det nud. Nuda je v\u011bta, kter\u00e1 za\u010d\u00edn\u00e1 slovem \"J\u00e1\". V\u011bty jsou odd\u011bleny '.', '?' nebo '!'.\n\nNap\u0159\u00edklad:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Napi\u0161te funkci, kter\u00e1 vezme zpr\u00e1vu a zak\u00f3duje ji takov\u00fdm zp\u016fsobem, \n\u017ee zam\u011bn\u00ed velikost v\u0161ech p\u00edsmen a nahrad\u00ed v\u0161echny samohl\u00e1sky ve \nzpr\u00e1v\u011b p\u00edsmenem, kter\u00e9 se v anglick\u00e9 abeced\u011b nach\u00e1z\u00ed o 2 m\u00edsta d\u00e1le. \nP\u0159edpokl\u00e1dejte pouze p\u00edsmena.\n\nP\u0159\u00edklady:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Dostanete seznam cel\u00fdch \u010d\u00edsel.\n    Mus\u00edte naj\u00edt nejv\u011bt\u0161\u00ed prvo\u010d\u00edslo a vr\u00e1tit sou\u010det jeho \u010d\u00edslic.\n\n    P\u0159\u00edklady:\n    Pro lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] by m\u011bl b\u00fdt v\u00fdstup 10.\n    Pro lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] by m\u011bl b\u00fdt v\u00fdstup 25.\n    Pro lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] by m\u011bl b\u00fdt v\u00fdstup 13.\n    Pro lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] by m\u011bl b\u00fdt v\u00fdstup 11.\n    Pro lst = [0,81,12,3,1,21] by m\u011bl b\u00fdt v\u00fdstup 3.\n    Pro lst = [0,8,1,2,1,7] by m\u011bl b\u00fdt v\u00fdstup 7.\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Vzhledem k slovn\u00edku vr\u00e1t\u00ed True, pokud jsou v\u0161echny kl\u00ed\u010de \u0159et\u011bzce v mal\u00fdch p\u00edsmenech nebo v\u0161echny kl\u00ed\u010de jsou \u0159et\u011bzce ve velk\u00fdch p\u00edsmenech, jinak vr\u00e1t\u00ed False. Funkce by m\u011bla vr\u00e1tit False, pokud je dan\u00fd slovn\u00edk pr\u00e1zdn\u00fd.\n\nP\u0159\u00edklady:\ncheck_dict_case by m\u011blo vr\u00e1tit True.\ncheck_dict_case by m\u011blo vr\u00e1tit False.\ncheck_dict_case by m\u011blo vr\u00e1tit False.\ncheck_dict_case by m\u011blo vr\u00e1tit False.\ncheck_dict_case by m\u011blo vr\u00e1tit True.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Implementujte funkci, kter\u00e1 p\u0159ijme nez\u00e1porn\u00e9 cel\u00e9 \u010d\u00edslo a vr\u00e1t\u00ed pole prvn\u00edch n cel\u00fdch \u010d\u00edsel, kter\u00e1 jsou prvo\u010d\u00edsla a men\u0161\u00ed ne\u017e n.\nNap\u0159\u00edklad:\ncount_up_to => [2,3]\ncount_up_to => [2,3,5,7]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17,19]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Dokon\u010dete funkci, kter\u00e1 p\u0159ijme dv\u011b cel\u00e1 \u010d\u00edsla a vr\u00e1t\u00ed\n    sou\u010din jejich jednotkov\u00fdch \u010d\u00edslic.\n    P\u0159edpokl\u00e1dejte, \u017ee vstup je v\u017edy platn\u00fd.\n    P\u0159\u00edklady:\n    multiply by m\u011blo vr\u00e1tit 16.\n    multiply by m\u011blo vr\u00e1tit 72.\n    multiply by m\u011blo vr\u00e1tit 0.\n    multiply by m\u011blo vr\u00e1tit 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Vzhledem k \u0159et\u011bzci s spo\u010d\u00edtejte po\u010det velk\u00fdch samohl\u00e1sek na sud\u00fdch indexech.\n\n    Nap\u0159\u00edklad:\n    count_upper vr\u00e1t\u00ed 1\n    count_upper vr\u00e1t\u00ed 0\n    count_upper vr\u00e1t\u00ed 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Je d\u00e1no kladn\u00e9 cel\u00e9 \u010d\u00edslo n, mus\u00edte vytvo\u0159it hromadu n \u00farovn\u00ed kamen\u016f.\n    Prvn\u00ed \u00farove\u0148 m\u00e1 n kamen\u016f.\n    Po\u010det kamen\u016f na dal\u0161\u00ed \u00farovni je:\n        - dal\u0161\u00ed lich\u00e9 \u010d\u00edslo, pokud je n lich\u00e9.\n        - dal\u0161\u00ed sud\u00e9 \u010d\u00edslo, pokud je n sud\u00e9.\n    Vra\u0165te po\u010det kamen\u016f na ka\u017ed\u00e9 \u00farovni v seznamu, kde prvek na indexu\n    i p\u0159edstavuje po\u010det kamen\u016f na \u00farovni.\n\n    P\u0159\u00edklady:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Bude v\u00e1m zad\u00e1n \u0159et\u011bzec slov odd\u011blen\u00fdch \u010d\u00e1rkami nebo mezerami. Va\u0161\u00edm \u00fakolem je\n    rozd\u011blit \u0159et\u011bzec na slova a vr\u00e1tit pole t\u011bchto slov.\n    \n    Nap\u0159\u00edklad:\n    words_string == [\"Ahoj\", \"jmenuji\", \"se\", \"Jan\"]\n    words_string == [\"Jedna\", \"dv\u011b\", \"t\u0159i\", \"\u010dty\u0159i\", \"p\u011bt\", \"\u0161est\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Tato funkce bere dv\u011b kladn\u00e1 \u010d\u00edsla x a y a vrac\u00ed nejv\u011bt\u0161\u00ed sud\u00e9 cel\u00e9 \u010d\u00edslo, kter\u00e9 se nach\u00e1z\u00ed v rozmez\u00ed [x, y] v\u010detn\u011b. Pokud takov\u00e9 \u010d\u00edslo neexistuje, funkce by m\u011bla vr\u00e1tit -1.\n\nNap\u0159\u00edklad:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Dostanete dv\u011b kladn\u00e1 cel\u00e1 \u010d\u00edsla n a m a va\u0161\u00edm \u00fakolem je vypo\u010d\u00edtat pr\u016fm\u011br \u010d\u00edsel od n po m.\nZaokrouhlete odpov\u011b\u010f na nejbli\u017e\u0161\u00ed cel\u00e9 \u010d\u00edslo a p\u0159eve\u010fte ji na bin\u00e1rn\u00ed form\u00e1t.\nPokud je n v\u011bt\u0161\u00ed ne\u017e m, vra\u0165te -1.\nP\u0159\u00edklad:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Vzhledem k seznamu kladn\u00fdch cel\u00fdch \u010d\u00edsel x vra\u0165te se\u0159azen\u00fd seznam v\u0161ech prvk\u016f, kter\u00e9 neobsahuj\u00ed \u017e\u00e1dnou sudou \u010d\u00edslici.\n\nPozn\u00e1mka: Vr\u00e1cen\u00fd seznam by m\u011bl b\u00fdt se\u0159azen ve vzestupn\u00e9m po\u0159ad\u00ed.\n\nNap\u0159\u00edklad:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Pokud je pole cel\u00e9 \u010d\u00edsel, se\u0159a\u010fte cel\u00e1 \u010d\u00edsla, kter\u00e1 jsou mezi 1 a 9 v\u010detn\u011b, \n    oto\u010dte v\u00fdsledn\u00e9 pole a pot\u00e9 nahra\u010fte ka\u017edou \u010d\u00edslici jej\u00edm odpov\u00eddaj\u00edc\u00edm n\u00e1zvem z\n    \"Jedna\", \"Dva\", \"T\u0159i\", \"\u010cty\u0159i\", \"P\u011bt\", \"\u0160est\", \"Sedm\", \"Osm\", \"Dev\u011bt\".\n\n    Nap\u0159\u00edklad:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> se\u0159adit arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> oto\u010dit arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      vr\u00e1tit [\"Osm\", \"P\u011bt\", \"\u010cty\u0159i\", \"T\u0159i\", \"Dva\", \"Dva\", \"Jedna\", \"Jedna\"]\n    \n      Pokud je pole pr\u00e1zdn\u00e9, vra\u0165te pr\u00e1zdn\u00e9 pole:\n      arr = []\n      vr\u00e1tit []\n    \n      Pokud pole obsahuje n\u011bjak\u00e9 zvl\u00e1\u0161tn\u00ed \u010d\u00edslo, ignorujte ho:\n      arr = [1, -1, 55] \n            -> se\u0159adit arr -> [-1, 1, 55]\n            -> oto\u010dit arr -> [55, 1, -1]\n      vr\u00e1tit = ['Jedna']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Implementujte funkci f, kter\u00e1 bere n jako parametr\n    a vrac\u00ed seznam velikosti n, takov\u00fd, \u017ee hodnota prvku na indexu i je faktori\u00e1l i, pokud je i sud\u00e9,\n    nebo sou\u010det \u010d\u00edsel od 1 do i jinak.\n    i za\u010d\u00edn\u00e1 od 1.\n    faktori\u00e1l i je n\u00e1soben\u00ed \u010d\u00edsel od 1 do i.\n    P\u0159\u00edklad:\n    f == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Vzhledem k dan\u00e9mu kladn\u00e9mu \u010d\u00edslu n, vra\u0165te n-tici, kter\u00e1 obsahuje po\u010det sud\u00fdch a lich\u00fdch\n    celo\u010d\u00edseln\u00fdch palindrom\u016f, kter\u00e9 spadaj\u00ed do rozsahu, v\u010detn\u011b.\n\n    P\u0159\u00edklad1:\n\n        Vstup: 3\n        V\u00fdstup:\n        Vysv\u011btlen\u00ed:\n        Celo\u010d\u00edseln\u00e9 palindromy jsou 1, 2, 3. Jeden z nich je sud\u00fd a dva z nich jsou lich\u00e9.\n\n    P\u0159\u00edklad2:\n\n        Vstup: 12\n        V\u00fdstup:\n        Vysv\u011btlen\u00ed:\n        Celo\u010d\u00edseln\u00e9 palindromy jsou 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u010cty\u0159i z nich jsou sud\u00e9 a \u0161est z nich je lich\u00fdch.\n\n    Pozn\u00e1mka:\n        1. 1 <= n <= 10^3\n        2. Vr\u00e1cen\u00e1 n-tice obsahuje po\u010det sud\u00fdch a lich\u00fdch celo\u010d\u00edseln\u00fdch palindrom\u016f v dan\u00e9m po\u0159ad\u00ed.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Napi\u0161te funkci count_nums, kter\u00e1 p\u0159ij\u00edm\u00e1 pole cel\u00fdch \u010d\u00edsel a vrac\u00ed po\u010det prvk\u016f, jejich\u017e sou\u010det \u010d\u00edslic je > 0.\nPokud je \u010d\u00edslo z\u00e1porn\u00e9, pak jeho prvn\u00ed podepsan\u00e1 \u010d\u00edslice bude z\u00e1porn\u00e1:\nnap\u0159. -123 m\u00e1 podepsan\u00e9 \u010d\u00edslice -1, 2 a 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"M\u00e1me pole 'arr' z N cel\u00fdch \u010d\u00edsel arr[1], arr[2], ..., arr[N]. \u010c\u00edsla v poli budou n\u00e1hodn\u011b uspo\u0159\u00e1d\u00e1na. Va\u0161\u00edm \u00fakolem je ur\u010dit, zda je mo\u017en\u00e9 z\u00edskat pole se\u0159azen\u00e9 v neklesaj\u00edc\u00edm po\u0159ad\u00ed proveden\u00edm n\u00e1sleduj\u00edc\u00ed operace na dan\u00e9m poli:\n    M\u016f\u017eete prov\u00e9st operaci posunu doprava libovoln\u00fd po\u010detkr\u00e1t.\n\n    Operace posunu doprava znamen\u00e1 posunut\u00ed v\u0161ech prvk\u016f pole o jednu pozici doprava. Posledn\u00ed prvek pole bude p\u0159esunut na za\u010d\u00e1tek pole, tj. na index 0.\n\n    Pokud je mo\u017en\u00e9 z\u00edskat se\u0159azen\u00e9 pole proveden\u00edm v\u00fd\u0161e uveden\u00e9 operace, vra\u0165te True, jinak vra\u0165te False.\n    Pokud je dan\u00e9 pole pr\u00e1zdn\u00e9, vra\u0165te True.\n\n    Pozn\u00e1mka: U dan\u00e9ho seznamu je zaru\u010deno, \u017ee m\u00e1 unik\u00e1tn\u00ed prvky.\n\n    Nap\u0159\u00edklad:\n\n    move_one_ball ==> True\n    Vysv\u011btlen\u00ed: Proveden\u00edm 2 operac\u00ed posunu doprava lze dos\u00e1hnout neklesaj\u00edc\u00edho po\u0159ad\u00ed pro dan\u00e9 pole.\n    move_one_ball ==> False\n    Vysv\u011btlen\u00ed: Nen\u00ed mo\u017en\u00e9 z\u00edskat neklesaj\u00edc\u00ed po\u0159ad\u00ed pro dan\u00e9 pole proveden\u00edm libovoln\u00e9ho po\u010dtu operac\u00ed posunu doprava.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"V tomto probl\u00e9mu implementujete funkci, kter\u00e1 p\u0159ij\u00edm\u00e1 dva seznamy \u010d\u00edsel a ur\u010d\u00ed, zda je mo\u017en\u00e9 prov\u00e9st v\u00fdm\u011bnu prvk\u016f mezi nimi, aby se lst1 stal seznamem pouze sud\u00fdch \u010d\u00edsel. Neexistuje \u017e\u00e1dn\u00e9 omezen\u00ed na po\u010det vym\u011bn\u011bn\u00fdch prvk\u016f mezi lst1 a lst2. Pokud je mo\u017en\u00e9 vym\u011bnit prvky mezi lst1 a lst2 tak, aby v\u0161echny prvky v lst1 byly sud\u00e9, vra\u0165te \"ANO\". Jinak vra\u0165te \"NE\".\nNap\u0159\u00edklad:\nexchange => \"ANO\"\nexchange => \"NE\"\nP\u0159edpokl\u00e1d\u00e1 se, \u017ee vstupn\u00ed seznamy budou nepr\u00e1zdn\u00e9.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Vzhledem k \u0159et\u011bzci p\u0159edstavuj\u00edc\u00edmu mezery odd\u011blen\u00e9 mal\u00fdmi p\u00edsmeny, vra\u0165te slovn\u00edk\n    s p\u00edsmenem s nejv\u011bt\u0161\u00edm opakov\u00e1n\u00edm a obsahuj\u00edc\u00ed odpov\u00eddaj\u00edc\u00ed po\u010det.\n    Pokud m\u00e1 n\u011bkolik p\u00edsmen stejn\u00fd v\u00fdskyt, vra\u0165te v\u0161echna z nich.\n\n    P\u0159\u00edklad:\n    histogram == {'a': 1, 'b': 1, 'c': 1}\n    histogram == {'a': 2, 'b': 2}\n    histogram == {'a': 2, 'b': 2}\n    histogram == {'b': 4}\n    histogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"\u00dakol\n    M\u00e1me d\u00e1ny dva \u0159et\u011bzce s a c, mus\u00edte odstranit v\u0161echny znaky v s, kter\u00e9 se rovnaj\u00ed jak\u00e9mukoli znaku v c,\n    a pot\u00e9 zkontrolovat, zda je v\u00fdsledn\u00fd \u0159et\u011bzec palindrom.\n    \u0158et\u011bzec se naz\u00fdv\u00e1 palindrom, pokud se \u010dte stejn\u011b dozadu i dop\u0159edu.\n    M\u011bli byste vr\u00e1tit n-tici obsahuj\u00edc\u00ed v\u00fdsledn\u00fd \u0159et\u011bzec a True\/False pro kontrolu.\n    P\u0159\u00edklad\n    Pro s = \"abcde\", c = \"ae\", v\u00fdsledek by m\u011bl b\u00fdt\n    Pro s = \"abcdef\", c = \"b\" v\u00fdsledek by m\u011bl b\u00fdt\n    Pro s = \"abcdedcba\", c = \"ab\", v\u00fdsledek by m\u011bl b\u00fdt\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Vzhledem k seznamu \u0159et\u011bzc\u016f, kde ka\u017ed\u00fd \u0159et\u011bzec obsahuje pouze \u010d\u00edslice, vra\u0165te seznam.\n    Ka\u017ed\u00fd prvek i v\u00fdstupu by m\u011bl b\u00fdt \"po\u010det lich\u00fdch prvk\u016f v \u0159et\u011bzci i vstupu.\" kde v\u0161echny i by m\u011bly b\u00fdt nahrazeny po\u010dtem lich\u00fdch \u010d\u00edslic v i-t\u00e9m \u0159et\u011bzci vstupu.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Vzhledem k poli cel\u00fdch \u010d\u00edsel nums, najd\u011bte minim\u00e1ln\u00ed sou\u010det jak\u00e9koli neprazdn\u00e9 pod-pole nums.\nP\u0159\u00edklad:\nminSubArraySum == 1\nminSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Zde je p\u0159eklad v\u011bty do \u010de\u0161tiny:\n\nM\u00e1te obd\u00e9ln\u00edkovou m\u0159\u00ed\u017eku studn\u00ed. Ka\u017ed\u00fd \u0159\u00e1dek p\u0159edstavuje jednu studnu a ka\u017ed\u00e1 1 v \u0159\u00e1dku p\u0159edstavuje jednu jednotku vody. Ka\u017ed\u00e1 studna m\u00e1 odpov\u00eddaj\u00edc\u00ed kbel\u00edk, kter\u00fd lze pou\u017e\u00edt k \u010derp\u00e1n\u00ed vody z n\u00ed, a v\u0161echny kbel\u00edky maj\u00ed stejnou kapacitu. Va\u0161\u00edm \u00fakolem je pou\u017e\u00edt kbel\u00edky k vypr\u00e1zdn\u011bn\u00ed studn\u00ed. V\u00fdstupem je po\u010det spu\u0161t\u011bn\u00ed kbel\u00edk\u016f.\n\nP\u0159\u00edklad1:\n    Vstup:\n        m\u0159\u00ed\u017eka: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        kapacita_kbel\u00edku: 1\n    V\u00fdstup: 6\n\nP\u0159\u00edklad2:\n    Vstup:\n        m\u0159\u00ed\u017eka: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        kapacita_kbel\u00edku: 2\n    V\u00fdstup: 5\n\nP\u0159\u00edklad3:\n    Vstup:\n        m\u0159\u00ed\u017eka: [[0,0,0], [0,0,0]]\n        kapacita_kbel\u00edku: 5\n    V\u00fdstup: 0\n\nOmezen\u00ed:\n    * v\u0161echny studny maj\u00ed stejnou d\u00e9lku\n    * 1 <= d\u00e9lka_m\u0159\u00ed\u017eky <= 10^2\n    * 1 <= d\u00e9lka_m\u0159\u00ed\u017eky[:,1] <= 10^2\n    * m\u0159\u00ed\u017eka[i][j] -> 0 | 1\n    * 1 <= kapacita <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    V tomto Kata mus\u00edte se\u0159adit pole nez\u00e1porn\u00fdch cel\u00fdch \u010d\u00edsel podle po\u010dtu jedni\u010dek v jejich bin\u00e1rn\u00ed reprezentaci vzestupn\u011b. Pro stejn\u00fd po\u010det jedni\u010dek se\u0159a\u010fte podle desetinn\u00e9 hodnoty.\n\nMus\u00ed to b\u00fdt implementov\u00e1no takto:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Vzhledem k \u0159et\u011bzci s a p\u0159irozen\u00e9mu \u010d\u00edslu n, m\u00e1te za \u00fakol implementovat funkci, kter\u00e1 vr\u00e1t\u00ed seznam v\u0161ech slov z \u0159et\u011bzce s, kter\u00e1 obsahuj\u00ed p\u0159esn\u011b n souhl\u00e1sek, v po\u0159ad\u00ed, v jak\u00e9m se tato slova objevuj\u00ed v \u0159et\u011bzci s.\nPokud je \u0159et\u011bzec s pr\u00e1zdn\u00fd, pak by funkce m\u011bla vr\u00e1tit pr\u00e1zdn\u00fd seznam.\nPozn\u00e1mka: m\u016f\u017eete p\u0159edpokl\u00e1dat, \u017ee vstupn\u00ed \u0159et\u011bzec obsahuje pouze p\u00edsmena a mezery.\nP\u0159\u00edklady:\nselect_words ==> [\"little\"]\nselect_words ==> [\"Mary\", \"lamb\"]\nselect_words ==> []\nselect_words ==> [\"world\"]\nselect_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Dostanete slovo. Va\u0161\u00edm \u00fakolem je naj\u00edt nejbli\u017e\u0161\u00ed samohl\u00e1sku, kter\u00e1 stoj\u00ed mezi dv\u011bma souhl\u00e1skami z prav\u00e9 strany slova.\n\n    Samohl\u00e1sky na za\u010d\u00e1tku a na konci se nepo\u010d\u00edtaj\u00ed. Pokud nenajdete \u017e\u00e1dnou samohl\u00e1sku, kter\u00e1 spl\u0148uje v\u00fd\u0161e uvedenou podm\u00ednku, vra\u0165te pr\u00e1zdn\u00fd \u0159et\u011bzec.\n\n    M\u016f\u017eete p\u0159edpokl\u00e1dat, \u017ee dan\u00fd \u0159et\u011bzec obsahuje pouze anglick\u00e1 p\u00edsmena.\n\n    P\u0159\u00edklad:\n    get_closest_vowel ==> \"u\"\n    get_closest_vowel ==> \"U\"\n    get_closest_vowel ==> \"\"\n    get_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Vzhledem k poli arr cel\u00fdch \u010d\u00edsel a kladn\u00e9mu cel\u00e9mu \u010d\u00edslu k, vra\u0165te se\u0159azen\u00fd seznam d\u00e9lky k s maxim\u00e1ln\u00edmi k \u010d\u00edsly v arr.\n\nP\u0159\u00edklad1:\n\n    Vstup: arr = [-3, -4, 5], k = 3\n    V\u00fdstup: [-4, -3, 5]\n\nP\u0159\u00edklad2:\n\n    Vstup: arr = [4, -4, 4], k = 2\n    V\u00fdstup: [4, 4]\n\nP\u0159\u00edklad3:\n\n    Vstup: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    V\u00fdstup: [2]\n\nPozn\u00e1mka:\n    1. D\u00e9lka pole bude v rozmez\u00ed [1, 1000].\n    2. Prvky v poli budou v rozmez\u00ed [-1000, 1000].\n    3. 0 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Vzhledem k nepr\u00e1zdn\u00e9mu seznamu cel\u00fdch \u010d\u00edsel vra\u0165te sou\u010det v\u0161ech lich\u00fdch prvk\u016f, kter\u00e9 jsou na sud\u00fdch pozic\u00edch.\n\nP\u0159\u00edklady\nsolution ==> 12\nsolution ==> 9\nsolution ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Je-li d\u00e1no nepr\u00e1zdn\u00e9 pole cel\u00fdch \u010d\u00edsel arr a cel\u00e9 \u010d\u00edslo k, vra\u0165te sou\u010det prvk\u016f s nanejv\u00fd\u0161 dv\u011bma \u010d\u00edslicemi z prvn\u00edch k prvk\u016f pole arr.\n\nP\u0159\u00edklad:\n\n    Vstup: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    V\u00fdstup: 24 # sou\u010det 21 + 3\n\nOmezen\u00ed:\n    1. 1 <= d\u00e9lka <= 100\n    2. 1 <= k <= d\u00e9lka\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Vzhledem k pozitivn\u00edmu cel\u00e9mu \u010d\u00edslu n, vra\u0165te se\u0159azen\u00fd seznam, kter\u00fd obsahuje lich\u00e1 \u010d\u00edsla v Collatzov\u011b posloupnosti.\n\n    Collatzova domn\u011bnka je domn\u011bnka v matematice, kter\u00e1 se t\u00fdk\u00e1 posloupnosti definovan\u00e9\n    n\u00e1sledovn\u011b: za\u010dn\u011bte s jak\u00fdmkoliv kladn\u00fdm cel\u00fdm \u010d\u00edslem n. Pot\u00e9 ka\u017ed\u00fd \u010dlen je z\u00edsk\u00e1n\n    z p\u0159edchoz\u00edho \u010dlenu takto: pokud je p\u0159edchoz\u00ed \u010dlen sud\u00fd, n\u00e1sleduj\u00edc\u00ed \u010dlen je polovinou\n    p\u0159edchoz\u00edho \u010dlenu. Pokud je p\u0159edchoz\u00ed \u010dlen lich\u00fd, n\u00e1sleduj\u00edc\u00ed \u010dlen je 3kr\u00e1t p\u0159edchoz\u00ed\n    \u010dlen plus 1. Domn\u011bnka je, \u017ee bez ohledu na hodnotu n, posloupnost v\u017edy dos\u00e1hne 1.\n\n    Pozn\u00e1mka:\n        1. Collatz je [1].\n        2. vr\u00e1cen\u00fd seznam je se\u0159azen\u00fd vzestupn\u011b.\n\n    Nap\u0159\u00edklad:\n    get_odd_collatz vrac\u00ed [1, 5] # Collatzova posloupnost pro 5 je [5, 16, 8, 4, 2, 1], tak\u017ee lich\u00e1 \u010d\u00edsla jsou pouze 1 a 5.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Mus\u00edte napsat funkci, kter\u00e1 ov\u011b\u0159\u00ed zadan\u00fd \u0159et\u011bzec datumu a vr\u00e1t\u00ed True, pokud je datum platn\u00e9, jinak vr\u00e1t\u00ed False.\nDatum je platn\u00e9, pokud jsou spln\u011bna n\u00e1sleduj\u00edc\u00ed pravidla:\n1. \u0158et\u011bzec datumu nen\u00ed pr\u00e1zdn\u00fd.\n2. Po\u010det dn\u00ed nen\u00ed men\u0161\u00ed ne\u017e 1 nebo vy\u0161\u0161\u00ed ne\u017e 31 dn\u00ed pro m\u011bs\u00edce 1, 3, 5, 7, 8, 10, 12. A po\u010det dn\u00ed nen\u00ed men\u0161\u00ed ne\u017e 1 nebo vy\u0161\u0161\u00ed ne\u017e 30 dn\u00ed pro m\u011bs\u00edce 4, 6, 9, 11. A po\u010det dn\u00ed nen\u00ed men\u0161\u00ed ne\u017e 1 nebo vy\u0161\u0161\u00ed ne\u017e 29 pro m\u011bs\u00edc 2.\n3. M\u011bs\u00edce by nem\u011bly b\u00fdt men\u0161\u00ed ne\u017e 1 nebo vy\u0161\u0161\u00ed ne\u017e 12.\n4. Datum by m\u011blo b\u00fdt ve form\u00e1tu: mm-dd-yyyy\n\nnap\u0159\u00edklad:\nvalid_date => True\n\nvalid_date => False\n\nvalid_date => False\n\nvalid_date => True\n\nvalid_date => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Dostanete dva intervaly,\n    kde ka\u017ed\u00fd interval je dvojic\u00ed cel\u00fdch \u010d\u00edsel. Nap\u0159\u00edklad, interval = =.\n    Dan\u00e9 intervaly jsou uzav\u0159en\u00e9, co\u017e znamen\u00e1, \u017ee interval\n    zahrnuje jak start, tak end.\n    U ka\u017ed\u00e9ho dan\u00e9ho intervalu se p\u0159edpokl\u00e1d\u00e1, \u017ee jeho start je men\u0161\u00ed nebo rovn\u00fd end.\n    Va\u0161\u00edm \u00fakolem je zjistit, zda je d\u00e9lka pr\u016fniku t\u011bchto dvou\n    interval\u016f prvo\u010d\u00edslem.\n    Nap\u0159\u00edklad, pr\u016fnik interval\u016f, je,\n    jeho\u017e d\u00e9lka je 1, co\u017e nen\u00ed prvo\u010d\u00edslo.\n    Pokud je d\u00e9lka pr\u016fniku prvo\u010d\u00edslem, vra\u0165te \"ANO\",\n    jinak vra\u0165te \"NE\".\n    Pokud se dva intervaly nep\u0159ekr\u00fdvaj\u00ed, vra\u0165te \"NE\".\n\n    [vstup\/v\u00fdstup] vzorky:\n    intersection,) ==> \"NE\"\n    intersection,) ==> \"NE\"\n    intersection,) ==> \"ANO\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Jste dostali pole arr cel\u00fdch \u010d\u00edsel a mus\u00edte vr\u00e1tit\n    sou\u010det absolutn\u00edch hodnot t\u011bchto \u010d\u00edsel vyn\u00e1soben\u00fd produktem v\u0161ech znam\u00e9nek\n    ka\u017ed\u00e9ho \u010d\u00edsla v poli, reprezentovan\u00fdch jako 1, -1 nebo 0.\n    Pozn\u00e1mka: pro pr\u00e1zdn\u00e9 pole vra\u0165te None.\n\n    P\u0159\u00edklad:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    D\u00e1n m\u0159\u00ed\u017e s N \u0159\u00e1dky a N sloupci a kladn\u00fdm cel\u00fdm \u010d\u00edslem k,\n    ka\u017ed\u00e1 bu\u0148ka m\u0159\u00ed\u017ee obsahuje hodnotu. Ka\u017ed\u00e9 cel\u00e9 \u010d\u00edslo z rozsahu [1, N * N]\n    se objevuje p\u0159esn\u011b jednou na bu\u0148k\u00e1ch m\u0159\u00ed\u017ee.\n\n    Mus\u00edte naj\u00edt minim\u00e1ln\u00ed cestu d\u00e9lky k v m\u0159\u00ed\u017ei. M\u016f\u017eete za\u010d\u00edt z libovoln\u00e9 bu\u0148ky,\n    a p\u0159i ka\u017ed\u00e9m kroku se m\u016f\u017eete p\u0159esunout do n\u011bkter\u00e9 ze sousedn\u00edch bu\u0148ek,\n    jin\u00fdmi slovy, m\u016f\u017eete j\u00edt do bu\u0148ky, kter\u00e1 sd\u00edl\u00ed hranu s va\u0161\u00ed aktu\u00e1ln\u00ed bu\u0148kou.\n    V\u0161imn\u011bte si, \u017ee cesta d\u00e9lky k znamen\u00e1 n\u00e1v\u0161t\u011bvu p\u0159esn\u011b k bu\u0148ek.\n    NEM\u016e\u017dETE opustit m\u0159\u00ed\u017e.\n    Cesta A je pova\u017eov\u00e1na za men\u0161\u00ed ne\u017e cesta B, pokud\n    po vytvo\u0159en\u00ed se\u0159azen\u00fdch seznam\u016f hodnot na bu\u0148k\u00e1ch, kter\u00fdmi A a B proch\u00e1zej\u00ed, je lst_A lexikograficky men\u0161\u00ed ne\u017e lst_B,\n    jin\u00fdmi slovy, existuje cel\u00e9 \u010d\u00edslo index i, takov\u00e9 \u017ee lst_A[i] < lst_B[i]\n    a pro jak\u00e9koli j m\u00e1me lst_A[j] = lst_B[j].\n    Je zaru\u010deno, \u017ee odpov\u011b\u010f je jednozna\u010dn\u00e1.\n    Vr\u00e1tit se\u0159azen\u00fd seznam hodnot na bu\u0148k\u00e1ch, kter\u00fdmi minim\u00e1ln\u00ed cesta proch\u00e1z\u00ed.\n\n    P\u0159\u00edklady:\n\n        Vstup: m\u0159\u00ed\u017e = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        V\u00fdstup: [1, 2, 1]\n\n        Vstup: m\u0159\u00ed\u017e = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        V\u00fdstup: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Ka\u017ed\u00fd zn\u00e1 Fibonacciho posloupnost, kter\u00e1 byla d\u016fkladn\u011b studov\u00e1na matematiky v posledn\u00edch n\u011bkolika stolet\u00edch. Av\u0161ak, co lid\u00e9 neznaj\u00ed, je Tribonacciho posloupnost.\nTribonacciho posloupnost je definov\u00e1na rekurenc\u00ed:\ntri = 3\ntri = 1 + n \/ 2, pokud je n sud\u00e9.\ntri = tri + tri + tri, pokud je n lich\u00e9.\nNap\u0159\u00edklad:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n        = 2 + 3 + 3 = 8 \nJe v\u00e1m d\u00e1no nez\u00e1porn\u00e9 cel\u00e9 \u010d\u00edslo n, mus\u00edte vr\u00e1tit seznam prvn\u00edch n + 1 \u010d\u00edsel Tribonacciho posloupnosti.\nP\u0159\u00edklady:\ntri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Vzhledem k kladn\u00e9mu cel\u00e9mu \u010d\u00edslu n vra\u0165te sou\u010din lich\u00fdch \u010d\u00edslic.\n    Vra\u0165te 0, pokud jsou v\u0161echny \u010d\u00edslice sud\u00e9.\n    Nap\u0159\u00edklad:\n    digits  == 1\n    digits  == 0\n    digits == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Zad\u00e1n seznam \u010d\u00edsel.\n    Je pot\u0159eba vr\u00e1tit sou\u010det druh\u00fdch mocnin \u010d\u00edsel v dan\u00e9m seznamu,\n    nejprve zaokrouhlen\u00edm ka\u017ed\u00e9ho prvku na horn\u00ed cel\u00e9 \u010d\u00edslo.\n    P\u0159\u00edklady:\n    Pro lst = [1,2,3] by v\u00fdstup m\u011bl b\u00fdt 14\n    Pro lst = [1,4,9] by v\u00fdstup m\u011bl b\u00fdt 98\n    Pro lst = [1,3,5,7] by v\u00fdstup m\u011bl b\u00fdt 84\n    Pro lst = [1.4,4.2,0] by v\u00fdstup m\u011bl b\u00fdt 29\n    Pro lst = [-2.4,1,1] by v\u00fdstup m\u011bl b\u00fdt 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Vytvo\u0159te funkci, kter\u00e1 vr\u00e1t\u00ed nejv\u011bt\u0161\u00ed index prvku, kter\u00fd nen\u00ed v\u011bt\u0161\u00ed ne\u017e nebo roven prvku, kter\u00fd je bezprost\u0159edn\u011b p\u0159ed n\u00edm. Pokud takov\u00fd prvek neexistuje, vra\u0165te -1. Dan\u00e9 pole nebude obsahovat duplicitn\u00ed hodnoty.\n\nP\u0159\u00edklady:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Vytvo\u0159te funkci, kter\u00e1 p\u0159ij\u00edm\u00e1 cel\u00e1 \u010d\u00edsla, desetinn\u00e1 \u010d\u00edsla nebo \u0159et\u011bzce p\u0159edstavuj\u00edc\u00ed re\u00e1ln\u00e1 \u010d\u00edsla, a vr\u00e1t\u00ed v\u011bt\u0161\u00ed prom\u011bnnou ve sv\u00e9m dan\u00e9m datov\u00e9m typu. Vra\u0165te None, pokud jsou hodnoty stejn\u00e9.\nPozn\u00e1mka: Pokud je re\u00e1ln\u00e9 \u010d\u00edslo reprezentov\u00e1no jako \u0159et\u011bzec, desetinn\u00fd bod m\u016f\u017ee b\u00fdt . nebo ,\n\ncompare_one -> 2.5\ncompare_one -> \"2,3\"\ncompare_one -> \"6\"\ncompare_one -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Vyhodno\u0165te, zda lze dan\u00e9 \u010d\u00edslo n napsat jako sou\u010det p\u0159esn\u011b 4 kladn\u00fdch sud\u00fdch \u010d\u00edsel.\n    P\u0159\u00edklad\n    is_equal_to_sum_even == Ne\n    is_equal_to_sum_even == Ne\n    is_equal_to_sum_even == Ano\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Brazilsk\u00fd faktori\u00e1l je definov\u00e1n jako:\n    brazilsk\u00fd_faktori\u00e1l = n! *! *! * ... * 1!\n    kde n > 0\n\n    Nap\u0159\u00edklad:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Vzhledem k \u0159et\u011bzci text, nahra\u010fte v\u0161echny mezery v n\u011bm podtr\u017e\u00edtky,\na pokud m\u00e1 \u0159et\u011bzec v\u00edce ne\u017e 2 po sob\u011b jdouc\u00ed mezery,\npak nahra\u010fte v\u0161echny po sob\u011b jdouc\u00ed mezery poml\u010dkou.\n\nfix_spaces == \"Example\"\nfix_spaces == \"Example_1\"\nfix_spaces == \"_Example_2\"\nfix_spaces == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Vytvo\u0159te funkci, kter\u00e1 p\u0159ij\u00edm\u00e1 \u0159et\u011bzec p\u0159edstavuj\u00edc\u00ed n\u00e1zev souboru a vrac\u00ed\n    'Ano', pokud je n\u00e1zev souboru platn\u00fd, a vrac\u00ed 'Ne' v opa\u010dn\u00e9m p\u0159\u00edpad\u011b.\n    N\u00e1zev souboru je pova\u017eov\u00e1n za platn\u00fd, pokud a pouze pokud jsou spln\u011bny v\u0161echny n\u00e1sleduj\u00edc\u00ed podm\u00ednky:\n    - V n\u00e1zvu souboru nesm\u00ed b\u00fdt v\u00edce ne\u017e t\u0159i \u010d\u00edslice.\n    - N\u00e1zev souboru obsahuje p\u0159esn\u011b jednu te\u010dku '.'\n    - Pod\u0159et\u011bzec p\u0159ed te\u010dkou nesm\u00ed b\u00fdt pr\u00e1zdn\u00fd a mus\u00ed za\u010d\u00ednat p\u00edsmenem latinsk\u00e9 abecedy.\n    - Pod\u0159et\u011bzec za te\u010dkou mus\u00ed b\u00fdt jeden z t\u011bchto: ['txt', 'exe', 'dll']\n    P\u0159\u00edklady:\n    file_name_check # => 'Ano'\n    file_name_check # => 'Ne'\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"Tato funkce p\u0159ijme seznam cel\u00fdch \u010d\u00edsel. U v\u0161ech polo\u017eek v seznamu bude funkce umoc\u0148ovat polo\u017eku na druhou, pokud je jej\u00ed index n\u00e1sobkem \u010d\u00edsla 3, a bude umoc\u0148ovat polo\u017eku na t\u0159et\u00ed, pokud je jej\u00ed index n\u00e1sobkem \u010d\u00edsla 4 a nen\u00ed n\u00e1sobkem \u010d\u00edsla 3. Funkce nezm\u011bn\u00ed polo\u017eky v seznamu, jejich\u017e indexy nejsou n\u00e1sobkem \u010d\u00edsla 3 nebo 4. Funkce n\u00e1sledn\u011b vr\u00e1t\u00ed sou\u010det v\u0161ech polo\u017eek.\n\nP\u0159\u00edklady:\nPro lst = [1,2,3] by m\u011bl b\u00fdt v\u00fdstup 6\nPro lst = [] by m\u011bl b\u00fdt v\u00fdstup 0\nPro lst = [-1,-5,2,-1,-5] by m\u011bl b\u00fdt v\u00fdstup -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Byl v\u00e1m zad\u00e1n \u0159et\u011bzec p\u0159edstavuj\u00edc\u00ed v\u011btu,\n    v\u011bta obsahuje n\u011bkter\u00e1 slova odd\u011blen\u00e1 mezerou,\n    a mus\u00edte vr\u00e1tit \u0159et\u011bzec, kter\u00fd obsahuje slova z p\u016fvodn\u00ed v\u011bty,\n    jejich\u017e d\u00e9lky jsou prvo\u010d\u00edsla,\n    po\u0159ad\u00ed slov v nov\u00e9m \u0159et\u011bzci by m\u011blo b\u00fdt stejn\u00e9 jako v p\u016fvodn\u00edm.\n\n    P\u0159\u00edklad1:\n        Vstup: sentence = \"This is a test\"\n        V\u00fdstup: \"is\"\n\n    P\u0159\u00edklad2:\n        Vstup: sentence = \"lets go for swimming\"\n        V\u00fdstup: \"go for\"\n\n    Omezen\u00ed:\n        * 1 <= d\u00e9lka v\u011bty <= 100\n        * v\u011bta obsahuje pouze p\u00edsmena\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Va\u0161\u00edm \u00fakolem je implementovat funkci, kter\u00e1 zjednodu\u0161\u00ed v\u00fdraz\n    x * n. Funkce vr\u00e1t\u00ed True, pokud x * n vyhodnot\u00ed jako cel\u00e9 \u010d\u00edslo, a False\n    v opa\u010dn\u00e9m p\u0159\u00edpad\u011b. Oba x a n jsou \u0159et\u011bzcov\u00e9 reprezentace zlomk\u016f a maj\u00ed n\u00e1sleduj\u00edc\u00ed form\u00e1t,\n    <\u010ditatel>\/<jmenovatel>, kde \u010ditatel i jmenovatel jsou kladn\u00e1 cel\u00e1 \u010d\u00edsla.\n\n    M\u016f\u017eete p\u0159edpokl\u00e1dat, \u017ee x a n jsou platn\u00e9 zlomky a nemaj\u00ed nulu jako jmenovatele.\n\n    simplify = True\n    simplify = False\n    simplify = False\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Napi\u0161te funkci, kter\u00e1 se\u0159ad\u00ed dan\u00fd seznam cel\u00fdch \u010d\u00edsel\nv rostouc\u00edm po\u0159ad\u00ed podle sou\u010dtu jejich \u010d\u00edslic.\nPozn\u00e1mka: pokud je n\u011bkolik polo\u017eek se stejn\u00fdm sou\u010dtem jejich \u010d\u00edslic,\nse\u0159a\u010fte je podle jejich indexu v p\u016fvodn\u00edm seznamu.\n\nNap\u0159\u00edklad:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Napi\u0161te funkci, kter\u00e1 jako vstup p\u0159ij\u00edm\u00e1 pole \u010d\u00edsel a vrac\u00ed po\u010det prvk\u016f v poli, kter\u00e9 jsou v\u011bt\u0161\u00ed ne\u017e 10 a ob\u011b prvn\u00ed a posledn\u00ed \u010d\u00edslice \u010d\u00edsla jsou lich\u00e9.\nNap\u0159\u00edklad:\nspecialFilter => 1\nspecialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Je v\u00e1m d\u00e1no kladn\u00e9 cel\u00e9 \u010d\u00edslo n. Mus\u00edte vytvo\u0159it pole cel\u00fdch \u010d\u00edsel a d\u00e9lky n.\nPro ka\u017ed\u00e9 i plat\u00ed, \u017ee hodnota a[i] = i * i - i + 1.\nVra\u0165te po\u010det trojic z pole a, kde i < j < k, \na a[i] + a[j] + a[k] je n\u00e1sobkem \u010d\u00edsla 3.\n\nP\u0159\u00edklad:\n    Vstup: n = 5\n    V\u00fdstup: 1\n    Vysv\u011btlen\u00ed: \n    a = [1, 3, 7, 13, 21]\n    Jedin\u00e1 platn\u00e1 trojice je.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Napi\u0161te funkci, kter\u00e1 p\u0159ij\u00edm\u00e1 seznam \u0159et\u011bzc\u016f jako parametr,\n    odstran\u00ed z n\u011bj \u0159et\u011bzce, kter\u00e9 maj\u00ed lichou d\u00e9lku,\n    a vr\u00e1t\u00ed v\u00fdsledn\u00fd seznam v se\u0159azen\u00e9m po\u0159ad\u00ed.\n    Seznam je v\u017edy seznam \u0159et\u011bzc\u016f a nikdy pole \u010d\u00edsel,\n    a m\u016f\u017ee obsahovat duplicity.\n    Po\u0159ad\u00ed seznamu by m\u011blo b\u00fdt vzestupn\u011b podle d\u00e9lky ka\u017ed\u00e9ho slova, a m\u011bli byste\n    vr\u00e1tit seznam se\u0159azen\u00fd podle tohoto pravidla.\n    Pokud maj\u00ed dv\u011b slova stejnou d\u00e9lku, se\u0159a\u010fte seznam abecedn\u011b.\n    Funkce by m\u011bla vr\u00e1tit seznam \u0159et\u011bzc\u016f v se\u0159azen\u00e9m po\u0159ad\u00ed.\n    M\u016f\u017eete p\u0159edpokl\u00e1dat, \u017ee v\u0161echna slova budou m\u00edt stejnou d\u00e9lku.\n    Nap\u0159\u00edklad:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Jednoduch\u00fd program, kter\u00fd by m\u011bl vr\u00e1tit hodnotu x, pokud je n prvo\u010d\u00edslo, a m\u011bl by vr\u00e1tit hodnotu y jinak.\n\nP\u0159\u00edklady:\npro x_or_y == 34\npro x_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Mysl\u00edm, \u017ee si v\u0161ichni pamatujeme ten pocit, kdy\u017e je kone\u010dn\u011b zn\u00e1m v\u00fdsledek n\u011bjak\u00e9 dlouho o\u010dek\u00e1van\u00e9 ud\u00e1losti. Pocity a my\u0161lenky, kter\u00e9 v tu chv\u00edli m\u00e1te, ur\u010dit\u011b stoj\u00ed za to zaznamenat a porovnat.\n\nVa\u0161\u00edm \u00fakolem je zjistit, zda osoba spr\u00e1vn\u011b odhadla v\u00fdsledky n\u011bkolika z\u00e1pas\u016f. Jsou v\u00e1m d\u00e1ny dv\u011b pole sk\u00f3re a odhad\u016f stejn\u00e9 d\u00e9lky, p\u0159i\u010dem\u017e ka\u017ed\u00fd index ukazuje na z\u00e1pas. Vra\u0165te pole stejn\u00e9 d\u00e9lky, kter\u00e9 ozna\u010duje, jak daleko byl ka\u017ed\u00fd odhad. Pokud odhadli spr\u00e1vn\u011b, hodnota je 0, a pokud ne, hodnota je absolutn\u00ed rozd\u00edl mezi odhadem a sk\u00f3re.\n\np\u0159\u00edklad:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Budete m\u00edt zadan\u00fd n\u00e1zev t\u0159\u00eddy a seznam roz\u0161\u00ed\u0159en\u00ed.\n    Roz\u0161\u00ed\u0159en\u00ed se pou\u017e\u00edvaj\u00ed k na\u010d\u00edt\u00e1n\u00ed dal\u0161\u00edch t\u0159\u00edd do t\u0159\u00eddy. \n    S\u00edla roz\u0161\u00ed\u0159en\u00ed je n\u00e1sleduj\u00edc\u00ed: P\u0159edpokl\u00e1dejme, \u017ee CAP je po\u010det velk\u00fdch p\u00edsmen \n    v n\u00e1zvu roz\u0161\u00ed\u0159en\u00ed a SM je po\u010det mal\u00fdch p\u00edsmen v n\u00e1zvu roz\u0161\u00ed\u0159en\u00ed, s\u00edla je d\u00e1na \n    zlomkem CAP - SM. \n    M\u011bli byste naj\u00edt nejsiln\u011bj\u0161\u00ed roz\u0161\u00ed\u0159en\u00ed a vr\u00e1tit \u0159et\u011bzec v tomto form\u00e1tu: \n    ClassName.StrongestExtensionName.\n    Pokud jsou dv\u011b nebo v\u00edce roz\u0161\u00ed\u0159en\u00ed se stejnou silou, m\u011bli byste \n    vybrat to, kter\u00e9 je v seznamu prvn\u00ed.\n    Nap\u0159\u00edklad, pokud m\u00e1te zad\u00e1no \"Slices\" jako t\u0159\u00eddu a seznam roz\u0161\u00ed\u0159en\u00ed:\n    ['SErviNGSliCes', 'Cheese', 'StuFfed'], pak byste m\u011bli \n    vr\u00e1tit 'Slices.SErviNGSliCes', proto\u017ee 'SErviNGSliCes' je nejsiln\u011bj\u0161\u00ed roz\u0161\u00ed\u0159en\u00ed.\n    P\u0159\u00edklad:\n    pro Strongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Dostanete 2 slova. Mus\u00edte vr\u00e1tit True, pokud je druh\u00e9 slovo nebo n\u011bkter\u00e1 jeho rotace pod\u0159et\u011bzcem v prvn\u00edm slov\u011b.\n    cycpattern_check => False\n    cycpattern_check => True\n    cycpattern_check => False\n    cycpattern_check => True\n    cycpattern_check => False\n    cycpattern_check => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Zadan\u00e9 cel\u00e9 \u010d\u00edslo. Vra\u0165te n-tici, kter\u00e1 m\u00e1 po\u010det sud\u00fdch a lich\u00fdch \u010d\u00edslic.\n\n     P\u0159\u00edklad:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Pokud je zad\u00e1no kladn\u00e9 cel\u00e9 \u010d\u00edslo, z\u00edskejte jeho ekvivalent v \u0159\u00edmsk\u00fdch \u010d\u00edslic\u00edch jako \u0159et\u011bzec a vra\u0165te jej mal\u00fdmi p\u00edsmeny.\n    Omezen\u00ed: 1 <= num <= 1000\n\n    P\u0159\u00edklady:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Napi\u0161te funkci, kter\u00e1 p\u0159ij\u00edm\u00e1 seznam \u0159et\u011bzc\u016f.\n    Seznam obsahuje r\u016fzn\u00e1 slova. Vra\u0165te slovo s maxim\u00e1ln\u00edm po\u010dtem unik\u00e1tn\u00edch znak\u016f.\n    Pokud m\u00e1 v\u00edce \u0159et\u011bzc\u016f maxim\u00e1ln\u00ed po\u010det unik\u00e1tn\u00edch znak\u016f, vra\u0165te ten, kter\u00fd je v\n    lexikografick\u00e9m po\u0159ad\u00ed prvn\u00ed.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Jsi hladov\u00fd kr\u00e1l\u00edk a u\u017e jsi sn\u011bdl ur\u010dit\u00fd po\u010det mrkv\u00ed, ale te\u010f pot\u0159ebuje\u0161 sn\u00edst v\u00edce mrkv\u00ed, aby ses nasytil na dne\u0161n\u00ed den. M\u011bl bys vr\u00e1tit pole [celkov\u00fd po\u010det sn\u011bden\u00fdch mrkv\u00ed po tv\u00fdch j\u00eddlech, po\u010det mrkv\u00ed zb\u00fdvaj\u00edc\u00edch po tv\u00fdch j\u00eddlech]. Pokud nezb\u00fdv\u00e1 dostatek mrkv\u00ed, sn\u00ed\u0161 v\u0161echny zb\u00fdvaj\u00edc\u00ed mrkve, ale st\u00e1le bude\u0161 hladov\u00fd.\n\nP\u0159\u00edklad:\n* eat -> [11, 4]\n* eat -> [12, 1]\n* eat -> [11, 0]\n* eat -> [7, 0]\n\nProm\u011bnn\u00e9:\n@number : cel\u00e9 \u010d\u00edslo\n    po\u010det mrkv\u00ed, kter\u00e9 jsi sn\u011bdl.\n@need : cel\u00e9 \u010d\u00edslo\n    po\u010det mrkv\u00ed, kter\u00e9 pot\u0159ebuje\u0161 sn\u00edst.\n@remaining : cel\u00e9 \u010d\u00edslo\n    po\u010det zb\u00fdvaj\u00edc\u00edch mrkv\u00ed, kter\u00e9 jsou na sklad\u011b.\n\nOmezen\u00ed:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nU\u017eij si to :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Vzhledem ke dv\u011bma seznam\u016fm oper\u00e1tor\u016f a operand\u016f. Prvn\u00ed seznam obsahuje z\u00e1kladn\u00ed algebraick\u00e9 operace a druh\u00fd seznam je seznam cel\u00fdch \u010d\u00edsel. Pou\u017eijte tyto dva seznamy k vytvo\u0159en\u00ed algebraick\u00e9ho v\u00fdrazu a vra\u0165te v\u00fdsledek tohoto v\u00fdrazu.\n\nZ\u00e1kladn\u00ed algebraick\u00e9 operace:\nS\u010d\u00edt\u00e1n\u00ed \nOd\u010d\u00edt\u00e1n\u00ed \nN\u00e1soben\u00ed \nCel\u00e9 d\u011blen\u00ed \nMocn\u011bn\u00ed \n\nP\u0159\u00edklad:\noper\u00e1tor['+', '*', '-']\npole = [2, 3, 4, 5]\nv\u00fdsledek = 2 + 3 * 4 - 5\n=> v\u00fdsledek = 9\n\nPozn\u00e1mka:\nD\u00e9lka seznamu oper\u00e1tor\u016f je rovna d\u00e9lce seznamu operand\u016f minus jedna.\nOperandy jsou seznam nez\u00e1porn\u00fdch cel\u00fdch \u010d\u00edsel.\nSeznam oper\u00e1tor\u016f obsahuje alespo\u0148 jeden oper\u00e1tor a seznam operand\u016f obsahuje alespo\u0148 dva operandy.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Zadan\u00fd je \u0159et\u011bzec s.\n    pokud je s[i] p\u00edsmeno, zm\u011b\u0148te jeho velikost z mal\u00e9 na velkou nebo naopak,\n    jinak ho ponechte tak, jak je.\n    Pokud \u0159et\u011bzec neobsahuje \u017e\u00e1dn\u00e1 p\u00edsmena, p\u0159evra\u0165te \u0159et\u011bzec.\n    Funkce by m\u011bla vr\u00e1tit v\u00fdsledn\u00fd \u0159et\u011bzec.\n    P\u0159\u00edklady\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Vzhledem k \u0159et\u011bzci 'text' vra\u0165te jeho md5 hash ekvivalentn\u00ed \u0159et\u011bzec.\n    Pokud je 'text' pr\u00e1zdn\u00fd \u0159et\u011bzec, vra\u0165te None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Je-li d\u00e1no dv\u011b kladn\u00e1 cel\u00e1 \u010d\u00edsla a b, vra\u0165te sud\u00e9 \u010d\u00edslice mezi a a b ve vzestupn\u00e9m po\u0159ad\u00ed.\n\nNap\u0159\u00edklad:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]