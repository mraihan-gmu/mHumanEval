[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verilen say\u0131 listesindeki herhangi iki say\u0131n\u0131n, verilen e\u015fikten daha yak\u0131n olup olmad\u0131\u011f\u0131n\u0131 kontrol edin.\n\u00d6rnek:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Bu fonksiyona girdi olarak, birden fazla i\u00e7 i\u00e7e ge\u00e7mi\u015f parantez grubu i\u00e7eren bir dize sa\u011flan\u0131r. Amac\u0131n\u0131z, bu gruplar\u0131 ayr\u0131 dizelere ay\u0131rmak ve bu dizelerin listesini d\u00f6nd\u00fcrmektir. Ayr\u0131 gruplar dengelidir ve birbirlerinin i\u00e7inde i\u00e7 i\u00e7e ge\u00e7mez. Girdi dizisindeki bo\u015fluklar\u0131 g\u00f6rmezden gelin. \u00d6rnek:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Verilen pozitif bir ondal\u0131k say\u0131, tam say\u0131 k\u0131sm\u0131na ve ondal\u0131k k\u0131sm\u0131na ayr\u0131labilir.\n\nOndal\u0131k k\u0131sm\u0131 d\u00f6nd\u00fcr\u00fcn.\n\u00d6rnek:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Banka hesab\u0131 \u00fczerinde ba\u015flang\u0131\u00e7 bakiyesi s\u0131f\u0131r olan bir liste para yat\u0131rma ve \u00e7ekme i\u015flemleri veriliyor. G\u00f6reviniz, herhangi bir noktada hesap bakiyesinin s\u0131f\u0131r\u0131n alt\u0131na d\u00fc\u015f\u00fcp d\u00fc\u015fmedi\u011fini tespit etmektir. E\u011fer d\u00fc\u015ferse, fonksiyon True d\u00f6nd\u00fcrmelidir. Aksi takdirde False d\u00f6nd\u00fcrmelidir.\n\u00d6rnek:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Belirli bir girdi numaralar\u0131 listesi i\u00e7in, bu veri k\u00fcmesinin ortalamas\u0131 etraf\u0131ndaki Ortalama Mutlak Sapmay\u0131 hesaplay\u0131n.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktas\u0131 aras\u0131ndaki ortalama mutlak farkt\u0131r:\n    OMS = ortalama | x - x_ortalama |\n    \u00d6rnek:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Girdi listesi `numbers`'\u0131n her iki ard\u0131\u015f\u0131k eleman\u0131 aras\u0131na bir 'delimeter' say\u0131s\u0131 ekleyin.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Bu fonksiyona verilen girdi, bo\u015fluklarla ayr\u0131lm\u0131\u015f i\u00e7 i\u00e7e parantezlerden olu\u015fan birden fazla grubu temsil eden bir dizedir.\n    Her grup i\u00e7in, parantezlerin en derin i\u00e7 i\u00e7e ge\u00e7me seviyesini \u00e7\u0131kt\u0131lar.\n    \u00d6rne\u011fin,) en fazla iki seviyeli i\u00e7 i\u00e7e ge\u00e7meye sahipken,)) \u00fc\u00e7 seviyelidir.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Bir giri\u015f dizesi listesini, yaln\u0131zca belirli bir alt dizeyi i\u00e7erenler i\u00e7in filtreleyin.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Verilen bir tam say\u0131lar listesindeki t\u00fcm tam say\u0131lar\u0131n toplam\u0131 ve \u00e7arp\u0131m\u0131ndan olu\u015fan bir demet d\u00f6nd\u00fcr\u00fcn. \n    Bo\u015f toplam 0'a ve bo\u015f \u00e7arp\u0131m 1'e e\u015fit olmal\u0131d\u0131r.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Verilen bir tam say\u0131 listesinden, s\u0131ralamadaki belirli ana kadar bulunan en b\u00fcy\u00fck eleman\u0131n bir listesini olu\u015fturun.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Verilen dizenin bir palindrom olup olmad\u0131\u011f\u0131n\u0131 test edin. \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Girdi, yaln\u0131zca 1'ler ve 0'lardan olu\u015fan iki a ve b dizgisidir.\n    Bu girdiler \u00fczerinde ikili XOR i\u015flemi ger\u00e7ekle\u015ftirin ve sonucu da bir dizgi olarak d\u00f6nd\u00fcr\u00fcn.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Bir dizi string i\u00e7inden, en uzun olan\u0131n\u0131 d\u00f6nd\u00fcr. Ayn\u0131 uzunlukta birden fazla string olmas\u0131 durumunda ilk olan\u0131n\u0131 d\u00f6nd\u00fcr. Girdi listesi bo\u015fsa None d\u00f6nd\u00fcr.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \u0130ki tamsay\u0131 a ve b'nin en b\u00fcy\u00fck ortak b\u00f6lenini d\u00f6nd\u00fcr\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Girdi dizesinin en k\u0131sadan en uzuna kadar olan t\u00fcm \u00f6neklerinin listesini d\u00f6nd\u00fcr.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" 0'dan ba\u015flayarak n dahil olmak \u00fczere bo\u015flukla ayr\u0131lm\u0131\u015f say\u0131lar i\u00e7eren bir dize d\u00f6nd\u00fcr.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Verilen bir string'de ka\u00e7 farkl\u0131 karakter bulundu\u011funu bulun.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Bu fonksiyona girdi, \u00f6zel bir ASCII format\u0131nda m\u00fczik notalar\u0131n\u0131 temsil eden bir dizedir. G\u00f6reviniz, bu dizgeyi ayr\u0131\u015ft\u0131rmak ve her bir notan\u0131n ka\u00e7 vuru\u015f s\u00fcrd\u00fc\u011f\u00fcn\u00fc belirten tamsay\u0131lar listesini d\u00f6nd\u00fcrmektir.\n\n\u0130\u015fte bir efsane:\n'o' - tam nota, d\u00f6rt vuru\u015f s\u00fcrer\n'o|' - yar\u0131m nota, iki vuru\u015f s\u00fcrer\n'.|' - \u00e7eyrek nota, bir vuru\u015f s\u00fcrer\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Verilen bir alt dizi orijinal dizide ka\u00e7 kez bulunabilir bulun. \u00dcst \u00fcste gelen durumlar\u0131 say\u0131n.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Girdi, 's\u0131f\u0131r'dan 'dokuz'a kadar rakamlar\u0131n bo\u015flukla ayr\u0131lm\u0131\u015f bir dizgesidir.\n    Ge\u00e7erli se\u00e7enekler 's\u0131f\u0131r', 'bir', 'iki', '\u00fc\u00e7', 'd\u00f6rt', 'be\u015f', 'alt\u0131', 'yedi', 'sekiz' ve 'dokuz'dur.\n    Say\u0131lar\u0131n en k\u00fc\u00e7\u00fc\u011f\u00fcnden en b\u00fcy\u00fc\u011f\u00fcne s\u0131ralanm\u0131\u015f haliyle dizgeyi geri d\u00f6nd\u00fcr\u00fcn.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Sa\u011flanan bir say\u0131 listesinden birbirine en yak\u0131n olan iki say\u0131y\u0131 se\u00e7in ve bunlar\u0131 s\u0131ral\u0131 olarak geri d\u00f6nd\u00fcr\u00fcn.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Verilen say\u0131 listesini, \u00f6yle bir do\u011frusal d\u00f6n\u00fc\u015f\u00fcm uygula ki, en k\u00fc\u00e7\u00fck say\u0131 0 ve en b\u00fcy\u00fck say\u0131 1 olsun.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Verilen listedeki Python de\u011ferlerini yaln\u0131zca tamsay\u0131lar i\u00e7in filtreleyin.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Verilen dizgenin uzunlu\u011funu d\u00f6nd\u00fcr.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Verilen bir say\u0131 n i\u00e7in, n'den k\u00fc\u00e7\u00fck olan ve n'i tam b\u00f6len en b\u00fcy\u00fck say\u0131y\u0131 bulun.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Verilen tam say\u0131n\u0131n asal \u00e7arpanlar\u0131n\u0131n listesini en k\u00fc\u00e7\u00fckten en b\u00fcy\u00fc\u011fe do\u011fru d\u00f6nd\u00fcr\u00fcn.\n    Her bir \u00e7arpan, \u00e7arpanlara ay\u0131rmada ka\u00e7 kez ge\u00e7ti\u011fine kar\u015f\u0131l\u0131k gelen say\u0131da listelenmelidir.\n    Girdi say\u0131s\u0131, t\u00fcm \u00e7arpanlar\u0131n \u00e7arp\u0131m\u0131na e\u015fit olmal\u0131d\u0131r.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Bir tam say\u0131 listesinden, birden fazla kez ge\u00e7en t\u00fcm \u00f6\u011feleri \u00e7\u0131kar\u0131n. Geriye kalan \u00f6\u011felerin s\u0131ras\u0131n\u0131 giri\u015fteki gibi koruyun.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Belirli bir dize i\u00e7in, k\u00fc\u00e7\u00fck harfleri b\u00fcy\u00fck harfe ve b\u00fcy\u00fck harfleri k\u00fc\u00e7\u00fck harfe \u00e7evirin.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Dize listesini tek bir dizeye birle\u015ftir.\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Bir giri\u015f listesindeki dizeleri, yaln\u0131zca belirli bir \u00f6n ekle ba\u015flayanlar\u0131 filtreleyin.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Listedeki sadece pozitif say\u0131lar\u0131 d\u00f6nd\u00fcr.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Verilen bir say\u0131 asal ise true, de\u011filse false d\u00f6nd\u00fcr.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Katsay\u0131lar\u0131 xs olan polinomu x noktas\u0131nda de\u011ferlendirir.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Bu fonksiyon, bir liste l al\u0131r ve l' listesini d\u00f6nd\u00fcr\u00fcr. Bu liste, \u00fc\u00e7e b\u00f6l\u00fcnmeyen indekslerde l ile ayn\u0131d\u0131r. \u00dc\u00e7e b\u00f6l\u00fcnebilen indekslerdeki de\u011ferler ise l'nin kar\u015f\u0131l\u0131k gelen indekslerindeki de\u011ferlerle ayn\u0131d\u0131r, ancak s\u0131ralanm\u0131\u015ft\u0131r.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Bir listedeki s\u0131ralanm\u0131\u015f benzersiz \u00f6\u011feleri d\u00f6nd\u00fcr\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Listedeki en b\u00fcy\u00fck \u00f6\u011feyi d\u00f6nd\u00fcr.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"11 veya 13 ile b\u00f6l\u00fcnebilen ve n'den k\u00fc\u00e7\u00fck olan tam say\u0131larda 7 rakam\u0131n\u0131n ka\u00e7 kez g\u00f6r\u00fcnd\u00fc\u011f\u00fcn\u00fc d\u00f6nd\u00fcr.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Bu fonksiyon, bir l listesini al\u0131r ve l' listesini d\u00f6nd\u00fcr\u00fcr. l' listesi, tek indekslerde l ile \u00f6zde\u015fken, \u00e7ift indekslerdeki de\u011ferleri l'nin \u00e7ift indekslerindeki de\u011ferlere e\u015fittir, ancak s\u0131ralanm\u0131\u015ft\u0131r.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    \u00dc\u00e7 karakterlik gruplar\u0131 d\u00f6ng\u00fcleyerek kodlanm\u0131\u015f dizeyi d\u00f6nd\u00fcr\u00fcr.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib, hem Fibonacci say\u0131s\u0131 hem de asal olan n'inci say\u0131y\u0131 d\u00f6nd\u00fcr\u00fcr.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero bir liste tam say\u0131y\u0131 girdi olarak al\u0131r.\n    E\u011fer listede toplam\u0131 s\u0131f\u0131r olan \u00fc\u00e7 farkl\u0131 eleman varsa True, aksi takdirde False d\u00f6ner.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    \u015eu c\u00fcmleyi T\u00fcrk\u00e7eye \u00e7evirin:\n\nHayal edin ki m\u00fckemmel d\u00fcz bir sonsuz uzunlukta bir yol var. n araba sola do\u011fru giderken, ayn\u0131 anda farkl\u0131 bir n araba seti sa\u011fa do\u011fru gidiyor. Bu iki araba seti ba\u015flang\u0131\u00e7ta birbirlerinden \u00e7ok uzakta ba\u015fl\u0131yorlar. T\u00fcm arabalar ayn\u0131 h\u0131zda hareket ediyor. Bir araban\u0131n sola giderken sa\u011fa giden bir arabaya \u00e7arpmas\u0131na \u00e7arp\u0131\u015fma denir. Ancak, arabalar sonsuz derecede dayan\u0131kl\u0131 ve g\u00fc\u00e7l\u00fcd\u00fcr; bu nedenle, \u00e7arp\u0131\u015fmam\u0131\u015f gibi kendi yollar\u0131nda hareket etmeye devam ederler.\n\nBu fonksiyon b\u00f6yle \u00e7arp\u0131\u015fmalar\u0131n say\u0131s\u0131n\u0131 \u00e7\u0131kt\u0131lar.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Elemanlar\u0131 1 art\u0131r\u0131lm\u0131\u015f \u015fekilde listeyi d\u00f6nd\u00fcr.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero, bir liste tamsay\u0131y\u0131 girdi olarak al\u0131r.\n    Listede toplam\u0131 s\u0131f\u0131r olan iki farkl\u0131 eleman varsa True, aksi takdirde False d\u00f6ner.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Girdi say\u0131s\u0131 x'in say\u0131sal taban\u0131n\u0131 de\u011fi\u015ftirin.\n    D\u00f6n\u00fc\u015f\u00fcmden sonra string g\u00f6sterimini d\u00f6nd\u00fcr\u00fcn.\n    Taban say\u0131lar\u0131 10'dan k\u00fc\u00e7\u00fckt\u00fcr.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Bir \u00fc\u00e7genin kenar uzunlu\u011fu ve y\u00fcksekli\u011fi verildi\u011finde, alan\u0131n\u0131 hesapla.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 say\u0131 dizisi, \u015fu \u015fekilde tan\u0131mlanan Fibbonacci dizisine benzer bir dizidir:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\nL\u00fctfen fib4 say\u0131 dizisinin n'inci eleman\u0131n\u0131 verimli bir \u015fekilde hesaplayan bir fonksiyon yaz\u0131n. \u00d6zyineleme kullanmay\u0131n.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Listenin ortanca de\u011ferini d\u00f6nd\u00fcr.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Verilen stringin palindrom olup olmad\u0131\u011f\u0131n\u0131 kontrol eder.\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"2^n mod p de\u011ferini d\u00f6nd\u00fcr.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    Her karakteri alfabede 5 harf kayd\u0131rarak kodlanm\u0131\u015f dizeyi d\u00f6nd\u00fcr\u00fcr.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels, bir dize alan ve sesli harfler olmadan d\u00f6nd\u00fcren bir i\u015flevdir.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Listedeki t\u00fcm say\u0131lar e\u015fik de\u011feri t'nin alt\u0131ndaysa True d\u00f6nd\u00fcr.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"\u0130ki say\u0131 olan x ve y'yi topla.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    \u0130ki kelimenin ayn\u0131 karakterlere sahip olup olmad\u0131\u011f\u0131n\u0131 kontrol edin.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"n'inci Fibonacci say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" K\u00f6\u015feli parantezler \"<\" ve \">\" karakterlerinden olu\u015fan bir dizidir.\n    Her a\u00e7\u0131l\u0131\u015f parantezinin kar\u015f\u0131l\u0131k gelen bir kapan\u0131\u015f parantezi varsa True d\u00f6nd\u00fcr.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Liste elemanlar\u0131 monotonik olarak art\u0131yorsa veya azal\u0131yorsa True d\u00f6nd\u00fcr.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u0130ki liste i\u00e7in s\u0131ralanm\u0131\u015f benzersiz ortak \u00f6\u011feleri d\u00f6nd\u00fcr.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"n'in en b\u00fcy\u00fck asal \u00e7arpan\u0131n\u0131 d\u00f6nd\u00fcr. n'in 1'den b\u00fcy\u00fck ve asal olmad\u0131\u011f\u0131n\u0131 varsay\u0131n.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n, 1'den n'ye kadar olan say\u0131lar\u0131 toplayan bir fonksiyondur.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Parantezler, \"\" karakterlerinden olu\u015fan bir dizidir.\n    Her a\u00e7\u0131l\u0131\u015f parantezinin kar\u015f\u0131l\u0131k gelen bir kapan\u0131\u015f parantezi varsa True d\u00f6ner.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs, bir polinomun katsay\u0131lar\u0131n\u0131 temsil eder.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Bu polinomun t\u00fcrevini ayn\u0131 formda d\u00f6nd\u00fcr\u00fcn.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"FibFib say\u0131 dizisi, Fibonacci dizisine benzer bir dizidir ve \u015fu \u015fekilde tan\u0131mlan\u0131r:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    L\u00fctfen FibFib say\u0131 dizisinin n'inci eleman\u0131n\u0131 verimli bir \u015fekilde hesaplayan bir fonksiyon yazar m\u0131s\u0131n\u0131z?\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nDaha fazla test durumu ekle.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Tam say\u0131n\u0131n rakamlar\u0131n\u0131 dairesel olarak kayd\u0131r\u0131n, rakamlar\u0131 sa\u011fa do\u011fru kayd\u0131r\u0131n ve sonucu bir dize olarak d\u00f6nd\u00fcr\u00fcn.\nE\u011fer kayd\u0131rma, rakam say\u0131s\u0131ndan b\u00fcy\u00fckse, rakamlar\u0131 ters \u00e7evirin.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"G\u00f6rev\n    Bir dizeyi girdi olarak alan ve yaln\u0131zca b\u00fcy\u00fck harflerin ASCII kodlar\u0131n\u0131n toplam\u0131n\u0131 d\u00f6nd\u00fcren bir fonksiyon yaz\u0131n.\n\n    \u00d6rnekler:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Bu g\u00f6revde, bir meyve sepetinde da\u011f\u0131t\u0131lan elma ve portakal say\u0131s\u0131n\u0131 temsil eden bir dize verilecektir. Bu sepet elma, portakal ve mango meyvelerini i\u00e7erir. Elma ve portakallar\u0131n toplam say\u0131s\u0131n\u0131 temsil eden dize ve sepet i\u00e7indeki meyvelerin toplam say\u0131s\u0131n\u0131 temsil eden bir tamsay\u0131 verildi\u011finde, sepetteki mango meyvelerinin say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn. \u00d6rne\u011fin:\nfruit_distribution ->19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"A\u011fac\u0131n negatif olmayan tamsay\u0131 d\u00fc\u011f\u00fcmlerine sahip bir dal\u0131n\u0131 temsil eden bir dizi verildi\u011finde, g\u00f6reviniz d\u00fc\u011f\u00fcmlerden birini koparmak ve geri d\u00f6nd\u00fcrmektir. Kopar\u0131lan d\u00fc\u011f\u00fcm en k\u00fc\u00e7\u00fck \u00e7ift de\u011fere sahip d\u00fc\u011f\u00fcm olmal\u0131d\u0131r. Ayn\u0131 en k\u00fc\u00e7\u00fck \u00e7ift de\u011fere sahip birden fazla d\u00fc\u011f\u00fcm bulunursa, en k\u00fc\u00e7\u00fck indekse sahip d\u00fc\u011f\u00fcm\u00fc geri d\u00f6nd\u00fcr\u00fcn.\n\nKopar\u0131lan d\u00fc\u011f\u00fcm bir liste i\u00e7inde d\u00f6nd\u00fcr\u00fclmelidir, [en k\u00fc\u00e7\u00fck de\u011fer, indeksi]. E\u011fer hi\u00e7 \u00e7ift de\u011fer yoksa veya verilen dizi bo\u015fsa, [] d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnek1:\n    Girdi: [4,2,3]\n    \u00c7\u0131kt\u0131: [2, 1]\n    A\u00e7\u0131klama: 2 en k\u00fc\u00e7\u00fck \u00e7ift de\u011fere sahiptir ve en k\u00fc\u00e7\u00fck indekse sahiptir.\n\n\u00d6rnek2:\n    Girdi: [1,2,3]\n    \u00c7\u0131kt\u0131: [2, 1]\n    A\u00e7\u0131klama: 2 en k\u00fc\u00e7\u00fck \u00e7ift de\u011fere sahiptir ve en k\u00fc\u00e7\u00fck indekse sahiptir.\n\n\u00d6rnek3:\n    Girdi: []\n    \u00c7\u0131kt\u0131: []\n\n\u00d6rnek4:\n    Girdi: [5, 0, 3, 0, 4, 2]\n    \u00c7\u0131kt\u0131: [0, 1]\n    A\u00e7\u0131klama: 0 en k\u00fc\u00e7\u00fck de\u011fere sahiptir, ancak iki tane s\u0131f\u0131r vard\u0131r, bu y\u00fczden en k\u00fc\u00e7\u00fck indekse sahip olan ilk s\u0131f\u0131r\u0131 se\u00e7eriz.\n\nK\u0131s\u0131tlamalar:\n    * 1 <= d\u00fc\u011f\u00fcmler.length <= 10000\n    * 0 <= d\u00fc\u011f\u00fcm.de\u011feri\"\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Bir tamsay\u0131 dizisi olan arr verildi\u011finde, diziyi palindromik yapmak i\u00e7in de\u011fi\u015ftirilmesi gereken minimum eleman say\u0131s\u0131n\u0131 bulun. Palindromik bir dizi, ileri ve geri ayn\u0131 \u015fekilde okunan bir dizidir. Bir de\u011fi\u015fiklikte, bir eleman\u0131 herhangi bir ba\u015fka elemana d\u00f6n\u00fc\u015ft\u00fcrebilirsiniz.\n\n\u00d6rne\u011fin:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"A\u015fa\u011f\u0131daki c\u00fcmleyi T\u00fcrk\u00e7eye \u00e7evirin:\n\n3 asal say\u0131n\u0131n \u00e7arp\u0131m\u0131 olan bir say\u0131 verildi\u011finde, do\u011fru d\u00f6nd\u00fcren bir fonksiyon yaz\u0131n\n    ve aksi takdirde yanl\u0131\u015f d\u00f6nd\u00fcren.'n\u0131n 100'den k\u00fc\u00e7\u00fck oldu\u011funu bilerek.\n    \u00d6rnek:\n    is_multiply_prime == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"G\u00f6reviniz, x say\u0131s\u0131n\u0131n n'nin basit bir kuvveti olup olmad\u0131\u011f\u0131n\u0131 kontrol eden ve do\u011fruysa true, di\u011fer durumlarda false d\u00f6nd\u00fcren bir fonksiyon yazmakt\u0131r.\n    x, n**int=x oldu\u011funda n'nin basit bir kuvvetidir.\n    \u00d6rne\u011fin:\n    is_simple_power => true\n    is_simple_power => true\n    is_simple_power => true\n    is_simple_power => false\n    is_simple_power => false\n    is_simple_power => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Size bir fonksiyon yazma g\u00f6revi verildi. Bu fonksiyon, bir onalt\u0131l\u0131k say\u0131y\u0131 string olarak alacak ve asal olan onalt\u0131l\u0131k basamaklar\u0131n say\u0131s\u0131n\u0131 sayacak.\nOnalt\u0131l\u0131k basamaklar 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F'dir.\nAsal say\u0131lar ise 2, 3, 5, 7, 11, 13, 17,... \u015feklindedir.\nYani, a\u015fa\u011f\u0131daki basamaklar\u0131n say\u0131s\u0131n\u0131 belirlemeniz gerekiyor: 2, 3, 5, 7, B, D.\nNot: Giri\u015fin her zaman do\u011fru veya bo\u015f bir string oldu\u011funu ve A,B,C,D,E,F sembollerinin her zaman b\u00fcy\u00fck harf oldu\u011funu varsayabilirsiniz.\n\u00d6rnekler:\nnum = \"AB\" i\u00e7in \u00e7\u0131kt\u0131 1 olmal\u0131d\u0131r.\nnum = \"1077E\" i\u00e7in \u00e7\u0131kt\u0131 2 olmal\u0131d\u0131r.\nnum = \"ABED1A33\" i\u00e7in \u00e7\u0131kt\u0131 4 olmal\u0131d\u0131r.\nnum = \"123456789ABCDEF0\" i\u00e7in \u00e7\u0131kt\u0131 6 olmal\u0131d\u0131r.\nnum = \"2020\" i\u00e7in \u00e7\u0131kt\u0131 2 olmal\u0131d\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Size onaylanan c\u00fcmleyi T\u00fcrk\u00e7eye \u00e7evirdim:\n\nSize ondal\u0131k bi\u00e7imde bir say\u0131 verilecek ve g\u00f6reviniz onu ikili formata d\u00f6n\u00fc\u015ft\u00fcrmektir. Fonksiyon bir string d\u00f6nd\u00fcrmeli ve her karakter bir ikili say\u0131 temsil etmelidir. Stringdeki her karakter '0' veya '1' olacakt\u0131r.\n\nStringin ba\u015f\u0131nda ve sonunda 'db' \u015feklinde fazladan iki karakter olacak. Bu ekstra karakterler formatla ilgili yard\u0131mc\u0131 olmak i\u00e7in oradalar.\n\n\u00d6rnekler:\ndecimal_to_binary   # \"db1111db\" d\u00f6nd\u00fcr\u00fcr\ndecimal_to_binary   # \"db100000db\" d\u00f6nd\u00fcr\u00fcr\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"Size bir s dizesi verilir.\nG\u00f6reviniz, dizeyi mutlu olup olmad\u0131\u011f\u0131n\u0131 kontrol etmektir.\nBir dize uzunlu\u011fu en az 3 ve her 3 ard\u0131\u015f\u0131k harf farkl\u0131ysa mutlu kabul edilir.\n\u00d6rne\u011fin:\nis_happy => Yanl\u0131\u015f\nis_happy => Yanl\u0131\u015f\nis_happy => Do\u011fru\nis_happy => Yanl\u0131\u015f\nis_happy => Do\u011fru\nis_happy => Yanl\u0131\u015f\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"D\u00f6nemin son haftas\u0131 ve \u00f6\u011fretmen \u00f6\u011frencilerin notlar\u0131n\u0131 vermek zorunda. \u00d6\u011fretmen, notland\u0131rma i\u00e7in kendi algoritmas\u0131n\u0131 yapm\u0131\u015f. Tek sorun, notland\u0131rma i\u00e7in kulland\u0131\u011f\u0131 kodu kaybetmi\u015f olmas\u0131. Size baz\u0131 \u00f6\u011frencilerin GPA listesini vermi\u015f ve a\u015fa\u011f\u0131daki tabloyu kullanarak harf notlar\u0131 listesini \u00e7\u0131kt\u0131layabilecek bir fonksiyon yazman\u0131z gerekiyor:\n\n             GPA       |    Harf Notu\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    \u00d6rnek:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Bir dizge alan ve dizgenin uzunlu\u011fu asal say\u0131 ise True, de\u011filse False d\u00f6nd\u00fcren bir fonksiyon yaz\u0131n.\n\u00d6rnekler:\nprime_length == True\nprime_length == True\nprime_length == True\nprime_length == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Pozitif bir n tam say\u0131s\u0131 verildi\u011finde, 1 ile ba\u015flayan veya biten n basamakl\u0131 pozitif say\u0131lar\u0131n say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Verilen pozitif tam say\u0131 N i\u00e7in, basamaklar\u0131n\u0131n toplam\u0131n\u0131 ikili olarak d\u00f6nd\u00fcr\u00fcn.\n\n    \u00d6rnek\n        N = 1000 i\u00e7in, basamaklar\u0131n toplam\u0131 1 olacak ve \u00e7\u0131kt\u0131 \"1\" olmal\u0131.\n        N = 150 i\u00e7in, basamaklar\u0131n toplam\u0131 6 olacak ve \u00e7\u0131kt\u0131 \"110\" olmal\u0131.\n        N = 147 i\u00e7in, basamaklar\u0131n toplam\u0131 12 olacak ve \u00e7\u0131kt\u0131 \"1100\" olmal\u0131.\n    \n    De\u011fi\u015fkenler:\n        @N tam say\u0131\n             S\u0131n\u0131rlamalar: 0 \u2264 N \u2264 10000.\n    \u00c7\u0131kt\u0131:\n         \u0130kili say\u0131 \u015feklinde bir string\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Bo\u015f olmayan bir tam say\u0131 listesi lst verildi\u011finde, tek indekslerdeki \u00e7ift elemanlar\u0131 toplay\u0131n.\n\n    \u00d6rnekler:\n        add ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Bir fonksiyon yaz\u0131n, bu fonksiyon bir string al\u0131r ve bunun s\u0131ral\u0131 bir versiyonunu d\u00f6ner.\n    Stringin s\u0131ral\u0131 versiyonu, t\u00fcm kelimelerin her karakterin\n    ascii de\u011ferine g\u00f6re artan s\u0131rayla d\u00fczenlendi\u011fi yeni bir kelimeyle de\u011fi\u015ftirildi\u011fi bir stringdir.\n    Not: C\u00fcmledeki kelimelerin ve bo\u015fluklar\u0131n s\u0131ras\u0131n\u0131 korumal\u0131s\u0131n\u0131z.\n\n    \u00d6rne\u011fin:\n    anti_shuffle 'Hi' d\u00f6ner\n    anti_shuffle 'ehllo' d\u00f6ner\n    anti_shuffle 'Hello !!!Wdlor' d\u00f6ner\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Size iki boyutlu bir veri veriliyor, i\u00e7 i\u00e7e ge\u00e7mi\u015f listeler \u015feklinde,\n    bu veri matrislere benzer, ancak matrislerin aksine,\n    her sat\u0131r farkl\u0131 say\u0131da s\u00fctun i\u00e7erebilir.\n    Verilen lst ve tam say\u0131 x ile, listede x tam say\u0131lar\u0131n\u0131 bulun\n    ve [, ...] \u015feklinde koordinatlar\u0131n listesini d\u00f6nd\u00fcr\u00fcn,\n    her bir demet bir koordinat - olacak \u015fekilde, 0'dan ba\u015flayarak.\n    Koordinatlar\u0131 \u00f6nce sat\u0131rlara g\u00f6re artan s\u0131rada s\u0131ralay\u0131n.\n    Ayr\u0131ca, sat\u0131rdaki koordinatlar\u0131 s\u00fctunlara g\u00f6re azalan s\u0131rada s\u0131ralay\u0131n.\n\n    \u00d6rnekler:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [,,,,]\n    get_row == []\n    get_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Negatif olmayan tamsay\u0131lar i\u00e7eren bir dizi verildi\u011finde, verilen diziyi s\u0131ralad\u0131ktan sonra bir kopyas\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn. \u0130lk indeksin de\u011feri ile son indeksin de\u011feri toplam\u0131 tek ise diziyi artan s\u0131rayla, \u00e7ift ise azalan s\u0131rayla s\u0131ralay\u0131n.\n\nNot:\n* Verilen diziyi de\u011fi\u015ftirmeyin.\n\n\u00d6rnekler:\n* sort_array => []\n* sort_array => [5]\n* sort_array => [0, 1, 2, 3, 4, 5]\n* sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Bir fonksiyon olu\u015fturun ve ad\u0131na `encrypt` deyin; bu fonksiyon bir string arg\u00fcman almal\u0131 ve d\u00f6nd\u00fcr\u00fclen string, alfabenin d\u00f6nd\u00fcr\u00fclmesiyle \u015fifrelenmi\u015f olmal\u0131d\u0131r. Alfabe, harflerin iki \u00e7arp\u0131 iki yer kayd\u0131r\u0131lmas\u0131 \u015feklinde d\u00f6nd\u00fcr\u00fclmelidir. \n\u00d6rne\u011fin:\n`encrypt` 'lm' d\u00f6nd\u00fcrmelidir.\n`encrypt` 'ewhjklnop' d\u00f6nd\u00fcrmelidir.\n`encrypt` 'kj' d\u00f6nd\u00fcrmelidir.\n`encrypt` 'ix' d\u00f6nd\u00fcrmelidir.\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Bir tamsay\u0131 listesi verildi.\n    Listenin 2. en k\u00fc\u00e7\u00fck eleman\u0131n\u0131 d\u00f6nd\u00fcren next_smallest fonksiyonunu yaz\u0131n.\n    B\u00f6yle bir eleman yoksa None d\u00f6nd\u00fcr\u00fcn.\n\n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Size bir kelime dizisi verilecek ve g\u00f6reviniz s\u0131k\u0131nt\u0131lar\u0131n say\u0131s\u0131n\u0131 saymak olacak. S\u0131k\u0131nt\u0131, \"Ben\" kelimesiyle ba\u015flayan bir c\u00fcmledir. C\u00fcmleler '.', '?' veya '!' ile s\u0131n\u0131rland\u0131r\u0131l\u0131r.\n\n\u00d6rne\u011fin:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Bir mesaj alan ve bu mesaj\u0131 \u015fu \u015fekilde kodlayan bir fonksiyon yaz\u0131n: \n    T\u00fcm harflerin b\u00fcy\u00fck\/k\u00fc\u00e7\u00fck harf durumunu de\u011fi\u015ftirir, mesajdaki \n    t\u00fcm sesli harfleri \u0130ngiliz alfabesinde o sesli harften 2 harf \n    sonra gelen harf ile de\u011fi\u015ftirir. \n    Sadece harflerin oldu\u011funu varsay\u0131n. \n    \n    \u00d6rnekler:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Size bir tamsay\u0131 listesi verilmi\u015ftir.\n    En b\u00fcy\u00fck asal de\u011feri bulman\u0131z ve rakamlar\u0131n\u0131n toplam\u0131n\u0131 d\u00f6nd\u00fcrmeniz gerekmektedir.\n\n    \u00d6rnekler:\n    lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] i\u00e7in \u00e7\u0131kt\u0131 10 olmal\u0131d\u0131r\n    lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] i\u00e7in \u00e7\u0131kt\u0131 25 olmal\u0131d\u0131r\n    lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] i\u00e7in \u00e7\u0131kt\u0131 13 olmal\u0131d\u0131r\n    lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] i\u00e7in \u00e7\u0131kt\u0131 11 olmal\u0131d\u0131r\n    lst = [0,81,12,3,1,21] i\u00e7in \u00e7\u0131kt\u0131 3 olmal\u0131d\u0131r\n    lst = [0,8,1,2,1,7] i\u00e7in \u00e7\u0131kt\u0131 7 olmal\u0131d\u0131r\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Verilen bir s\u00f6zl\u00fckte, t\u00fcm anahtarlar k\u00fc\u00e7\u00fck harfli dizelerse veya t\u00fcm anahtarlar b\u00fcy\u00fck harfli dizelerse True d\u00f6nd\u00fcr\u00fcn, aksi takdirde False d\u00f6nd\u00fcr\u00fcn. \nVerilen s\u00f6zl\u00fck bo\u015fsa, i\u015flev False d\u00f6nd\u00fcrmelidir.\n\u00d6rnekler:\ncheck_dict_case True d\u00f6nd\u00fcrmelidir.\ncheck_dict_case False d\u00f6nd\u00fcrmelidir.\ncheck_dict_case False d\u00f6nd\u00fcrmelidir.\ncheck_dict_case False d\u00f6nd\u00fcrmelidir.\ncheck_dict_case True d\u00f6nd\u00fcrmelidir.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Negatif olmayan bir tam say\u0131 alan ve n'den k\u00fc\u00e7\u00fck olan ilk n asal say\u0131lar\u0131n bir dizisini d\u00f6nd\u00fcren bir fonksiyon uygulay\u0131n.\n\u00d6rne\u011fin:\ncount_up_to => [2,3]\ncount_up_to => [2,3,5,7]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17,19]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Fonksiyonu tamamlay\u0131n, iki tam say\u0131 al\u0131r ve bu say\u0131lar\u0131n birler basamaklar\u0131n\u0131n \u00e7arp\u0131m\u0131n\u0131 d\u00f6nd\u00fcr\u00fcr.\nGirdinin her zaman ge\u00e7erli oldu\u011funu varsay\u0131n.\n\u00d6rnekler:\nmultiply 16 d\u00f6nd\u00fcrmelidir.\nmultiply 72 d\u00f6nd\u00fcrmelidir.\nmultiply 0 d\u00f6nd\u00fcrmelidir.\nmultiply 20 d\u00f6nd\u00fcrmelidir.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Verilen s stringi i\u00e7in, \u00e7ift indekslerdeki b\u00fcy\u00fck harfli \u00fcnl\u00fclerin say\u0131s\u0131n\u0131 say\u0131n.\n\n    \u00d6rne\u011fin:\n    count_upper 1 d\u00f6nd\u00fcr\u00fcr\n    count_upper 0 d\u00f6nd\u00fcr\u00fcr\n    count_upper 0 d\u00f6nd\u00fcr\u00fcr\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Pozitif bir tamsay\u0131 n verildi\u011finde, n seviyeli bir ta\u015f y\u0131\u011f\u0131n\u0131 yapman\u0131z gerekiyor.\n    \u0130lk seviyede n ta\u015f vard\u0131r.\n    Bir sonraki seviyedeki ta\u015f say\u0131s\u0131:\n        - E\u011fer n tek ise, bir sonraki tek say\u0131d\u0131r.\n        - E\u011fer n \u00e7ift ise, bir sonraki \u00e7ift say\u0131d\u0131r.\n    Her seviyedeki ta\u015f say\u0131s\u0131n\u0131 bir listede d\u00f6nd\u00fcr\u00fcn, burada i indeksindeki eleman. seviyedeki ta\u015f say\u0131s\u0131n\u0131 temsil eder.\n\n    \u00d6rnekler:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Size, virg\u00fcller veya bo\u015fluklarla ayr\u0131lm\u0131\u015f kelimelerden olu\u015fan bir dize verilecektir. G\u00f6reviniz,\n    diziyi kelimelere ay\u0131rmak ve kelimelerin bir dizisini d\u00f6nd\u00fcrmektir.\n    \n    \u00d6rne\u011fin:\n    words_string == [\"Merhaba\", \"benim\", \"ad\u0131m\", \"John\"]\n    words_string == [\"Bir\", \"iki\", \"\u00fc\u00e7\", \"d\u00f6rt\", \"be\u015f\", \"alt\u0131\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Bu fonksiyon, x ve y olmak \u00fczere iki pozitif say\u0131 al\u0131r ve [x, y] aral\u0131\u011f\u0131nda en b\u00fcy\u00fck \u00e7ift tamsay\u0131y\u0131 d\u00f6ner. E\u011fer b\u00f6yle bir say\u0131 yoksa, fonksiyon -1 d\u00f6nd\u00fcrmelidir.\n\n\u00d6rne\u011fin:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Size, iki pozitif tam say\u0131 n ve m verilmi\u015ftir ve g\u00f6reviniz n'den m'ye kadar olan tam say\u0131lar\u0131n ortalamas\u0131n\u0131 hesaplamakt\u0131r.\nCevab\u0131 en yak\u0131n tamsay\u0131ya yuvarlay\u0131n ve bunu ikili formata d\u00f6n\u00fc\u015ft\u00fcr\u00fcn.\nE\u011fer n, m'den b\u00fcy\u00fckse, -1 d\u00f6nd\u00fcr\u00fcn.\n\u00d6rnekler:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Pozitif tam say\u0131lardan olu\u015fan bir x listesi verildi\u011finde, i\u00e7inde \u00e7ift rakam bulunmayan t\u00fcm elemanlar\u0131n s\u0131ralanm\u0131\u015f bir listesini d\u00f6nd\u00fcr\u00fcn.\n\nNot: D\u00f6nd\u00fcr\u00fclen liste artan s\u0131rada s\u0131ralanm\u0131\u015f olmal\u0131d\u0131r.\n\n\u00d6rne\u011fin:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Bir tamsay\u0131 dizisi verildi\u011finde, 1 ile 9 aras\u0131ndaki tamsay\u0131lar\u0131 s\u0131rala,\n    ortaya \u00e7\u0131kan diziyi ters \u00e7evir, ve ard\u0131ndan her rakam\u0131 \"Bir\", \"\u0130ki\", \"\u00dc\u00e7\", \"D\u00f6rt\", \"Be\u015f\", \"Alt\u0131\", \n    \"Yedi\", \"Sekiz\", \"Dokuz\" kar\u015f\u0131l\u0131k gelen ad\u0131yla de\u011fi\u015ftir.\n\n    \u00d6rne\u011fin:\n      dizi = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> diziyi s\u0131rala -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> diziyi ters \u00e7evir -> [8, 5, 4, 3, 2, 2, 1, 1]\n      d\u00f6n\u00fc\u015f = [\"Sekiz\", \"Be\u015f\", \"D\u00f6rt\", \"\u00dc\u00e7\", \"\u0130ki\", \"\u0130ki\", \"Bir\", \"Bir\"]\n    \n      E\u011fer dizi bo\u015fsa, bo\u015f bir dizi d\u00f6nd\u00fcr:\n      dizi = []\n      d\u00f6n\u00fc\u015f = []\n    \n      E\u011fer dizide herhangi bir garip say\u0131 varsa, onu yoksay:\n      dizi = [1, -1, 55] \n            -> diziyi s\u0131rala -> [-1, 1, 55]\n            -> diziyi ters \u00e7evir -> [55, 1, -1]\n      d\u00f6n\u00fc\u015f = ['Bir']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Fonksiyon f'yi n parametresiyle alacak \u015fekilde implement edin ve n boyutunda bir liste d\u00f6nd\u00fcrs\u00fcn. Listenin i indeksindeki eleman\u0131n de\u011feri, e\u011fer i \u00e7iftse i'nin fakt\u00f6riyeli, aksi takdirde 1'den i'ye kadar olan say\u0131lar\u0131n toplam\u0131 olsun. i, 1'den ba\u015flar. i'nin fakt\u00f6riyeli 1'den i'ye kadar olan say\u0131lar\u0131n \u00e7arp\u0131m\u0131d\u0131r.\n\u00d6rnek:\nf == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Pozitif bir tamsay\u0131 n verildi\u011finde, aral\u0131k i\u00e7inde yer alan \u00e7ift ve tek tamsay\u0131 palindromlar\u0131n\u0131n say\u0131s\u0131n\u0131 i\u00e7eren bir demet d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnek1:\n\n    Girdi: 3\n    \u00c7\u0131kt\u0131:\n    A\u00e7\u0131klama:\n    Tamsay\u0131 palindromlar\u0131 1, 2, 3. Bunlardan biri \u00e7ift, ikisi tek.\n\n\u00d6rnek2:\n\n    Girdi: 12\n    \u00c7\u0131kt\u0131:\n    A\u00e7\u0131klama:\n    Tamsay\u0131 palindromlar\u0131 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Bunlardan d\u00f6rd\u00fc \u00e7ift, alt\u0131s\u0131 tek.\n\nNot:\n    1. 1 <= n <= 10^3\n    2. D\u00f6nd\u00fcr\u00fclen demet s\u0131ras\u0131yla \u00e7ift ve tek tamsay\u0131 palindromlar\u0131n\u0131n say\u0131s\u0131n\u0131 i\u00e7erir.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Bir fonksiyon yaz\u0131n count_nums isimli, bu fonksiyon bir tamsay\u0131 dizisi al\u0131r ve rakamlar\u0131n\u0131n toplam\u0131 0'dan b\u00fcy\u00fck olan elemanlar\u0131n say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcr.\n    E\u011fer bir say\u0131 negatiftir ise, ilk i\u015faretli rakam\u0131 negatif olacakt\u0131r:\n    \u00f6rn. -123 i\u00e7in i\u015faretli rakamlar -1, 2 ve 3't\u00fcr.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Elimizde N tane tamsay\u0131dan olu\u015fan 'arr' adl\u0131 bir dizi var: arr[1], arr[2], ..., arr[N]. Dizideki say\u0131lar rastgele s\u0131ralanm\u0131\u015f olacak. G\u00f6reviniz, verilen dizi \u00fczerinde a\u015fa\u011f\u0131daki i\u015flemi ger\u00e7ekle\u015ftirerek diziyi artmayan s\u0131raya g\u00f6re s\u0131ralaman\u0131n m\u00fcmk\u00fcn olup olmad\u0131\u011f\u0131n\u0131 belirlemek:\n\n    Dizide istenilen kadar sa\u011fa kayd\u0131rma i\u015flemi yapman\u0131za izin veriliyor.\n\n    Bir sa\u011fa kayd\u0131rma i\u015flemi, dizideki t\u00fcm elemanlar\u0131n bir pozisyon sa\u011fa kayd\u0131r\u0131lmas\u0131 anlam\u0131na gelir. Dizinin son eleman\u0131 ba\u015flang\u0131\u00e7 pozisyonuna yani 0. indekse ta\u015f\u0131n\u0131r.\n\n    Yukar\u0131daki i\u015flemi ger\u00e7ekle\u015ftirerek s\u0131ral\u0131 bir dizi elde etmek m\u00fcmk\u00fcnse True, de\u011filse False d\u00f6nd\u00fcr\u00fcn.\n    Verilen dizi bo\u015fsa True d\u00f6nd\u00fcr\u00fcn.\n\n    Not: Verilen listenin benzersiz elemanlara sahip oldu\u011fu garantilidir.\n\n    \u00d6rne\u011fin:\n\n    move_one_ball==>True\n    A\u00e7\u0131klama: 2 sa\u011fa kayd\u0131rma i\u015flemi yaparak, verilen dizi i\u00e7in artmayan s\u0131ra elde edilebilir.\n    move_one_ball==>False\n    A\u00e7\u0131klama: Herhangi bir say\u0131da sa\u011fa kayd\u0131rma i\u015flemi yaparak verilen dizi i\u00e7in artmayan s\u0131ra elde etmek m\u00fcmk\u00fcn de\u011fildir.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Bu problemde, iki say\u0131 listesini alan ve aralar\u0131ndaki eleman de\u011fi\u015fimini yaparak lst1'in yaln\u0131zca \u00e7ift say\u0131lardan olu\u015fan bir liste haline gelip gelemeyece\u011fini belirleyen bir fonksiyon uygulayacaks\u0131n\u0131z. lst1 ve lst2 aras\u0131nda de\u011fi\u015ftirilen elemanlar\u0131n say\u0131s\u0131nda bir s\u0131n\u0131rlama yoktur. lst1 ve lst2 aras\u0131nda eleman de\u011fi\u015fimi yaparak lst1'in t\u00fcm elemanlar\u0131n\u0131 \u00e7ift yapmak m\u00fcmk\u00fcnse \"EVET\" d\u00f6nd\u00fcr\u00fcn. Aksi takdirde \"HAYIR\" d\u00f6nd\u00fcr\u00fcn.\n\u00d6rne\u011fin:\nexchange => \"EVET\"\nexchange => \"HAYIR\"\nGirdi listelerinin bo\u015f olmad\u0131\u011f\u0131 varsay\u0131lmaktad\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Bir bo\u015flukla ayr\u0131lm\u0131\u015f k\u00fc\u00e7\u00fck harflerden olu\u015fan bir dize verildi\u011finde, en \u00e7ok tekrar eden harfi ve ona kar\u015f\u0131l\u0131k gelen say\u0131y\u0131 i\u00e7eren bir s\u00f6zl\u00fck d\u00f6nd\u00fcr\u00fcn. E\u011fer birka\u00e7 harf ayn\u0131 say\u0131da ge\u00e7iyorsa, hepsini d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnek:\nhistogram == {'a': 1, 'b': 1, 'c': 1}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'b': 4}\nhistogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"G\u00f6rev\n    Bize iki dize s ve c verilir, s'deki her karakteri c'deki herhangi bir karaktere e\u015fit olanlar\u0131 silmelisiniz,\n    ard\u0131ndan sonu\u00e7 dizisinin palindrom olup olmad\u0131\u011f\u0131n\u0131 kontrol etmelisiniz.\n    Bir dize, ileriye do\u011fru okundu\u011fu gibi geriye do\u011fru da okunuyorsa palindrom olarak adland\u0131r\u0131l\u0131r.\n    Sonu\u00e7 dizisini ve kontrol i\u00e7in Do\u011fru\/Yanl\u0131\u015f i\u00e7eren bir demet d\u00f6nd\u00fcrmelisiniz.\n    \u00d6rnek\n    s = \"abcde\", c = \"ae\" i\u00e7in, sonu\u00e7 olmal\u0131d\u0131r.\n    s = \"abcdef\", c = \"b\" i\u00e7in, sonu\u00e7 olmal\u0131d\u0131r.\n    s = \"abcdedcba\", c = \"ab\" i\u00e7in, sonu\u00e7 olmal\u0131d\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Bir dizi string verildi\u011finde, her string yaln\u0131zca rakamlardan olu\u015fur, bir liste d\u00f6nd\u00fcr. \n    \u00c7\u0131kt\u0131n\u0131n her bir i eleman\u0131, \"girdinin i stringindeki tek say\u0131lar\u0131n say\u0131s\u0131\" olmal\u0131d\u0131r. \n    Buradaki t\u00fcm i'ler, girdinin i'inci stringindeki tek rakamlar\u0131n say\u0131s\u0131 ile de\u011fi\u015ftirilmelidir.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Bir dizi tam say\u0131 i\u00e7eren nums verildi\u011finde, nums'un herhangi bir bo\u015f olmayan alt dizisinin minimum toplam\u0131n\u0131 bulun.\n    \u00d6rnek\n    minSubArraySum == 1\n    minSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Size bir dikd\u00f6rtgen \u0131zgara kuyular\u0131 verildi. Her sat\u0131r tek bir kuyuyu temsil eder ve bir sat\u0131rdaki her 1, tek bir su birimini temsil eder. Her kuyunun, i\u00e7inden su \u00e7ekmek i\u00e7in kullan\u0131labilecek bir kovas\u0131 vard\u0131r ve t\u00fcm kovalar\u0131n kapasitesi ayn\u0131d\u0131r. G\u00f6reviniz, kovalar\u0131 kullanarak kuyular\u0131 bo\u015faltmakt\u0131r. Kovalar\u0131 ka\u00e7 kez indirmek gerekti\u011fini \u00e7\u0131kt\u0131 olarak verin.\n\n\u00d6rnek 1:\n    Girdi: \n        \u0131zgara : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        kova_kapasitesi : 1\n    \u00c7\u0131kt\u0131: 6\n\n\u00d6rnek 2:\n    Girdi: \n        \u0131zgara : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        kova_kapasitesi : 2\n    \u00c7\u0131kt\u0131: 5\n\n\u00d6rnek 3:\n    Girdi: \n        \u0131zgara : [[0,0,0], [0,0,0]]\n        kova_kapasitesi : 5\n    \u00c7\u0131kt\u0131: 0\n\nK\u0131s\u0131tlamalar:\n    * T\u00fcm kuyular ayn\u0131 uzunlu\u011fa sahiptir.\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= kapasite <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Bu Kata'da, bir dizi pozitif olmayan tam say\u0131lar\u0131, ikili g\u00f6sterimlerinde bulunan birlerin say\u0131s\u0131na g\u00f6re artan s\u0131rayla s\u0131ralaman\u0131z gerekiyor.\n    Benzer say\u0131da bire sahip olanlar i\u00e7in, ondal\u0131k de\u011fere g\u00f6re s\u0131ralay\u0131n.\n\n    Bu \u015fekilde uygulanmal\u0131d\u0131r:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Bir dize s ve do\u011fal bir say\u0131 n verildi\u011finde, \n    s dizesindeki tam olarak n \u00fcns\u00fcz i\u00e7eren t\u00fcm kelimeleri listeleyen bir fonksiyon \n    uygulaman\u0131z istenmi\u015ftir. Bu kelimeler s dizesinde g\u00f6r\u00fcnd\u00fckleri s\u0131rayla listelenmelidir.\n    E\u011fer s dizesi bo\u015fsa, fonksiyon bo\u015f bir liste d\u00f6nd\u00fcrmelidir.\n    Not: Girdi dizisinin yaln\u0131zca harfler ve bo\u015fluklar i\u00e7erdi\u011fini varsayabilirsiniz.\n    \u00d6rnekler:\n    select_words ==> [\"little\"]\n    select_words ==> [\"Mary\", \"lamb\"]\n    select_words ==> []\n    select_words ==> [\"world\"]\n    select_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Size bir kelime veriliyor. G\u00f6reviniz, kelimenin sa\u011f taraf\u0131ndan iki \u00fcns\u00fcz aras\u0131nda duran en yak\u0131n \u00fcnl\u00fcy\u00fc bulmakt\u0131r.\n\nBa\u015flang\u0131\u00e7 ve biti\u015fteki \u00fcnl\u00fcler say\u0131lmaz. Yukar\u0131daki ko\u015fullar\u0131 kar\u015f\u0131layan herhangi bir \u00fcnl\u00fc bulamazsan\u0131z, bo\u015f bir dize d\u00f6nd\u00fcr\u00fcn.\n\nVerilen dizede yaln\u0131zca \u0130ngilizce harfler oldu\u011funu varsayabilirsiniz.\n\n\u00d6rnekler:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Verilen bir tamsay\u0131 dizisi arr ve pozitif bir tamsay\u0131 k ile, arr i\u00e7indeki en b\u00fcy\u00fck k say\u0131y\u0131 i\u00e7eren ve s\u0131ralanm\u0131\u015f bir liste d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnek1:\n\n    Girdi: arr = [-3, -4, 5], k = 3\n    \u00c7\u0131kt\u0131: [-4, -3, 5]\n\n\u00d6rnek2:\n\n    Girdi: arr = [4, -4, 4], k = 2\n    \u00c7\u0131kt\u0131: [4, 4]\n\n\u00d6rnek3:\n\n    Girdi: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    \u00c7\u0131kt\u0131: [2]\n\nNot:\n    1. Dizinin uzunlu\u011fu [1, 1000] aral\u0131\u011f\u0131nda olacakt\u0131r.\n    2. Dizideki elemanlar [-1000, 1000] aral\u0131\u011f\u0131nda olacakt\u0131r.\n    3. 0 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Bo\u015f olmayan bir tamsay\u0131 listesi verildi\u011finde, \u00e7ift pozisyonlardaki t\u00fcm tek elemanlar\u0131n toplam\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnekler\nsolution ==> 12\nsolution ==> 9\nsolution ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Bo\u015f olmayan bir tamsay\u0131 dizisi arr ve bir tamsay\u0131 k verildi\u011finde, arr'nin ilk k eleman\u0131ndan en fazla iki basamakl\u0131 olan elemanlar\u0131n toplam\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnek:\n\n    Girdi: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    \u00c7\u0131kt\u0131: 24 # 21 + 3'\u00fcn toplam\u0131\n\nK\u0131s\u0131tlamalar:\n    1. 1 <= len <= 100\n    2. 1 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Verilen pozitif bir tam say\u0131 n i\u00e7in, collatz dizisindeki tek say\u0131lar\u0131 i\u00e7eren s\u0131ral\u0131 bir liste d\u00f6nd\u00fcr\u00fcn.\n\n    Collatz varsay\u0131m\u0131, a\u015fa\u011f\u0131daki gibi tan\u0131mlanan bir diziyi ilgilendiren bir matematiksel varsay\u0131md\u0131r: herhangi bir pozitif tam say\u0131 n ile ba\u015flay\u0131n. Daha sonra her terim bir \u00f6nceki terimden a\u015fa\u011f\u0131daki \u015fekilde elde edilir: E\u011fer bir \u00f6nceki terim \u00e7ift ise, sonraki terim bir \u00f6nceki terimin yar\u0131s\u0131d\u0131r. E\u011fer bir \u00f6nceki terim tek ise, sonraki terim bir \u00f6nceki terimin 3 kat\u0131 art\u0131 1'dir. Varsay\u0131m, n'in de\u011feri ne olursa olsun, dizinin her zaman 1'e ula\u015faca\u011f\u0131d\u0131r.\n\n    Not:\n        1. Collatz [1]'dir.\n        2. d\u00f6nd\u00fcr\u00fclen liste artan s\u0131rayla s\u0131ralanm\u0131\u015ft\u0131r.\n\n    \u00d6rne\u011fin:\n    get_odd_collatz [1, 5] d\u00f6nd\u00fcr\u00fcr # 5 i\u00e7in collatz dizisi [5, 16, 8, 4, 2, 1] olup, tek say\u0131lar yaln\u0131zca 1 ve 5'tir.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Verilen bir tarih dizesini do\u011frulayan ve tarih ge\u00e7erliyse True, aksi takdirde False d\u00f6nd\u00fcren bir fonksiyon yazmal\u0131s\u0131n\u0131z.\nTarih, a\u015fa\u011f\u0131daki kurallar\u0131n t\u00fcm\u00fc kar\u015f\u0131land\u0131\u011f\u0131nda ge\u00e7erlidir:\n1. Tarih dizesi bo\u015f olmamal\u0131d\u0131r.\n2. G\u00fcn say\u0131s\u0131, 1, 3, 5, 7, 8, 10, 12 aylar\u0131 i\u00e7in 1'den az veya 31'den fazla olmamal\u0131d\u0131r. Ve g\u00fcn say\u0131s\u0131, 4, 6, 9, 11 aylar\u0131 i\u00e7in 1'den az veya 30'dan fazla olmamal\u0131d\u0131r. Ve g\u00fcn say\u0131s\u0131, 2. ay i\u00e7in 1'den az veya 29'dan fazla olmamal\u0131d\u0131r.\n3. Aylar 1'den az veya 12'den fazla olmamal\u0131d\u0131r.\n4. Tarih \u015fu formatta olmal\u0131d\u0131r: aa-gg-yyyy\n\n\u00d6rne\u011fin:\nvalid_date => True\n\nvalid_date => False\n\nvalid_date => False\n\nvalid_date => True\n\nvalid_date => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"Size iki aral\u0131k veriliyor,\n    her aral\u0131k bir \u00e7ift tamsay\u0131dan olu\u015fur. \u00d6rne\u011fin, aral\u0131k = =.\n    Verilen aral\u0131klar kapal\u0131d\u0131r, yani aral\u0131k\n    hem ba\u015flang\u0131\u00e7 hem de biti\u015f noktalar\u0131n\u0131 i\u00e7erir.\n    Her verilen aral\u0131k i\u00e7in, ba\u015flang\u0131c\u0131n\u0131n biti\u015fine e\u015fit veya ondan k\u00fc\u00e7\u00fck oldu\u011fu varsay\u0131l\u0131r.\n    G\u00f6reviniz, bu iki aral\u0131\u011f\u0131n kesi\u015fiminin uzunlu\u011funun asal say\u0131 olup olmad\u0131\u011f\u0131n\u0131 belirlemektir.\n    \u00d6rne\u011fin, ve aral\u0131klar\u0131n\u0131n kesi\u015fimi olup,\n    bu kesi\u015fimin uzunlu\u011fu 1'dir ve bu asal bir say\u0131 de\u011fildir.\n    Kesi\u015fimin uzunlu\u011fu asal bir say\u0131 ise, \"EVET\" d\u00f6nd\u00fcr\u00fcn,\n    aksi takdirde \"HAYIR\" d\u00f6nd\u00fcr\u00fcn.\n    \u0130ki aral\u0131k kesi\u015fmiyorsa, \"HAYIR\" d\u00f6nd\u00fcr\u00fcn.\n\n    [girdi\/\u00e7\u0131kt\u0131] \u00f6rnekleri:\n    intersection,) ==> \"HAYIR\"\n    intersection,) ==> \"HAYIR\"\n    intersection,) ==> \"EVET\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Size verilen tamsay\u0131lar dizisi arr i\u00e7in, her bir say\u0131n\u0131n i\u015faretlerinin \u00e7arp\u0131m\u0131yla tamsay\u0131lar\u0131n b\u00fcy\u00fckl\u00fcklerinin toplam\u0131n\u0131 d\u00f6nd\u00fcrmeniz gerekiyor. \u0130\u015faretler 1, -1 veya 0 ile temsil edilir. Not: Bo\u015f bir dizi i\u00e7in None d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnek:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Verilen bir \u0131zgara N sat\u0131r ve N s\u00fctun i\u00e7erir ve pozitif bir tamsay\u0131 k ile her h\u00fccre bir de\u011fer i\u00e7erir. [1, N * N] aral\u0131\u011f\u0131ndaki her tamsay\u0131 \u0131zgaradaki h\u00fccrelerde tam olarak bir kez g\u00f6r\u00fcn\u00fcr.\n\nk uzunlu\u011fundaki minimum yolu bulmal\u0131s\u0131n\u0131z. Herhangi bir h\u00fccreden ba\u015flayabilirsiniz ve her ad\u0131mda kom\u015fu h\u00fccrelere ge\u00e7ebilirsiniz; yani, mevcut h\u00fccrenizle bir kenar payla\u015fan h\u00fccrelere gidebilirsiniz.\nL\u00fctfen k uzunlu\u011fundaki bir yolun tam olarak k h\u00fccreyi ziyaret etmek anlam\u0131na geldi\u011fini unutmay\u0131n.\nIzgaran\u0131n d\u0131\u015f\u0131na \u00e7\u0131kamazs\u0131n\u0131z.\nUzunluk k olan bir yol A, yol B'den k\u00fc\u00e7\u00fckt\u00fcr e\u011fer A ve B'nin \u00fczerinden ge\u00e7ti\u011fi h\u00fccrelerdeki de\u011ferlerin s\u0131ral\u0131 listelerini olu\u015fturduktan sonra lst_A, lst_B'den leksikografik olarak k\u00fc\u00e7\u00fckse, yani, lst_A[i] < lst_B[i] ve herhangi bir j i\u00e7in lst_A[j] = lst_B[j] olacak \u015fekilde bir tamsay\u0131 indeksi i varsa.\nCevab\u0131n benzersiz oldu\u011fu garantilidir.\nMinimum yolun ge\u00e7ti\u011fi h\u00fccrelerdeki de\u011ferlerin s\u0131ral\u0131 bir listesini d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnekler:\n\n    Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n    Output: [1, 2, 1]\n\n    Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n    Output: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Herkes Fibonacci dizisini bilir, son birka\u00e7 y\u00fczy\u0131lda matematik\u00e7iler taraf\u0131ndan derinlemesine incelenmi\u015ftir. Ancak, insanlar\u0131n bilmedi\u011fi \u015fey Tribonacci dizisidir. Tribonacci dizisi \u015fu \u015fekilde tan\u0131mlan\u0131r:\ntri = 3\ntri = 1 + n \/ 2, e\u011fer n \u00e7ift ise.\ntri = tri + tri + tri, e\u011fer n tek ise.\n\u00d6rne\u011fin:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n           = 2 + 3 + 3 = 8\nSize s\u0131f\u0131r veya pozitif bir tamsay\u0131 n veriliyor, Tribonacci dizisinin ilk n + 1 say\u0131s\u0131n\u0131 i\u00e7eren bir liste d\u00f6nd\u00fcrmelisiniz. \n\u00d6rnekler:\ntri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Pozitif bir tam say\u0131 n verildi\u011finde, tek rakamlar\u0131n \u00e7arp\u0131m\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn.\n    T\u00fcm rakamlar \u00e7ift ise 0 d\u00f6nd\u00fcr\u00fcn.\n    \u00d6rne\u011fin:\n    rakamlar  == 1\n    rakamlar  == 0\n    rakamlar == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Size bir say\u0131 listesi verildi.\n    Verilen listedeki say\u0131lar\u0131n karelerinin toplam\u0131n\u0131 d\u00f6nd\u00fcrmeniz gerekiyor,\n    \u00f6nce listedeki her \u00f6\u011feyi yukar\u0131 yuvarlayarak tam say\u0131ya d\u00f6n\u00fc\u015ft\u00fcr\u00fcn.\n    \u00d6rnekler:\n    lst = [1,2,3] i\u00e7in \u00e7\u0131kt\u0131 14 olmal\u0131\n    lst = [1,4,9] i\u00e7in \u00e7\u0131kt\u0131 98 olmal\u0131\n    lst = [1,3,5,7] i\u00e7in \u00e7\u0131kt\u0131 84 olmal\u0131\n    lst = [1.4,4.2,0] i\u00e7in \u00e7\u0131kt\u0131 29 olmal\u0131\n    lst = [-2.4,1,1] i\u00e7in \u00e7\u0131kt\u0131 6 olmal\u0131\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"A\u015fa\u011f\u0131daki c\u00fcmleyi T\u00fcrk\u00e7eye \u00e7evirin:\n\nBir \u00f6nceki \u00f6\u011feye e\u015fit veya ondan b\u00fcy\u00fck olmayan bir \u00f6\u011fenin en b\u00fcy\u00fck dizinini d\u00f6nd\u00fcren bir fonksiyon olu\u015fturun. E\u011fer b\u00f6yle bir \u00f6\u011fe yoksa, -1 d\u00f6nd\u00fcr\u00fcn. Verilen dizi, yinelenen de\u011ferler i\u00e7ermeyecektir.\n\n\u00d6rnekler:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Fonksiyon, tamsay\u0131lar, ondal\u0131k say\u0131lar veya ger\u00e7ek say\u0131lar\u0131 temsil eden dizgileri almal\u0131 ve verilen de\u011fi\u015fken t\u00fcr\u00fcnde daha b\u00fcy\u00fck olan de\u011fi\u015fkeni d\u00f6nd\u00fcrmelidir. De\u011ferler e\u015fitse None d\u00f6nd\u00fcrmelidir.\nNot: Ger\u00e7ek bir say\u0131 dizgi olarak temsil ediliyorsa, ondal\u0131k ayrac\u0131 . veya , olabilir.\n\n```python\ndef compare_one:\n    # If both values are equal, return None\n    if str == str:\n        return None\n    \n    # Convert string representations to floats for comparison\n    def to_float:\n        if isinstance:\n            value = value.replace\n        return float\n    \n    # Compare the values based on their float representation\n    larger_value = max\n    \n    # Return the larger value in its original type\n    if larger_value == a:\n        return a\n    else:\n        return b\n\nprint)      # 2.5\nprint)    # \"2,3\"\nprint)  # \"6\"\nprint)      # None\n```\n\nBu fonksiyon tamsay\u0131lar, ondal\u0131k say\u0131lar veya ger\u00e7ek say\u0131lar\u0131 temsil eden dizgilerle \u00e7al\u0131\u015f\u0131r ve verilen de\u011fi\u015fken t\u00fcr\u00fcnde daha b\u00fcy\u00fck olan\u0131 d\u00f6nd\u00fcr\u00fcr. De\u011ferler e\u015fitse None d\u00f6ner. Ger\u00e7ek bir say\u0131 dizgi olarak temsil ediliyorsa, ondal\u0131k ayrac\u0131 . veya , olabilir.\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Verilen n say\u0131s\u0131n\u0131n tam olarak 4 pozitif \u00e7ift say\u0131n\u0131n toplam\u0131 olarak yaz\u0131l\u0131p yaz\u0131lamayaca\u011f\u0131n\u0131 de\u011ferlendirin.\n    \u00d6rnek\n    is_equal_to_sum_even == Yanl\u0131\u015f\n    is_equal_to_sum_even == Yanl\u0131\u015f\n    is_equal_to_sum_even == Do\u011fru\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Brezilya fakt\u00f6riyeli \u015fu \u015fekilde tan\u0131mlan\u0131r:\n    brezilya_fakt\u00f6riyel = n! *! *! * ... * 1!\n    burada n > 0\n    \n    \u00d6rne\u011fin:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Belirtilen bir string'de t\u00fcm bo\u015fluklar\u0131 alt \u00e7izgi ile de\u011fi\u015ftirin ve e\u011fer bir string'de 2'den fazla ard\u0131\u015f\u0131k bo\u015fluk varsa, t\u00fcm ard\u0131\u015f\u0131k bo\u015fluklar\u0131 - ile de\u011fi\u015ftirin.\n\nfix_spaces == \"Example\"\nfix_spaces == \"Example_1\"\nfix_spaces == \"_Example_2\"\nfix_spaces == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Bir dosya ismini temsil eden bir string alan ve dosya ismi ge\u00e7erliyse 'Evet', aksi takdirde 'Hay\u0131r' d\u00f6nd\u00fcren bir fonksiyon olu\u015fturun.\nBir dosya isminin ge\u00e7erli say\u0131lmas\u0131 i\u00e7in yaln\u0131zca a\u015fa\u011f\u0131daki t\u00fcm ko\u015fullar\u0131n kar\u015f\u0131lanmas\u0131 gerekir:\n- Dosya isminde \u00fc\u00e7ten fazla rakam olmamal\u0131d\u0131r.\n- Dosya ismi tam olarak bir nokta '.' i\u00e7ermelidir.\n- Noktadan \u00f6nceki alt dize bo\u015f olmamal\u0131 ve Latin alfabesinden bir harf ile ba\u015flamal\u0131d\u0131r.\n- Noktadan sonraki alt dize \u015fu de\u011ferlerden biri olmal\u0131d\u0131r: ['txt', 'exe', 'dll']\n\u00d6rnekler:\nfile_name_check # => 'Evet'\nfile_name_check # => 'Hay\u0131r'\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"Bu fonksiyon bir tamsay\u0131 listesi alacakt\u0131r. Listedeki t\u00fcm giri\u015fler i\u00e7in, fonksiyon, indeksi 3'\u00fcn kat\u0131 olan tamsay\u0131 giri\u015fini karesini alacak ve indeksi 3'\u00fcn kat\u0131 olmay\u0131p 4'\u00fcn kat\u0131 olan tamsay\u0131 giri\u015fini k\u00fcp\u00fcn\u00fc alacakt\u0131r. \u0130ndeksleri 3 veya 4'\u00fcn kat\u0131 olmayan listelerdeki giri\u015fler de\u011fi\u015ftirilmeyecektir. Fonksiyon daha sonra t\u00fcm giri\u015flerin toplam\u0131n\u0131 d\u00f6nd\u00fcrecektir.\n\n\u00d6rnekler:\nlst = [1,2,3] i\u00e7in \u00e7\u0131kt\u0131 6 olmal\u0131d\u0131r.\nlst = [] i\u00e7in \u00e7\u0131kt\u0131 0 olmal\u0131d\u0131r.\nlst = [-1,-5,2,-1,-5] i\u00e7in \u00e7\u0131kt\u0131 -126 olmal\u0131d\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Size bir c\u00fcmleyi temsil eden bir dize verilmi\u015ftir,\n    bu c\u00fcmle baz\u0131 kelimeleri bo\u015fluk ile ayr\u0131lm\u0131\u015f olarak i\u00e7ermektedir,\n    ve sizin orijinal c\u00fcmledeki kelimelerden,\n    uzunluklar\u0131 asal say\u0131 olanlar\u0131 i\u00e7eren bir dize d\u00f6nd\u00fcrmeniz gerekmektedir,\n    yeni dizedeki kelimelerin s\u0131ras\u0131 orijinal c\u00fcmle ile ayn\u0131 olmal\u0131d\u0131r.\n\n    \u00d6rnek1:\n        Girdi: sentence = \"This is a test\"\n        \u00c7\u0131kt\u0131: \"is\"\n\n    \u00d6rnek2:\n        Girdi: sentence = \"lets go for swimming\"\n        \u00c7\u0131kt\u0131: \"go for\"\n\n    K\u0131s\u0131tlar:\n        * 1 <= len <= 100\n        * sentence yaln\u0131zca harfler i\u00e7erir\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"G\u00f6reviniz, x * n ifadesini sadele\u015ftirecek bir fonksiyon uygulamakt\u0131r. Fonksiyon, x * n ifadesi tam say\u0131ya e\u015fitlenirse True, aksi takdirde False d\u00f6nd\u00fcr\u00fcr. Hem x hem de n, bir kesirin string g\u00f6sterimi olup <pay>\/<payda> format\u0131nda pozitif tam say\u0131lardan olu\u015fur.\n\nx ve n'nin ge\u00e7erli kesirler oldu\u011funu ve paydalar\u0131n\u0131n s\u0131f\u0131r olmad\u0131\u011f\u0131n\u0131 varsayabilirsiniz.\n\nsimplify = True\nsimplify = False\nsimplify = False\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    A\u015fa\u011f\u0131daki c\u00fcmleyi T\u00fcrk\u00e7eye \u00e7evirin:\n\nBir fonksiyon yaz\u0131n, bu fonksiyon verilen tamsay\u0131 listesini\n    rakamlar\u0131n\u0131n toplam\u0131na g\u00f6re artan s\u0131rada s\u0131ralas\u0131n.\n    Not: E\u011fer rakamlar\u0131n\u0131n toplam\u0131 ayn\u0131 olan birden fazla \u00f6\u011fe varsa,\n    bunlar\u0131 orijinal listedeki indekslerine g\u00f6re s\u0131ralay\u0131n.\n\n    \u00d6rne\u011fin:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Bir fonksiyon yaz\u0131n, bu fonksiyon bir dizi say\u0131y\u0131 girdi olarak al\u0131r ve \n    dizideki elemanlardan 10'dan b\u00fcy\u00fck olan ve hem ilk hem de son rakam\u0131 \n    tek olan say\u0131lar\u0131n say\u0131s\u0131n\u0131 d\u00f6ner.\n    \u00d6rne\u011fin:\n    specialFilter => 1 \n    specialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Size n pozitif bir tamsay\u0131 verildi\u011finde, n uzunlu\u011funda bir tamsay\u0131 dizisi a olu\u015fturmal\u0131s\u0131n\u0131z.\n        Her bir i i\u00e7in, a[i] de\u011feri = i * i - i + 1. \u00fc\u00e7l\u00fclerinin say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn, burada i < j < k ve a[i] + a[j] + a[k] 3'\u00fcn kat\u0131.\n\n    \u00d6rnek:\n        Girdi: n = 5\n        \u00c7\u0131kt\u0131: 1\n        A\u00e7\u0131klama: \n        a = [1, 3, 7, 13, 21]\n        Tek ge\u00e7erli \u00fc\u00e7l\u00fc.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Bir fonksiyon yaz\u0131n, bu fonksiyon bir dizi string parametre olarak al\u0131r,\n    i\u00e7inden uzunlu\u011fu tek say\u0131 olan string'leri siler,\n    ve sonu\u00e7lanan diziyi s\u0131ralanm\u0131\u015f bir \u015fekilde geri d\u00f6nd\u00fcr\u00fcr,\n    Dizi her zaman stringlerden olu\u015fur ve asla say\u0131lardan olu\u015fan bir array de\u011fildir,\n    ve tekrarlar i\u00e7erebilir.\n    Dizinin s\u0131ras\u0131 her kelimenin uzunlu\u011funa g\u00f6re artan \u015fekilde olmal\u0131d\u0131r,\n    ve bu kurala g\u00f6re s\u0131ralanm\u0131\u015f olarak d\u00f6nd\u00fcrmelisiniz.\n    E\u011fer iki kelimenin uzunlu\u011fu ayn\u0131 ise, diziyi alfabetik olarak s\u0131ralay\u0131n.\n    Fonksiyon s\u0131ralanm\u0131\u015f bir string dizisi d\u00f6nd\u00fcrmelidir.\n    B\u00fct\u00fcn kelimelerin ayn\u0131 uzunlukta olaca\u011f\u0131n\u0131 varsayabilirsiniz.\n    \u00d6rne\u011fin:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"n asal say\u0131 ise x de\u011ferini d\u00f6nd\u00fcrmesi gereken, aksi takdirde y de\u011ferini d\u00f6nd\u00fcrmesi gereken basit bir program.\n\n    \u00d6rnekler:\n    x_or_y == 34\n    x_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Bence hepimiz uzun zamand\u0131r beklenen bir olay\u0131n sonucunun nihayet belli oldu\u011fu an\u0131 hat\u0131rl\u0131yoruzdur. O anda ya\u015fad\u0131\u011f\u0131n\u0131z duygular ve d\u00fc\u015f\u00fcnceler kesinlikle not edilmeye ve kar\u015f\u0131la\u015ft\u0131r\u0131lmaya de\u011fer.\n\nG\u00f6reviniz, bir ki\u015finin bir dizi ma\u00e7\u0131n sonu\u00e7lar\u0131n\u0131 do\u011fru tahmin edip etmedi\u011fini belirlemektir. Her bir indeksi bir ma\u00e7\u0131 g\u00f6steren e\u015fit uzunlukta iki skor ve tahmin dizisi verilmi\u015ftir. Her tahminin ne kadar uzakta oldu\u011funu belirten ayn\u0131 uzunlukta bir dizi d\u00f6nd\u00fcr\u00fcn. E\u011fer do\u011fru tahmin etmi\u015flerse, de\u011fer 0 olur, e\u011fer de\u011filse, tahmin ile skor aras\u0131ndaki mutlak fark de\u011feri olur.\n\n\u00f6rnek:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Size bir s\u0131n\u0131f\u0131n ad\u0131 ve bir uzant\u0131lar listesi verilecektir. \nUzant\u0131lar, s\u0131n\u0131fa ek s\u0131n\u0131flar y\u00fcklemek i\u00e7in kullan\u0131lacakt\u0131r. \nUzant\u0131n\u0131n g\u00fcc\u00fc \u015fu \u015fekildedir: CAP, uzant\u0131n\u0131n ad\u0131ndaki b\u00fcy\u00fck harflerin say\u0131s\u0131d\u0131r ve SM, k\u00fc\u00e7\u00fck harflerin say\u0131s\u0131d\u0131r. G\u00fc\u00e7, CAP - SM kesiri ile belirlenir. \nEn g\u00fc\u00e7l\u00fc uzant\u0131y\u0131 bulmal\u0131 ve \u015fu formatta bir string d\u00f6nd\u00fcrmelisiniz: ClassName.StrongestExtensionName.\nE\u011fer iki veya daha fazla uzant\u0131 ayn\u0131 g\u00fcce sahipse, listede ilk geleni se\u00e7melisiniz.\n\u00d6rne\u011fin, size \"Slices\" s\u0131n\u0131f\u0131 ve \u015fu uzant\u0131lar listesi verilmi\u015fse: ['SErviNGSliCes', 'Cheese', 'StuFfed'] \no zaman 'Slices.SErviNGSliCes' d\u00f6nd\u00fcrmelisiniz \u00e7\u00fcnk\u00fc 'SErviNGSliCes' en g\u00fc\u00e7l\u00fc uzant\u0131d\u0131r.\n\u00d6rnek:\nStrongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Size 2 kelime verilir. \u0130kinci kelime veya onun herhangi bir d\u00f6ng\u00fcs\u00fc ilk kelimenin i\u00e7inde bir alt dize ise True d\u00f6nd\u00fcrmelisiniz.\n\n    cycpattern_check => False\n    cycpattern_check => True\n    cycpattern_check => False\n    cycpattern_check => True\n    cycpattern_check => False\n    cycpattern_check => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Verilen bir tam say\u0131dan, s\u0131ras\u0131yla \u00e7ift ve tek basamaklar\u0131n say\u0131s\u0131n\u0131 i\u00e7eren bir demet d\u00f6nd\u00fcr\u00fcn.\n\n     \u00d6rnek:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Verilen bir pozitif tam say\u0131 i\u00e7in, onun Roma rakam\u0131 kar\u015f\u0131l\u0131\u011f\u0131n\u0131 bir dize olarak elde edin ve k\u00fc\u00e7\u00fck harflerle geri d\u00f6nd\u00fcr\u00fcn.\n    K\u0131s\u0131tlamalar: 1 <= say\u0131 <= 1000\n\n    \u00d6rnekler:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Bir fonksiyon yaz\u0131n ve bu fonksiyon bir dizi string kabul etsin.\n    Bu dizi farkl\u0131 kelimeler i\u00e7eriyor. En fazla say\u0131da benzersiz karaktere sahip olan kelimeyi d\u00f6nd\u00fcr\u00fcn.\n    E\u011fer birden fazla string en fazla benzersiz karaktere sahipse, alfabetik s\u0131rada ilk geleni d\u00f6nd\u00fcr\u00fcn.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    A\u00e7 tav\u015fans\u0131n ve zaten belli bir miktar havu\u00e7 yedin, \n    ama \u015fimdi g\u00fcn\u00fcn yemeklerini tamamlamak i\u00e7in daha fazla havu\u00e7 yemen gerekiyor.\n    Bir dizi d\u00f6nd\u00fcrmelisin: [ yemeklerinden sonra yenen toplam havu\u00e7 say\u0131s\u0131, \n                              yemeklerinden sonra kalan havu\u00e7 say\u0131s\u0131 ]\n    E\u011fer yeterince kalan havu\u00e7 yoksa, t\u00fcm kalan havu\u00e7lar\u0131 yiyeceksin ama yine de a\u00e7 olacaks\u0131n.\n\n    \u00d6rnek:\n    * eat -> [11, 4]\n    * eat -> [12, 1]\n    * eat -> [11, 0]\n    * eat -> [7, 0]\n    \n    De\u011fi\u015fkenler:\n    @number : tam say\u0131\n        yedi\u011fin havu\u00e7 say\u0131s\u0131.\n    @need : tam say\u0131\n        yemen gereken havu\u00e7 say\u0131s\u0131.\n    @remaining : tam say\u0131\n        stokta mevcut kalan havu\u00e7 say\u0131s\u0131\n    \n    K\u0131s\u0131tlar:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    \u0130yi e\u011flenceler :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    \u0130ki liste verildi\u011finde, operat\u00f6r ve operand. \u0130lk liste temel cebir i\u015flemlerini i\u00e7erir ve ikinci liste bir tamsay\u0131 listesidir. Verilen iki listeyi kullanarak cebirsel ifadeyi olu\u015fturun ve bu ifadenin de\u011ferlendirilmi\u015f halini d\u00f6nd\u00fcr\u00fcn.\n\nTemel cebir i\u015flemleri:\nToplama\n\u00c7\u0131karma\n\u00c7arpma\nTaban b\u00f6lme\n\u00dcs alma\n\n\u00d6rnek:\noperator['+', '*', '-']\ndizi = [2, 3, 4, 5]\nsonu\u00e7 = 2 + 3 * 4 - 5\n=> sonu\u00e7 = 9\n\nNot:\n    Operat\u00f6r listesi uzunlu\u011fu operand listesi uzunlu\u011fundan bir eksiktir.\n    Operand listesi negatif olmayan tamsay\u0131lardan olu\u015fur.\n    Operat\u00f6r listesi en az bir operat\u00f6r i\u00e7erir ve operand listesi en az iki operand i\u00e7erir.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Size bir `s` stringi veriliyor.\n    E\u011fer s[i] bir harfse, onun durumunu k\u00fc\u00e7\u00fckten b\u00fcy\u00fc\u011fe veya tam tersi \u015fekilde de\u011fi\u015ftirin,\n    aksi takdirde oldu\u011fu gibi b\u0131rak\u0131n.\n    E\u011fer string hi\u00e7 harf i\u00e7ermiyorsa, stringi ters \u00e7evirin.\n    Fonksiyon, ortaya \u00e7\u0131kan stringi d\u00f6nd\u00fcrmelidir.\n    \u00d6rnekler:\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Verilen 'text' dizesinin md5 hash e\u015fde\u011ferini d\u00f6nd\u00fcr\u00fcn.\n    E\u011fer 'text' bo\u015f bir dize ise, None d\u00f6nd\u00fcr\u00fcn.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    \u0130ki pozitif tam say\u0131 a ve b verildi\u011finde, a ile b aras\u0131ndaki \u00e7ift rakamlar\u0131 artan s\u0131rayla d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rne\u011fin:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]