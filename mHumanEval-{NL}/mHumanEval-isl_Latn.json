[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Athuga\u00f0u hvort \u00ed gefnum lista af t\u00f6lum, s\u00e9u einhverjar tv\u00e6r t\u00f6lur n\u00e6r hvor annarri en gefi\u00f0 vi\u00f0mi\u00f0.\nD\u00e6mi:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Inntak \u00ed \u00feessa fall er strengur sem inniheldur margar h\u00f3pa af innfelldum svigum. Markmi\u00f0 \u00feitt er a\u00f0\n    a\u00f0skilja \u00feessa h\u00f3pa \u00ed a\u00f0skilda strengi og skila lista af \u00feeim.\n    A\u00f0skildir h\u00f3par eru jafnv\u00e6gi og ekki innfelldir hver \u00ed \u00f6\u00f0rum.\n    Hunsa skal \u00f6ll bil \u00ed inntaksstrengnum.\n    D\u00e6mi:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Gefi\u00f0 j\u00e1kv\u00e6\u00f0a kommut\u00f6lu m\u00e1 sundurgreina \u00ed heilt\u00f6luhluta og brot.\n\nSkila\u00f0u brotshluta t\u00f6lunnar.\nD\u00e6mi:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" \u00de\u00fa ert me\u00f0 lista yfir innlagnir og \u00fattektir \u00e1 bankareikningi sem byrjar me\u00f0 n\u00fallst\u00f6\u00f0u. Verkefni\u00f0 \u00feitt er a\u00f0 greina hvort jafnv\u00e6gi\u00f0 \u00e1 reikningnum falli ni\u00f0ur fyrir n\u00fall einhvern t\u00edma, og \u00e1 \u00feeim t\u00edmapunkti \u00e6tti falli\u00f0 a\u00f0 skila True. Annars \u00e6tti \u00fea\u00f0 a\u00f0 skila False. D\u00e6mi:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Fyrir gefinn lista af inntakst\u00f6lum, reikni\u00f0 me\u00f0altalsfr\u00e1vik \u00ed kringum me\u00f0altal \u00feessa gagnasafns. Me\u00f0altalsfr\u00e1vik er me\u00f0alalgilt fr\u00e1vik hvers staks fr\u00e1 mi\u00f0punkti:\nMAD = me\u00f0altal | x - x_me\u00f0altal |\nD\u00e6mi:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Settu inn 'afmarkara' \u00e1 milli hverra tveggja samliggjandi staka \u00ed inntakslistanum `t\u00f6lur`\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Inntak \u00ed \u00feessa a\u00f0ger\u00f0 er strengur sem t\u00e1knar marga h\u00f3pa innfelldra sviga a\u00f0skilda me\u00f0 bilum.\n    Fyrir hvern h\u00f3p, skila\u00f0u d\u00fdpsta stiginu af innfellingu sviga.\n    T.d. hefur) mest tv\u00f6 stig af innfellingu en)) hefur \u00ferj\u00fa.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" S\u00eda\u00f0u lista af strengjum \u00feannig a\u00f0 a\u00f0eins \u00feeir innihaldi tiltekinn undirsteng.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Fyrir gefinn lista af heilt\u00f6lum, skila\u00f0u tvennd sem samanstendur af summu og margfeldi allra heiltalna \u00ed listanum.\nT\u00f3m summa \u00e6tti a\u00f0 vera j\u00f6fn 0 og t\u00f3mt margfeldi \u00e6tti a\u00f0 vera jafnt 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" \u00dat fr\u00e1 gefnum lista heiltalna, b\u00faa til lista yfir h\u00e6sta gildi\u00f0 \u00e1 hverjum t\u00edmapunkti \u00ed r\u00f6\u00f0inni.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Pr\u00f3fa\u00f0u hvort gefinn strengur s\u00e9 samhverfa \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Inntak eru tveir strengir a og b sem samanstanda a\u00f0eins af 1 og 0.\n    Framkv\u00e6mdu tv\u00edundar XOR \u00e1 \u00feessum innt\u00f6kum og skila\u00f0u ni\u00f0urst\u00f6\u00f0unni einnig sem streng.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" \u00dar lista strengja, skila\u00f0u \u00feeim lengsta. Skila\u00f0u \u00feeim fyrsta ef margir strengir eru jafn langir. Skila\u00f0u None ef innsl\u00e1ttur listi er t\u00f3mur.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Skila st\u00e6rsta samdeili tveggja heiltalna a og b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Skila lista yfir alla forskeyti fr\u00e1 \u00fev\u00ed stysta til \u00feess lengsta \u00far inntaksstrengnum.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Skila streng sem inniheldur t\u00f6lur a\u00f0skildar me\u00f0 bilum fr\u00e1 0 upp \u00ed n me\u00f0tali\u00f0.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Gefi\u00f0 streng, finndu \u00fat hversu m\u00f6rg s\u00e9rst\u00f6k t\u00e1kn hann inniheldur.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Inntak \u00ed \u00feessa fall er strengur sem t\u00e1knar n\u00f3tur \u00ed s\u00e9rst\u00f6ku ASCII-sni\u00f0i.\n    Verkefni \u00feitt er a\u00f0 greina \u00feennan streng og skila lista af heilt\u00f6lum sem samsvara \u00fev\u00ed hversu margar sl\u00f6g hver n\u00f3ta varir.\n\n    H\u00e9r er lykillinn:\n    'o' - heilan\u00f3ta, varir fj\u00f6gur sl\u00f6g\n    'o|' - h\u00e1lfn\u00f3ta, varir tv\u00f6 sl\u00f6g\n    '.|' - fj\u00f3r\u00f0ungn\u00f3ta, varir eitt slag\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Finndu hversu oft tilteki\u00f0 undirstreng m\u00e1 finna \u00ed upprunalega strengnum. Teldu sk\u00f6runartilvik.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Inntaki\u00f0 er strengur af t\u00f6lust\u00f6fum a\u00f0skildum me\u00f0 bilum fr\u00e1 'n\u00fall' til 'n\u00edu'.\n    Gildar valkostir eru 'n\u00fall', 'einn', 'tveir', '\u00fer\u00edr', 'fj\u00f3rir', 'fimm', 'sex', 'sj\u00f6', '\u00e1tta' og 'n\u00edu'.\n    Skila\u00f0u strengnum me\u00f0 t\u00f6lunum ra\u00f0a\u00f0 fr\u00e1 \u00feeim minnsta til hins st\u00e6rsta.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" \u00dar lista me\u00f0 t\u00f6lum skal velja tv\u00e6r t\u00f6lur sem eru n\u00e6st hvorri annarri og skila \u00feeim \u00ed r\u00f6\u00f0.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Gefnum lista af t\u00f6lum, skal beita l\u00ednulegri umbreytingu \u00e1 \u00feann lista,\n    \u00feannig a\u00f0 minnsta talan ver\u00f0i 0 og s\u00fa st\u00e6rsta ver\u00f0i 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" S\u00eda\u00f0u listann \u00feannig a\u00f0 hann innihaldi a\u00f0eins heilt\u00f6lur \u00far Python-gildum.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Skila\u00f0u lengd tiltekins strengs.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Fyrir gefna t\u00f6lu n, finndu st\u00e6rstu t\u00f6luna sem gengur upp \u00ed n, minni en n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Skila\u00f0u lista yfir frum\u00fe\u00e6tti tiltekins heilt\u00f6lu \u00ed r\u00f6\u00f0 fr\u00e1 \u00feeim minnsta til \u00feess st\u00e6rsta. \n    Hver \u00fe\u00e1ttur \u00e6tti a\u00f0 vera skr\u00e1\u00f0ur eins oft og hann kemur fyrir \u00ed \u00fe\u00e1ttuninni.\n    Innsl\u00e1ttartalan \u00e6tti a\u00f0 vera j\u00f6fn margfeldi allra \u00fe\u00e1ttanna.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \u00dar lista af heilt\u00f6lum skal fjarl\u00e6gja alla \u00fe\u00e6tti sem koma fyrir oftar en einu sinni. Halda skal r\u00f6\u00f0 \u00fe\u00e1ttanna sem eftir eru eins og \u00ed inntakinu.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Fyrir gefinn streng, breyttu l\u00e1gst\u00f6fum \u00ed h\u00e1stafi og h\u00e1st\u00f6fum \u00ed l\u00e1gstafi.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Tengja lista af strengjum saman \u00ed einn streng\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" S\u00eda\u00f0u innsl\u00e1ttarlista strengja einungis fyrir \u00fe\u00e1 sem byrja \u00e1 tilteknu forskeyti.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Skila\u00f0u a\u00f0eins j\u00e1kv\u00e6\u00f0um t\u00f6lum \u00ed listanum.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Skila\u00f0u satt ef gefin tala er pr\u00edmtala, annars \u00f3satt.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Metur margli\u00f0u me\u00f0 stu\u00f0lana xs \u00e1 punktinum x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"\u00deessi fall tekur lista l og skilar lista l' \u00feannig a\u00f0:\n    l' er eins og l \u00e1 \u00feeim v\u00edsum sem ekki eru deilanlegir me\u00f0 \u00feremur, \u00e1 me\u00f0an gildin \u00e1 v\u00edsunum sem eru deilanlegir me\u00f0 \u00feremur eru j\u00f6fn\n    gildum samsvarandi v\u00edsanna \u00ed l, en ra\u00f0a\u00f0.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Skila\u00f0u ra\u00f0a\u00f0ri lista af einst\u00f6kum \u00fe\u00e1ttum.\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Skila\u00f0u st\u00e6rsta stakinu \u00ed listanum.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Skila\u00f0u fj\u00f6lda skipta sem t\u00f6lustafurinn 7 kemur fyrir \u00ed heilum t\u00f6lum minni en n, sem eru deilanlegar me\u00f0 11 e\u00f0a 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"\u00deessi fall tekur lista l og skilar lista l' \u00feannig a\u00f0\n    l' er eins og l \u00ed oddat\u00f6lueindunum, \u00e1 me\u00f0an gildin \u00e1 sl\u00e9ttum eindum eru j\u00f6fn\n    gildum sl\u00e9ttu eindanna \u00ed l, en ra\u00f0a\u00f0 eftir st\u00e6r\u00f0.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    skilar k\u00f3\u00f0u\u00f0um streng me\u00f0 \u00fev\u00ed a\u00f0 hj\u00f3la h\u00f3pa af \u00feremur st\u00f6fum.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib skilar n-ta t\u00f6lunni sem er b\u00e6\u00f0i Fibonacci tala og pr\u00edmtala.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    ```plaintext\ntriples_sum_to_zero tekur lista af heilt\u00f6lum sem inntak.\n    \u00dea\u00f0 skilar True ef \u00fea\u00f0 eru \u00fer\u00edr \u00f3l\u00edkir stakir \u00ed listanum sem \n    leggja saman \u00ed n\u00fall, annars False.\n```\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    \u00cdmynda\u00f0u \u00fe\u00e9r veg sem er fullkomlega bein, \u00f3endanlega l\u00f6ng l\u00edna.\nn b\u00edlar keyra fr\u00e1 vinstri til h\u00e6gri; samt\u00edmis keyrir annar h\u00f3pur af n b\u00edlum\nfr\u00e1 h\u00e6gri til vinstri. H\u00f3parnir tveir byrja mj\u00f6g langt fr\u00e1\nhvor \u00f6\u00f0rum. Allir b\u00edlar fara \u00e1 sama hra\u00f0a. Tveir b\u00edlar rekast saman \u00feegar b\u00edll sem fer fr\u00e1 vinstri til h\u00e6gri rekst \u00e1 b\u00edl sem fer fr\u00e1 h\u00e6gri til vinstri.\nB\u00edlarnir eru hins vegar \u00f3endanlega traustir og sterkir; sem lei\u00f0ir til \u00feess a\u00f0 \u00feeir halda \u00e1fram a\u00f0 fara eftir sinni lei\u00f0 eins og \u00feeir hafi ekki rekist saman.\n\n\u00deessi fall skilar fj\u00f6lda sl\u00edkra \u00e1rekstra.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Skila lista me\u00f0 st\u00f6kum auknum um 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    `pairs_sum_to_zero` tekur lista af heilt\u00f6lum sem inntak.\n    \u00fea\u00f0 skilar True ef \u00fea\u00f0 eru tv\u00f6 a\u00f0greind st\u00f6k \u00ed listanum sem\n    leggja saman \u00ed n\u00fall, og False annars.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Breyttu talnagrunninum \u00e1 innsl\u00e1ttart\u00f6lunni x \u00ed annan grunn.\n    Skila\u00f0u strengjum eftir breytinguna.\n    Grunnn\u00famer eru minni en 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Gefi\u00f0 lengd hli\u00f0ar og h\u00e6\u00f0, skila\u00f0u flatarm\u00e1li \u00fer\u00edhyrnings.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 talnarunan er r\u00f6\u00f0 svipu\u00f0 Fibbonacci r\u00f6\u00f0inni sem er skilgreind \u00e1 eftirfarandi h\u00e1tt:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    Vinsamlegast skrifa\u00f0u fall til a\u00f0 reikna n-ta staki\u00f0 \u00ed fib4 talnar\u00f6\u00f0inni \u00e1 skilvirkan h\u00e1tt. Ekki nota endurkv\u00e6mni.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Skila\u00f0u mi\u00f0gildi stakanna \u00ed listanum l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Athugar hvort gefin strengur s\u00e9 samhverfa\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Skila 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    skilar k\u00f3\u00f0u\u00f0um streng me\u00f0 \u00fev\u00ed a\u00f0 f\u00e6ra hvern staf um 5 \u00ed stafr\u00f3finu.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels er fall sem tekur streng og skilar streng \u00e1n s\u00e9rhlj\u00f3\u00f0a.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Skila\u00f0u Satt ef allir t\u00f6lur \u00ed listanum l eru undir \u00fer\u00f6skuldinum t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Legg\u00f0u saman tv\u00e6r t\u00f6lur, x og y.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Athuga\u00f0u hvort tv\u00f6 or\u00f0 hafi s\u00f6mu stafi.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Skila n-ta Fibonacci-t\u00f6lu.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Svigar eru strengur af \"<\" og \">\". \n    Skila\u00f0u True ef hver opnunarsvigi hefur samsvarandi lokunarsviga.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Skila\u00f0u True ef stak listans eru einh\u00e6ft vaxandi e\u00f0a minnkandi.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Skila\u00f0u ra\u00f0a\u00f0ri einstaka sameiginlegri frumefnum tveggja lista.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Skila\u00f0u st\u00e6rsta frum\u00fe\u00e6tti n. Gert er r\u00e1\u00f0 fyrir a\u00f0 n > 1 og s\u00e9 ekki frumtala.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n er fall sem leggur saman t\u00f6lurnar fr\u00e1 1 til n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Svigar eru strengur af \"\". \n    Skila\u00f0u True ef hver opnunarsvigi hefur samsvarandi lokunarsviga.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs t\u00e1kna stu\u00f0la margli\u00f0u.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Skila\u00f0u aflei\u00f0u \u00feessarar margli\u00f0u \u00e1 sama formi.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"T\u00f6lur\u00f6\u00f0in FibFib er r\u00f6\u00f0 sem l\u00edkist Fibonacci-r\u00f6\u00f0inni og er skilgreind \u00e1 eftirfarandi h\u00e1tt:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Vinsamlegast skrifa\u00f0u fall til a\u00f0 reikna n-ta stak FibFib t\u00f6lur\u00f6\u00f0arinnar \u00e1 skilvirkan h\u00e1tt.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nB\u00e6ttu vi\u00f0 fleiri pr\u00f3funartilvikum.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Hli\u00f0ra t\u00f6lust\u00f6fum heilt\u00f6lunnar x \u00ed hring, hli\u00f0ra t\u00f6lust\u00f6fum til h\u00e6gri um hli\u00f0run\n    og skila ni\u00f0urst\u00f6\u00f0unni sem streng.\n    Ef hli\u00f0run > fj\u00f6ldi t\u00f6lustafa, skila t\u00f6lust\u00f6fum \u00ed \u00f6fugri r\u00f6\u00f0.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"\u00de\u00fdddu eftirfarandi setningu \u00e1 \u00edslensku:\n\nSkrifa\u00f0u fall sem tekur streng sem inntak og skilar summu ASCII gildanna a\u00f0eins fyrir st\u00f3ra stafi.\n\nD\u00e6mi:\n```\ndigitSum => 0\ndigitSum => 131\ndigitSum => 67\ndigitSum => 69\ndigitSum => 131\ndigitSum => 153\n```\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    \u00cd \u00feessu verkefni muntu f\u00e1 streng sem t\u00e1knar fj\u00f6lda eplis og appels\u00edna sem dreift er \u00ed \u00e1vaxtak\u00f6rfu, \u00feessi karfa inniheldur epli, appels\u00ednur og mang\u00f3\u00e1vaxtir. Me\u00f0 gefnum streng sem t\u00e1knar heildarfj\u00f6lda appels\u00edna og epli og heilt\u00f6lu sem t\u00e1knar heildarfj\u00f6lda \u00e1vaxta \u00ed k\u00f6rfunni, skila\u00f0u fj\u00f6lda mang\u00f3\u00e1vaxta \u00ed k\u00f6rfunni.\nTil d\u00e6mis:\nfruit_distribution -> 19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Hafi r\u00f6\u00f0 sem t\u00e1knar grein tr\u00e9s sem inniheldur ekki-neikv\u00e6\u00f0ar heilt\u00f6lur,\n    \u00fe\u00e1 er verkefni\u00f0 \u00feitt a\u00f0 velja einn af hn\u00fatunum og skila honum.\n    Hn\u00faturinn sem \u00fe\u00fa velur \u00e1 a\u00f0 vera hn\u00faturinn me\u00f0 minnsta sl\u00e9tta gildi\u00f0.\n    Ef til eru margir hn\u00fatar me\u00f0 sama minnsta sl\u00e9tta gildi, skila\u00f0u hn\u00fatinum sem er me\u00f0 minnsta v\u00edsit\u00f6lu.\n\n    Valdi hn\u00faturinn skal skila \u00ed lista, [ minnst_gildi, v\u00edsitala \u00feess ],\n    Ef engin sl\u00e9tt gildi eru til e\u00f0a gefna r\u00f6\u00f0in er t\u00f3m, skila\u00f0u [].\n\n    D\u00e6mi1:\n        Inntak: [4,2,3]\n        \u00dattak: [2, 1]\n        Sk\u00fdring: 2 hefur minnsta sl\u00e9tta gildi\u00f0, og 2 hefur minnsta v\u00edsit\u00f6lu.\n\n    D\u00e6mi2:\n        Inntak: [1,2,3]\n        \u00dattak: [2, 1]\n        Sk\u00fdring: 2 hefur minnsta sl\u00e9tta gildi\u00f0, og 2 hefur minnsta v\u00edsit\u00f6lu.\n\n    D\u00e6mi3:\n        Inntak: []\n        \u00dattak: []\n\n    D\u00e6mi4:\n        Inntak: [5, 0, 3, 0, 4, 2]\n        \u00dattak: [0, 1]\n        Sk\u00fdring: 0 er minnsta gildi\u00f0, en \u00fea\u00f0 eru tv\u00e6r n\u00fallur,\n                 \u00feannig a\u00f0 vi\u00f0 veljum fyrsta n\u00falli\u00f0, sem hefur minnsta v\u00edsit\u00f6lu.\n\n    Takmarkanir:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\"\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Gefin fylki arr af heilt\u00f6lum, finndu l\u00e1gmarksfj\u00f6lda \u00fe\u00e1tta sem \u00fearf a\u00f0 breyta til a\u00f0 gera fylki\u00f0 symmetr\u00edskt. Symmetr\u00edskt fylki er fylki sem er lesi\u00f0 eins aftur \u00e1 bak og \u00e1fram. \u00cd einni breytingu getur\u00f0u breytt einum \u00fe\u00e6tti \u00ed einhvern annan \u00fe\u00e1tt.\n\nTil d\u00e6mis:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Skrifa\u00f0u fall sem skilar satt ef gefna talan er margf\u00f6ldun \u00feriggja pr\u00edmtalna og \u00f3satt annars.\nVitandi a\u00f0 er minna en 100.\nD\u00e6mi:\nis_multiply_prime == Satt\n30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Verkefni\u00f0 \u00feitt er a\u00f0 skrifa fall sem skilar satt ef tala x er einf\u00f6ld veldistala af n og \u00f3satt annars.\nx er einf\u00f6ld veldistala af n ef n**int=x.\nTil d\u00e6mis:\nis_simple_power => satt\nis_simple_power => satt\nis_simple_power => satt\nis_simple_power => \u00f3satt\nis_simple_power => \u00f3satt\nis_simple_power => \u00f3satt\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"\u00de\u00e9r hefur veri\u00f0 fali\u00f0 a\u00f0 skrifa fall sem tekur \u00e1 m\u00f3ti sext\u00e1ndakerfist\u00f6lu sem streng og telur fj\u00f6lda sext\u00e1ndakerfistafna sem eru frumt\u00f6lur.\nSext\u00e1ndakerfistafir eru 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nFrumt\u00f6lur eru 2, 3, 5, 7, 11, 13, 17,...\nSvo \u00fe\u00fa \u00fearft a\u00f0 \u00e1kvar\u00f0a fj\u00f6lda eftirfarandi stafa: 2, 3, 5, 7, B, D.\nAthuga\u00f0u: \u00fe\u00fa m\u00e1tt gera r\u00e1\u00f0 fyrir a\u00f0 inntaki\u00f0 s\u00e9 alltaf r\u00e9tt e\u00f0a t\u00f3mt strengur, og t\u00e1knin A, B, C, D, E, F eru alltaf h\u00e1stafir.\nD\u00e6mi:\nFyrir num = \"AB\" \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 1.\nFyrir num = \"1077E\" \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 2.\nFyrir num = \"ABED1A33\" \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 4.\nFyrir num = \"123456789ABCDEF0\" \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 6.\nFyrir num = \"2020\" \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 2.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"\u00de\u00e9r ver\u00f0ur gefin tala \u00e1 tugakerfi og verkefni \u00feitt er a\u00f0 breyta henni \u00ed tv\u00edundarform. Falli\u00f0 \u00e6tti a\u00f0 skila streng, \u00fear sem hver stafur stendur fyrir tv\u00edundart\u00f6lu. Hver stafur \u00ed strengnum ver\u00f0ur '0' e\u00f0a '1'.\n\n\u00dea\u00f0 ver\u00f0a nokkrir auka stafir 'db' \u00ed byrjun og \u00ed lok strengsins. Auka stafirnir eru \u00fear til a\u00f0 hj\u00e1lpa vi\u00f0 sni\u00f0i\u00f0.\n\nD\u00e6mi:\ndecimal_to_binary   # skilar \"db1111db\"\ndecimal_to_binary   # skilar \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"\u00de\u00fa f\u00e6r\u00f0 streng s.\n    Verkefni \u00feitt er a\u00f0 athuga hvort strengurinn s\u00e9 gla\u00f0ur e\u00f0a ekki.\n    Strengur er gla\u00f0ur ef lengd hans er a\u00f0 minnsta kosti 3 og hverjir 3 samliggjandi stafir eru \u00f3l\u00edkir.\n    Til d\u00e6mis:\n    is_happy => Rangt\n    is_happy => Rangt\n    is_happy => Satt\n    is_happy => Rangt\n    is_happy => Satt\n    is_happy => Rangt\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u00dea\u00f0 er s\u00ed\u00f0asta vikan \u00e1 \u00f6nninni og kennarinn \u00fearf a\u00f0 gefa nemendum einkunnir. Kennarinn hefur veri\u00f0 a\u00f0 b\u00faa til eigin reiknirit til a\u00f0 gefa einkunnir. Eina vandam\u00e1li\u00f0 er, a\u00f0 h\u00fan hefur t\u00fdnt k\u00f3\u00f0anum sem h\u00fan nota\u00f0i til a\u00f0 gefa einkunnir. H\u00fan hefur gefi\u00f0 \u00fe\u00e9r lista yfir me\u00f0aleinkunnir nokkurra nemenda og \u00fe\u00fa \u00fearft a\u00f0 skrifa fall sem getur skila\u00f0 lista af b\u00f3kstafseinkunnum me\u00f0 \u00fev\u00ed a\u00f0 nota eftirfarandi t\u00f6flu:\n             \n             GPA       |    B\u00f3kstafseinkunn\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    D\u00e6mi:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Skrifa\u00f0u fall sem tekur streng og skilar s\u00f6nnu ef lengd strengsins er pr\u00edmtala e\u00f0a \u00f3s\u00f6nnu annars.\n    D\u00e6mi:\n    prime_length == Satt\n    prime_length == Satt\n    prime_length == Satt\n    prime_length == \u00d3satt\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Gefi\u00f0 j\u00e1kv\u00e6\u00f0a heilt\u00f6lu n, skila\u00f0u fj\u00f6lda n-stafa j\u00e1kv\u00e6\u00f0ra talna sem byrja e\u00f0a enda \u00e1 t\u00f6lunni 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Gefi\u00f0 j\u00e1kv\u00e6\u00f0a heilt\u00f6lu N, skila samtals summu stafa hennar \u00ed tv\u00edundarkerfi.\n\n    D\u00e6mi\n        Fyrir N = 1000, ver\u00f0ur summan af st\u00f6fum 1 og \u00fattaki\u00f0 \u00e6tti a\u00f0 vera \"1\".\n        Fyrir N = 150, ver\u00f0ur summan af st\u00f6fum 6 og \u00fattaki\u00f0 \u00e6tti a\u00f0 vera \"110\".\n        Fyrir N = 147, ver\u00f0ur summan af st\u00f6fum 12 og \u00fattaki\u00f0 \u00e6tti a\u00f0 vera \"1100\".\n    \n    Breytur:\n        @N heiltala\n             Takmarkanir: 0 \u2264 N \u2264 10000.\n    \u00dattak:\n         strengur af tv\u00edundart\u00f6lu\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Gefi\u00f0 er ekki-t\u00f3mt lista af heilt\u00f6lum lst. Leggi\u00f0 saman sl\u00e9ttar t\u00f6lur sem eru \u00e1 oddat\u00f6lum st\u00f6\u00f0um.\n\n    D\u00e6mi:\n        add ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Skrifa\u00f0u fall sem tekur streng og skilar ra\u00f0a\u00f0ri \u00fatg\u00e1fu af honum.\n    Ra\u00f0a\u00f0 \u00fatg\u00e1fa af streng, er strengur \u00fear sem \u00f6ll or\u00f0\n    eru skipt \u00fat fyrir n\u00fdtt or\u00f0 \u00fear sem allir stafir eru ra\u00f0a\u00f0ir \u00ed\n    h\u00e6kkandi r\u00f6\u00f0 mi\u00f0a\u00f0 vi\u00f0 ascii-gildi.\n    Athugi\u00f0: \u00de\u00fa \u00e6ttir a\u00f0 halda r\u00f6\u00f0 or\u00f0a og t\u00f3mar\u00fama \u00ed setningunni.\n\n    Til d\u00e6mis:\n    anti_shuffle skilar 'Hi'\n    anti_shuffle skilar 'ehllo'\n    anti_shuffle skilar 'Hello !!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    \u00de\u00fa f\u00e6r\u00f0 tv\u00edv\u00ed\u00f0 g\u00f6gn, sem eru innfelldir listar, \n    sem l\u00edkjast fylki, en \u00f3l\u00edkt fylkjum, \n    getur hver r\u00f6\u00f0 haft mismunandi fj\u00f6lda d\u00e1lka.\n    Me\u00f0 tilliti til lst og heilt\u00f6lunnar x, finndu heilt\u00f6luna x \u00ed listanum, \n    og skila\u00f0u lista af tvenndum, [, ...] \u00feannig a\u00f0 \n    hver tvennd er hnit -, byrja\u00f0 me\u00f0 0.\n    Ra\u00f0a hniti upphaflega eftir r\u00f6\u00f0um \u00ed vaxandi r\u00f6\u00f0.\n    Einnig, ra\u00f0a hniti \u00ed r\u00f6\u00f0 eftir d\u00e1lkum \u00ed minnkandi r\u00f6\u00f0.\n    \n    D\u00e6mi:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [,,,,]\n    get_row == []\n    get_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Gefi\u00f0 fylki af ekki-neikv\u00e6\u00f0um heilt\u00f6lum, skila\u00f0u afriti af gefnu fylkinu eftir a\u00f0 hafa ra\u00f0a\u00f0 \u00fev\u00ed,\n\u00fe\u00fa munt ra\u00f0a gefnu fylki \u00ed h\u00e6kkandi r\u00f6\u00f0 ef summan er oddatala,\ne\u00f0a ra\u00f0a \u00fev\u00ed \u00ed l\u00e6kkandi r\u00f6\u00f0 ef summan er sl\u00e9tt tala.\n\nAthugi\u00f0:\n* ekki breyta gefna fylkinu.\n\nD\u00e6mi:\n* sort_array => []\n* sort_array => [5]\n* sort_array => [0, 1, 2, 3, 4, 5]\n* sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"B\u00fa\u00f0u til falli\u00f0 encrypt sem tekur streng sem r\u00f6k og skilar dulk\u00f3\u00f0u\u00f0um streng \u00fear sem stafr\u00f3fi\u00f0 er f\u00e6rt til. Stafr\u00f3fi\u00f0 \u00e6tti a\u00f0 f\u00e6rast \u00feannig a\u00f0 b\u00f3kst\u00f6funum s\u00e9 skipt um fj\u00f6gur s\u00e6ti. Til d\u00e6mis:\nencrypt skilar 'lm'\nencrypt skilar 'ewhjklnop'\nencrypt skilar 'kj'\nencrypt skilar 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    \u00de\u00fa f\u00e6r\u00f0 lista af heilt\u00f6lum.\n    Skrifa\u00f0u falli\u00f0 next_smallest sem skilar 2. minnsta stakinu \u00e1 listanum.\n    Skila\u00f0u None ef \u00fea\u00f0 er ekkert sl\u00edkt stak.\n    \n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    \u00de\u00e9r ver\u00f0ur gefin strengur af or\u00f0um, og verkefni \u00feitt er a\u00f0 telja fj\u00f6lda lei\u00f0inda. Lei\u00f0indi eru setning sem byrjar \u00e1 or\u00f0inu \u201e\u00c9g\u201c. Setningar eru afmarka\u00f0ar me\u00f0 '.', '?' e\u00f0a '!'.\n\nTil d\u00e6mis:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Skrifa\u00f0u fall sem tekur skilabo\u00f0 og k\u00f3\u00f0ar \u00feau \u00e1 \u00feann h\u00e1tt a\u00f0 \u00fea\u00f0 skiptir um \n    h\u00e1stafi og l\u00e1gstafi fyrir allar stafir, og skiptir \u00fat \u00f6llum s\u00e9rhlj\u00f3\u00f0um \u00ed \n    skilabo\u00f0unum me\u00f0 stafnum sem er 2 st\u00f6\u00f0um \u00e1 eftir \u00feeim s\u00e9rhlj\u00f3\u00f0i \u00ed ensku \n    stafr\u00f3finu. \n    Gert er r\u00e1\u00f0 fyrir a\u00f0 a\u00f0eins s\u00e9u stafir. \n    \n    D\u00e6mi:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"\u00de\u00fa f\u00e6r\u00f0 lista af heilt\u00f6lum.\n    \u00de\u00fa \u00fearft a\u00f0 finna st\u00e6rsta frumt\u00f6luver\u00f0m\u00e6ti\u00f0 og skila summu t\u00f6lustafanna hennar.\n\n    D\u00e6mi:\n    Fyrir lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 10\n    Fyrir lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 25\n    Fyrir lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 13\n    Fyrir lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 11\n    Fyrir lst = [0,81,12,3,1,21] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 3\n    Fyrir lst = [0,8,1,2,1,7] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Gefi\u00f0 or\u00f0ab\u00f3k, skila True ef \u00f6ll lykilor\u00f0 eru strengir \u00ed l\u00e1gst\u00f6fum e\u00f0a \u00f6ll lykilor\u00f0 eru strengir \u00ed h\u00e1st\u00f6fum, annars skila False.\nFalli\u00f0 \u00e6tti a\u00f0 skila False ef gefin or\u00f0ab\u00f3k er t\u00f3m.\nD\u00e6mi:\ncheck_dict_case \u00e6tti a\u00f0 skila True.\ncheck_dict_case \u00e6tti a\u00f0 skila False.\ncheck_dict_case \u00e6tti a\u00f0 skila False.\ncheck_dict_case \u00e6tti a\u00f0 skila False.\ncheck_dict_case \u00e6tti a\u00f0 skila True.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"\u00datf\u00e6r\u00f0u fall sem tekur vi\u00f0 ekki neikv\u00e6\u00f0ri heilt\u00f6lu og skilar fylki me\u00f0 fyrstu n heilt\u00f6lunum sem eru pr\u00edmt\u00f6lur og minni en n.\n    til d\u00e6mis:\n    count_up_to => [2,3]\n    count_up_to => [2,3,5,7]\n    count_up_to => []\n    count_up_to => [2,3,5,7,11,13,17,19]\n    count_up_to => []\n    count_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Lj\u00faktu vi\u00f0 falli\u00f0 sem tekur tv\u00e6r heilt\u00f6lur og skilar margfeldi einingastafa \u00feeirra.\nGera m\u00e1 r\u00e1\u00f0 fyrir a\u00f0 inntaki\u00f0 s\u00e9 alltaf gilt.\nD\u00e6mi:\nmultiply \u00e6tti a\u00f0 skila 16.\nmultiply \u00e6tti a\u00f0 skila 72.\nmultiply \u00e6tti a\u00f0 skila 0.\nmultiply \u00e6tti a\u00f0 skila 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Gefin strengur s, teldu fj\u00f6lda h\u00e1stafa s\u00e9rhlj\u00f3\u00f0a \u00ed j\u00f6fnum v\u00edsit\u00f6lum.\n\n    Til d\u00e6mis:\n    count_upper skilar 1\n    count_upper skilar 0\n    count_upper skilar 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Gefi\u00f0 j\u00e1kv\u00e6\u00f0a heilt\u00f6lu n, \u00fe\u00fa \u00fearft a\u00f0 b\u00faa til hr\u00fagu me\u00f0 n l\u00f6gum af steinum.\n    Fyrsta lagi\u00f0 hefur n steina.\n    Fj\u00f6ldi steina \u00ed n\u00e6sta lagi er:\n        - n\u00e6sta oddatala ef n er oddatala.\n        - n\u00e6sta sl\u00e9tta tala ef n er sl\u00e9tt tala.\n    Skila\u00f0u fj\u00f6lda steina \u00ed hverju lagi \u00ed lista, \u00fear sem stak \u00e1 v\u00edsit\u00f6lu i t\u00e1knar fj\u00f6lda steina \u00ed lagi.\n\n    D\u00e6mi:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    \u00de\u00fa munt f\u00e1 streng af or\u00f0um a\u00f0skildum me\u00f0 kommum e\u00f0a bilum. Verkefni\u00f0 \u00feitt er a\u00f0\n    skipta strengnum \u00ed or\u00f0 og skila fylki af or\u00f0unum.\n    \n    Til d\u00e6mis:\n    words_string == [\"H\u00e6\", \"\u00e9g\", \"heiti\", \"J\u00f3n\"]\n    words_string == [\"Einn\", \"tveir\", \"\u00fer\u00edr\", \"fj\u00f3rir\", \"fimm\", \"sex\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"\u00deessi fall tekur tv\u00e6r j\u00e1kv\u00e6\u00f0ar t\u00f6lur x og y og skilar st\u00e6rstu sl\u00e9ttri heilt\u00f6lu sem er \u00e1 bilinu [x, y] a\u00f0 me\u00f0t\u00f6ldu. Ef engin sl\u00edk tala er til, \u00e1 falli\u00f0 a\u00f0 skila -1.\n\nTil d\u00e6mis:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"\u00de\u00e9r eru gefnar tv\u00e6r j\u00e1kv\u00e6\u00f0ar heilt\u00f6lur n og m, og verkefni\u00f0 \u00feitt er a\u00f0 reikna me\u00f0altal heiltalnanna fr\u00e1 n til m. N\u00e1munda\u00f0u svari\u00f0 a\u00f0 n\u00e6stu heilt\u00f6lu og breyttu \u00fev\u00ed \u00ed tv\u00edundakerfi. Ef n er st\u00e6rra en m, skila\u00f0u -1.\n\nD\u00e6mi:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Gefi\u00f0 lista af j\u00e1kv\u00e6\u00f0um heilt\u00f6lum x. Skila\u00f0u flokku\u00f0um lista af \u00f6llum \n    st\u00f6kum sem hafa ekki nein sl\u00e9tt t\u00f6lustaf.\n\n    Athugi\u00f0: Skila\u00f0i listi \u00e6tti a\u00f0 vera flokka\u00f0ur \u00ed h\u00e6kkandi r\u00f6\u00f0.\n\n    Til d\u00e6mis:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Gefi\u00f0 fylki af heilt\u00f6lum, ra\u00f0i\u00f0 heilt\u00f6lunum sem eru \u00e1 bilinu 1 til 9 a\u00f0 me\u00f0t\u00f6ldum, sn\u00fai\u00f0 vi\u00f0 \u00fatkomunni og skipti\u00f0 s\u00ed\u00f0an hverri t\u00f6lu \u00fat fyrir nafn hennar \u00ed \"Einn\", \"Tveir\", \"\u00der\u00edr\", \"Fj\u00f3rir\", \"Fimm\", \"Sex\", \"Sj\u00f6\", \"\u00c1tta\", \"N\u00edu\".\n\nTil d\u00e6mis:\n  fylki = [2, 1, 1, 4, 5, 8, 2, 3]   \n        -> ra\u00f0a fylki -> [1, 1, 2, 2, 3, 4, 5, 8] \n        -> sn\u00faa vi\u00f0 fylki -> [8, 5, 4, 3, 2, 2, 1, 1]\n  skila [\"\u00c1tta\", \"Fimm\", \"Fj\u00f3rir\", \"\u00der\u00edr\", \"Tveir\", \"Tveir\", \"Einn\", \"Einn\"]\n\nEf fylki\u00f0 er t\u00f3mt, skila t\u00f3mu fylki:\n  fylki = []\n  skila []\n\nEf fylki\u00f0 inniheldur einhverja undarlega t\u00f6lu, hunsa hana:\n  fylki = [1, -1 , 55] \n        -> ra\u00f0a fylki -> [-1, 1, 55]\n        -> sn\u00faa vi\u00f0 fylki -> [55, 1, -1]\n  skila = ['Einn']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" \u00datf\u00e6ra skal falli\u00f0 f sem tekur n sem f\u00e6ribreytu\n    og skilar lista af st\u00e6r\u00f0 n, \u00feannig a\u00f0 gildi staks \u00e1 v\u00edsit\u00f6lu i s\u00e9 margfeldi i ef i er sl\u00e9tt tala\n    e\u00f0a summan af t\u00f6lum fr\u00e1 1 til i annars.\n    i byrjar fr\u00e1 1.\n    margfeldi i er margf\u00f6ldunin af t\u00f6lunum fr\u00e1 1 til i.\n    D\u00e6mi:\n    f == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Gefi\u00f0 j\u00e1kv\u00e6\u00f0a heilt\u00f6lu n, skila\u00f0u tv\u00edund sem inniheldur fj\u00f6lda sl\u00e9ttra og odda\n    heilt\u00f6lupalindr\u00f3ma sem falla innan bilsins, \u00fear me\u00f0 talin.\n\n    D\u00e6mi1:\n\n        Inntak: 3\n        \u00dattak:\n        Sk\u00fdring:\n        Heilt\u00f6lupalindr\u00f3m eru 1, 2, 3. Ein \u00feeirra er sl\u00e9tt og tv\u00e6r \u00feeirra eru oddat\u00f6lur.\n\n    D\u00e6mi2:\n\n        Inntak: 12\n        \u00dattak:\n        Sk\u00fdring:\n        Heilt\u00f6lupalindr\u00f3m eru 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Fj\u00f3rar \u00feeirra eru sl\u00e9ttar og sex \u00feeirra eru oddat\u00f6lur.\n\n    Athugi\u00f0:\n        1. 1 <= n <= 10^3\n        2. Skila\u00f0 tv\u00edund inniheldur fj\u00f6lda sl\u00e9ttra og odda heilt\u00f6lupalindr\u00f3ma \u00ed s\u00f6mu r\u00f6\u00f0.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Skrifa\u00f0u falli\u00f0 count_nums sem tekur fylki heiltalna og skilar\n    fj\u00f6lda staka \u00fear sem summa t\u00f6lustafa er > 0.\n    Ef tala er neikv\u00e6\u00f0, \u00fe\u00e1 ver\u00f0ur fyrsti stafur hennar neikv\u00e6\u00f0ur:\n    t.d. hefur -123 t\u00f6lustafina -1, 2 og 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Vi\u00f0 h\u00f6fum fylki 'arr' me\u00f0 N heilt\u00f6lum arr[1], arr[2], ..., arr[N]. T\u00f6lurnar \u00ed fylkinu eru \u00ed handah\u00f3fskenndri r\u00f6\u00f0. Verkefni\u00f0 \u00feitt er a\u00f0 \u00e1kvar\u00f0a hvort h\u00e6gt s\u00e9 a\u00f0 f\u00e1 fylki \u00ed ekki-minnkandi r\u00f6\u00f0 me\u00f0 \u00fev\u00ed a\u00f0 framkv\u00e6ma eftirfarandi a\u00f0ger\u00f0 \u00e1 gefna fylkinu:\n    \u00de\u00fa m\u00e1tt framkv\u00e6ma h\u00e6gri f\u00e6rslu a\u00f0ger\u00f0 eins oft og \u00fe\u00fa vilt.\n\nEin h\u00e6gri f\u00e6rslu a\u00f0ger\u00f0 \u00fe\u00fd\u00f0ir a\u00f0 f\u00e6ra \u00f6ll st\u00f6k fylkisins um eina st\u00f6\u00f0u til h\u00e6gri. S\u00ed\u00f0asta staki\u00f0 \u00ed fylkinu ver\u00f0ur flutt \u00ed upphafsst\u00f6\u00f0u fylkisins, \u00fe.e. \u00e1 0. v\u00edsit\u00f6lu.\n\nEf h\u00e6gt er a\u00f0 f\u00e1 sortera\u00f0 fylki me\u00f0 \u00fev\u00ed a\u00f0 framkv\u00e6ma ofangreinda a\u00f0ger\u00f0, \u00fe\u00e1 skal skila True, annars False.\nEf gefna fylki\u00f0 er t\u00f3mt, \u00fe\u00e1 skal skila True.\n\nAthugi\u00f0: Gefna listanum er tryggt a\u00f0 hafa einst\u00f6k st\u00f6k.\n\nD\u00e6mi:\n\nmove_one_ball==>True\nSk\u00fdring: Me\u00f0 \u00fev\u00ed a\u00f0 framkv\u00e6ma 2 h\u00e6gri f\u00e6rslu a\u00f0ger\u00f0ir er h\u00e6gt a\u00f0 n\u00e1 ekki-minnkandi r\u00f6\u00f0 fyrir gefna fylki\u00f0.\nmove_one_ball==>False\nSk\u00fdring: \u00dea\u00f0 er ekki h\u00e6gt a\u00f0 f\u00e1 ekki-minnkandi r\u00f6\u00f0 fyrir gefna fylki\u00f0 me\u00f0 \u00fev\u00ed a\u00f0 framkv\u00e6ma einhverjar h\u00e6gri f\u00e6rslu a\u00f0ger\u00f0ir.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"\u00cd \u00feessu verkefni muntu \u00fatf\u00e6ra fall sem tekur tvo lista af t\u00f6lum, og \u00e1kvar\u00f0ar hvort h\u00e6gt s\u00e9 a\u00f0 skipta \u00fat st\u00f6kum \u00e1 milli \u00feeirra til a\u00f0 gera lst1 a\u00f0 lista me\u00f0 eing\u00f6ngu sl\u00e9ttum t\u00f6lum. \u00dea\u00f0 er engin takm\u00f6rkun \u00e1 fj\u00f6lda staka sem m\u00e1 skipta \u00e1 milli lst1 og lst2. Ef \u00fea\u00f0 er h\u00e6gt a\u00f0 skipta st\u00f6kum \u00e1 milli lst1 og lst2 til a\u00f0 gera \u00f6ll st\u00f6k lst1 sl\u00e9tt, skila\u00f0u \"J\u00c1\". Annars skila\u00f0u \"NEI\".\nTil d\u00e6mis:\nexchange => \"J\u00c1\"\nexchange => \"NEI\"\nGert er r\u00e1\u00f0 fyrir a\u00f0 inntakslistarnir ver\u00f0i ekki t\u00f3mir.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Mi\u00f0a\u00f0 vi\u00f0 streng sem t\u00e1knar bilskilin l\u00e1gstafir, skila\u00f0u or\u00f0ab\u00f3k af stafnum me\u00f0 flestum endurtekningum og samsvarandi fj\u00f6lda. Ef nokkrir stafir hafa s\u00f6mu t\u00ed\u00f0ni, skila\u00f0u \u00feeim \u00f6llum.\n\nD\u00e6mi:\nhistogram == {'a': 1, 'b': 1, 'c': 1}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'b': 4}\nhistogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Verkefni\n    Okkur eru gefnir tveir strengir s og c, \u00fe\u00fa \u00fearft a\u00f0 ey\u00f0a \u00f6llum st\u00f6fum \u00ed s sem eru jafnir einhverjum staf \u00ed c\n    og s\u00ed\u00f0an athuga hvort \u00fatkomustrengurinn s\u00e9 spegilmynd.\n    Strengur er kalla\u00f0ur spegilmynd ef hann les fram \u00e1 bak eins og aftur \u00e1 bak.\n    \u00de\u00fa \u00e6ttir a\u00f0 skila tv\u00edund sem inniheldur \u00fatkomustrenginn og True\/False fyrir athugunina.\n    D\u00e6mi\n    Fyrir s = \"abcde\", c = \"ae\", \u00e6tti \u00fatkoman a\u00f0 vera\n    Fyrir s = \"abcdef\", c = \"b\", \u00e6tti \u00fatkoman a\u00f0 vera\n    Fyrir s = \"abcdedcba\", c = \"ab\", \u00e6tti \u00fatkoman a\u00f0 vera\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Mi\u00f0a\u00f0 vi\u00f0 lista af strengjum, \u00fear sem hver strengur inniheldur a\u00f0eins t\u00f6lustafi, skila\u00f0u lista.\n    Hvert stak i \u00ed \u00fatkomulistanum \u00e6tti a\u00f0 vera \"fj\u00f6ldi oddatala \u00ed streng i \u00ed inntakinu,\" \u00fear sem allar i \u00e6ttu a\u00f0 vera skipt \u00fat fyrir fj\u00f6lda oddatala \u00ed i-ta strengnum \u00ed inntakinu.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Gefi\u00f0 fylki af heilt\u00f6lum nums, finndu l\u00e6gsta summu allra ekki-t\u00f3ma undirfylkja af nums.\nD\u00e6mi\nminSubArraySum == 1\nminSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    \u00de\u00fa f\u00e6r\u00f0 r\u00e9tthyrnt net af brunnum. Hver r\u00f6\u00f0 t\u00e1knar einn brunn,\nog hver 1 \u00ed r\u00f6\u00f0 t\u00e1knar eina einingu af vatni.\nHver brunnur hefur samsvarandi f\u00f6tu sem h\u00e6gt er a\u00f0 nota til a\u00f0 taka vatn \u00far honum,\nog allar f\u00f6tur hafa sama r\u00famtak.\nVerkefni\u00f0 \u00feitt er a\u00f0 nota f\u00f6tur til a\u00f0 t\u00e6ma brunnana.\nSkila\u00f0u fj\u00f6lda skipta sem \u00fe\u00fa \u00fearft a\u00f0 l\u00e6kka f\u00f6tur.\n\nD\u00e6mi 1:\n    Inntak: \n        net : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        f\u00f6tur\u00famtak : 1\n    \u00dattak: 6\n\nD\u00e6mi 2:\n    Inntak: \n        net : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        f\u00f6tur\u00famtak : 2\n    \u00dattak: 5\n\nD\u00e6mi 3:\n    Inntak: \n        net : [[0,0,0], [0,0,0]]\n        f\u00f6tur\u00famtak : 5\n    \u00dattak: 0\n\nTakmarkanir:\n    * allir brunnar eru jafn langir\n    * 1 <= net.lengd <= 10^2\n    * 1 <= net[:,1].lengd <= 10^2\n    * net[i][j] -> 0 | 1\n    * 1 <= r\u00famtak <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    \u00cd \u00feessari Kata \u00fearftu a\u00f0 ra\u00f0a fylki af j\u00e1kv\u00e6\u00f0um heilt\u00f6lum eftir fj\u00f6lda eininga \u00ed tv\u00edundarformi \u00feeirra \u00ed h\u00e6kkandi r\u00f6\u00f0. Fyrir sama fj\u00f6lda eininga, ra\u00f0a\u00f0u eftir tugagildi.\n\n\u00deetta ver\u00f0ur a\u00f0 vera \u00fatf\u00e6rt svona:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Gefi\u00f0 er strengjann s og n\u00e1tt\u00farulega t\u00f6lu n, \u00fe\u00fa hefur veri\u00f0 be\u00f0inn um a\u00f0 \u00fatf\u00e6ra \n    fall sem skilar lista af \u00f6llum or\u00f0um \u00far strengnum s sem innihalda n\u00e1kv\u00e6mlega \n    n samhlj\u00f3\u00f0a, \u00ed \u00feeirri r\u00f6\u00f0 sem \u00feessi or\u00f0 birtast \u00ed strengnum s.\n    Ef strengurinn s er t\u00f3mur \u00fe\u00e1 \u00e6tti falli\u00f0 a\u00f0 skila t\u00f3mum lista.\n    Athugi\u00f0: \u00fe\u00fa m\u00e1tt gera r\u00e1\u00f0 fyrir a\u00f0 strengurinn innihaldi a\u00f0eins stafi og bil.\n    D\u00e6mi:\n    select_words ==> [\"little\"]\n    select_words ==> [\"Mary\", \"lamb\"]\n    select_words ==> []\n    select_words ==> [\"world\"]\n    select_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"\u00de\u00fa f\u00e6r\u00f0 or\u00f0. Verkefni\u00f0 \u00feitt er a\u00f0 finna n\u00e1l\u00e6gasta s\u00e9rhlj\u00f3\u00f0i\u00f0 sem stendur \u00e1 milli \n    tveggja samhlj\u00f3\u00f0a fr\u00e1 h\u00e6gri hli\u00f0 or\u00f0sins.\n    \n    S\u00e9rhlj\u00f3\u00f0 \u00ed byrjun og enda teljast ekki me\u00f0. Skila\u00f0u t\u00f3mum streng ef \u00fe\u00fa finnur ekki \n    neitt s\u00e9rhlj\u00f3\u00f0 sem uppfyllir ofangreind skilyr\u00f0i. \n\n    \u00de\u00fa getur gert r\u00e1\u00f0 fyrir \u00fev\u00ed a\u00f0 gefni strengurinn innihaldi a\u00f0eins enskan staf.\n\n    D\u00e6mi:\n    get_closest_vowel ==> \"u\"\n    get_closest_vowel ==> \"U\"\n    get_closest_vowel ==> \"\"\n    get_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Mi\u00f0a\u00f0 vi\u00f0 fylki\u00f0 arr af heilt\u00f6lum og j\u00e1kv\u00e6\u00f0a heilt\u00f6lu k, skila\u00f0u ra\u00f0a\u00f0ri lista af lengd k me\u00f0 h\u00e6stu k t\u00f6lunum \u00ed arr.\n\nD\u00e6mi1:\n\n    Inntak: arr = [-3, -4, 5], k = 3\n    \u00dattak: [-4, -3, 5]\n\nD\u00e6mi2:\n\n    Inntak: arr = [4, -4, 4], k = 2\n    \u00dattak: [4, 4]\n\nD\u00e6mi3:\n\n    Inntak: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    \u00dattak: [2]\n\nAths:\n    1. Lengd fylkisins ver\u00f0ur \u00e1 bilinu [1, 1000].\n    2. St\u00f6k \u00ed fylkinu ver\u00f0a \u00e1 bilinu [-1000, 1000].\n    3. 0 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"\u00deegar gefinn er \u00f3t\u00f3mur listi af heilt\u00f6lum, skila\u00f0u summu allra oddatala sem eru \u00e1 j\u00f6fnum s\u00e6tum.\n\nD\u00e6mi:\nsolution ==> 12\nsolution ==> 9\nsolution ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Gefin er ekki t\u00f3m talnalisti arr og heiltala k, skila\u00f0u summu staka me\u00f0 a\u00f0 h\u00e1marki tveggja t\u00f6lustafa \u00far fyrstu k st\u00f6kum arr.\n\nD\u00e6mi:\n\n    Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Output: 24 # summa 21 + 3\n\nTakmarkanir:\n    1. 1 <= lengd <= 100\n    2. 1 <= k <= lengd\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Gefi\u00f0 j\u00e1kv\u00e6\u00f0a heilt\u00f6lu n, skila\u00f0u ra\u00f0a\u00f0ri lista sem inniheldur oddat\u00f6lurnar \u00ed Collatz-r\u00f6\u00f0inni.\n\n    Collatz-tilg\u00e1tan er tilg\u00e1ta \u00ed st\u00e6r\u00f0fr\u00e6\u00f0i sem fjallar um r\u00f6\u00f0 sem er skilgreind \u00e1 eftirfarandi h\u00e1tt: byrja\u00f0u \u00e1 hva\u00f0a j\u00e1kv\u00e6\u00f0u heilt\u00f6lu n sem er. \u00de\u00e1 er hvert skilyr\u00f0i fengi\u00f0 fr\u00e1 fyrra skilyr\u00f0i sem h\u00e9r segir: ef fyrra skilyr\u00f0i er sl\u00e9tt tala, er n\u00e6sta skilyr\u00f0i helmingur fyrra skilyr\u00f0is. Ef fyrra skilyr\u00f0i er oddatala, er n\u00e6sta skilyr\u00f0i 3 sinnum fyrra skilyr\u00f0i pl\u00fas 1. Tilg\u00e1tan er s\u00fa a\u00f0 sama hva\u00f0a gildi n hefur, \u00fe\u00e1 mun r\u00f6\u00f0in alltaf n\u00e1 t\u00f6lunni 1.\n\n    Athugi\u00f0: \n        1. Collatz er [1].\n        2. skila\u00f0ur listi ra\u00f0a\u00f0ur \u00ed h\u00e6kkandi r\u00f6\u00f0.\n\n    Til d\u00e6mis:\n    get_odd_collatz skilar [1, 5] # Collatz-r\u00f6\u00f0in fyrir 5 er [5, 16, 8, 4, 2, 1], svo oddat\u00f6lurnar eru a\u00f0eins 1 og 5.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"\u00de\u00fa \u00fearft a\u00f0 skrifa fall sem sta\u00f0festir gefi\u00f0 dagsetningarstreng og skilar True ef dagsetningin er gild, annars False.\nDagsetningin er gild ef \u00f6ll eftirfarandi skilyr\u00f0i eru uppfyllt:\n1. Dagsetningarstrengurinn er ekki t\u00f3mur.\n2. Fj\u00f6ldi daga er ekki minni en 1 e\u00f0a meiri en 31 fyrir m\u00e1nu\u00f0ina 1, 3, 5, 7, 8, 10, 12. Og fj\u00f6ldi daga er ekki minni en 1 e\u00f0a meiri en 30 fyrir m\u00e1nu\u00f0ina 4, 6, 9, 11. Og fj\u00f6ldi daga er ekki minni en 1 e\u00f0a meiri en 29 fyrir m\u00e1nu\u00f0inn 2.\n3. M\u00e1nu\u00f0irnir \u00e6ttu ekki a\u00f0 vera minni en 1 e\u00f0a meiri en 12.\n4. Dagsetningin \u00e6tti a\u00f0 vera \u00ed \u00feessu formi: mm-dd-yyyy\n\ntil d\u00e6mis:\nvalid_date => True\n\nvalid_date => False\n\nvalid_date => False\n\nvalid_date => True\n\nvalid_date => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"\u00de\u00fa f\u00e6r\u00f0 tv\u00f6 t\u00edmabil, \u00fear sem hvert t\u00edmabil er par heiltalna. Til d\u00e6mis, t\u00edmabil = =. Gefnu t\u00edmabilin eru loku\u00f0 sem \u00fe\u00fd\u00f0ir a\u00f0 t\u00edmabili\u00f0 inniheldur b\u00e6\u00f0i byrjun og endi. Fyrir hvert gefi\u00f0 t\u00edmabil er gert r\u00e1\u00f0 fyrir a\u00f0 byrjun \u00feess s\u00e9 minni e\u00f0a j\u00f6fn endi \u00feess. Verkefni\u00f0 \u00feitt er a\u00f0 \u00e1kvar\u00f0a hvort lengd sk\u00f6runar \u00feessara tveggja t\u00edmabila s\u00e9 frumtala. Til d\u00e6mis, sk\u00f6run t\u00edmabilanna og er sem hefur lengdina 1, sem er ekki frumtala. Ef lengd sk\u00f6runarinnar er frumtala, skila \"J\u00c1\", annars skila \"NEI\". Ef t\u00edmabilin skarast ekki, skila \"NEI\".\n\n[input\/output] d\u00e6mi:\nsk\u00f6run,) ==> \"NEI\"\nsk\u00f6run,) ==> \"NEI\"\nsk\u00f6run,) ==> \"J\u00c1\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    \u00de\u00fa f\u00e6r\u00f0 fylki arr af heilt\u00f6lum og \u00fe\u00fa \u00fearft a\u00f0 skila summu st\u00e6r\u00f0a heiltalna margfalda\u00f0 me\u00f0 margfeldi allra merkja hverrar t\u00f6lu \u00ed fylkinu, t\u00e1kna\u00f0 me\u00f0 1, -1 e\u00f0a 0. Athugi\u00f0: skila\u00f0u None fyrir t\u00f3mt fylki.\n\nD\u00e6mi:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Gefi\u00f0 er net me\u00f0 N r\u00f6\u00f0um og N d\u00e1lkum og j\u00e1kv\u00e6\u00f0ri heilt\u00f6lu k, \n    inniheldur hver reitur netsins gildi. S\u00e9rhver heiltala \u00e1 bilinu [1, N * N]\n    kemur n\u00e1kv\u00e6mlega einu sinni fyrir \u00ed reitunum \u00e1 netinu.\n\n    \u00de\u00fa \u00fearft a\u00f0 finna l\u00e1gmarkslei\u00f0 af lengd k \u00ed netinu. \u00de\u00fa getur byrja\u00f0 \n    \u00far hva\u00f0a reit sem er, og \u00ed hverju skrefi getur \u00fe\u00fa fari\u00f0 \u00ed hva\u00f0a n\u00e1grannareit sem er,\n    me\u00f0 \u00f6\u00f0rum or\u00f0um, \u00fe\u00fa getur fari\u00f0 \u00ed reiti sem deila br\u00fan me\u00f0 n\u00faverandi reit.\n    Vinsamlegast athugi\u00f0 a\u00f0 lei\u00f0 af lengd k merkir a\u00f0 heims\u00e6kja n\u00e1kv\u00e6mlega k reiti (ekki\n    endilega \u00f3l\u00edka).\n    \u00de\u00fa M\u00c1TT EKKI fara \u00fat fyrir neti\u00f0.\n    Lei\u00f0 A er talin minni en lei\u00f0 B ef \n    eftir a\u00f0 gera r\u00f6\u00f0unarlista af gildunum \u00e1 reitunum sem A og B fara \u00ed gegnum, er lst_A or\u00f0ab\u00f3karlega minni en lst_B, me\u00f0 \u00f6\u00f0rum or\u00f0um, \u00fea\u00f0 er til heilt\u00f6luskilgreiningarv\u00edsir i\n    \u00feannig a\u00f0 lst_A[i] < lst_B[i] og fyrir hva\u00f0a j h\u00f6fum vi\u00f0\n    lst_A[j] = lst_B[j].\n    \u00dea\u00f0 er tryggt a\u00f0 svari\u00f0 er einstakt.\n    Skila\u00f0u r\u00f6\u00f0u\u00f0um lista af gildunum \u00e1 reitunum sem l\u00e1gmarkslei\u00f0in fer \u00ed gegnum.\n\n    D\u00e6mi:\n\n        Inntak: net = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        \u00dattak: [1, 2, 1]\n\n        Inntak: net = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        \u00dattak: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Allir \u00feekkja Fibonacci-r\u00f6\u00f0ina, h\u00fan hefur veri\u00f0 ranns\u00f6ku\u00f0 \u00edtarlega af st\u00e6r\u00f0fr\u00e6\u00f0ingum s\u00ed\u00f0ustu aldir. Hins vegar vita ekki allir um Tribonacci-r\u00f6\u00f0ina. Tribonacci-r\u00f6\u00f0in er skilgreind me\u00f0 endurkv\u00e6mni:\ntri = 3\ntri = 1 + n \/ 2, ef n er sl\u00e9tt tala.\ntri =  tri + tri + tri, ef n er oddatala.\nTil d\u00e6mis:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n       = 2 + 3 + 3 = 8 \n\u00de\u00e9r er gefin \u00f3neikv\u00e6\u00f0 heiltala n, og \u00fe\u00fa \u00e1tt a\u00f0 skila lista af fyrstu n + 1 t\u00f6lunum \u00ed Tribonacci-r\u00f6\u00f0inni.\nD\u00e6mi:\ntri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Gefi\u00f0 j\u00e1kv\u00e6\u00f0a heilt\u00f6lu n, skila\u00f0u margfeldi oddat\u00f6lustafa.\n    Skila\u00f0u 0 ef allir stafirnir eru sl\u00e9ttir.\n    Til d\u00e6mis:\n    t\u00f6lur  == 1\n    t\u00f6lur  == 0\n    t\u00f6lur == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"\u00de\u00fa f\u00e6r\u00f0 lista af t\u00f6lum.\n    \u00de\u00fa \u00fearft a\u00f0 skila summunni af t\u00f6lum \u00ed listanum, \u00fear sem hver tala er h\u00e6kku\u00f0 \u00ed anna\u00f0 veldi,\n    en fyrst skal runda hverja t\u00f6lu \u00ed listanum upp \u00e1 n\u00e6stu heilu t\u00f6lu.\n    D\u00e6mi:\n    Fyrir lst = [1,2,3] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 14\n    Fyrir lst = [1,4,9] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 98\n    Fyrir lst = [1,3,5,7] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 84\n    Fyrir lst = [1.4,4.2,0] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 29\n    Fyrir lst = [-2.4,1,1] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"B\u00fa\u00f0u til fall sem skilar st\u00e6rsta v\u00edsit\u00f6lu staks sem er ekki st\u00e6rra en e\u00f0a jafnt stakinu sem er strax \u00e1 undan \u00fev\u00ed. Ef ekkert sl\u00edkt stak er til, skilar falli\u00f0 -1. Gefna fylki\u00f0 mun ekki innihalda tv\u00edtekin gildi.\n\nD\u00e6mi:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    B\u00fa\u00f0u til fall sem tekur heilt\u00f6lur, kommut\u00f6lur e\u00f0a strengi sem t\u00e1kna raunverulegar t\u00f6lur og skilar st\u00e6rri breytunni \u00ed gefnu breytutegundinni. Skila\u00f0u None ef gildin eru j\u00f6fn.\nAthugi\u00f0: Ef raunveruleg tala er t\u00e1knu\u00f0 sem strengur, g\u00e6ti kommut\u00e1kni\u00f0 veri\u00f0 . e\u00f0a ,\n\ncompare_one -> 2.5\ncompare_one -> \"2,3\"\ncompare_one -> \"6\"\ncompare_one -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Meti\u00f0 hvort h\u00e6gt s\u00e9 a\u00f0 skrifa tiltekna t\u00f6lu n sem summu n\u00e1kv\u00e6mlega 4 j\u00e1kv\u00e6\u00f0ra jafngilda talna.\n    D\u00e6mi\n    is_equal_to_sum_even == \u00d3satt\n    is_equal_to_sum_even == \u00d3satt\n    is_equal_to_sum_even == Satt\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Brasil\u00edskur hr\u00f3pmerktisstu\u00f0ull er skilgreindur sem:\n    brasil\u00edskur_hr\u00f3pmerktisstu\u00f0ull = n! *! *! * ... * 1!\n    \u00fear sem n > 0\n\n    Til d\u00e6mis:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Gefi\u00f0 strenginn texti, skipti\u00f0 \u00f6llum bilum \u00ed honum \u00fat fyrir undirstrik, \n    og ef strengurinn hefur meira en 2 samfelld bil, \n    skipti\u00f0 \u00fe\u00e1 \u00f6llum samfelldum bilum \u00fat fyrir - \n    \n    fix_spaces == \"D\u00e6mi\"\n    fix_spaces == \"D\u00e6mi_1\"\n    fix_spaces == \"_D\u00e6mi_2\"\n    fix_spaces == \"_D\u00e6mi-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"B\u00fa\u00f0u til fall sem tekur streng sem t\u00e1knar skr\u00e1arnafn og skilar 'J\u00e1' ef skr\u00e1arnafni\u00f0 er gilt, og skilar 'Nei' annars.\nSkr\u00e1arnafn er tali\u00f0 gilt ef og a\u00f0eins ef \u00f6ll eftirfarandi skilyr\u00f0i eru uppfyllt:\n- \u00dea\u00f0 mega ekki vera fleiri en \u00fer\u00edr t\u00f6lustafir \u00ed skr\u00e1arnafninu.\n- Skr\u00e1arnafni\u00f0 inniheldur n\u00e1kv\u00e6mlega einn punkt '.'\n- Undirstrengurinn fyrir punktinn m\u00e1 ekki vera t\u00f3mur og hann byrjar \u00e1 b\u00f3kstaf \u00far latneska stafr\u00f3finu.\n- Undirstrengurinn eftir punktinn skal vera einn af \u00feessum: ['txt', 'exe', 'dll']\nD\u00e6mi:\nfile_name_check # => 'J\u00e1'\nfile_name_check # => 'Nei'\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\u00deessi fall mun taka lista af heilt\u00f6lum. Fyrir \u00f6ll st\u00f6k \u00ed listanum mun falli\u00f0 setja heilt\u00f6lustaki\u00f0 \u00ed anna\u00f0 veldi ef v\u00edsitala \u00feess er margfeldi af 3 og mun setja heilt\u00f6lustaki\u00f0 \u00ed \u00feri\u00f0ja veldi ef v\u00edsitala \u00feess er margfeldi af 4 og ekki margfeldi af 3. Falli\u00f0 mun ekki breyta st\u00f6kum \u00ed listanum \u00fear sem v\u00edsit\u00f6lur \u00feeirra eru ekki margfeldi af 3 e\u00f0a 4. Falli\u00f0 mun s\u00ed\u00f0an skila summu allra staka.\n\nD\u00e6mi:\nFyrir lst = [1,2,3] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 6\nFyrir lst = [] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera 0\nFyrir lst = [-1,-5,2,-1,-5] \u00e6tti \u00fattaki\u00f0 a\u00f0 vera -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    \u00de\u00fa f\u00e6r\u00f0 streng sem t\u00e1knar setningu,\n    setningin inniheldur nokkur or\u00f0 a\u00f0skilin me\u00f0 bili,\n    og \u00fe\u00fa \u00fearft a\u00f0 skila streng sem inniheldur or\u00f0in \u00far upprunalegu setningunni,\n    \u00fear sem lengd or\u00f0anna eru pr\u00edmt\u00f6lur,\n    r\u00f6\u00f0 or\u00f0anna \u00ed n\u00fdja strengnum \u00e6tti a\u00f0 vera s\u00fa sama og \u00ed upprunalegu setningunni.\n\n    D\u00e6mi1:\n        Inntak: setning = \"This is a test\"\n        \u00dattak: \"is\"\n\n    D\u00e6mi2:\n        Inntak: setning = \"lets go for swimming\"\n        \u00dattak: \"go for\"\n\n    Takmarkanir:\n        * 1 <= lengd <= 100\n        * setningin inniheldur a\u00f0eins b\u00f3kstafi\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Verkefni\u00f0 \u00feitt er a\u00f0 \u00fatf\u00e6ra fall sem einfaldar tj\u00e1ninguna x * n. Falli\u00f0 skilar True ef x * n reiknast sem heiltala og False annars. B\u00e6\u00f0i x og n eru strengjaframsetningar \u00e1 brotum og hafa eftirfarandi sni\u00f0, <t\u00f6lur>\/<nefnari> \u00fear sem b\u00e6\u00f0i t\u00f6lur og nefnari eru j\u00e1kv\u00e6\u00f0ar heilt\u00f6lur.\n\n\u00de\u00fa getur gert r\u00e1\u00f0 fyrir a\u00f0 x og n s\u00e9u gild brot og hafi ekki n\u00fall sem nefnara.\n\nsimplify = True\nsimplify = False\nsimplify = False\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Skrifa\u00f0u fall sem ra\u00f0ar gefnum lista af heilt\u00f6lum \u00ed h\u00e6kkandi r\u00f6\u00f0 mi\u00f0a\u00f0 vi\u00f0 summu t\u00f6lustafa \u00feeirra. Athugi\u00f0: ef \u00fea\u00f0 eru nokkrir hlutir me\u00f0 s\u00f6mu summu t\u00f6lustafa, ra\u00f0a\u00f0u \u00feeim eftir v\u00edsit\u00f6lu \u00feeirra \u00ed upprunalega listanum.\n\nTil d\u00e6mis:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Skrifa\u00f0u fall sem tekur fylki af t\u00f6lum sem inntak og skilar fj\u00f6lda staka \u00ed fylkinu sem eru meiri en 10 og b\u00e6\u00f0i fyrsta og s\u00ed\u00f0asta t\u00f6lustafur t\u00f6lunnar eru oddat\u00f6lur.\nTil d\u00e6mis:\nspecialFilter => 1\nspecialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    \u00de\u00fa f\u00e6r\u00f0 j\u00e1kv\u00e6\u00f0a heilt\u00f6lu n. \u00de\u00fa \u00fearft a\u00f0 b\u00faa til heilt\u00f6lu fylki a af lengd n.\n    Fyrir hvert i er gildi\u00f0 \u00e1 a[i] = i * i - i + 1.\n    Skila\u00f0u fj\u00f6lda \u00ferennda \u00far a \u00fear sem i < j < k, \n    og a[i] + a[j] + a[k] er margfeldi af 3.\n\n    D\u00e6mi:\n        Inntak: n = 5\n        \u00dattak: 1\n        Sk\u00fdring: \n        a = [1, 3, 7, 13, 21]\n        Eina gildan \u00ferenndin er.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Skrifa\u00f0u fall sem tekur vi\u00f0 lista af strengjum sem f\u00e6ribreytu,\n    ey\u00f0ir strengjunum sem hafa staka lengd \u00far honum,\n    og skilar lista me\u00f0 ni\u00f0urst\u00f6\u00f0unni \u00ed ra\u00f0a\u00f0ri r\u00f6\u00f0.\n    Listinn er alltaf listi af strengjum og aldrei fylki af t\u00f6lum,\n    og hann getur innihaldi\u00f0 afrit.\n    R\u00f6\u00f0 listans \u00e6tti a\u00f0 vera \u00ed vaxandi r\u00f6\u00f0 eftir lengd hvers or\u00f0s, og \u00fe\u00fa\n    \u00e6ttir a\u00f0 skila listanum ra\u00f0a\u00f0 eftir \u00feeirri reglu.\n    Ef tv\u00f6 or\u00f0 hafa sama lengd, ra\u00f0a\u00f0u listanum \u00ed stafr\u00f3fsr\u00f6\u00f0.\n    Falli\u00f0 \u00e6tti a\u00f0 skila lista af strengjum \u00ed ra\u00f0a\u00f0ri r\u00f6\u00f0.\n    \u00de\u00fa getur gert r\u00e1\u00f0 fyrir a\u00f0 \u00f6ll or\u00f0 hafi s\u00f6mu lengd.\n    Til d\u00e6mis:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Einfalt forrit sem \u00e6tti a\u00f0 skila gildinu x ef n er frumtala og \u00e6tti a\u00f0 skila gildinu y annars.\n\nD\u00e6mi:\nfyrir x_or_y == 34\nfyrir x_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"\u00c9g held a\u00f0 vi\u00f0 munum \u00f6ll eftir \u00feeirri tilfinningu \u00feegar ni\u00f0ursta\u00f0a einhvers atbur\u00f0ar, sem vi\u00f0 h\u00f6fum be\u00f0i\u00f0 lengi eftir, er loksins or\u00f0in lj\u00f3s. Tilfinningarnar og hugmyndirnar sem \u00fe\u00fa hefur \u00e1 \u00fev\u00ed augnabliki eru kl\u00e1rlega \u00feess vir\u00f0i a\u00f0 skr\u00e1 ni\u00f0ur og bera saman. Verkefni\u00f0 \u00feitt er a\u00f0 \u00e1kvar\u00f0a hvort einstaklingur hafi giska\u00f0 r\u00e9tt \u00e1 ni\u00f0urst\u00f6\u00f0ur fj\u00f6lda leikja. \u00de\u00e9r eru gefnar tv\u00e6r fylki me\u00f0 stigum og giskum af s\u00f6mu lengd, \u00fear sem hver v\u00edsir s\u00fdnir einn leik. Skila\u00f0u fylki af s\u00f6mu lengd sem s\u00fdnir hversu langt hvert gisk var fr\u00e1 r\u00e9ttri ni\u00f0urst\u00f6\u00f0u. Ef \u00feeir hafa giska\u00f0 r\u00e9tt er gildi\u00f0 0, og ef ekki, er gildi\u00f0 algildur munur \u00e1 milli giskisins og stiganna.\n\nD\u00e6mi:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"\u00de\u00e9r ver\u00f0ur gefi\u00f0 nafn \u00e1 klasa og lista af vi\u00f0b\u00f3tum.\n    Vi\u00f0b\u00e6turnar eru nota\u00f0ar til a\u00f0 hla\u00f0a fleiri kl\u00f6sum \u00ed klasann. Styrkleiki vi\u00f0b\u00f3tarinnar er eftirfarandi: L\u00e1tum CAP vera fj\u00f6lda h\u00e1stafa \u00ed nafni vi\u00f0b\u00f3tarinnar, og l\u00e1tum SM vera fj\u00f6lda l\u00e1gstafa \u00ed nafni vi\u00f0b\u00f3tarinnar. Styrkleikinn er gefinn me\u00f0 hlutfallinu CAP - SM.\n    \u00de\u00fa \u00e6ttir a\u00f0 finna sterkustu vi\u00f0b\u00f3tina og skila streng \u00ed \u00feessu formi: ClassName.StrongestExtensionName.\n    Ef \u00fea\u00f0 eru tv\u00e6r e\u00f0a fleiri vi\u00f0b\u00e6tur me\u00f0 sama styrkleika, \u00e6ttir \u00fe\u00fa a\u00f0 velja \u00fe\u00e1 sem kemur fyrst \u00ed listanum.\n    Til d\u00e6mis, ef \u00fe\u00fa f\u00e6r\u00f0 \"Slices\" sem klasa og lista af vi\u00f0b\u00f3tum: ['SErviNGSliCes', 'Cheese', 'StuFfed'] \u00fe\u00e1 \u00e6ttir \u00fe\u00fa a\u00f0 skila 'Slices.SErviNGSliCes' \u00fev\u00ed 'SErviNGSliCes' er sterkasta vi\u00f0b\u00f3tin.\n    D\u00e6mi:\n    fyrir Strongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"\u00de\u00fa f\u00e6r\u00f0 2 or\u00f0. \u00de\u00fa \u00fearft a\u00f0 skila True ef anna\u00f0 or\u00f0i\u00f0 e\u00f0a einhverjar sn\u00faningar \u00feess eru undirstrengur \u00ed fyrsta or\u00f0inu.\n    cycpattern_check => False\n    cycpattern_check => True\n    cycpattern_check => False\n    cycpattern_check => True\n    cycpattern_check => False\n    cycpattern_check => True\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Gefi\u00f0 heilt\u00f6lu. Skila\u00f0u tv\u00edund sem hefur fj\u00f6lda sl\u00e9ttra og oddat\u00f6lustafa \u00ed s\u00f6mu r\u00f6\u00f0.\n\n     D\u00e6mi:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Gefi\u00f0 j\u00e1kv\u00e6\u00f0a heilt\u00f6lu, f\u00e1i\u00f0 r\u00f3mverska t\u00f6lu jafngildi hennar sem streng,\n    og skila\u00f0u \u00fev\u00ed \u00ed l\u00e1gst\u00f6fum.\n    Takmarkanir: 1 <= tala <= 1000\n\n    D\u00e6mi:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Skrifa\u00f0u fall sem tekur vi\u00f0 lista af strengjum.\n    Listinn inniheldur mismunandi or\u00f0. Skila\u00f0u or\u00f0inu me\u00f0 flestum einst\u00f6kum\n    st\u00f6fum. Ef m\u00f6rg or\u00f0 hafa jafnmarga einstaka stafi, skila\u00f0u \u00fev\u00ed sem kemur\n    fyrst \u00ed or\u00f0ab\u00f3kar\u00f6\u00f0.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    \u00de\u00fa ert svangur kan\u00edna og \u00fe\u00fa hefur \u00feegar bor\u00f0a\u00f0 \u00e1kve\u00f0inn fj\u00f6lda gulr\u00f3ta,\n    en n\u00fa \u00fearftu a\u00f0 bor\u00f0a fleiri gulr\u00e6tur til a\u00f0 kl\u00e1ra m\u00e1lt\u00ed\u00f0ir dagsins.\n    \u00de\u00fa \u00e6ttir a\u00f0 skila fylki af [ heildarfj\u00f6lda bor\u00f0a\u00f0ra gulr\u00f3ta eftir m\u00e1lt\u00ed\u00f0irnar,\n                                    fj\u00f6lda gulr\u00f3ta sem eftir eru eftir m\u00e1lt\u00ed\u00f0irnar ]\n    ef \u00fea\u00f0 eru ekki n\u00e6gar gulr\u00e6tur eftir, munt \u00fe\u00fa bor\u00f0a allar \u00fe\u00e6r sem eru eftir, en munt samt vera svangur.\n    \n    D\u00e6mi:\n    * bor\u00f0a -> [11, 4]\n    * bor\u00f0a -> [12, 1]\n    * bor\u00f0a -> [11, 0]\n    * bor\u00f0a -> [7, 0]\n    \n    Breytur:\n    @number : heiltala\n        fj\u00f6ldi gulr\u00f3ta sem \u00fe\u00fa hefur bor\u00f0a\u00f0.\n    @need : heiltala\n        fj\u00f6ldi gulr\u00f3ta sem \u00fe\u00fa \u00fearft a\u00f0 bor\u00f0a.\n    @remaining : heiltala\n        fj\u00f6ldi gulr\u00f3ta sem eftir eru \u00e1 lager\n    \n    Takmarkanir:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    G\u00f3\u00f0a skemmtun :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Mi\u00f0a\u00f0 vi\u00f0 tv\u00e6r lista, rekstrara\u00f0ila og rekstrar\u00fe\u00e1tt. Fyrri listinn hefur grundvallar algebrua\u00f0ger\u00f0ir, og \n    seinni listinn er listi af heilt\u00f6lum. Nota\u00f0u \u00feessa tvo lista til a\u00f0 b\u00faa til algebrulegt \n    tj\u00e1ningu og skila\u00f0u mati \u00e1 \u00feessari tj\u00e1ningu.\n\n    Grundvallar algebrua\u00f0ger\u00f0irnar:\n    Samlagning \n    Fr\u00e1dr\u00e1ttur \n    Margf\u00f6ldun \n    Heildar deiling \n    Veldisv\u00edsun \n\n    D\u00e6mi:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    ni\u00f0ursta\u00f0a = 2 + 3 * 4 - 5\n    => ni\u00f0ursta\u00f0a = 9\n\n    Athugi\u00f0:\n        Lengd rekstrara\u00f0ilalista er j\u00f6fn lengd rekstrar\u00fe\u00e1ttalista m\u00ednus einn.\n        Rekstrar\u00fe\u00e1ttalisti er listi af \u00f3neikv\u00e6\u00f0um heilt\u00f6lum.\n        Rekstrara\u00f0ilalisti hefur a\u00f0 minnsta kosti einn rekstrara\u00f0ila, og rekstrar\u00fe\u00e1ttalisti hefur a\u00f0 minnsta kosti tvo rekstrar\u00fe\u00e6tti.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"\u00de\u00fa f\u00e6r\u00f0 streng s.\n    Ef s[i] er b\u00f3kstafur, breyttu \u00fe\u00e1 um h\u00e1staf e\u00f0a l\u00e1gstaf,\n    annars haltu \u00fev\u00ed eins og \u00fea\u00f0 er.\n    Ef strengurinn inniheldur enga b\u00f3kstafi, sn\u00fa\u00f0u strengnum vi\u00f0.\n    Falli\u00f0 \u00e6tti a\u00f0 skila breyttum streng.\n    D\u00e6mi:\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Gefi\u00f0 strenginn 'texti', skili\u00f0 md5 hash samsvarandi streng.\n    Ef 'texti' er t\u00f3mur strengur, skili\u00f0 None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Gefnar tv\u00e6r j\u00e1kv\u00e6\u00f0ar heilt\u00f6lur a og b, skila\u00f0u j\u00f6fnum t\u00f6lum \u00e1 milli a og b, \u00ed h\u00e6kkandi r\u00f6\u00f0.\n\nTil d\u00e6mis:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]