[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ki\u1ec3m tra xem trong danh s\u00e1ch c\u00e1c s\u1ed1 \u0111\u00e3 cho, c\u00f3 hai s\u1ed1 n\u00e0o g\u1ea7n nhau h\u01a1n ng\u01b0\u1ee1ng \u0111\u00e3 cho hay kh\u00f4ng.\nV\u00ed d\u1ee5:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" \u0110\u1ea7u v\u00e0o c\u1ee7a h\u00e0m n\u00e0y l\u00e0 m\u1ed9t chu\u1ed7i ch\u1ee9a nhi\u1ec1u nh\u00f3m d\u1ea5u ngo\u1eb7c \u0111\u01a1n l\u1ed3ng nhau. M\u1ee5c ti\u00eau c\u1ee7a b\u1ea1n l\u00e0\n    t\u00e1ch c\u00e1c nh\u00f3m \u0111\u00f3 th\u00e0nh c\u00e1c chu\u1ed7i ri\u00eang bi\u1ec7t v\u00e0 tr\u1ea3 v\u1ec1 danh s\u00e1ch c\u00e1c chu\u1ed7i \u0111\u00f3.\n    C\u00e1c nh\u00f3m ri\u00eang bi\u1ec7t l\u00e0 c\u00e2n b\u1eb1ng v\u00e0 kh\u00f4ng l\u1ed3ng v\u00e0o nhau.\n    B\u1ecf qua b\u1ea5t k\u1ef3 kho\u1ea3ng tr\u1eafng n\u00e0o trong chu\u1ed7i \u0111\u1ea7u v\u00e0o.\n    V\u00ed d\u1ee5:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Cho m\u1ed9t s\u1ed1 th\u1eadp ph\u00e2n d\u01b0\u01a1ng, n\u00f3 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c ph\u00e2n t\u00edch th\u00e0nh ph\u1ea7n nguy\u00ean v\u00e0 ph\u1ea7n th\u1eadp ph\u00e2n.\n\nTr\u1ea3 v\u1ec1 ph\u1ea7n th\u1eadp ph\u00e2n c\u1ee7a s\u1ed1 \u0111\u00f3.\nV\u00ed d\u1ee5:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t danh s\u00e1ch c\u00e1c giao d\u1ecbch n\u1ea1p ti\u1ec1n v\u00e0 r\u00fat ti\u1ec1n tr\u00ean m\u1ed9t t\u00e0i kho\u1ea3n ng\u00e2n h\u00e0ng b\u1eaft \u0111\u1ea7u v\u1edbi s\u1ed1 d\u01b0 b\u1eb1ng kh\u00f4ng. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 ph\u00e1t hi\u1ec7n xem li\u1ec7u v\u00e0o b\u1ea5t k\u1ef3 th\u1eddi \u0111i\u1ec3m n\u00e0o s\u1ed1 d\u01b0 t\u00e0i kho\u1ea3n c\u00f3 gi\u1ea3m xu\u1ed1ng d\u01b0\u1edbi kh\u00f4ng hay kh\u00f4ng, v\u00e0 t\u1ea1i th\u1eddi \u0111i\u1ec3m \u0111\u00f3 h\u00e0m n\u00ean tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb True. Ng\u01b0\u1ee3c l\u1ea1i, n\u00f3 n\u00ean tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb False.\n    V\u00ed d\u1ee5:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \u0110\u1ed1i v\u1edbi m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 \u0111\u1ea7u v\u00e0o cho tr\u01b0\u1edbc, t\u00ednh \u0110\u1ed9 l\u1ec7ch tuy\u1ec7t \u0111\u1ed1i trung b\u00ecnh xung quanh gi\u00e1 tr\u1ecb trung b\u00ecnh c\u1ee7a t\u1eadp d\u1eef li\u1ec7u n\u00e0y.\n\u0110\u1ed9 l\u1ec7ch tuy\u1ec7t \u0111\u1ed1i trung b\u00ecnh l\u00e0 trung b\u00ecnh c\u1ee7a c\u00e1c gi\u00e1 tr\u1ecb tuy\u1ec7t \u0111\u1ed1i ch\u00eanh l\u1ec7ch gi\u1eefa m\u1ed7i ph\u1ea7n t\u1eed v\u00e0 m\u1ed9t \u0111i\u1ec3m trung t\u00e2m:\nMAD = trung b\u00ecnh | x - x_mean |\nV\u00ed d\u1ee5:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Ch\u00e8n m\u1ed9t 'k\u00fd t\u1ef1 ph\u00e2n c\u00e1ch' gi\u1eefa m\u1ed7i hai ph\u1ea7n t\u1eed li\u00ean ti\u1ebfp c\u1ee7a danh s\u00e1ch \u0111\u1ea7u v\u00e0o `numbers`.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" \u0110\u1ea7u v\u00e0o cho h\u00e0m n\u00e0y l\u00e0 m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho nhi\u1ec1u nh\u00f3m ngo\u1eb7c \u0111\u01a1n l\u1ed3ng nhau, \u0111\u01b0\u1ee3c ng\u0103n c\u00e1ch b\u1edfi d\u1ea5u c\u00e1ch.\n    \u0110\u1ed1i v\u1edbi m\u1ed7i nh\u00f3m, xu\u1ea5t ra m\u1ee9c \u0111\u1ed9 l\u1ed3ng s\u00e2u nh\u1ea5t c\u1ee7a ngo\u1eb7c \u0111\u01a1n.\n    V\u00ed d\u1ee5:) c\u00f3 m\u1ee9c \u0111\u1ed9 l\u1ed3ng t\u1ed1i \u0111a l\u00e0 hai trong khi)) c\u00f3 m\u1ee9c \u0111\u1ed9 l\u1ed3ng l\u00e0 ba.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" L\u1ecdc m\u1ed9t danh s\u00e1ch \u0111\u1ea7u v\u00e0o c\u00e1c chu\u1ed7i ch\u1ec9 \u0111\u1ec3 l\u1ea5y nh\u1eefng chu\u1ed7i c\u00f3 ch\u1ee9a chu\u1ed7i con \u0111\u00e3 cho.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" \u0110\u1ed1i v\u1edbi m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean cho tr\u01b0\u1edbc, h\u00e3y tr\u1ea3 v\u1ec1 m\u1ed9t b\u1ed9 g\u1ed3m t\u1ed5ng v\u00e0 t\u00edch c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c s\u1ed1 nguy\u00ean trong danh s\u00e1ch.\n    T\u1ed5ng c\u1ee7a danh s\u00e1ch r\u1ed7ng n\u00ean b\u1eb1ng 0 v\u00e0 t\u00edch c\u1ee7a danh s\u00e1ch r\u1ed7ng n\u00ean b\u1eb1ng 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" T\u1eeb m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean cho tr\u01b0\u1edbc, t\u1ea1o ra m\u1ed9t danh s\u00e1ch c\u00e1c ph\u1ea7n t\u1eed l\u1edbn nh\u1ea5t li\u00ean ti\u1ebfp \u0111\u01b0\u1ee3c t\u00ecm th\u1ea5y cho \u0111\u1ebfn th\u1eddi \u0111i\u1ec3m \u0111\u00e3 cho trong chu\u1ed7i.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Ki\u1ec3m tra xem chu\u1ed7i \u0111\u00e3 cho c\u00f3 ph\u1ea3i l\u00e0 chu\u1ed7i \u0111\u1ed1i x\u1ee9ng kh\u00f4ng \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" \u0110\u1ea7u v\u00e0o l\u00e0 hai chu\u1ed7i a v\u00e0 b ch\u1ec9 bao g\u1ed3m c\u00e1c k\u00fd t\u1ef1 1 v\u00e0 0.\n    Th\u1ef1c hi\u1ec7n ph\u00e9p to\u00e1n XOR nh\u1ecb ph\u00e2n tr\u00ean c\u00e1c \u0111\u1ea7u v\u00e0o n\u00e0y v\u00e0 tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 c\u0169ng d\u01b0\u1edbi d\u1ea1ng chu\u1ed7i.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Trong danh s\u00e1ch c\u00e1c chu\u1ed7i, tr\u1ea3 v\u1ec1 chu\u1ed7i d\u00e0i nh\u1ea5t. Tr\u1ea3 v\u1ec1 chu\u1ed7i \u0111\u1ea7u ti\u00ean trong tr\u01b0\u1eddng h\u1ee3p c\u00f3 nhi\u1ec1u chu\u1ed7i c\u00f3 c\u00f9ng \u0111\u1ed9 d\u00e0i. Tr\u1ea3 v\u1ec1 None trong tr\u01b0\u1eddng h\u1ee3p danh s\u00e1ch \u0111\u1ea7u v\u00e0o tr\u1ed1ng.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Tr\u1ea3 v\u1ec1 \u01b0\u1edbc chung l\u1edbn nh\u1ea5t c\u1ee7a hai s\u1ed1 nguy\u00ean a v\u00e0 b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Tr\u1ea3 v\u1ec1 danh s\u00e1ch t\u1ea5t c\u1ea3 c\u00e1c ti\u1ec1n t\u1ed1 t\u1eeb ng\u1eafn nh\u1ea5t \u0111\u1ebfn d\u00e0i nh\u1ea5t c\u1ee7a chu\u1ed7i \u0111\u1ea7u v\u00e0o.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i ch\u1ee9a c\u00e1c s\u1ed1 c\u00e1ch nhau b\u1eb1ng kho\u1ea3ng tr\u1eafng b\u1eaft \u0111\u1ea7u t\u1eeb 0 \u0111\u1ebfn n bao g\u1ed3m c\u1ea3 n.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" D\u1ef1a v\u00e0o m\u1ed9t chu\u1ed7i, t\u00ecm ra chu\u1ed7i \u0111\u00f3 bao g\u1ed3m bao nhi\u00eau k\u00fd t\u1ef1 kh\u00e1c nhau.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \u0110\u1ea7u v\u00e0o cho h\u00e0m n\u00e0y l\u00e0 m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho c\u00e1c n\u1ed1t nh\u1ea1c trong m\u1ed9t \u0111\u1ecbnh d\u1ea1ng ASCII \u0111\u1eb7c bi\u1ec7t.\nNhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 ph\u00e2n t\u00edch chu\u1ed7i n\u00e0y v\u00e0 tr\u1ea3 v\u1ec1 danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean t\u01b0\u01a1ng \u1ee9ng v\u1edbi s\u1ed1 nh\u1ecbp m\u00e0 m\u1ed7i n\u1ed1t k\u00e9o d\u00e0i.\n\n\u0110\u00e2y l\u00e0 ch\u00fa gi\u1ea3i:\n'o' - n\u1ed1t tr\u00f2n, k\u00e9o d\u00e0i b\u1ed1n nh\u1ecbp\n'o|' - n\u1ed1t tr\u1eafng, k\u00e9o d\u00e0i hai nh\u1ecbp\n'.|' - n\u1ed1t \u0111en, k\u00e9o d\u00e0i m\u1ed9t nh\u1ecbp\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" T\u00ecm s\u1ed1 l\u1ea7n m\u1ed9t chu\u1ed7i con cho tr\u01b0\u1edbc xu\u1ea5t hi\u1ec7n trong chu\u1ed7i g\u1ed1c. \u0110\u1ebfm c\u1ea3 nh\u1eefng tr\u01b0\u1eddng h\u1ee3p tr\u00f9ng l\u1eb7p.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" \u0110\u1ea7u v\u00e0o l\u00e0 m\u1ed9t chu\u1ed7i c\u00e1c ch\u1eef s\u1ed1 \u0111\u01b0\u1ee3c ph\u00e2n t\u00e1ch b\u1eb1ng d\u1ea5u c\u00e1ch t\u1eeb 'zero' \u0111\u1ebfn 'nine'.\n    C\u00e1c l\u1ef1a ch\u1ecdn h\u1ee3p l\u1ec7 l\u00e0 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' v\u00e0 'nine'.\n    Tr\u1ea3 v\u1ec1 chu\u1ed7i v\u1edbi c\u00e1c s\u1ed1 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp t\u1eeb nh\u1ecf nh\u1ea5t \u0111\u1ebfn l\u1edbn nh\u1ea5t.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" T\u1eeb danh s\u00e1ch c\u00e1c s\u1ed1 \u0111\u01b0\u1ee3c cung c\u1ea5p, ch\u1ecdn v\u00e0 tr\u1ea3 v\u1ec1 hai s\u1ed1 g\u1ea7n nhau nh\u1ea5t v\u00e0 tr\u1ea3 v\u1ec1 ch\u00fang theo th\u1ee9 t\u1ef1.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" V\u1edbi danh s\u00e1ch c\u00e1c s\u1ed1, h\u00e3y \u00e1p d\u1ee5ng bi\u1ebfn \u0111\u1ed5i tuy\u1ebfn t\u00ednh cho danh s\u00e1ch \u0111\u00f3,\n    sao cho s\u1ed1 nh\u1ecf nh\u1ea5t tr\u1edf th\u00e0nh 0 v\u00e0 s\u1ed1 l\u1edbn nh\u1ea5t tr\u1edf th\u00e0nh 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" L\u1ecdc danh s\u00e1ch c\u00e1c gi\u00e1 tr\u1ecb Python ch\u1ec9 \u0111\u1ec3 l\u1ea1i c\u00e1c s\u1ed1 nguy\u00ean.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Tr\u1ea3 v\u1ec1 \u0111\u1ed9 d\u00e0i c\u1ee7a chu\u1ed7i \u0111\u00e3 cho\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" \u0110\u1ed1i v\u1edbi m\u1ed9t s\u1ed1 cho tr\u01b0\u1edbc n, h\u00e3y t\u00ecm s\u1ed1 l\u1edbn nh\u1ea5t chia h\u1ebft cho n m\u00e0 nh\u1ecf h\u01a1n n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Tr\u1ea3 v\u1ec1 danh s\u00e1ch c\u00e1c th\u1eeba s\u1ed1 nguy\u00ean t\u1ed1 c\u1ee7a s\u1ed1 nguy\u00ean \u0111\u00e3 cho theo th\u1ee9 t\u1ef1 t\u1eeb nh\u1ecf \u0111\u1ebfn l\u1edbn.\nM\u1ed7i th\u1eeba s\u1ed1 n\u00ean \u0111\u01b0\u1ee3c li\u1ec7t k\u00ea s\u1ed1 l\u1ea7n t\u01b0\u01a1ng \u1ee9ng v\u1edbi s\u1ed1 l\u1ea7n n\u00f3 xu\u1ea5t hi\u1ec7n trong ph\u00e2n t\u00edch th\u1eeba s\u1ed1.\nS\u1ed1 \u0111\u1ea7u v\u00e0o ph\u1ea3i b\u1eb1ng t\u00edch c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c th\u1eeba s\u1ed1.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" T\u1eeb m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean, lo\u1ea1i b\u1ecf t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed xu\u1ea5t hi\u1ec7n nhi\u1ec1u h\u01a1n m\u1ed9t l\u1ea7n.\n    Gi\u1eef nguy\u00ean th\u1ee9 t\u1ef1 c\u1ee7a c\u00e1c ph\u1ea7n t\u1eed c\u00f2n l\u1ea1i nh\u01b0 trong \u0111\u1ea7u v\u00e0o.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" \u0110\u1ed1i v\u1edbi m\u1ed9t chu\u1ed7i cho tr\u01b0\u1edbc, chuy\u1ec3n c\u00e1c k\u00fd t\u1ef1 vi\u1ebft th\u01b0\u1eddng th\u00e0nh vi\u1ebft hoa v\u00e0 c\u00e1c k\u00fd t\u1ef1 vi\u1ebft hoa th\u00e0nh vi\u1ebft th\u01b0\u1eddng.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" K\u1ebft h\u1ee3p danh s\u00e1ch c\u00e1c chu\u1ed7i th\u00e0nh m\u1ed9t chu\u1ed7i duy nh\u1ea5t\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" L\u1ecdc m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i \u0111\u1ea7u v\u00e0o ch\u1ec9 cho nh\u1eefng chu\u1ed7i b\u1eaft \u0111\u1ea7u b\u1eb1ng m\u1ed9t ti\u1ec1n t\u1ed1 cho tr\u01b0\u1edbc.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Ch\u1ec9 tr\u1ea3 v\u1ec1 c\u00e1c s\u1ed1 d\u01b0\u01a1ng trong danh s\u00e1ch.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb true n\u1ebfu s\u1ed1 \u0111\u00e3 cho l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1, v\u00e0 false n\u1ebfu kh\u00f4ng ph\u1ea3i.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    \u0110\u00e1nh gi\u00e1 \u0111a th\u1ee9c v\u1edbi c\u00e1c h\u1ec7 s\u1ed1 xs t\u1ea1i \u0111i\u1ec3m x.\n    tr\u1ea3 v\u1ec1 xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"H\u00e0m n\u00e0y nh\u1eadn m\u1ed9t danh s\u00e1ch l v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch l' sao cho\n    l' gi\u1ed1ng h\u1ec7t l \u1edf c\u00e1c ch\u1ec9 s\u1ed1 kh\u00f4ng chia h\u1ebft cho ba, trong khi c\u00e1c gi\u00e1 tr\u1ecb t\u1ea1i c\u00e1c ch\u1ec9 s\u1ed1 chia h\u1ebft cho ba s\u1ebd b\u1eb1ng\n    v\u1edbi c\u00e1c gi\u00e1 tr\u1ecb \u1edf c\u00e1c ch\u1ec9 s\u1ed1 t\u01b0\u01a1ng \u1ee9ng c\u1ee7a l, nh\u01b0ng \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 c\u00e1c ph\u1ea7n t\u1eed duy nh\u1ea5t \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp trong m\u1ed9t danh s\u00e1ch\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 ph\u1ea7n t\u1eed l\u1edbn nh\u1ea5t trong danh s\u00e1ch.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 s\u1ed1 l\u1ea7n ch\u1eef s\u1ed1 7 xu\u1ea5t hi\u1ec7n trong c\u00e1c s\u1ed1 nguy\u00ean nh\u1ecf h\u01a1n n v\u00e0 chia h\u1ebft cho 11 ho\u1eb7c 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"H\u00e0m n\u00e0y nh\u1eadn v\u00e0o m\u1ed9t danh s\u00e1ch l v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch l' sao cho\n    l' gi\u1ed1ng h\u1ec7t l \u1edf c\u00e1c ch\u1ec9 s\u1ed1 l\u1ebb, trong khi c\u00e1c gi\u00e1 tr\u1ecb \u1edf c\u00e1c ch\u1ec9 s\u1ed1 ch\u1eb5n b\u1eb1ng v\u1edbi\n    c\u00e1c gi\u00e1 tr\u1ecb \u1edf c\u00e1c ch\u1ec9 s\u1ed1 ch\u1eb5n c\u1ee7a l, nh\u01b0ng \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    tr\u1ea3 v\u1ec1 chu\u1ed7i \u0111\u00e3 m\u00e3 h\u00f3a b\u1eb1ng c\u00e1ch l\u1eb7p l\u1ea1i c\u00e1c nh\u00f3m ba k\u00fd t\u1ef1.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib tr\u1ea3 v\u1ec1 s\u1ed1 th\u1ee9 n m\u00e0 l\u00e0 m\u1ed9t s\u1ed1 Fibonacci v\u00e0 c\u0169ng l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    `triples_sum_to_zero` nh\u1eadn m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean l\u00e0m \u0111\u1ea7u v\u00e0o.\nN\u00f3 tr\u1ea3 v\u1ec1 True n\u1ebfu c\u00f3 ba ph\u1ea7n t\u1eed kh\u00e1c nhau trong danh s\u00e1ch c\u00f3 t\u1ed5ng b\u1eb1ng kh\u00f4ng, v\u00e0 ng\u01b0\u1ee3c l\u1ea1i tr\u1ea3 v\u1ec1 False.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    H\u00e3y t\u01b0\u1edfng t\u01b0\u1ee3ng m\u1ed9t con \u0111\u01b0\u1eddng l\u00e0 m\u1ed9t \u0111\u01b0\u1eddng th\u1eb3ng ho\u00e0n h\u1ea3o v\u00f4 h\u1ea1n. \nC\u00f3 \\ chi\u1ebfc xe \u0111ang ch\u1ea1y t\u1eeb tr\u00e1i sang ph\u1ea3i; \u0111\u1ed3ng th\u1eddi, m\u1ed9t t\u1eadp h\u1ee3p kh\u00e1c g\u1ed3m \\ chi\u1ebfc xe \n\u0111ang ch\u1ea1y t\u1eeb ph\u1ea3i sang tr\u00e1i. Hai t\u1eadp h\u1ee3p xe n\u00e0y ban \u0111\u1ea7u c\u00e1ch nhau r\u1ea5t xa. T\u1ea5t c\u1ea3 c\u00e1c xe \u0111\u1ec1u di chuy\u1ec3n v\u1edbi c\u00f9ng t\u1ed1c \u0111\u1ed9. Hai xe \u0111\u01b0\u1ee3c cho l\u00e0 va ch\u1ea1m khi m\u1ed9t chi\u1ebfc xe \u0111ang di chuy\u1ec3n t\u1eeb tr\u00e1i sang ph\u1ea3i \u0111\u1ee5ng ph\u1ea3i m\u1ed9t chi\u1ebfc xe \u0111ang di chuy\u1ec3n t\u1eeb ph\u1ea3i sang tr\u00e1i. \nTuy nhi\u00ean, c\u00e1c xe \u0111\u1ec1u v\u00f4 c\u00f9ng c\u1ee9ng c\u00e1p v\u00e0 m\u1ea1nh m\u1ebd; do \u0111\u00f3, ch\u00fang ti\u1ebfp t\u1ee5c di chuy\u1ec3n tr\u00ean qu\u1ef9 \u0111\u1ea1o c\u1ee7a m\u00ecnh nh\u01b0 th\u1ec3 ch\u00fang kh\u00f4ng va ch\u1ea1m.\n\nH\u00e0m n\u00e0y s\u1ebd tr\u1ea3 v\u1ec1 s\u1ed1 l\u1ea7n va ch\u1ea1m nh\u01b0 v\u1eady.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 danh s\u00e1ch v\u1edbi c\u00e1c ph\u1ea7n t\u1eed \u0111\u01b0\u1ee3c t\u0103ng th\u00eam 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    `pairs_sum_to_zero` nh\u1eadn m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean l\u00e0m \u0111\u1ea7u v\u00e0o.\nN\u00f3 tr\u1ea3 v\u1ec1 True n\u1ebfu c\u00f3 hai ph\u1ea7n t\u1eed kh\u00e1c nhau trong danh s\u00e1ch c\u00f3 t\u1ed5ng b\u1eb1ng kh\u00f4ng, v\u00e0 ng\u01b0\u1ee3c l\u1ea1i tr\u1ea3 v\u1ec1 False.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Thay \u0111\u1ed5i c\u01a1 s\u1ed1 c\u1ee7a s\u1ed1 \u0111\u1ea7u v\u00e0o x th\u00e0nh c\u01a1 s\u1ed1.\n    tr\u1ea3 v\u1ec1 d\u1ea1ng chu\u1ed7i sau khi chuy\u1ec3n \u0111\u1ed5i.\n    c\u00e1c s\u1ed1 c\u01a1 s\u1ed1 nh\u1ecf h\u01a1n 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Cho chi\u1ec1u d\u00e0i c\u1ee7a m\u1ed9t c\u1ea1nh v\u00e0 chi\u1ec1u cao, h\u00e3y tr\u1ea3 v\u1ec1 di\u1ec7n t\u00edch c\u1ee7a m\u1ed9t tam gi\u00e1c.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"D\u00e3y s\u1ed1 Fib4 l\u00e0 m\u1ed9t d\u00e3y s\u1ed1 t\u01b0\u01a1ng t\u1ef1 nh\u01b0 d\u00e3y s\u1ed1 Fibonacci \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a nh\u01b0 sau:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    Vui l\u00f2ng vi\u1ebft m\u1ed9t h\u00e0m \u0111\u1ec3 t\u00ednh to\u00e1n ph\u1ea7n t\u1eed th\u1ee9 n c\u1ee7a d\u00e3y s\u1ed1 Fib4 m\u1ed9t c\u00e1ch hi\u1ec7u qu\u1ea3. Kh\u00f4ng s\u1eed d\u1ee5ng \u0111\u1ec7 quy.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb trung v\u1ecb c\u1ee7a c\u00e1c ph\u1ea7n t\u1eed trong danh s\u00e1ch l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Ki\u1ec3m tra xem chu\u1ed7i \u0111\u00e3 cho c\u00f3 ph\u1ea3i l\u00e0 palindrome kh\u00f4ng\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    tr\u1ea3 v\u1ec1 chu\u1ed7i \u0111\u00e3 m\u00e3 h\u00f3a b\u1eb1ng c\u00e1ch d\u1ecbch chuy\u1ec3n m\u1ed7i k\u00fd t\u1ef1 5 v\u1ecb tr\u00ed trong b\u1ea3ng ch\u1eef c\u00e1i.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels l\u00e0 m\u1ed9t h\u00e0m nh\u1eadn v\u00e0o m\u1ed9t chu\u1ed7i v\u00e0 tr\u1ea3 v\u1ec1 chu\u1ed7i kh\u00f4ng c\u00f3 nguy\u00ean \u00e2m.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 True n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c s\u1ed1 trong danh s\u00e1ch l \u0111\u1ec1u nh\u1ecf h\u01a1n ng\u01b0\u1ee1ng t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"C\u1ed9ng hai s\u1ed1 x v\u00e0 y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Ki\u1ec3m tra xem hai t\u1eeb c\u00f3 c\u00f9ng c\u00e1c k\u00fd t\u1ef1 hay kh\u00f4ng.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 s\u1ed1 Fibonacci th\u1ee9 n.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" D\u01b0\u1edbi \u0111\u00e2y l\u00e0 chu\u1ed7i c\u00e1c d\u1ea5u ngo\u1eb7c \"<\" v\u00e0 \">\". \n    Tr\u1ea3 v\u1ec1 True n\u1ebfu m\u1ed7i d\u1ea5u ngo\u1eb7c m\u1edf c\u00f3 m\u1ed9t d\u1ea5u ngo\u1eb7c \u0111\u00f3ng t\u01b0\u01a1ng \u1ee9ng.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 True n\u1ebfu c\u00e1c ph\u1ea7n t\u1eed trong danh s\u00e1ch t\u0103ng ho\u1eb7c gi\u1ea3m \u0111\u01a1n \u0111i\u1ec7u.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Tr\u1ea3 v\u1ec1 c\u00e1c ph\u1ea7n t\u1eed chung duy nh\u1ea5t \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp t\u1eeb hai danh s\u00e1ch.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Tr\u1ea3 v\u1ec1 \u01b0\u1edbc s\u1ed1 nguy\u00ean t\u1ed1 l\u1edbn nh\u1ea5t c\u1ee7a n. Gi\u1ea3 s\u1eed n > 1 v\u00e0 kh\u00f4ng ph\u1ea3i l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n l\u00e0 m\u1ed9t h\u00e0m t\u00ednh t\u1ed5ng c\u00e1c s\u1ed1 t\u1eeb 1 \u0111\u1ebfn n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" D\u1ea5u ngo\u1eb7c l\u00e0 m\u1ed9t chu\u1ed7i c\u1ee7a \"\". Tr\u1ea3 v\u1ec1 True n\u1ebfu m\u1ed7i d\u1ea5u ngo\u1eb7c m\u1edf c\u00f3 m\u1ed9t d\u1ea5u ngo\u1eb7c \u0111\u00f3ng t\u01b0\u01a1ng \u1ee9ng.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u0111\u1ea1i di\u1ec7n cho c\u00e1c h\u1ec7 s\u1ed1 c\u1ee7a m\u1ed9t \u0111a th\u1ee9c.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Tr\u1ea3 v\u1ec1 \u0111\u1ea1o h\u00e0m c\u1ee7a \u0111a th\u1ee9c n\u00e0y d\u01b0\u1edbi c\u00f9ng m\u1ed9t d\u1ea1ng.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"D\u00e3y s\u1ed1 FibFib l\u00e0 m\u1ed9t d\u00e3y s\u1ed1 t\u01b0\u01a1ng t\u1ef1 nh\u01b0 d\u00e3y Fibonacci \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a nh\u01b0 sau:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Vui l\u00f2ng vi\u1ebft m\u1ed9t h\u00e0m \u0111\u1ec3 t\u00ednh to\u00e1n hi\u1ec7u qu\u1ea3 ph\u1ea7n t\u1eed th\u1ee9 n c\u1ee7a d\u00e3y s\u1ed1 FibFib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nTh\u00eam nhi\u1ec1u tr\u01b0\u1eddng h\u1ee3p ki\u1ec3m th\u1eed h\u01a1n.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"D\u1ecbch chuy\u1ec3n c\u00e1c ch\u1eef s\u1ed1 c\u1ee7a s\u1ed1 nguy\u00ean x theo v\u00f2ng tr\u00f2n, d\u1ecbch c\u00e1c ch\u1eef s\u1ed1 sang ph\u1ea3i theo gi\u00e1 tr\u1ecb shift\n    v\u00e0 tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 d\u01b0\u1edbi d\u1ea1ng chu\u1ed7i.\n    N\u1ebfu shift > s\u1ed1 l\u01b0\u1ee3ng ch\u1eef s\u1ed1, tr\u1ea3 v\u1ec1 c\u00e1c ch\u1eef s\u1ed1 \u0111\u00e3 \u0111\u1ea3o ng\u01b0\u1ee3c.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"D\u1ecbch c\u00e2u sau sang ti\u1ebfng Vi\u1ec7t.\n\nNhi\u1ec7m v\u1ee5\n    Vi\u1ebft m\u1ed9t h\u00e0m nh\u1eadn m\u1ed9t chu\u1ed7i \u0111\u1ea7u v\u00e0o v\u00e0 tr\u1ea3 v\u1ec1 t\u1ed5ng c\u00e1c m\u00e3 ASCII c\u1ee7a c\u00e1c k\u00fd t\u1ef1 vi\u1ebft hoa.\n\n    V\u00ed d\u1ee5:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Trong nhi\u1ec7m v\u1ee5 n\u00e0y, b\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho s\u1ed1 l\u01b0\u1ee3ng t\u00e1o v\u00e0 cam \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i trong m\u1ed9t gi\u1ecf tr\u00e1i c\u00e2y. Gi\u1ecf n\u00e0y ch\u1ee9a t\u00e1o, cam v\u00e0 xo\u00e0i. V\u1edbi chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho t\u1ed5ng s\u1ed1 l\u01b0\u1ee3ng cam v\u00e0 t\u00e1o v\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean \u0111\u1ea1i di\u1ec7n cho t\u1ed5ng s\u1ed1 tr\u00e1i c\u00e2y trong gi\u1ecf, h\u00e3y tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng tr\u00e1i xo\u00e0i trong gi\u1ecf.\nV\u00ed d\u1ee5:\nfruit_distribution -> 19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"D\u1ef1a v\u00e0o m\u1ed9t m\u1ea3ng \u0111\u1ea1i di\u1ec7n cho m\u1ed9t nh\u00e1nh c\u1ee7a c\u00e2y c\u00f3 c\u00e1c n\u00fat l\u00e0 s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m,\nnhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 ch\u1ecdn m\u1ed9t trong nh\u1eefng n\u00fat v\u00e0 tr\u1ea3 v\u1ec1 n\u00f3.\nN\u00fat \u0111\u01b0\u1ee3c ch\u1ecdn ph\u1ea3i l\u00e0 n\u00fat c\u00f3 gi\u00e1 tr\u1ecb ch\u1eb5n nh\u1ecf nh\u1ea5t.\nN\u1ebfu c\u00f3 nhi\u1ec1u n\u00fat c\u00f3 c\u00f9ng gi\u00e1 tr\u1ecb ch\u1eb5n nh\u1ecf nh\u1ea5t, tr\u1ea3 v\u1ec1 n\u00fat c\u00f3 ch\u1ec9 s\u1ed1 nh\u1ecf nh\u1ea5t.\n\nN\u00fat \u0111\u01b0\u1ee3c ch\u1ecdn n\u00ean \u0111\u01b0\u1ee3c tr\u1ea3 v\u1ec1 trong m\u1ed9t danh s\u00e1ch, [gi\u00e1 tr\u1ecb nh\u1ecf nh\u1ea5t, ch\u1ec9 s\u1ed1 c\u1ee7a n\u00f3].\nN\u1ebfu kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ch\u1eb5n n\u00e0o ho\u1eb7c m\u1ea3ng cho tr\u01b0\u1edbc r\u1ed7ng, tr\u1ea3 v\u1ec1 [].\n\nV\u00ed d\u1ee5 1:\n    \u0110\u1ea7u v\u00e0o: [4,2,3]\n    \u0110\u1ea7u ra: [2, 1]\n    Gi\u1ea3i th\u00edch: 2 c\u00f3 gi\u00e1 tr\u1ecb ch\u1eb5n nh\u1ecf nh\u1ea5t, v\u00e0 2 c\u00f3 ch\u1ec9 s\u1ed1 nh\u1ecf nh\u1ea5t.\n\nV\u00ed d\u1ee5 2:\n    \u0110\u1ea7u v\u00e0o: [1,2,3]\n    \u0110\u1ea7u ra: [2, 1]\n    Gi\u1ea3i th\u00edch: 2 c\u00f3 gi\u00e1 tr\u1ecb ch\u1eb5n nh\u1ecf nh\u1ea5t, v\u00e0 2 c\u00f3 ch\u1ec9 s\u1ed1 nh\u1ecf nh\u1ea5t.\n\nV\u00ed d\u1ee5 3:\n    \u0110\u1ea7u v\u00e0o: []\n    \u0110\u1ea7u ra: []\n\nV\u00ed d\u1ee5 4:\n    \u0110\u1ea7u v\u00e0o: [5, 0, 3, 0, 4, 2]\n    \u0110\u1ea7u ra: [0, 1]\n    Gi\u1ea3i th\u00edch: 0 l\u00e0 gi\u00e1 tr\u1ecb nh\u1ecf nh\u1ea5t, nh\u01b0ng c\u00f3 hai s\u1ed1 kh\u00f4ng,\n                 n\u00ean ch\u00fang ta s\u1ebd ch\u1ecdn s\u1ed1 kh\u00f4ng \u0111\u1ea7u ti\u00ean, c\u00f3 ch\u1ec9 s\u1ed1 nh\u1ecf nh\u1ea5t.\n\nR\u00e0ng bu\u1ed9c:\n    * 1 <= \u0111\u1ed9 d\u00e0i c\u1ee7a m\u1ea3ng <= 10000\n    * 0 <= gi\u00e1 tr\u1ecb c\u1ee7a n\u00fat\"\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Cho m\u1ed9t m\u1ea3ng `arr` g\u1ed3m c\u00e1c s\u1ed1 nguy\u00ean, h\u00e3y t\u00ecm s\u1ed1 l\u01b0\u1ee3ng ph\u1ea7n t\u1eed t\u1ed1i thi\u1ec3u c\u1ea7n thay \u0111\u1ed5i \u0111\u1ec3 l\u00e0m cho m\u1ea3ng tr\u1edf th\u00e0nh m\u1ea3ng \u0111\u1ed1i x\u1ee9ng. M\u1ed9t m\u1ea3ng \u0111\u1ed1i x\u1ee9ng l\u00e0 m\u1ea3ng \u0111\u01b0\u1ee3c \u0111\u1ecdc t\u1eeb tr\u00e1i sang ph\u1ea3i v\u00e0 t\u1eeb ph\u1ea3i sang tr\u00e1i \u0111\u1ec1u gi\u1ed1ng nhau. Trong m\u1ed9t l\u1ea7n thay \u0111\u1ed5i, b\u1ea1n c\u00f3 th\u1ec3 thay \u0111\u1ed5i m\u1ed9t ph\u1ea7n t\u1eed th\u00e0nh b\u1ea5t k\u1ef3 ph\u1ea7n t\u1eed n\u00e0o kh\u00e1c.\n\nV\u00ed d\u1ee5:\n```\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n```\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb \u0111\u00fang n\u1ebfu s\u1ed1 cho tr\u01b0\u1edbc l\u00e0 t\u00edch c\u1ee7a 3 s\u1ed1 nguy\u00ean t\u1ed1 v\u00e0 sai trong tr\u01b0\u1eddng h\u1ee3p ng\u01b0\u1ee3c l\u1ea1i. Bi\u1ebft r\u1eb1ng nh\u1ecf h\u01a1n 100.\n    V\u00ed d\u1ee5:\n    is_multiply_prime == \u0110\u00fang\n    30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 vi\u1ebft m\u1ed9t h\u00e0m tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb true n\u1ebfu m\u1ed9t s\u1ed1 x l\u00e0 l\u0169y th\u1eeba \u0111\u01a1n gi\u1ea3n c\u1ee7a n v\u00e0 false trong c\u00e1c tr\u01b0\u1eddng h\u1ee3p kh\u00e1c.\nx l\u00e0 l\u0169y th\u1eeba \u0111\u01a1n gi\u1ea3n c\u1ee7a n n\u1ebfu n**int=x\nV\u00ed d\u1ee5:\nis_simple_power => true\nis_simple_power => true\nis_simple_power => true\nis_simple_power => false\nis_simple_power => false\nis_simple_power => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c giao nhi\u1ec7m v\u1ee5 vi\u1ebft m\u1ed9t h\u00e0m nh\u1eadn v\u00e0o m\u1ed9t s\u1ed1 h\u1ec7 th\u1eadp l\u1ee5c ph\u00e2n d\u01b0\u1edbi d\u1ea1ng chu\u1ed7i v\u00e0 \u0111\u1ebfm s\u1ed1 ch\u1eef s\u1ed1 h\u1ec7 th\u1eadp l\u1ee5c ph\u00e2n l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1. C\u00e1c ch\u1eef s\u1ed1 h\u1ec7 th\u1eadp l\u1ee5c ph\u00e2n l\u00e0 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. C\u00e1c s\u1ed1 nguy\u00ean t\u1ed1 l\u00e0 2, 3, 5, 7, 11, 13, 17,... V\u00ec v\u1eady, b\u1ea1n c\u1ea7n x\u00e1c \u0111\u1ecbnh s\u1ed1 l\u01b0\u1ee3ng c\u00e1c ch\u1eef s\u1ed1 sau: 2, 3, 5, 7, B, D. L\u01b0u \u00fd: b\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng \u0111\u1ea7u v\u00e0o lu\u00f4n \u0111\u00fang ho\u1eb7c l\u00e0 chu\u1ed7i r\u1ed7ng v\u00e0 c\u00e1c k\u00fd hi\u1ec7u A, B, C, D, E, F lu\u00f4n l\u00e0 ch\u1eef hoa. V\u00ed d\u1ee5: \u0110\u1ed1i v\u1edbi num = \"AB\" k\u1ebft qu\u1ea3 ph\u1ea3i l\u00e0 1. \u0110\u1ed1i v\u1edbi num = \"1077E\" k\u1ebft qu\u1ea3 ph\u1ea3i l\u00e0 2. \u0110\u1ed1i v\u1edbi num = \"ABED1A33\" k\u1ebft qu\u1ea3 ph\u1ea3i l\u00e0 4. \u0110\u1ed1i v\u1edbi num = \"123456789ABCDEF0\" k\u1ebft qu\u1ea3 ph\u1ea3i l\u00e0 6. \u0110\u1ed1i v\u1edbi num = \"2020\" k\u1ebft qu\u1ea3 ph\u1ea3i l\u00e0 2.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t s\u1ed1 \u1edf d\u1ea1ng th\u1eadp ph\u00e2n v\u00e0 nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 chuy\u1ec3n \u0111\u1ed5i n\u00f3 sang\n    \u0111\u1ecbnh d\u1ea1ng nh\u1ecb ph\u00e2n. H\u00e0m n\u00ean tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i, v\u1edbi m\u1ed7i k\u00fd t\u1ef1 \u0111\u1ea1i di\u1ec7n cho m\u1ed9t s\u1ed1 nh\u1ecb ph\u00e2n.\n    M\u1ed7i k\u00fd t\u1ef1 trong chu\u1ed7i s\u1ebd l\u00e0 '0' ho\u1eb7c '1'.\n\n    S\u1ebd c\u00f3 m\u1ed9t c\u1eb7p k\u00fd t\u1ef1 'db' th\u00eam v\u00e0o \u1edf \u0111\u1ea7u v\u00e0 cu\u1ed1i chu\u1ed7i.\n    C\u00e1c k\u00fd t\u1ef1 th\u00eam v\u00e0o n\u00e0y nh\u1eb1m gi\u00fap \u0111\u1ecbnh d\u1ea1ng.\n\n    V\u00ed d\u1ee5:\n    decimal_to_binary   # tr\u1ea3 v\u1ec1 \"db1111db\"\n    decimal_to_binary   # tr\u1ea3 v\u1ec1 \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t chu\u1ed7i s.\nNhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 ki\u1ec3m tra xem chu\u1ed7i \u0111\u00f3 c\u00f3 h\u1ea1nh ph\u00fac hay kh\u00f4ng.\nM\u1ed9t chu\u1ed7i \u0111\u01b0\u1ee3c coi l\u00e0 h\u1ea1nh ph\u00fac n\u1ebfu \u0111\u1ed9 d\u00e0i c\u1ee7a n\u00f3 \u00edt nh\u1ea5t l\u00e0 3 v\u00e0 m\u1ed7i 3 ch\u1eef c\u00e1i li\u00ean ti\u1ebfp \u0111\u1ec1u kh\u00e1c nhau.\nV\u00ed d\u1ee5:\nis_happy => Sai\nis_happy => Sai\nis_happy => \u0110\u00fang\nis_happy => Sai\nis_happy => \u0110\u00fang\nis_happy => Sai\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u0110\u00e2y l\u00e0 tu\u1ea7n cu\u1ed1i c\u1ee7a h\u1ecdc k\u1ef3 v\u00e0 gi\u00e1o vi\u00ean ph\u1ea3i \u0111\u01b0a ra \u0111i\u1ec3m s\u1ed1 cho h\u1ecdc sinh. Gi\u00e1o vi\u00ean \u0111\u00e3 t\u1ef1 t\u1ea1o ra m\u1ed9t thu\u1eadt to\u00e1n \u0111\u1ec3 ch\u1ea5m \u0111i\u1ec3m. V\u1ea5n \u0111\u1ec1 duy nh\u1ea5t l\u00e0 c\u00f4 \u1ea5y \u0111\u00e3 m\u1ea5t m\u00e3 m\u00e0 c\u00f4 \u1ea5y s\u1eed d\u1ee5ng \u0111\u1ec3 ch\u1ea5m \u0111i\u1ec3m. C\u00f4 \u1ea5y \u0111\u00e3 \u0111\u01b0a cho b\u1ea1n m\u1ed9t danh s\u00e1ch c\u00e1c GPA c\u1ee7a m\u1ed9t s\u1ed1 h\u1ecdc sinh v\u00e0 b\u1ea1n ph\u1ea3i vi\u1ebft m\u1ed9t h\u00e0m c\u00f3 th\u1ec3 xu\u1ea5t ra danh s\u00e1ch c\u00e1c \u0111i\u1ec3m ch\u1eef c\u00e1i s\u1eed d\u1ee5ng b\u1ea3ng sau \u0111\u00e2y:\n\n             GPA       |    \u0110i\u1ec3m ch\u1eef c\u00e1i\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    V\u00ed d\u1ee5:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m nh\u1eadn v\u00e0o m\u1ed9t chu\u1ed7i v\u00e0 tr\u1ea3 v\u1ec1 True n\u1ebfu \u0111\u1ed9 d\u00e0i c\u1ee7a chu\u1ed7i l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1 ho\u1eb7c False n\u1ebfu kh\u00f4ng ph\u1ea3i.\n    V\u00ed d\u1ee5:\n    prime_length == True\n    prime_length == True\n    prime_length == True\n    prime_length == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng c\u00e1c s\u1ed1 nguy\u00ean d\u01b0\u01a1ng c\u00f3 n ch\u1eef s\u1ed1 b\u1eaft \u0111\u1ea7u ho\u1eb7c k\u1ebft th\u00fac b\u1eb1ng 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng N, tr\u1ea3 v\u1ec1 t\u1ed5ng c\u00e1c ch\u1eef s\u1ed1 c\u1ee7a n\u00f3 d\u01b0\u1edbi d\u1ea1ng nh\u1ecb ph\u00e2n.\n\n    V\u00ed d\u1ee5:\n        V\u1edbi N = 1000, t\u1ed5ng c\u00e1c ch\u1eef s\u1ed1 s\u1ebd l\u00e0 1 v\u00e0 \u0111\u1ea7u ra s\u1ebd l\u00e0 \"1\".\n        V\u1edbi N = 150, t\u1ed5ng c\u00e1c ch\u1eef s\u1ed1 s\u1ebd l\u00e0 6 v\u00e0 \u0111\u1ea7u ra s\u1ebd l\u00e0 \"110\".\n        V\u1edbi N = 147, t\u1ed5ng c\u00e1c ch\u1eef s\u1ed1 s\u1ebd l\u00e0 12 v\u00e0 \u0111\u1ea7u ra s\u1ebd l\u00e0 \"1100\".\n    \n    Bi\u1ebfn:\n        @N s\u1ed1 nguy\u00ean\n             R\u00e0ng bu\u1ed9c: 0 \u2264 N \u2264 10000.\n    \u0110\u1ea7u ra:\n         m\u1ed9t chu\u1ed7i s\u1ed1 nh\u1ecb ph\u00e2n\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"D\u1ef1a v\u00e0o m\u1ed9t danh s\u00e1ch s\u1ed1 nguy\u00ean lst kh\u00f4ng r\u1ed7ng. C\u1ed9ng c\u00e1c ph\u1ea7n t\u1eed ch\u1eb5n n\u1eb1m \u1edf c\u00e1c ch\u1ec9 s\u1ed1 l\u1ebb.\n\n    V\u00ed d\u1ee5:\n        add ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Vi\u1ebft m\u1ed9t h\u00e0m nh\u1eadn v\u00e0o m\u1ed9t chu\u1ed7i v\u00e0 tr\u1ea3 v\u1ec1 phi\u00ean b\u1ea3n \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp c\u1ee7a n\u00f3.\n    Phi\u00ean b\u1ea3n s\u1eafp x\u1ebfp c\u1ee7a chu\u1ed7i l\u00e0 m\u1ed9t chu\u1ed7i trong \u0111\u00f3 t\u1ea5t c\u1ea3 c\u00e1c t\u1eeb\n    \u0111\u01b0\u1ee3c thay th\u1ebf b\u1eb1ng m\u1ed9t t\u1eeb m\u1edbi m\u00e0 t\u1ea5t c\u1ea3 c\u00e1c k\u00fd t\u1ef1 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n d\u1ef1a tr\u00ean gi\u00e1 tr\u1ecb ascii.\n    L\u01b0u \u00fd: B\u1ea1n ph\u1ea3i gi\u1eef nguy\u00ean th\u1ee9 t\u1ef1 c\u1ee7a c\u00e1c t\u1eeb v\u00e0 kho\u1ea3ng tr\u1eafng trong c\u00e2u.\n\n    V\u00ed d\u1ee5:\n    anti_shuffle tr\u1ea3 v\u1ec1 'Hi'\n    anti_shuffle tr\u1ea3 v\u1ec1 'ehllo'\n    anti_shuffle tr\u1ea3 v\u1ec1 'Hello !!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p d\u1eef li\u1ec7u hai chi\u1ec1u d\u01b0\u1edbi d\u1ea1ng danh s\u00e1ch l\u1ed3ng nhau, t\u01b0\u01a1ng t\u1ef1 nh\u01b0 ma tr\u1eadn. Tuy nhi\u00ean, kh\u00f4ng gi\u1ed1ng nh\u01b0 c\u00e1c ma tr\u1eadn, m\u1ed7i h\u00e0ng c\u00f3 th\u1ec3 ch\u1ee9a m\u1ed9t s\u1ed1 c\u1ed9t kh\u00e1c nhau. Cho danh s\u00e1ch `lst` v\u00e0 s\u1ed1 nguy\u00ean `x`, h\u00e3y t\u00ecm c\u00e1c s\u1ed1 nguy\u00ean `x` trong danh s\u00e1ch v\u00e0 tr\u1ea3 v\u1ec1 danh s\u00e1ch c\u00e1c b\u1ed9 d\u1eef li\u1ec7u, [, ...] sao cho m\u1ed7i b\u1ed9 d\u1eef li\u1ec7u l\u00e0 m\u1ed9t t\u1ecda \u0111\u1ed9 -, b\u1eaft \u0111\u1ea7u t\u1eeb 0. S\u1eafp x\u1ebfp c\u00e1c t\u1ecda \u0111\u1ed9 ban \u0111\u1ea7u theo h\u00e0ng t\u0103ng d\u1ea7n. Ngo\u00e0i ra, s\u1eafp x\u1ebfp c\u00e1c t\u1ecda \u0111\u1ed9 c\u1ee7a h\u00e0ng theo c\u1ed9t gi\u1ea3m d\u1ea7n.\n\nV\u00ed d\u1ee5:\nget_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1) == [,,,,]\nget_row == []\nget_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    D\u01b0\u1edbi \u0111\u00e2y l\u00e0 b\u1ea3n d\u1ecbch c\u1ee7a c\u00e2u \u0111\u00e3 cho sang ti\u1ebfng Vi\u1ec7t:\n\nCho m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m, tr\u1ea3 v\u1ec1 m\u1ed9t b\u1ea3n sao c\u1ee7a m\u1ea3ng \u0111\u00e3 cho sau khi s\u1eafp x\u1ebfp.\nB\u1ea1n s\u1ebd s\u1eafp x\u1ebfp m\u1ea3ng \u0111\u00e3 cho theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n n\u1ebfu t\u1ed5ng l\u00e0 s\u1ed1 l\u1ebb,\nho\u1eb7c s\u1eafp x\u1ebfp n\u00f3 theo th\u1ee9 t\u1ef1 gi\u1ea3m d\u1ea7n n\u1ebfu t\u1ed5ng l\u00e0 s\u1ed1 ch\u1eb5n.\n\nL\u01b0u \u00fd:\n* kh\u00f4ng thay \u0111\u1ed5i m\u1ea3ng \u0111\u00e3 cho.\n\nV\u00ed d\u1ee5:\n* sort_array => []\n* sort_array => [5]\n* sort_array => [0, 1, 2, 3, 4, 5]\n* sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"T\u1ea1o m\u1ed9t h\u00e0m m\u00e3 h\u00f3a c\u00f3 t\u00ean l\u00e0 encrypt nh\u1eadn m\u1ed9t chu\u1ed7i l\u00e0m \u0111\u1ed1i s\u1ed1 v\u00e0 \ntr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i \u0111\u01b0\u1ee3c m\u00e3 h\u00f3a v\u1edbi b\u1ea3ng ch\u1eef c\u00e1i \u0111\u01b0\u1ee3c xoay. \nB\u1ea3ng ch\u1eef c\u00e1i n\u00ean \u0111\u01b0\u1ee3c xoay theo c\u00e1ch m\u00e0 c\u00e1c ch\u1eef c\u00e1i \nd\u1ecbch chuy\u1ec3n xu\u1ed1ng hai l\u1ea7n hai v\u1ecb tr\u00ed.\nV\u00ed d\u1ee5:\nencrypt tr\u1ea3 v\u1ec1 'lm'\nencrypt tr\u1ea3 v\u1ec1 'ewhjklnop'\nencrypt tr\u1ea3 v\u1ec1 'kj'\nencrypt tr\u1ea3 v\u1ec1 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean.\n    H\u00e3y vi\u1ebft m\u1ed9t h\u00e0m next_smallest \u0111\u1ec3 tr\u1ea3 v\u1ec1 ph\u1ea7n t\u1eed nh\u1ecf th\u1ee9 2 trong danh s\u00e1ch.\n    Tr\u1ea3 v\u1ec1 None n\u1ebfu kh\u00f4ng c\u00f3 ph\u1ea7n t\u1eed nh\u01b0 v\u1eady.\n    \n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cho m\u1ed9t chu\u1ed7i t\u1eeb, v\u00e0 nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 \u0111\u1ebfm s\u1ed1 l\u01b0\u1ee3ng c\u00e2u nh\u00e0m ch\u00e1n. M\u1ed9t c\u00e2u nh\u00e0m ch\u00e1n l\u00e0 m\u1ed9t c\u00e2u b\u1eaft \u0111\u1ea7u b\u1eb1ng t\u1eeb \"I\". C\u00e1c c\u00e2u \u0111\u01b0\u1ee3c ph\u00e2n c\u00e1ch b\u1eb1ng '.', '?' ho\u1eb7c '!'.\n\nV\u00ed d\u1ee5:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Vi\u1ebft m\u1ed9t h\u00e0m nh\u1eadn m\u1ed9t th\u00f4ng \u0111i\u1ec7p v\u00e0 m\u00e3 h\u00f3a th\u00f4ng \u0111i\u1ec7p \u0111\u00f3 theo c\u00e1ch:\n1. \u0110\u1ed5i tr\u01b0\u1eddng h\u1ee3p c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c ch\u1eef c\u00e1i.\n2. Thay th\u1ebf t\u1ea5t c\u1ea3 c\u00e1c nguy\u00ean \u00e2m trong th\u00f4ng \u0111i\u1ec7p b\u1eb1ng ch\u1eef c\u00e1i xu\u1ea5t hi\u1ec7n tr\u01b0\u1edbc \u0111\u00f3 2 v\u1ecb tr\u00ed trong b\u1ea3ng ch\u1eef c\u00e1i ti\u1ebfng Anh.\nGi\u1ea3 \u0111\u1ecbnh ch\u1ec9 c\u00f3 c\u00e1c ch\u1eef c\u00e1i.\n\nV\u00ed d\u1ee5:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean.\n    B\u1ea1n c\u1ea7n t\u00ecm gi\u00e1 tr\u1ecb nguy\u00ean t\u1ed1 l\u1edbn nh\u1ea5t v\u00e0 tr\u1ea3 v\u1ec1 t\u1ed5ng c\u00e1c ch\u1eef s\u1ed1 c\u1ee7a n\u00f3.\n\n    V\u00ed d\u1ee5:\n    V\u1edbi lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] th\u00ec k\u1ebft qu\u1ea3 s\u1ebd l\u00e0 10\n    V\u1edbi lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] th\u00ec k\u1ebft qu\u1ea3 s\u1ebd l\u00e0 25\n    V\u1edbi lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] th\u00ec k\u1ebft qu\u1ea3 s\u1ebd l\u00e0 13\n    V\u1edbi lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] th\u00ec k\u1ebft qu\u1ea3 s\u1ebd l\u00e0 11\n    V\u1edbi lst = [0,81,12,3,1,21] th\u00ec k\u1ebft qu\u1ea3 s\u1ebd l\u00e0 3\n    V\u1edbi lst = [0,8,1,2,1,7] th\u00ec k\u1ebft qu\u1ea3 s\u1ebd l\u00e0 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    D\u01b0\u1edbi \u0111\u00e2y l\u00e0 c\u00e2u \u0111\u01b0\u1ee3c d\u1ecbch sang ti\u1ebfng Vi\u1ec7t:\n\nCho m\u1ed9t t\u1eeb \u0111i\u1ec3n, tr\u1ea3 v\u1ec1 True n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c kh\u00f3a l\u00e0 chu\u1ed7i ch\u1eef th\u01b0\u1eddng ho\u1eb7c t\u1ea5t c\u1ea3 c\u00e1c kh\u00f3a l\u00e0 chu\u1ed7i ch\u1eef hoa, ng\u01b0\u1ee3c l\u1ea1i tr\u1ea3 v\u1ec1 False. H\u00e0m n\u00ean tr\u1ea3 v\u1ec1 False n\u1ebfu t\u1eeb \u0111i\u1ec3n \u0111\u01b0\u1ee3c cho l\u00e0 tr\u1ed1ng.\nV\u00ed d\u1ee5:\ncheck_dict_case n\u00ean tr\u1ea3 v\u1ec1 True.\ncheck_dict_case n\u00ean tr\u1ea3 v\u1ec1 False.\ncheck_dict_case n\u00ean tr\u1ea3 v\u1ec1 False.\ncheck_dict_case n\u00ean tr\u1ea3 v\u1ec1 False.\ncheck_dict_case n\u00ean tr\u1ea3 v\u1ec1 True.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Tri\u1ec3n khai m\u1ed9t h\u00e0m nh\u1eadn m\u1ed9t s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean t\u1ed1 \u0111\u1ea7u ti\u00ean nh\u1ecf h\u01a1n n.\n    v\u00ed d\u1ee5:\n    count_up_to => [2,3]\n    count_up_to => [2,3,5,7]\n    count_up_to => []\n    count_up_to => [2,3,5,7,11,13,17,19]\n    count_up_to => []\n    count_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Ho\u00e0n th\u00e0nh h\u00e0m nh\u1eadn hai s\u1ed1 nguy\u00ean v\u00e0 tr\u1ea3 v\u1ec1 \n    t\u00edch c\u1ee7a c\u00e1c ch\u1eef s\u1ed1 h\u00e0ng \u0111\u01a1n v\u1ecb c\u1ee7a ch\u00fang.\n    Gi\u1ea3 s\u1eed \u0111\u1ea7u v\u00e0o lu\u00f4n h\u1ee3p l\u1ec7.\n    V\u00ed d\u1ee5:\n    multiply s\u1ebd tr\u1ea3 v\u1ec1 16.\n    multiply s\u1ebd tr\u1ea3 v\u1ec1 72.\n    multiply s\u1ebd tr\u1ea3 v\u1ec1 0.\n    multiply s\u1ebd tr\u1ea3 v\u1ec1 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Cho m\u1ed9t chu\u1ed7i s, \u0111\u1ebfm s\u1ed1 nguy\u00ean \u00e2m vi\u1ebft hoa \u1edf c\u00e1c ch\u1ec9 s\u1ed1 ch\u1eb5n.\n\n    V\u00ed d\u1ee5:\n    count_upper tr\u1ea3 v\u1ec1 1\n    count_upper tr\u1ea3 v\u1ec1 0\n    count_upper tr\u1ea3 v\u1ec1 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, b\u1ea1n ph\u1ea3i t\u1ea1o m\u1ed9t \u0111\u1ed1ng g\u1ed3m n t\u1ea7ng \u0111\u00e1.\n    T\u1ea7ng \u0111\u1ea7u ti\u00ean c\u00f3 n vi\u00ean \u0111\u00e1.\n    S\u1ed1 vi\u00ean \u0111\u00e1 \u1edf t\u1ea7ng ti\u1ebfp theo l\u00e0:\n        - s\u1ed1 l\u1ebb ti\u1ebfp theo n\u1ebfu n l\u00e0 s\u1ed1 l\u1ebb.\n        - s\u1ed1 ch\u1eb5n ti\u1ebfp theo n\u1ebfu n l\u00e0 s\u1ed1 ch\u1eb5n.\n    Tr\u1ea3 v\u1ec1 s\u1ed1 vi\u00ean \u0111\u00e1 \u1edf m\u1ed7i t\u1ea7ng trong m\u1ed9t danh s\u00e1ch, trong \u0111\u00f3 ph\u1ea7n t\u1eed \u1edf ch\u1ec9 m\u1ee5c i \u0111\u1ea1i di\u1ec7n cho s\u1ed1 vi\u00ean \u0111\u00e1 \u1edf t\u1ea7ng.\n\n    V\u00ed d\u1ee5:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i c\u00e1c t\u1eeb \u0111\u01b0\u1ee3c ng\u0103n c\u00e1ch b\u1edfi d\u1ea5u ph\u1ea9y ho\u1eb7c d\u1ea5u c\u00e1ch. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 t\u00e1ch chu\u1ed7i th\u00e0nh c\u00e1c t\u1eeb v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng c\u00e1c t\u1eeb \u0111\u00f3.\n\nV\u00ed d\u1ee5:\nwords_string == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nwords_string == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"H\u00e0m n\u00e0y nh\u1eadn hai s\u1ed1 d\u01b0\u01a1ng x v\u00e0 y v\u00e0 tr\u1ea3 v\u1ec1 s\u1ed1 nguy\u00ean ch\u1eb5n l\u1edbn nh\u1ea5t n\u1eb1m trong kho\u1ea3ng [x, y] bao g\u1ed3m c\u1ea3 x v\u00e0 y. N\u1ebfu kh\u00f4ng c\u00f3 s\u1ed1 n\u00e0o nh\u01b0 v\u1eady, th\u00ec h\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 -1.\n\nV\u00ed d\u1ee5:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cho hai s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n v\u00e0 m, v\u00e0 nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 t\u00ednh trung b\u00ecnh c\u1ed9ng c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean t\u1eeb n \u0111\u1ebfn m. L\u00e0m tr\u00f2n k\u1ebft qu\u1ea3 \u0111\u1ebfn s\u1ed1 nguy\u00ean g\u1ea7n nh\u1ea5t v\u00e0 chuy\u1ec3n \u0111\u1ed5i n\u00f3 sang h\u1ec7 nh\u1ecb ph\u00e2n. N\u1ebfu n l\u1edbn h\u01a1n m, tr\u1ea3 v\u1ec1 -1.\nV\u00ed d\u1ee5:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"D\u01b0\u1edbi \u0111\u00e2y l\u00e0 danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean d\u01b0\u01a1ng x. Tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch \u0111\u00e3 s\u1eafp x\u1ebfp c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed kh\u00f4ng c\u00f3 ch\u1eef s\u1ed1 ch\u1eb5n n\u00e0o.\n\nL\u01b0u \u00fd: Danh s\u00e1ch tr\u1ea3 v\u1ec1 ph\u1ea3i \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n.\n\nV\u00ed d\u1ee5:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    V\u1edbi m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1 nguy\u00ean, s\u1eafp x\u1ebfp c\u00e1c s\u1ed1 nguy\u00ean trong kho\u1ea3ng t\u1eeb 1 \u0111\u1ebfn 9, \u0111\u1ea3o ng\u01b0\u1ee3c m\u1ea3ng k\u1ebft qu\u1ea3, sau \u0111\u00f3 thay th\u1ebf m\u1ed7i ch\u1eef s\u1ed1 b\u1eb1ng t\u00ean t\u01b0\u01a1ng \u1ee9ng c\u1ee7a n\u00f3 t\u1eeb \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\nV\u00ed d\u1ee5:\n  arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n        -> s\u1eafp x\u1ebfp arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n        -> \u0111\u1ea3o ng\u01b0\u1ee3c arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n  tr\u1ea3 v\u1ec1 [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n  N\u1ebfu m\u1ea3ng tr\u1ed1ng, tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng tr\u1ed1ng:\n  arr = []\n  tr\u1ea3 v\u1ec1 []\n\n  N\u1ebfu m\u1ea3ng c\u00f3 b\u1ea5t k\u1ef3 s\u1ed1 l\u1ea1 n\u00e0o, b\u1ecf qua ch\u00fang:\n  arr = [1, -1, 55] \n        -> s\u1eafp x\u1ebfp arr -> [-1, 1, 55]\n        -> \u0111\u1ea3o ng\u01b0\u1ee3c arr -> [55, 1, -1]\n  tr\u1ea3 v\u1ec1 ['One']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" H\u00e3y tri\u1ec3n khai h\u00e0m f nh\u1eadn tham s\u1ed1 n,\n    v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch c\u00f3 k\u00edch th\u01b0\u1edbc n, sao cho gi\u00e1 tr\u1ecb c\u1ee7a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 i l\u00e0 giai th\u1eeba c\u1ee7a i n\u1ebfu i l\u00e0 s\u1ed1 ch\u1eb5n\n    ho\u1eb7c t\u1ed5ng c\u1ee7a c\u00e1c s\u1ed1 t\u1eeb 1 \u0111\u1ebfn i n\u1ebfu i l\u00e0 s\u1ed1 l\u1ebb.\n    i b\u1eaft \u0111\u1ea7u t\u1eeb 1.\n    giai th\u1eeba c\u1ee7a i l\u00e0 t\u00edch c\u1ee7a c\u00e1c s\u1ed1 t\u1eeb 1 \u0111\u1ebfn i.\n    V\u00ed d\u1ee5:\n    f == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, tr\u1ea3 v\u1ec1 m\u1ed9t b\u1ed9 gi\u00e1 tr\u1ecb ch\u1ee9a s\u1ed1 l\u01b0\u1ee3ng c\u00e1c s\u1ed1 nguy\u00ean \u0111\u1ed1i x\u1ee9ng ch\u1eb5n v\u00e0 l\u1ebb n\u1eb1m trong kho\u1ea3ng t\u1eeb 1 \u0111\u1ebfn n, bao g\u1ed3m c\u1ea3 n.\n\n    V\u00ed d\u1ee5 1:\n\n        \u0110\u1ea7u v\u00e0o: 3\n        \u0110\u1ea7u ra:\n        Gi\u1ea3i th\u00edch:\n        C\u00e1c s\u1ed1 nguy\u00ean \u0111\u1ed1i x\u1ee9ng l\u00e0 1, 2, 3. Trong \u0111\u00f3 c\u00f3 m\u1ed9t s\u1ed1 ch\u1eb5n v\u00e0 hai s\u1ed1 l\u1ebb.\n\n    V\u00ed d\u1ee5 2:\n\n        \u0110\u1ea7u v\u00e0o: 12\n        \u0110\u1ea7u ra:\n        Gi\u1ea3i th\u00edch:\n        C\u00e1c s\u1ed1 nguy\u00ean \u0111\u1ed1i x\u1ee9ng l\u00e0 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Trong \u0111\u00f3 c\u00f3 b\u1ed1n s\u1ed1 ch\u1eb5n v\u00e0 s\u00e1u s\u1ed1 l\u1ebb.\n\n    L\u01b0u \u00fd:\n        1. 1 <= n <= 10^3\n        2. B\u1ed9 gi\u00e1 tr\u1ecb tr\u1ea3 v\u1ec1 s\u1ebd ch\u1ee9a s\u1ed1 l\u01b0\u1ee3ng c\u00e1c s\u1ed1 nguy\u00ean \u0111\u1ed1i x\u1ee9ng ch\u1eb5n v\u00e0 l\u1ebb theo th\u1ee9 t\u1ef1 t\u01b0\u01a1ng \u1ee9ng.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Vi\u1ebft m\u1ed9t h\u00e0m `count_nums` nh\u1eadn m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1 nguy\u00ean v\u00e0 tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng ph\u1ea7n t\u1eed c\u00f3 t\u1ed5ng c\u00e1c ch\u1eef s\u1ed1 l\u1edbn h\u01a1n 0.\nN\u1ebfu m\u1ed9t s\u1ed1 l\u00e0 s\u1ed1 \u00e2m, th\u00ec ch\u1eef s\u1ed1 \u0111\u1ea7u ti\u00ean c\u00f3 d\u1ea5u s\u1ebd l\u00e0 s\u1ed1 \u00e2m:\nV\u00ed d\u1ee5: -123 c\u00f3 c\u00e1c ch\u1eef s\u1ed1 c\u00f3 d\u1ea5u l\u00e0 -1, 2 v\u00e0 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Ch\u00fang ta c\u00f3 m\u1ed9t m\u1ea3ng 'arr' g\u1ed3m N s\u1ed1 nguy\u00ean arr[1], arr[2], ..., arr[N]. C\u00e1c s\u1ed1 trong m\u1ea3ng s\u1ebd \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp ng\u1eabu nhi\u00ean. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 x\u00e1c \u0111\u1ecbnh xem c\u00f3 th\u1ec3 s\u1eafp x\u1ebfp m\u1ea3ng theo th\u1ee9 t\u1ef1 kh\u00f4ng gi\u1ea3m b\u1eb1ng c\u00e1ch th\u1ef1c hi\u1ec7n thao t\u00e1c sau tr\u00ean m\u1ea3ng \u0111\u00e3 cho hay kh\u00f4ng:\n    B\u1ea1n \u0111\u01b0\u1ee3c ph\u00e9p th\u1ef1c hi\u1ec7n thao t\u00e1c d\u1ecbch ph\u1ea3i b\u1ea5t k\u1ef3 s\u1ed1 l\u1ea7n n\u00e0o.\n\nM\u1ed9t thao t\u00e1c d\u1ecbch ph\u1ea3i c\u00f3 ngh\u0129a l\u00e0 d\u1ecbch chuy\u1ec3n t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a m\u1ea3ng sang m\u1ed9t v\u1ecb tr\u00ed theo h\u01b0\u1edbng ph\u1ea3i. Ph\u1ea7n t\u1eed cu\u1ed1i c\u00f9ng c\u1ee7a m\u1ea3ng s\u1ebd \u0111\u01b0\u1ee3c chuy\u1ec3n \u0111\u1ebfn v\u1ecb tr\u00ed b\u1eaft \u0111\u1ea7u c\u1ee7a m\u1ea3ng, t\u1ee9c l\u00e0 ch\u1ec9 s\u1ed1 0.\n\nN\u1ebfu c\u00f3 th\u1ec3 s\u1eafp x\u1ebfp m\u1ea3ng theo th\u1ee9 t\u1ef1 kh\u00f4ng gi\u1ea3m b\u1eb1ng c\u00e1ch th\u1ef1c hi\u1ec7n thao t\u00e1c tr\u00ean th\u00ec tr\u1ea3 v\u1ec1 True, ng\u01b0\u1ee3c l\u1ea1i tr\u1ea3 v\u1ec1 False.\nN\u1ebfu m\u1ea3ng \u0111\u00e3 cho l\u00e0 tr\u1ed1ng th\u00ec tr\u1ea3 v\u1ec1 True.\n\nL\u01b0u \u00fd: Danh s\u00e1ch \u0111\u00e3 cho \u0111\u01b0\u1ee3c \u0111\u1ea3m b\u1ea3o c\u00f3 c\u00e1c ph\u1ea7n t\u1eed duy nh\u1ea5t.\n\nV\u00ed d\u1ee5:\n\nmove_one_ball ==> True\nGi\u1ea3i th\u00edch: B\u1eb1ng c\u00e1ch th\u1ef1c hi\u1ec7n 2 thao t\u00e1c d\u1ecbch ph\u1ea3i, c\u00f3 th\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c th\u1ee9 t\u1ef1 kh\u00f4ng gi\u1ea3m cho m\u1ea3ng \u0111\u00e3 cho.\nmove_one_ball ==> False\nGi\u1ea3i th\u00edch: Kh\u00f4ng th\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c th\u1ee9 t\u1ef1 kh\u00f4ng gi\u1ea3m cho m\u1ea3ng \u0111\u00e3 cho b\u1eb1ng c\u00e1ch th\u1ef1c hi\u1ec7n b\u1ea5t k\u1ef3 s\u1ed1 l\u1ea7n d\u1ecbch ph\u1ea3i n\u00e0o.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Trong b\u00e0i to\u00e1n n\u00e0y, b\u1ea1n s\u1ebd tri\u1ec3n khai m\u1ed9t h\u00e0m nh\u1eadn hai danh s\u00e1ch c\u00e1c s\u1ed1 v\u00e0 x\u00e1c \u0111\u1ecbnh xem li\u1ec7u c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n trao \u0111\u1ed5i c\u00e1c ph\u1ea7n t\u1eed gi\u1eefa ch\u00fang \u0111\u1ec3 bi\u1ebfn lst1 th\u00e0nh m\u1ed9t danh s\u00e1ch ch\u1ec9 g\u1ed3m c\u00e1c s\u1ed1 ch\u1eb5n hay kh\u00f4ng. Kh\u00f4ng c\u00f3 gi\u1edbi h\u1ea1n v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng ph\u1ea7n t\u1eed \u0111\u01b0\u1ee3c trao \u0111\u1ed5i gi\u1eefa lst1 v\u00e0 lst2. N\u1ebfu c\u00f3 th\u1ec3 trao \u0111\u1ed5i c\u00e1c ph\u1ea7n t\u1eed gi\u1eefa lst1 v\u00e0 lst2 \u0111\u1ec3 t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a lst1 \u0111\u1ec1u ch\u1eb5n, tr\u1ea3 v\u1ec1 \"C\u00d3\". Ng\u01b0\u1ee3c l\u1ea1i, tr\u1ea3 v\u1ec1 \"KH\u00d4NG\". V\u00ed d\u1ee5:\nexchange => \"C\u00d3\"\nexchange => \"KH\u00d4NG\"\nGi\u1ea3 s\u1eed r\u1eb1ng c\u00e1c danh s\u00e1ch \u0111\u1ea7u v\u00e0o s\u1ebd kh\u00f4ng r\u1ed7ng.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Cho m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho c\u00e1c ch\u1eef c\u00e1i vi\u1ebft th\u01b0\u1eddng \u0111\u01b0\u1ee3c ph\u00e2n t\u00e1ch b\u1eb1ng d\u1ea5u c\u00e1ch, tr\u1ea3 v\u1ec1 m\u1ed9t t\u1eeb \u0111i\u1ec3n\n    c\u1ee7a ch\u1eef c\u00e1i c\u00f3 s\u1ed1 l\u1ea7n l\u1eb7p l\u1ea1i nhi\u1ec1u nh\u1ea5t v\u00e0 ch\u1ee9a s\u1ed1 l\u1ea7n t\u01b0\u01a1ng \u1ee9ng.\n    N\u1ebfu nhi\u1ec1u ch\u1eef c\u00e1i c\u00f3 s\u1ed1 l\u1ea7n xu\u1ea5t hi\u1ec7n b\u1eb1ng nhau, tr\u1ea3 v\u1ec1 t\u1ea5t c\u1ea3 ch\u00fang.\n    \n    V\u00ed d\u1ee5:\n    histogram == {'a': 1, 'b': 1, 'c': 1}\n    histogram == {'a': 2, 'b': 2}\n    histogram == {'a': 2, 'b': 2}\n    histogram == {'b': 4}\n    histogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Nhi\u1ec7m v\u1ee5\n    Ch\u00fang ta c\u00f3 hai chu\u1ed7i s v\u00e0 c, b\u1ea1n ph\u1ea3i x\u00f3a t\u1ea5t c\u1ea3 c\u00e1c k\u00fd t\u1ef1 trong s m\u00e0 b\u1eb1ng b\u1ea5t k\u1ef3 k\u00fd t\u1ef1 n\u00e0o trong c, sau \u0111\u00f3 ki\u1ec3m tra xem chu\u1ed7i k\u1ebft qu\u1ea3 c\u00f3 ph\u1ea3i l\u00e0 chu\u1ed7i \u0111\u1ed1i x\u1ee9ng hay kh\u00f4ng.\n    M\u1ed9t chu\u1ed7i \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 chu\u1ed7i \u0111\u1ed1i x\u1ee9ng n\u1ebfu n\u00f3 \u0111\u1ecdc gi\u1ed1ng nhau t\u1eeb tr\u00e1i sang ph\u1ea3i v\u00e0 t\u1eeb ph\u1ea3i sang tr\u00e1i.\n    B\u1ea1n n\u00ean tr\u1ea3 v\u1ec1 m\u1ed9t tuple ch\u1ee9a chu\u1ed7i k\u1ebft qu\u1ea3 v\u00e0 True\/False cho vi\u1ec7c ki\u1ec3m tra.\n    V\u00ed d\u1ee5\n    V\u1edbi s = \"abcde\", c = \"ae\", k\u1ebft qu\u1ea3 s\u1ebd l\u00e0\n    V\u1edbi s = \"abcdef\", c = \"b\", k\u1ebft qu\u1ea3 s\u1ebd l\u00e0\n    V\u1edbi s = \"abcdedcba\", c = \"ab\", k\u1ebft qu\u1ea3 s\u1ebd l\u00e0\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"D\u01b0\u1edbi \u0111\u00e2y l\u00e0 danh s\u00e1ch c\u00e1c chu\u1ed7i, m\u1ed7i chu\u1ed7i ch\u1ec9 bao g\u1ed3m c\u00e1c ch\u1eef s\u1ed1, tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch.\n    M\u1ed7i ph\u1ea7n t\u1eed i c\u1ee7a \u0111\u1ea7u ra n\u00ean l\u00e0 \"s\u1ed1 l\u01b0\u1ee3ng ph\u1ea7n t\u1eed l\u1ebb trong chu\u1ed7i i c\u1ee7a \u0111\u1ea7u v\u00e0o\"\n    trong \u0111\u00f3 t\u1ea5t c\u1ea3 c\u00e1c i n\u00ean \u0111\u01b0\u1ee3c thay th\u1ebf b\u1eb1ng s\u1ed1 l\u01b0\u1ee3ng ch\u1eef s\u1ed1 l\u1ebb trong chu\u1ed7i th\u1ee9 i c\u1ee7a \u0111\u1ea7u v\u00e0o.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Cho m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1 nguy\u00ean nums, h\u00e3y t\u00ecm t\u1ed5ng nh\u1ecf nh\u1ea5t c\u1ee7a b\u1ea5t k\u1ef3 m\u1ea3ng con kh\u00f4ng r\u1ed7ng n\u00e0o c\u1ee7a nums.\n    V\u00ed d\u1ee5\n    minSubArraySum == 1\n    minSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t l\u01b0\u1edbi h\u00ecnh ch\u1eef nh\u1eadt c\u1ee7a c\u00e1c gi\u1ebfng. M\u1ed7i h\u00e0ng \u0111\u1ea1i di\u1ec7n cho m\u1ed9t gi\u1ebfng, v\u00e0 m\u1ed7i s\u1ed1 1 trong m\u1ed9t h\u00e0ng \u0111\u1ea1i di\u1ec7n cho m\u1ed9t \u0111\u01a1n v\u1ecb n\u01b0\u1edbc. M\u1ed7i gi\u1ebfng c\u00f3 m\u1ed9t x\u00f4 t\u01b0\u01a1ng \u1ee9ng c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 l\u1ea5y n\u01b0\u1edbc t\u1eeb gi\u1ebfng \u0111\u00f3, v\u00e0 t\u1ea5t c\u1ea3 c\u00e1c x\u00f4 \u0111\u1ec1u c\u00f3 c\u00f9ng dung t\u00edch. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 s\u1eed d\u1ee5ng c\u00e1c x\u00f4 \u0111\u1ec3 l\u00e0m c\u1ea1n c\u00e1c gi\u1ebfng. H\u00e3y xu\u1ea5t ra s\u1ed1 l\u1ea7n b\u1ea1n c\u1ea7n h\u1ea1 x\u00f4 xu\u1ed1ng.\n\nV\u00ed d\u1ee5 1:\n    \u0110\u1ea7u v\u00e0o:\n        l\u01b0\u1edbi: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        dung t\u00edch x\u00f4: 1\n    \u0110\u1ea7u ra: 6\n\nV\u00ed d\u1ee5 2:\n    \u0110\u1ea7u v\u00e0o:\n        l\u01b0\u1edbi: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        dung t\u00edch x\u00f4: 2\n    \u0110\u1ea7u ra: 5\n\nV\u00ed d\u1ee5 3:\n    \u0110\u1ea7u v\u00e0o:\n        l\u01b0\u1edbi: [[0,0,0], [0,0,0]]\n        dung t\u00edch x\u00f4: 5\n    \u0110\u1ea7u ra: 0\n\nR\u00e0ng bu\u1ed9c:\n    * t\u1ea5t c\u1ea3 c\u00e1c gi\u1ebfng \u0111\u1ec1u c\u00f3 c\u00f9ng chi\u1ec1u d\u00e0i\n    * 1 <= chi\u1ec1u d\u00e0i l\u01b0\u1edbi <= 10^2\n    * 1 <= chi\u1ec1u d\u00e0i c\u1ee7a m\u1ed7i h\u00e0ng trong l\u01b0\u1edbi <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= dung t\u00edch <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Trong b\u00e0i Kata n\u00e0y, b\u1ea1n ph\u1ea3i s\u1eafp x\u1ebfp m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m theo s\u1ed1 l\u01b0\u1ee3ng s\u1ed1 m\u1ed9t trong bi\u1ec3u di\u1ec5n nh\u1ecb ph\u00e2n c\u1ee7a ch\u00fang theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n. \u0110\u1ed1i v\u1edbi nh\u1eefng s\u1ed1 c\u00f3 c\u00f9ng s\u1ed1 l\u01b0\u1ee3ng s\u1ed1 m\u1ed9t, s\u1eafp x\u1ebfp d\u1ef1a tr\u00ean gi\u00e1 tr\u1ecb th\u1eadp ph\u00e2n.\n\nN\u00f3 ph\u1ea3i \u0111\u01b0\u1ee3c tri\u1ec3n khai nh\u01b0 th\u1ebf n\u00e0y:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Cho m\u1ed9t chu\u1ed7i s v\u00e0 m\u1ed9t s\u1ed1 t\u1ef1 nhi\u00ean n, b\u1ea1n \u0111\u01b0\u1ee3c giao nhi\u1ec7m v\u1ee5 tri\u1ec3n khai \nm\u1ed9t h\u00e0m tr\u1ea3 v\u1ec1 danh s\u00e1ch t\u1ea5t c\u1ea3 c\u00e1c t\u1eeb t\u1eeb chu\u1ed7i s c\u00f3 ch\u1ee9a ch\u00ednh x\u00e1c \nn ph\u1ee5 \u00e2m, theo th\u1ee9 t\u1ef1 c\u00e1c t\u1eeb xu\u1ea5t hi\u1ec7n trong chu\u1ed7i s.\nN\u1ebfu chu\u1ed7i s tr\u1ed1ng th\u00ec h\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch tr\u1ed1ng.\nL\u01b0u \u00fd: b\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh chu\u1ed7i \u0111\u1ea7u v\u00e0o ch\u1ec9 ch\u1ee9a c\u00e1c ch\u1eef c\u00e1i v\u00e0 d\u1ea5u c\u00e1ch.\nV\u00ed d\u1ee5:\nselect_words ==> [\"little\"]\nselect_words ==> [\"Mary\", \"lamb\"]\nselect_words ==> []\nselect_words ==> [\"world\"]\nselect_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t t\u1eeb. Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 t\u00ecm nguy\u00ean \u00e2m g\u1ea7n nh\u1ea5t n\u1eb1m gi\u1eefa hai ph\u1ee5 \u00e2m t\u1eeb ph\u00eda b\u00ean ph\u1ea3i c\u1ee7a t\u1eeb.\n\nNguy\u00ean \u00e2m \u1edf \u0111\u1ea7u v\u00e0 cu\u1ed1i kh\u00f4ng \u0111\u01b0\u1ee3c t\u00ednh. Tr\u1ea3 v\u1ec1 chu\u1ed7i r\u1ed7ng n\u1ebfu b\u1ea1n kh\u00f4ng t\u00ecm th\u1ea5y b\u1ea5t k\u1ef3 nguy\u00ean \u00e2m n\u00e0o \u0111\u00e1p \u1ee9ng \u0111i\u1ec1u ki\u1ec7n tr\u00ean.\n\nB\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng chu\u1ed7i \u0111\u01b0\u1ee3c cung c\u1ea5p ch\u1ec9 ch\u1ee9a c\u00e1c ch\u1eef c\u00e1i ti\u1ebfng Anh.\n\nV\u00ed d\u1ee5:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Cho m\u1ed9t m\u1ea3ng arr g\u1ed3m c\u00e1c s\u1ed1 nguy\u00ean v\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng k, h\u00e3y tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch \u0111\u00e3 s\u1eafp x\u1ebfp g\u1ed3m k s\u1ed1 l\u1edbn nh\u1ea5t trong arr.\n\nV\u00ed d\u1ee5 1:\n\n    \u0110\u1ea7u v\u00e0o: arr = [-3, -4, 5], k = 3\n    \u0110\u1ea7u ra: [-4, -3, 5]\n\nV\u00ed d\u1ee5 2:\n\n    \u0110\u1ea7u v\u00e0o: arr = [4, -4, 4], k = 2\n    \u0110\u1ea7u ra: [4, 4]\n\nV\u00ed d\u1ee5 3:\n\n    \u0110\u1ea7u v\u00e0o: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    \u0110\u1ea7u ra: [2]\n\nL\u01b0u \u00fd:\n    1. \u0110\u1ed9 d\u00e0i c\u1ee7a m\u1ea3ng s\u1ebd n\u1eb1m trong kho\u1ea3ng t\u1eeb [1, 1000].\n    2. C\u00e1c ph\u1ea7n t\u1eed trong m\u1ea3ng s\u1ebd n\u1eb1m trong kho\u1ea3ng t\u1eeb [-1000, 1000].\n    3. 0 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Cho m\u1ed9t danh s\u00e1ch kh\u00f4ng r\u1ed7ng g\u1ed3m c\u00e1c s\u1ed1 nguy\u00ean, tr\u1ea3 v\u1ec1 t\u1ed5ng c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed l\u1ebb n\u1eb1m \u1edf c\u00e1c v\u1ecb tr\u00ed ch\u1eb5n.\n\n    V\u00ed d\u1ee5:\n    solution ==> 12\n    solution ==> 9\n    solution ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Cho m\u1ed9t m\u1ea3ng s\u1ed1 nguy\u00ean kh\u00f4ng r\u1ed7ng arr v\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean k, h\u00e3y tr\u1ea3 v\u1ec1 t\u1ed5ng \n    c\u1ee7a c\u00e1c ph\u1ea7n t\u1eed c\u00f3 t\u1ed1i \u0111a hai ch\u1eef s\u1ed1 t\u1eeb k ph\u1ea7n t\u1eed \u0111\u1ea7u ti\u00ean c\u1ee7a arr.\n\n    V\u00ed d\u1ee5:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # t\u1ed5ng c\u1ee7a 21 + 3\n\n    R\u00e0ng bu\u1ed9c:\n        1. 1 <= \u0111\u1ed9 d\u00e0i c\u1ee7a arr <= 100\n        2. 1 <= k <= \u0111\u1ed9 d\u00e0i c\u1ee7a arr\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp ch\u1ee9a c\u00e1c s\u1ed1 l\u1ebb trong chu\u1ed7i Collatz.\n\n    Gi\u1ea3 thuy\u1ebft Collatz l\u00e0 m\u1ed9t gi\u1ea3 thuy\u1ebft trong to\u00e1n h\u1ecdc li\u00ean quan \u0111\u1ebfn m\u1ed9t chu\u1ed7i \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a \n    nh\u01b0 sau: b\u1eaft \u0111\u1ea7u v\u1edbi b\u1ea5t k\u1ef3 s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n n\u00e0o. M\u1ed7i s\u1ed1 h\u1ea1ng sau \u0111\u00f3 \u0111\u01b0\u1ee3c l\u1ea5y t\u1eeb s\u1ed1 h\u1ea1ng \n    tr\u01b0\u1edbc \u0111\u00f3 nh\u01b0 sau: n\u1ebfu s\u1ed1 h\u1ea1ng tr\u01b0\u1edbc l\u00e0 s\u1ed1 ch\u1eb5n, s\u1ed1 h\u1ea1ng ti\u1ebfp theo l\u00e0 m\u1ed9t n\u1eeda c\u1ee7a s\u1ed1 h\u1ea1ng \n    tr\u01b0\u1edbc. N\u1ebfu s\u1ed1 h\u1ea1ng tr\u01b0\u1edbc l\u00e0 s\u1ed1 l\u1ebb, s\u1ed1 h\u1ea1ng ti\u1ebfp theo l\u00e0 3 l\u1ea7n s\u1ed1 h\u1ea1ng tr\u01b0\u1edbc c\u1ed9ng v\u1edbi 1. Gi\u1ea3 thuy\u1ebft \n    cho r\u1eb1ng b\u1ea5t k\u1ec3 gi\u00e1 tr\u1ecb c\u1ee7a n l\u00e0 g\u00ec, chu\u1ed7i s\u1ebd lu\u00f4n \u0111\u1ea1t \u0111\u1ebfn 1.\n\n    L\u01b0u \u00fd: \n        1. Collatz l\u00e0 [1].\n        2. danh s\u00e1ch tr\u1ea3 v\u1ec1 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n.\n\n    V\u00ed d\u1ee5:\n    get_odd_collatz tr\u1ea3 v\u1ec1 [1, 5] # Chu\u1ed7i Collatz cho 5 l\u00e0 [5, 16, 8, 4, 2, 1], v\u00ec v\u1eady c\u00e1c s\u1ed1 l\u1ebb ch\u1ec9 c\u00f3 1 v\u00e0 5.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"B\u1ea1n ph\u1ea3i vi\u1ebft m\u1ed9t h\u00e0m \u0111\u1ec3 x\u00e1c th\u1ef1c m\u1ed9t chu\u1ed7i ng\u00e0y cho tr\u01b0\u1edbc v\u00e0 tr\u1ea3 v\u1ec1 True n\u1ebfu ng\u00e0y h\u1ee3p l\u1ec7, ng\u01b0\u1ee3c l\u1ea1i tr\u1ea3 v\u1ec1 False. Ng\u00e0y \u0111\u01b0\u1ee3c cho l\u00e0 h\u1ee3p l\u1ec7 n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c quy t\u1eafc sau \u0111\u00e2y \u0111\u01b0\u1ee3c th\u1ecfa m\u00e3n:\n1. Chu\u1ed7i ng\u00e0y kh\u00f4ng \u0111\u01b0\u1ee3c r\u1ed7ng.\n2. S\u1ed1 ng\u00e0y kh\u00f4ng \u0111\u01b0\u1ee3c nh\u1ecf h\u01a1n 1 ho\u1eb7c l\u1edbn h\u01a1n 31 cho c\u00e1c th\u00e1ng 1, 3, 5, 7, 8, 10, 12. V\u00e0 s\u1ed1 ng\u00e0y kh\u00f4ng \u0111\u01b0\u1ee3c nh\u1ecf h\u01a1n 1 ho\u1eb7c l\u1edbn h\u01a1n 30 cho c\u00e1c th\u00e1ng 4, 6, 9, 11. V\u00e0, s\u1ed1 ng\u00e0y kh\u00f4ng \u0111\u01b0\u1ee3c nh\u1ecf h\u01a1n 1 ho\u1eb7c l\u1edbn h\u01a1n 29 cho th\u00e1ng 2.\n3. C\u00e1c th\u00e1ng kh\u00f4ng \u0111\u01b0\u1ee3c nh\u1ecf h\u01a1n 1 ho\u1eb7c l\u1edbn h\u01a1n 12.\n4. Ng\u00e0y ph\u1ea3i \u1edf \u0111\u1ecbnh d\u1ea1ng: mm-dd-yyyy.\n\nV\u00ed d\u1ee5:\nvalid_date => True\n\nvalid_date => False\n\nvalid_date => False\n\nvalid_date => True\n\nvalid_date => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cho hai \u0111o\u1ea1n,\n    m\u1ed7i \u0111o\u1ea1n l\u00e0 m\u1ed9t c\u1eb7p s\u1ed1 nguy\u00ean. V\u00ed d\u1ee5, \u0111o\u1ea1n = =.\n    C\u00e1c \u0111o\u1ea1n \u0111\u00e3 cho l\u00e0 \u0111o\u1ea1n \u0111\u00f3ng, ngh\u0129a l\u00e0 \u0111o\u1ea1n\n    bao g\u1ed3m c\u1ea3 b\u1eaft \u0111\u1ea7u v\u00e0 k\u1ebft th\u00fac.\n    \u0110\u1ed1i v\u1edbi m\u1ed7i \u0111o\u1ea1n \u0111\u00e3 cho, gi\u1ea3 s\u1eed r\u1eb1ng b\u1eaft \u0111\u1ea7u nh\u1ecf h\u01a1n ho\u1eb7c b\u1eb1ng k\u1ebft th\u00fac.\n    Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 x\u00e1c \u0111\u1ecbnh xem \u0111\u1ed9 d\u00e0i giao c\u1ee7a hai \u0111o\u1ea1n n\u00e0y\n    c\u00f3 ph\u1ea3i l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1 hay kh\u00f4ng.\n    V\u00ed d\u1ee5, giao c\u1ee7a c\u00e1c \u0111o\u1ea1n, l\u00e0\n    v\u1edbi \u0111\u1ed9 d\u00e0i l\u00e0 1, kh\u00f4ng ph\u1ea3i l\u00e0 s\u1ed1 nguy\u00ean t\u1ed1.\n    N\u1ebfu \u0111\u1ed9 d\u00e0i c\u1ee7a giao l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1, tr\u1ea3 v\u1ec1 \"C\u00d3\",\n    n\u1ebfu kh\u00f4ng, tr\u1ea3 v\u1ec1 \"KH\u00d4NG\".\n    N\u1ebfu hai \u0111o\u1ea1n kh\u00f4ng giao nhau, tr\u1ea3 v\u1ec1 \"KH\u00d4NG\".\n\n    [m\u1eabu \u0111\u1ea7u v\u00e0o\/\u0111\u1ea7u ra]:\n    giao,) ==> \"KH\u00d4NG\"\n    giao,) ==> \"KH\u00d4NG\"\n    giao,) ==> \"C\u00d3\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t m\u1ea3ng arr g\u1ed3m c\u00e1c s\u1ed1 nguy\u00ean v\u00e0 b\u1ea1n c\u1ea7n tr\u1ea3 v\u1ec1\n    t\u1ed5ng \u0111\u1ed9 l\u1edbn c\u1ee7a c\u00e1c s\u1ed1 nguy\u00ean nh\u00e2n v\u1edbi t\u00edch c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c d\u1ea5u\n    c\u1ee7a m\u1ed7i s\u1ed1 trong m\u1ea3ng, \u0111\u01b0\u1ee3c bi\u1ec3u di\u1ec5n b\u1edfi 1, -1 ho\u1eb7c 0.\n    L\u01b0u \u00fd: tr\u1ea3 v\u1ec1 None n\u1ebfu m\u1ea3ng tr\u1ed1ng.\n\n    V\u00ed d\u1ee5:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Cho m\u1ed9t l\u01b0\u1edbi c\u00f3 N h\u00e0ng v\u00e0 N c\u1ed9t v\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng k,\n    m\u1ed7i \u00f4 c\u1ee7a l\u01b0\u1edbi ch\u1ee9a m\u1ed9t gi\u00e1 tr\u1ecb. M\u1ed7i s\u1ed1 nguy\u00ean trong ph\u1ea1m vi [1, N * N]\n    \u0111\u1ec1u xu\u1ea5t hi\u1ec7n \u0111\u00fang m\u1ed9t l\u1ea7n trong c\u00e1c \u00f4 c\u1ee7a l\u01b0\u1edbi.\n\n    B\u1ea1n ph\u1ea3i t\u00ecm \u0111\u01b0\u1eddng \u0111i ng\u1eafn nh\u1ea5t c\u00f3 \u0111\u1ed9 d\u00e0i k trong l\u01b0\u1edbi. B\u1ea1n c\u00f3 th\u1ec3 b\u1eaft \u0111\u1ea7u\n    t\u1eeb b\u1ea5t k\u1ef3 \u00f4 n\u00e0o, v\u00e0 trong m\u1ed7i b\u01b0\u1edbc, b\u1ea1n c\u00f3 th\u1ec3 di chuy\u1ec3n \u0111\u1ebfn b\u1ea5t k\u1ef3 \u00f4 n\u00e0o l\u00e2n c\u1eadn,\n    n\u00f3i c\u00e1ch kh\u00e1c, b\u1ea1n c\u00f3 th\u1ec3 \u0111i \u0111\u1ebfn c\u00e1c \u00f4 c\u00f3 chung m\u1ed9t c\u1ea1nh v\u1edbi \u00f4 hi\u1ec7n t\u1ea1i c\u1ee7a b\u1ea1n.\n    Xin l\u01b0u \u00fd r\u1eb1ng m\u1ed9t \u0111\u01b0\u1eddng \u0111i c\u00f3 \u0111\u1ed9 d\u00e0i k c\u00f3 ngh\u0129a l\u00e0 \u0111i th\u0103m \u0111\u00fang k \u00f4 (kh\u00f4ng nh\u1ea5t thi\u1ebft\n    ph\u1ea3i kh\u00e1c nhau).\n    B\u1ea1n KH\u00d4NG th\u1ec3 \u0111i ra ngo\u00e0i l\u01b0\u1edbi.\n    M\u1ed9t \u0111\u01b0\u1eddng \u0111i A \u0111\u01b0\u1ee3c coi l\u00e0 nh\u1ecf h\u01a1n m\u1ed9t \u0111\u01b0\u1eddng \u0111i B n\u1ebfu\n    sau khi t\u1ea1o danh s\u00e1ch c\u00f3 th\u1ee9 t\u1ef1 c\u00e1c gi\u00e1 tr\u1ecb tr\u00ean c\u00e1c \u00f4 m\u00e0 A v\u00e0 B \u0111i qua, lst_A nh\u1ecf h\u01a1n lst_B theo th\u1ee9 t\u1ef1 t\u1eeb \u0111i\u1ec3n, ngh\u0129a l\u00e0 t\u1ed3n t\u1ea1i m\u1ed9t ch\u1ec9 s\u1ed1 nguy\u00ean i\n    sao cho lst_A[i] < lst_B[i] v\u00e0 \u0111\u1ed1i v\u1edbi b\u1ea5t k\u1ef3 j n\u00e0o ch\u00fang ta c\u00f3\n    lst_A[j] = lst_B[j].\n    \u0110\u1ea3m b\u1ea3o r\u1eb1ng c\u00e2u tr\u1ea3 l\u1eddi l\u00e0 duy nh\u1ea5t.\n    Tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch c\u00f3 th\u1ee9 t\u1ef1 c\u00e1c gi\u00e1 tr\u1ecb tr\u00ean c\u00e1c \u00f4 m\u00e0 \u0111\u01b0\u1eddng \u0111i ng\u1eafn nh\u1ea5t \u0111i qua.\n\n    V\u00ed d\u1ee5:\n\n        \u0110\u1ea7u v\u00e0o: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        \u0110\u1ea7u ra: [1, 2, 1]\n\n        \u0110\u1ea7u v\u00e0o: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        \u0110\u1ea7u ra: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Ai c\u0169ng bi\u1ebft v\u1ec1 d\u00e3y Fibonacci, n\u00f3 \u0111\u00e3 \u0111\u01b0\u1ee3c nghi\u00ean c\u1ee9u k\u1ef9 l\u01b0\u1ee1ng b\u1edfi c\u00e1c nh\u00e0 to\u00e1n h\u1ecdc trong v\u00e0i th\u1ebf k\u1ef7 qua. Tuy nhi\u00ean, \u0111i\u1ec1u m\u00e0 m\u1ecdi ng\u01b0\u1eddi kh\u00f4ng bi\u1ebft l\u00e0 d\u00e3y Tribonacci. \n\nD\u00e3y Tribonacci \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a b\u1edfi c\u00f4ng th\u1ee9c truy h\u1ed3i nh\u01b0 sau:\n- tri = 3\n- tri = 1 + n \/ 2, n\u1ebfu n l\u00e0 s\u1ed1 ch\u1eb5n.\n- tri = tri + tri + tri, n\u1ebfu n l\u00e0 s\u1ed1 l\u1ebb.\n\nV\u00ed d\u1ee5:\n- tri = 1 + = 2\n- tri = 3\n- tri = tri + tri + tri\n          = 2 + 3 + 3 = 8 \n\nB\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m n, b\u1ea1n ph\u1ea3i tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch g\u1ed3m n + 1 s\u1ed1 \u0111\u1ea7u ti\u00ean c\u1ee7a d\u00e3y Tribonacci.\n\nV\u00ed d\u1ee5:\n- tri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n, tr\u1ea3 v\u1ec1 t\u00edch c\u1ee7a c\u00e1c ch\u1eef s\u1ed1 l\u1ebb.\n    Tr\u1ea3 v\u1ec1 0 n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c ch\u1eef s\u1ed1 \u0111\u1ec1u l\u00e0 s\u1ed1 ch\u1eb5n.\n    V\u00ed d\u1ee5:\n    digits == 1\n    digits == 0\n    digits == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1.\n    B\u1ea1n c\u1ea7n tr\u1ea3 v\u1ec1 t\u1ed5ng c\u1ee7a c\u00e1c s\u1ed1 b\u00ecnh ph\u01b0\u01a1ng trong danh s\u00e1ch \u0111\u00e3 cho,\n    l\u00e0m tr\u00f2n m\u1ed7i ph\u1ea7n t\u1eed trong danh s\u00e1ch l\u00ean s\u1ed1 nguy\u00ean g\u1ea7n nh\u1ea5t tr\u01b0\u1edbc.\n    V\u00ed d\u1ee5:\n    V\u1edbi lst = [1,2,3] \u0111\u1ea7u ra s\u1ebd l\u00e0 14\n    V\u1edbi lst = [1,4,9] \u0111\u1ea7u ra s\u1ebd l\u00e0 98\n    V\u1edbi lst = [1,3,5,7] \u0111\u1ea7u ra s\u1ebd l\u00e0 84\n    V\u1edbi lst = [1.4,4.2,0] \u0111\u1ea7u ra s\u1ebd l\u00e0 29\n    V\u1edbi lst = [-2.4,1,1] \u0111\u1ea7u ra s\u1ebd l\u00e0 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"T\u1ea1o m\u1ed9t h\u00e0m tr\u1ea3 v\u1ec1 ch\u1ec9 s\u1ed1 l\u1edbn nh\u1ea5t c\u1ee7a m\u1ed9t ph\u1ea7n t\u1eed kh\u00f4ng l\u1edbn h\u01a1n ho\u1eb7c b\u1eb1ng ph\u1ea7n t\u1eed ngay tr\u01b0\u1edbc n\u00f3. N\u1ebfu kh\u00f4ng c\u00f3 ph\u1ea7n t\u1eed n\u00e0o nh\u01b0 v\u1eady th\u00ec tr\u1ea3 v\u1ec1 -1. M\u1ea3ng \u0111\u01b0\u1ee3c cho s\u1ebd kh\u00f4ng ch\u1ee9a c\u00e1c gi\u00e1 tr\u1ecb tr\u00f9ng l\u1eb7p.\n\nV\u00ed d\u1ee5:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    T\u1ea1o m\u1ed9t h\u00e0m nh\u1eadn v\u00e0o c\u00e1c s\u1ed1 nguy\u00ean, s\u1ed1 th\u1ef1c, ho\u1eb7c chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho c\u00e1c s\u1ed1 th\u1ef1c, v\u00e0 tr\u1ea3 v\u1ec1 bi\u1ebfn l\u1edbn h\u01a1n trong ki\u1ec3u bi\u1ebfn \u0111\u00e3 cho. Tr\u1ea3 v\u1ec1 None n\u1ebfu c\u00e1c gi\u00e1 tr\u1ecb b\u1eb1ng nhau. L\u01b0u \u00fd: N\u1ebfu m\u1ed9t s\u1ed1 th\u1ef1c \u0111\u01b0\u1ee3c bi\u1ec3u di\u1ec5n d\u01b0\u1edbi d\u1ea1ng chu\u1ed7i, d\u1ea5u ph\u00e2n c\u00e1ch ph\u1ea7n th\u1eadp ph\u00e2n c\u00f3 th\u1ec3 l\u00e0 . ho\u1eb7c ,\n\ncompare_one \u00e2 -> 2.5\ncompare_one \u00e2 -> \"2,3\"\ncompare_one \u00e2 -> \"6\"\ncompare_one \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"\u0110\u00e1nh gi\u00e1 xem s\u1ed1 \u0111\u00e3 cho n c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c vi\u1ebft d\u01b0\u1edbi d\u1ea1ng t\u1ed5ng c\u1ee7a ch\u00ednh x\u00e1c 4 s\u1ed1 ch\u1eb5n d\u01b0\u01a1ng hay kh\u00f4ng\n    V\u00ed d\u1ee5\n    is_equal_to_sum_even == Sai\n    is_equal_to_sum_even == Sai\n    is_equal_to_sum_even == \u0110\u00fang\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Giai th\u1eeba Brazil \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a nh\u01b0 sau:\n    brazilian_factorial = n! *! *! * ... * 1!\n    trong \u0111\u00f3 n > 0\n\n    V\u00ed d\u1ee5:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    V\u1edbi m\u1ed9t chu\u1ed7i v\u0103n b\u1ea3n, thay th\u1ebf t\u1ea5t c\u1ea3 c\u00e1c d\u1ea5u c\u00e1ch trong \u0111\u00f3 b\u1eb1ng d\u1ea5u g\u1ea1ch d\u01b0\u1edbi, \nv\u00e0 n\u1ebfu m\u1ed9t chu\u1ed7i c\u00f3 h\u01a1n 2 kho\u1ea3ng tr\u1eafng li\u00ean ti\u1ebfp, \nth\u00ec thay th\u1ebf t\u1ea5t c\u1ea3 c\u00e1c kho\u1ea3ng tr\u1eafng li\u00ean ti\u1ebfp b\u1eb1ng m\u1ed9t d\u1ea5u g\u1ea1ch ngang.\n\nfix_spaces == \"Example\"\nfix_spaces == \"Example_1\"\nfix_spaces == \"_Example_2\"\nfix_spaces == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"T\u1ea1o m\u1ed9t h\u00e0m nh\u1eadn m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho t\u00ean t\u1ec7p v\u00e0 tr\u1ea3 v\u1ec1 'Yes' n\u1ebfu t\u00ean t\u1ec7p h\u1ee3p l\u1ec7, v\u00e0 tr\u1ea3 v\u1ec1 'No' n\u1ebfu kh\u00f4ng h\u1ee3p l\u1ec7.\nT\u00ean t\u1ec7p \u0111\u01b0\u1ee3c coi l\u00e0 h\u1ee3p l\u1ec7 n\u1ebfu v\u00e0 ch\u1ec9 n\u1ebfu t\u1ea5t c\u1ea3 c\u00e1c \u0111i\u1ec1u ki\u1ec7n sau \u0111\u01b0\u1ee3c th\u1ecfa m\u00e3n:\n- Kh\u00f4ng \u0111\u01b0\u1ee3c c\u00f3 nhi\u1ec1u h\u01a1n ba ch\u1eef s\u1ed1 trong t\u00ean t\u1ec7p.\n- T\u00ean t\u1ec7p ch\u1ee9a \u0111\u00fang m\u1ed9t d\u1ea5u ch\u1ea5m '.'\n- Chu\u1ed7i con tr\u01b0\u1edbc d\u1ea5u ch\u1ea5m kh\u00f4ng \u0111\u01b0\u1ee3c r\u1ed7ng v\u00e0 b\u1eaft \u0111\u1ea7u b\u1eb1ng m\u1ed9t ch\u1eef c\u00e1i t\u1eeb b\u1ea3ng ch\u1eef c\u00e1i Latin.\n- Chu\u1ed7i con sau d\u1ea5u ch\u1ea5m ph\u1ea3i l\u00e0 m\u1ed9t trong nh\u1eefng chu\u1ed7i sau: ['txt', 'exe', 'dll']\nV\u00ed d\u1ee5:\nfile_name_check # => 'Yes'\nfile_name_check # => 'No'\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"H\u00e0m n\u00e0y s\u1ebd nh\u1eadn v\u00e0o m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean. \u0110\u1ed1i v\u1edbi t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed trong danh s\u00e1ch, h\u00e0m s\u1ebd b\u00ecnh ph\u01b0\u01a1ng ph\u1ea7n t\u1eed n\u1ebfu ch\u1ec9 s\u1ed1 c\u1ee7a n\u00f3 l\u00e0 b\u1ed9i s\u1ed1 c\u1ee7a 3 v\u00e0 s\u1ebd l\u1eadp ph\u01b0\u01a1ng ph\u1ea7n t\u1eed n\u1ebfu ch\u1ec9 s\u1ed1 c\u1ee7a n\u00f3 l\u00e0 b\u1ed9i s\u1ed1 c\u1ee7a 4 v\u00e0 kh\u00f4ng ph\u1ea3i l\u00e0 b\u1ed9i s\u1ed1 c\u1ee7a 3. H\u00e0m s\u1ebd kh\u00f4ng thay \u0111\u1ed5i c\u00e1c ph\u1ea7n t\u1eed trong danh s\u00e1ch c\u00f3 ch\u1ec9 s\u1ed1 kh\u00f4ng ph\u1ea3i l\u00e0 b\u1ed9i s\u1ed1 c\u1ee7a 3 ho\u1eb7c 4. Sau \u0111\u00f3, h\u00e0m s\u1ebd tr\u1ea3 v\u1ec1 t\u1ed5ng c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed trong danh s\u00e1ch.\n\nV\u00ed d\u1ee5:\n\u0110\u1ed1i v\u1edbi lst = [1,2,3] \u0111\u1ea7u ra s\u1ebd l\u00e0 6\n\u0110\u1ed1i v\u1edbi lst = [] \u0111\u1ea7u ra s\u1ebd l\u00e0 0\n\u0110\u1ed1i v\u1edbi lst = [-1,-5,2,-1,-5] \u0111\u1ea7u ra s\u1ebd l\u00e0 -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t chu\u1ed7i \u0111\u1ea1i di\u1ec7n cho m\u1ed9t c\u00e2u,\nc\u00e2u n\u00e0y ch\u1ee9a m\u1ed9t s\u1ed1 t\u1eeb \u0111\u01b0\u1ee3c ng\u0103n c\u00e1ch b\u1eb1ng kho\u1ea3ng tr\u1eafng,\nv\u00e0 b\u1ea1n c\u1ea7n tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i ch\u1ee9a c\u00e1c t\u1eeb t\u1eeb c\u00e2u g\u1ed1c,\nm\u00e0 \u0111\u1ed9 d\u00e0i c\u1ee7a ch\u00fang l\u00e0 c\u00e1c s\u1ed1 nguy\u00ean t\u1ed1,\nth\u1ee9 t\u1ef1 c\u1ee7a c\u00e1c t\u1eeb trong chu\u1ed7i m\u1edbi ph\u1ea3i gi\u1ed1ng v\u1edbi c\u00e2u g\u1ed1c.\n\nV\u00ed d\u1ee5 1:\n    \u0110\u1ea7u v\u00e0o: c\u00e2u = \"This is a test\"\n    \u0110\u1ea7u ra: \"is\"\n\nV\u00ed d\u1ee5 2:\n    \u0110\u1ea7u v\u00e0o: c\u00e2u = \"lets go for swimming\"\n    \u0110\u1ea7u ra: \"go for\"\n\nR\u00e0ng bu\u1ed9c:\n    * 1 <= \u0111\u1ed9 d\u00e0i <= 100\n    * c\u00e2u ch\u1ec9 ch\u1ee9a c\u00e1c ch\u1eef c\u00e1i\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Nhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 tri\u1ec3n khai m\u1ed9t h\u00e0m s\u1ebd \u0111\u01a1n gi\u1ea3n h\u00f3a bi\u1ec3u th\u1ee9c\n    x * n. H\u00e0m tr\u1ea3 v\u1ec1 True n\u1ebfu x * n \u0111\u00e1nh gi\u00e1 th\u00e0nh m\u1ed9t s\u1ed1 nguy\u00ean v\u00e0 False\n    n\u1ebfu kh\u00f4ng. C\u1ea3 x v\u00e0 n \u0111\u1ec1u l\u00e0 bi\u1ec3u di\u1ec5n chu\u1ed7i c\u1ee7a m\u1ed9t ph\u00e2n s\u1ed1 v\u00e0 c\u00f3 \u0111\u1ecbnh d\u1ea1ng sau,\n    <t\u1eed s\u1ed1>\/<m\u1eabu s\u1ed1> n\u01a1i m\u00e0 c\u1ea3 t\u1eed s\u1ed1 v\u00e0 m\u1eabu s\u1ed1 \u0111\u1ec1u l\u00e0 c\u00e1c s\u1ed1 nguy\u00ean d\u01b0\u01a1ng.\n\n    B\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 s\u1eed r\u1eb1ng x v\u00e0 n l\u00e0 c\u00e1c ph\u00e2n s\u1ed1 h\u1ee3p l\u1ec7 v\u00e0 kh\u00f4ng c\u00f3 m\u1eabu s\u1ed1 b\u1eb1ng kh\u00f4ng.\n\n    simplify = True\n    simplify = False\n    simplify = False\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Vi\u1ebft m\u1ed9t h\u00e0m s\u1eafp x\u1ebfp danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean \u0111\u00e3 cho\n    theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n d\u1ef1a tr\u00ean t\u1ed5ng c\u00e1c ch\u1eef s\u1ed1 c\u1ee7a ch\u00fang.\n    L\u01b0u \u00fd: n\u1ebfu c\u00f3 nhi\u1ec1u ph\u1ea7n t\u1eed c\u00f3 t\u1ed5ng c\u00e1c ch\u1eef s\u1ed1 gi\u1ed1ng nhau,\n    s\u1eafp x\u1ebfp ch\u00fang d\u1ef1a tr\u00ean ch\u1ec9 s\u1ed1 c\u1ee7a ch\u00fang trong danh s\u00e1ch g\u1ed1c.\n\n    V\u00ed d\u1ee5:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m nh\u1eadn m\u1ed9t m\u1ea3ng c\u00e1c s\u1ed1 l\u00e0m \u0111\u1ea7u v\u00e0o v\u00e0 tr\u1ea3 v\u1ec1 s\u1ed1 l\u01b0\u1ee3ng ph\u1ea7n t\u1eed trong m\u1ea3ng l\u1edbn h\u01a1n 10 v\u00e0 c\u1ea3 ch\u1eef s\u1ed1 \u0111\u1ea7u ti\u00ean v\u00e0 cu\u1ed1i c\u00f9ng c\u1ee7a s\u1ed1 \u0111\u00f3 \u0111\u1ec1u l\u00e0 s\u1ed1 l\u1ebb.\nV\u00ed d\u1ee5:\nspecialFilter => 1 \nspecialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    B\u1ea1n \u0111\u01b0\u1ee3c cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n. B\u1ea1n ph\u1ea3i t\u1ea1o m\u1ed9t m\u1ea3ng s\u1ed1 nguy\u00ean a c\u00f3 \u0111\u1ed9 d\u00e0i n.\n\u0110\u1ed1i v\u1edbi m\u1ed7i i, gi\u00e1 tr\u1ecb c\u1ee7a a[i] = i * i - i + 1.\nTr\u1ea3 v\u1ec1 s\u1ed1 b\u1ed9 ba c\u1ee7a a m\u00e0 i < j < k, v\u00e0 a[i] + a[j] + a[k] l\u00e0 b\u1ed9i s\u1ed1 c\u1ee7a 3.\n\nV\u00ed d\u1ee5:\n\u0110\u1ea7u v\u00e0o: n = 5\n\u0110\u1ea7u ra: 1\nGi\u1ea3i th\u00edch:\na = [1, 3, 7, 13, 21]\nB\u1ed9 ba h\u1ee3p l\u1ec7 duy nh\u1ea5t l\u00e0.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m ch\u1ea5p nh\u1eadn m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i l\u00e0m tham s\u1ed1,\n    x\u00f3a c\u00e1c chu\u1ed7i c\u00f3 \u0111\u1ed9 d\u00e0i l\u1ebb kh\u1ecfi danh s\u00e1ch,\n    v\u00e0 tr\u1ea3 v\u1ec1 danh s\u00e1ch k\u1ebft qu\u1ea3 v\u1edbi th\u1ee9 t\u1ef1 \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp.\n    Danh s\u00e1ch lu\u00f4n l\u00e0 danh s\u00e1ch c\u00e1c chu\u1ed7i v\u00e0 kh\u00f4ng bao gi\u1edd l\u00e0 m\u1ed9t m\u1ea3ng s\u1ed1,\n    v\u00e0 n\u00f3 c\u00f3 th\u1ec3 ch\u1ee9a c\u00e1c ph\u1ea7n t\u1eed tr\u00f9ng l\u1eb7p.\n    Th\u1ee9 t\u1ef1 c\u1ee7a danh s\u00e1ch n\u00ean \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp t\u0103ng d\u1ea7n theo \u0111\u1ed9 d\u00e0i c\u1ee7a m\u1ed7i t\u1eeb, v\u00e0 b\u1ea1n\n    n\u00ean tr\u1ea3 v\u1ec1 danh s\u00e1ch \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo quy t\u1eafc \u0111\u00f3.\n    N\u1ebfu hai t\u1eeb c\u00f3 c\u00f9ng \u0111\u1ed9 d\u00e0i, s\u1eafp x\u1ebfp danh s\u00e1ch theo th\u1ee9 t\u1ef1 b\u1ea3ng ch\u1eef c\u00e1i.\n    H\u00e0m n\u00ean tr\u1ea3 v\u1ec1 m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i theo th\u1ee9 t\u1ef1 \u0111\u00e3 s\u1eafp x\u1ebfp.\n    B\u1ea1n c\u00f3 th\u1ec3 gi\u1ea3 \u0111\u1ecbnh r\u1eb1ng t\u1ea5t c\u1ea3 c\u00e1c t\u1eeb s\u1ebd c\u00f3 c\u00f9ng \u0111\u1ed9 d\u00e0i.\n    V\u00ed d\u1ee5:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"M\u1ed9t ch\u01b0\u01a1ng tr\u00ecnh \u0111\u01a1n gi\u1ea3n m\u00e0 s\u1ebd tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb c\u1ee7a x n\u1ebfu n l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean t\u1ed1 v\u00e0 s\u1ebd tr\u1ea3 v\u1ec1 gi\u00e1 tr\u1ecb c\u1ee7a y n\u1ebfu kh\u00f4ng ph\u1ea3i.\n\n    V\u00ed d\u1ee5:\n    cho x_or_y == 34\n    cho x_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"T\u00f4i ngh\u0129 r\u1eb1ng t\u1ea5t c\u1ea3 ch\u00fang ta \u0111\u1ec1u nh\u1edb c\u1ea3m gi\u00e1c khi k\u1ebft qu\u1ea3 c\u1ee7a m\u1ed9t s\u1ef1 ki\u1ec7n \u0111\u01b0\u1ee3c mong \u0111\u1ee3i t\u1eeb l\u00e2u cu\u1ed1i c\u00f9ng \u0111\u00e3 \u0111\u01b0\u1ee3c bi\u1ebft \u0111\u1ebfn. Nh\u1eefng c\u1ea3m x\u00fac v\u00e0 suy ngh\u0129 b\u1ea1n c\u00f3 v\u00e0o th\u1eddi \u0111i\u1ec3m \u0111\u00f3 ch\u1eafc ch\u1eafn \u0111\u00e1ng \u0111\u1ec3 ghi l\u1ea1i v\u00e0 so s\u00e1nh.\n\nNhi\u1ec7m v\u1ee5 c\u1ee7a b\u1ea1n l\u00e0 x\u00e1c \u0111\u1ecbnh xem m\u1ed9t ng\u01b0\u1eddi c\u00f3 \u0111o\u00e1n \u0111\u00fang k\u1ebft qu\u1ea3 c\u1ee7a m\u1ed9t s\u1ed1 tr\u1eadn \u0111\u1ea5u hay kh\u00f4ng. B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p hai m\u1ea3ng s\u1ed1 \u0111i\u1ec3m v\u00e0 d\u1ef1 \u0111o\u00e1n v\u1edbi \u0111\u1ed9 d\u00e0i b\u1eb1ng nhau, m\u1ed7i ch\u1ec9 s\u1ed1 \u0111\u1ea1i di\u1ec7n cho m\u1ed9t tr\u1eadn \u0111\u1ea5u. Tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng c\u00f3 c\u00f9ng \u0111\u1ed9 d\u00e0i bi\u1ec3u th\u1ecb m\u1ee9c \u0111\u1ed9 sai l\u1ec7ch c\u1ee7a m\u1ed7i d\u1ef1 \u0111o\u00e1n. N\u1ebfu h\u1ecd \u0111o\u00e1n \u0111\u00fang, gi\u00e1 tr\u1ecb l\u00e0 0, v\u00e0 n\u1ebfu kh\u00f4ng, gi\u00e1 tr\u1ecb l\u00e0 s\u1ef1 ch\u00eanh l\u1ec7ch tuy\u1ec7t \u0111\u1ed1i gi\u1eefa d\u1ef1 \u0111o\u00e1n v\u00e0 s\u1ed1 \u0111i\u1ec3m.\n\nv\u00ed d\u1ee5:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"B\u1ea1n s\u1ebd \u0111\u01b0\u1ee3c cung c\u1ea5p t\u00ean c\u1ee7a m\u1ed9t l\u1edbp v\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng.\n    C\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 t\u1ea3i th\u00eam c\u00e1c l\u1edbp v\u00e0o l\u1edbp \u0111\u00f3. \n    S\u1ee9c m\u1ea1nh c\u1ee7a ph\u1ea7n m\u1edf r\u1ed9ng \u0111\u01b0\u1ee3c t\u00ednh nh\u01b0 sau: G\u1ecdi CAP l\u00e0 s\u1ed1 l\u01b0\u1ee3ng ch\u1eef c\u00e1i vi\u1ebft hoa \n    trong t\u00ean c\u1ee7a ph\u1ea7n m\u1edf r\u1ed9ng, v\u00e0 g\u1ecdi SM l\u00e0 s\u1ed1 l\u01b0\u1ee3ng ch\u1eef c\u00e1i vi\u1ebft th\u01b0\u1eddng \n    trong t\u00ean c\u1ee7a ph\u1ea7n m\u1edf r\u1ed9ng, s\u1ee9c m\u1ea1nh \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng ph\u00e2n s\u1ed1 CAP - SM.\n    B\u1ea1n c\u1ea7n t\u00ecm ph\u1ea7n m\u1edf r\u1ed9ng m\u1ea1nh nh\u1ea5t v\u00e0 tr\u1ea3 v\u1ec1 m\u1ed9t chu\u1ed7i theo \u0111\u1ecbnh d\u1ea1ng sau:\n    ClassName.StrongestExtensionName.\n    N\u1ebfu c\u00f3 hai ho\u1eb7c nhi\u1ec1u ph\u1ea7n m\u1edf r\u1ed9ng c\u00f3 c\u00f9ng s\u1ee9c m\u1ea1nh, b\u1ea1n n\u00ean ch\u1ecdn ph\u1ea7n m\u1edf r\u1ed9ng \n    xu\u1ea5t hi\u1ec7n \u0111\u1ea7u ti\u00ean trong danh s\u00e1ch.\n    V\u00ed d\u1ee5, n\u1ebfu b\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p \"Slices\" l\u00e0 t\u00ean l\u1edbp v\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c ph\u1ea7n m\u1edf r\u1ed9ng:\n    ['SErviNGSliCes', 'Cheese', 'StuFfed'] th\u00ec b\u1ea1n n\u00ean tr\u1ea3 v\u1ec1 'Slices.SErviNGSliCes' \n    v\u00ec 'SErviNGSliCes' l\u00e0 ph\u1ea7n m\u1edf r\u1ed9ng m\u1ea1nh nh\u1ea5t.\n    V\u00ed d\u1ee5:\n    v\u1edbi Strongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cho 2 t\u1eeb. B\u1ea1n c\u1ea7n tr\u1ea3 v\u1ec1 True n\u1ebfu t\u1eeb th\u1ee9 hai ho\u1eb7c b\u1ea5t k\u1ef3 s\u1ef1 xoay v\u00f2ng n\u00e0o c\u1ee7a n\u00f3 l\u00e0 m\u1ed9t chu\u1ed7i con trong t\u1eeb th\u1ee9 nh\u1ea5t.\n    cycpattern_check => Sai\n    cycpattern_check => \u0110\u00fang\n    cycpattern_check => Sai\n    cycpattern_check => \u0110\u00fang\n    cycpattern_check => Sai\n    cycpattern_check => \u0110\u00fang\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Cho m\u1ed9t s\u1ed1 nguy\u00ean, tr\u1ea3 v\u1ec1 m\u1ed9t tuple ch\u1ee9a s\u1ed1 ch\u1eef s\u1ed1 ch\u1eb5n v\u00e0 l\u1ebb t\u01b0\u01a1ng \u1ee9ng.\n\n     V\u00ed d\u1ee5:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    D\u1ef1a v\u00e0o m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng, l\u1ea5y s\u1ed1 La M\u00e3 t\u01b0\u01a1ng \u0111\u01b0\u01a1ng d\u01b0\u1edbi d\u1ea1ng chu\u1ed7i v\u00e0 tr\u1ea3 v\u1ec1 n\u00f3 b\u1eb1ng ch\u1eef th\u01b0\u1eddng. \nH\u1ea1n ch\u1ebf: 1 <= num <= 1000\n\nV\u00ed d\u1ee5:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Vi\u1ebft m\u1ed9t h\u00e0m ch\u1ea5p nh\u1eadn m\u1ed9t danh s\u00e1ch c\u00e1c chu\u1ed7i. \nDanh s\u00e1ch ch\u1ee9a nhi\u1ec1u t\u1eeb kh\u00e1c nhau. Tr\u1ea3 v\u1ec1 t\u1eeb c\u00f3 s\u1ed1 l\u01b0\u1ee3ng k\u00fd t\u1ef1 duy nh\u1ea5t l\u1edbn nh\u1ea5t.\nN\u1ebfu nhi\u1ec1u chu\u1ed7i c\u00f3 s\u1ed1 l\u01b0\u1ee3ng k\u00fd t\u1ef1 duy nh\u1ea5t l\u1edbn nh\u1ea5t, tr\u1ea3 v\u1ec1 chu\u1ed7i \u0111\u1ee9ng tr\u01b0\u1edbc theo th\u1ee9 t\u1ef1 t\u1eeb \u0111i\u1ec3n.\n\nfind_max == \"string\"\nfind_max == \"enam\"\nfind_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    B\u1ea1n l\u00e0 m\u1ed9t ch\u00fa th\u1ecf \u0111\u00f3i b\u1ee5ng, v\u00e0 b\u1ea1n \u0111\u00e3 \u0103n m\u1ed9t s\u1ed1 l\u01b0\u1ee3ng c\u00e0 r\u1ed1t nh\u1ea5t \u0111\u1ecbnh, nh\u01b0ng b\u00e2y gi\u1edd b\u1ea1n c\u1ea7n \u0103n th\u00eam c\u00e0 r\u1ed1t \u0111\u1ec3 ho\u00e0n th\u00e0nh b\u1eefa \u0103n trong ng\u00e0y. B\u1ea1n n\u00ean tr\u1ea3 v\u1ec1 m\u1ed9t m\u1ea3ng g\u1ed3m [ t\u1ed5ng s\u1ed1 c\u00e0 r\u1ed1t \u0111\u00e3 \u0103n sau b\u1eefa \u0103n c\u1ee7a b\u1ea1n, s\u1ed1 c\u00e0 r\u1ed1t c\u00f2n l\u1ea1i sau b\u1eefa \u0103n c\u1ee7a b\u1ea1n ]. N\u1ebfu kh\u00f4ng c\u00f3 \u0111\u1ee7 c\u00e0 r\u1ed1t c\u00f2n l\u1ea1i, b\u1ea1n s\u1ebd \u0103n h\u1ebft s\u1ed1 c\u00e0 r\u1ed1t c\u00f2n l\u1ea1i, nh\u01b0ng v\u1eabn s\u1ebd \u0111\u00f3i.\n\nV\u00ed d\u1ee5:\n* eat -> [11, 4]\n* eat -> [12, 1]\n* eat -> [11, 0]\n* eat -> [7, 0]\n\nBi\u1ebfn:\n@number : s\u1ed1 nguy\u00ean\n    s\u1ed1 l\u01b0\u1ee3ng c\u00e0 r\u1ed1t m\u00e0 b\u1ea1n \u0111\u00e3 \u0103n.\n@need : s\u1ed1 nguy\u00ean\n    s\u1ed1 l\u01b0\u1ee3ng c\u00e0 r\u1ed1t m\u00e0 b\u1ea1n c\u1ea7n \u0103n.\n@remaining : s\u1ed1 nguy\u00ean\n    s\u1ed1 l\u01b0\u1ee3ng c\u00e0 r\u1ed1t c\u00f2n l\u1ea1i trong kho\n\nR\u00e0ng bu\u1ed9c:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nCh\u00fac b\u1ea1n vui v\u1ebb :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    D\u01b0\u1edbi \u0111\u00e2y l\u00e0 b\u1ea3n d\u1ecbch c\u1ee7a c\u00e2u ti\u1ebfng Anh tr\u00ean sang ti\u1ebfng Vi\u1ec7t:\n\nCho hai danh s\u00e1ch: operator v\u00e0 operand. Danh s\u00e1ch \u0111\u1ea7u ti\u00ean ch\u1ee9a c\u00e1c ph\u00e9p to\u00e1n \u0111\u1ea1i s\u1ed1 c\u01a1 b\u1ea3n, v\u00e0 danh s\u00e1ch th\u1ee9 hai l\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean. S\u1eed d\u1ee5ng hai danh s\u00e1ch \u0111\u00e3 cho \u0111\u1ec3 x\u00e2y d\u1ef1ng bi\u1ec3u th\u1ee9c \u0111\u1ea1i s\u1ed1 v\u00e0 tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 c\u1ee7a bi\u1ec3u th\u1ee9c n\u00e0y.\n\nC\u00e1c ph\u00e9p to\u00e1n \u0111\u1ea1i s\u1ed1 c\u01a1 b\u1ea3n:\nPh\u00e9p c\u1ed9ng\nPh\u00e9p tr\u1eeb\nPh\u00e9p nh\u00e2n\nPh\u00e9p chia l\u1ea5y ph\u1ea7n nguy\u00ean\nPh\u00e9p l\u0169y th\u1eeba\n\nV\u00ed d\u1ee5:\noperator = ['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nL\u01b0u \u00fd:\n    \u0110\u1ed9 d\u00e0i c\u1ee7a danh s\u00e1ch operator b\u1eb1ng \u0111\u1ed9 d\u00e0i c\u1ee7a danh s\u00e1ch operand tr\u1eeb \u0111i m\u1ed9t.\n    Operand l\u00e0 m\u1ed9t danh s\u00e1ch c\u00e1c s\u1ed1 nguy\u00ean kh\u00f4ng \u00e2m.\n    Danh s\u00e1ch operator c\u00f3 \u00edt nh\u1ea5t m\u1ed9t ph\u00e9p to\u00e1n, v\u00e0 danh s\u00e1ch operand c\u00f3 \u00edt nh\u1ea5t hai s\u1ed1 h\u1ea1ng.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"B\u1ea1n \u0111\u01b0\u1ee3c cung c\u1ea5p m\u1ed9t chu\u1ed7i s.\n    n\u1ebfu s[i] l\u00e0 m\u1ed9t ch\u1eef c\u00e1i, chuy\u1ec3n \u0111\u1ed5i ki\u1ec3u ch\u1eef c\u1ee7a n\u00f3 t\u1eeb ch\u1eef th\u01b0\u1eddng sang ch\u1eef hoa ho\u1eb7c ng\u01b0\u1ee3c l\u1ea1i,\n    n\u1ebfu kh\u00f4ng, gi\u1eef nguy\u00ean.\n    N\u1ebfu chu\u1ed7i kh\u00f4ng ch\u1ee9a ch\u1eef c\u00e1i n\u00e0o, \u0111\u1ea3o ng\u01b0\u1ee3c chu\u1ed7i.\n    H\u00e0m n\u00ean tr\u1ea3 v\u1ec1 chu\u1ed7i k\u1ebft qu\u1ea3.\n    V\u00ed d\u1ee5\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Cho m\u1ed9t chu\u1ed7i 'text', tr\u1ea3 v\u1ec1 chu\u1ed7i b\u0103m md5 t\u01b0\u01a1ng \u1ee9ng c\u1ee7a n\u00f3.\n    N\u1ebfu 'text' l\u00e0 m\u1ed9t chu\u1ed7i r\u1ed7ng, tr\u1ea3 v\u1ec1 None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Cho hai s\u1ed1 nguy\u00ean d\u01b0\u01a1ng a v\u00e0 b, tr\u1ea3 v\u1ec1 c\u00e1c ch\u1eef s\u1ed1 ch\u1eb5n gi\u1eefa a v\u00e0 b, theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n.\n\nV\u00ed d\u1ee5:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]