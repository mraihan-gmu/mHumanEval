[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Berilgen raqamlar tiziminde, berilgen thresholdtan birbirine yaq\u0131nraq olan eki raqam barm\u0131, dep tek\u015firi\u00f1iz.\nMisal:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Bu funksiyan\u0131\u00f1 kiri\u015f verisi i\u00e7 i\u00e7e kiri\u015f qawuslarnen birne\u00e7e topn\u0131 saqlaytqan bir yip ol\u0131p tab\u0131lad\u0131. Maqsat\u0131n\u0131z bu toplarn\u0131 ayr\u0131-ayr\u0131 yiplerge ay\u0131r\u0131p, olarn\u0131\u00f1 tizimisin qaytarmaq. Ayr\u0131 topn\u0131\u00f1 kiri\u015f qawuslar\u0131 tenq ve bir-birini\u00f1 i\u00e7ine kirmey. Kiri\u015f yipindegi bo\u015fluqlarn\u0131 iqtidar etmeyi\u00f1iz. Misal:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Pozitiv ondal\u0131kl\u0131 bir say\u0131 berilgen, o integer q\u0131sm\u0131na ve ondal\u0131k q\u0131sm\u0131na b\u00f6l\u00fcne bilir. \n\nSaan\u0131n ondal\u0131k q\u0131s\u0131m\u0131n\u0131 qaytar.\nMisal:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sana nol balansnen ba\u015flaytqan bank hesab\u0131nda depozit ve pul \u00e7ek\u00fcv operasyonlar\u0131 t\u0131z\u0131m\u0131 berildi. Senin vazifen - eger herqanda bir vaq\u0131tta hesabn\u0131\u00f1 balans\u0131 nol'dan a\u015fa\u011f\u0131 d\u00fc\u015fse, onu aniqlamaq ve on\u0131\u00f1 vaq\u0131t\u0131nda funksiyan\u0131\u00f1 True qaytarmaq\u0131. Eger de, ba\u015fq\u0131 vaq\u0131tlarda False qaytarmaq\u0131.\nMisal:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Berilgen kirit\u00fcv raqamlar tiz\u00fcv\u00fc i\u00e7\u00fcn, bu mal\u00fcmat toplusunun ortalamas\u0131 etraf\u0131nda Orta\u00e7aqta Orta\u00e7aqtan Sapma'n\u0131 hesapla.\nOrta\u00e7aqta Orta\u00e7aqtan Sapma, her bir element ve merkez nuqtas\u0131 aras\u0131ndaki ortalama mutlaq farqt\u0131r:\nOOS = ortalama | x - x_ortalama |\nMisal:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" \u0130ki ard arda kelgen element aras\u0131nda 'delimeter' nomerini qoy\u011fuz\u0131n.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Bu fenktsiyaga kiritilgen kirim, aralar\u0131nda bo\u015fluqlar olan birne\u00e7e parantezlerni\u00f1 i\u00e7 i\u00e7e ke\u00e7ken qruplar\u0131 \u015feklinde temsil etilgen bir yibik. \n    Her bir qrup i\u00e7\u00fcn, parantezlerni\u00f1 eng derin i\u00e7 i\u00e7e ke\u00e7ken seviyesini \u00e7\u0131qara. \n    Meselen,) maksimum eki seviyeli i\u00e7 i\u00e7e ke\u00e7ken parantezge ega, emma)) \u00fc\u00e7\u00fcnc\u00fc seviyeye ega.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Berilgen altq\u0131 qator\u0131n\u0131 saqlay\u011fan kiri\u015f qatarlar\u0131n\u0131\u00f1 tizimcesini faqat onlarn\u0131\u00f1 i\u00e7indekilerini filtrle.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Berilgen butun sonlar dizisi i\u00e7\u00fcn, dizideki b\u00fct\u00fcn sonlarn\u0131\u00f1 cemisi ve hasilinden ibaret tuple qaytar\u0131\u00f1\u0131z.\n    Bo\u015f cemi 0 ve bo\u015f hasili 1 olmal\u0131.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Berilgen tam say\u0131 listesinden, berilgen vaq\u0131tta s\u0131ralamada tabilgen en yuqar\u0131 elemendin ibaret rulonlu maksimum elementler listesini yarat\u0131n\u0131z.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Berilgen qatar\u0131n palindrom olup olmad\u0131\u011f\u0131n\u0131 s\u0131navdan ke\u00e7ir \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Kiritim a ve b iki simlerden ibaret, yaln\u0131zca 1 ve 0'lar.\n    Bu kiritilgenler \u00fczrinde binar XOR i\u015flemini yap ve neticeni da sim olaraq qaytar.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Yaz\u0131qlar sanav\u0131nan en uzun\u0131n\u0131 qaytar. Birne\u00e7esi bir uz\u0131nl\u0131qta bolsa, birincisini qaytar. Eger kiritilgen sanav bo\u015f olsa, None qaytar.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" \u0130ki butun san a ve b'nin en b\u00fcy\u00fck ortaq b\u00f6lenini qaytar.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Girdi yibikli\u011finin en k\u0131sa t\u0131n en uzun\u011fa kadar olan b\u00fct\u00fcn prefikslerini qaytar.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" 0-dan ba\u015flay\u0131p, n'ge qadar arada bir bo\u015fluq belen ay\u0131r\u0131l\u011fan sandan ibaret bir yip qaytar.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Berilgen s\u0131z\u0131q boyun\u00e7a, on\u0131\u00f1 ne\u00e7e ay\u0131r\u0131m belgiden ibaret ol\u011fan\u0131n tap\u0131\u00f1\u0131z\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Bu funksiyaya kiritim, hususi ASCII format\u0131nda musiqi notlar\u0131n\u0131 temsil etken bir sat\u0131rd\u0131r.\n    Sizin vazifeniz - bu sat\u0131r\u0131n\u0131 \u00e7\u00f6zmek ve her bir notun qancha zaman devam etkenligini belirliyen \n    integerlerden ibaret bir liste qaytarmakt\u0131r.\n\n    Mana legend:\n    'o' - tam nota, d\u00f6rt zaman devam eter\n    'o|' - yar\u0131m nota, eki zaman devam eter\n    '.|' - \u00e7eyrek nota, bir zaman devam eter\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Berilgen alt qatorn\u0131 as\u0131l qator i\u00e7inden ne\u00e7e kerez tapqan\u0131\u00f1n\u0131 tap. \u00d6stle\u015fken hallarn\u0131 sanap \u00e7\u0131q.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Girdi, 'zero'dan 'nine'\u011fa qadar olan say\u0131lar\u0131n bo\u015fluqnen ayr\u0131l\u011fan bir qator\u0131d\u0131r.\n    Kechikli variantlar 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' ve 'nine'd\u0131r.\n    Qatorn\u0131 say\u0131lar k\u00fc\u00e7\u00fckten b\u00fcy\u00fcge s\u0131ralap qaytar\u0131\u00f1\u0131z.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Berilgen raqamlar tizmesinden bir-birine en yaq\u0131n ol\u011fan eki raqamn\u0131 se\u00e7ip qaytar\u0131\u00f1\u0131z ve onlar\u0131 t\u00e1rtibinde qaytar\u0131\u00f1\u0131z.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Berilgen sanlar tizimcesine \u015funday bir s\u0131z\u0131qiy transformatsiya qollan\u0131n\u0131z,\n    ki, en ki\u00e7ik san 0 bol\u0131p \u00e7\u0131qs\u0131n ve en b\u00fcy\u00fck san 1 bol\u0131p \u00e7\u0131qs\u0131n.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Berilgen tizimni faqat butun sanlar i\u00e7\u00fcn s\u00fcz\u00fc\u00f1iz\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Berilgen y\u0131plamn\u0131\u00f1 uzunl\u0131\u011f\u0131n\u0131 qaytar\u0131n\u0131z\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Berilgen n san\u0131 \u00fc\u00e7\u00fcn, n-ni b\u00f6lecek en b\u00fcy\u00fck, n-den kichik san\u0131n\u0131 bulunuz.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Berilgen butun san\u0131n\u0131\u00f1 asal faktorlar\u0131n\u0131 ki\u00e7ikten uluy\u011fa teref tertipte keri ber. \n    Er bir faktorni faktorla\u015fuvda ka\u00e7 kere payda olsa, o kadar kere keri ber.\n    Kiritilgen san, b\u00fct\u00fcn faktorlarni\u00f1 k\u00f6beytmesini\u00f1 neticesine teyin olmal\u0131.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Siy\u0131mden butun birden art\u0131q kere \u00e7\u0131qqan elementlerni \u00e7\u0131qar\u0131p ta\u015fla. \n    Qal\u011fan elementlerni\u00f1 tertibini kireydeki kibi saqla.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Berilgen qator i\u00e7\u00fcn, ki\u00e7ik heriflerni ba\u015f heriflerge, ba\u015f heriflerni de ki\u00e7ik heriflerge \u00e7evire\u00f1iz.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" S\u0131ralamadan t\u0131zimni bir yoluv\u011fa birle\u015ftirmek\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Kiritilen yaz\u0131lar tizimini s\u00fcz\u00fcp, yaln\u0131z berilgen \u00f6neknen ba\u015flayanlar\u0131n\u0131 qald\u0131r\u0131n\u0131z.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Tizimd\u0435 f\u0430q\u0430t \u043en p\u043ez\u0456t\u0456vn\u0456 r\u0430qamlarni qaytar.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Berilgen san prost\u0131 olsa, true qaytar, aksi takdirde false.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Koefitsiyentleri xs olan polinomn\u0131 x noqtas\u0131nda bahalay\u0131r.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Bu funksiya l listesini al\u0131p, l' listesini qaytarad\u0131r, \u015fu\u015f\u0131nday ki,\n    l' listesi l listesini \u00fc\u00e7ke b\u00f6l\u00fcnmegen indeksleri boyun\u00e7a ayn\u0131d\u0131r, \u00fc\u00e7ke b\u00f6l\u00fcnen indekslerde ise l listesini \u015fo indekslerindeki \n    degerleri sorted olup, on\u0131\u00f1 kiymetleri bir-birine tenkdir.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Qaytar sorted unique elementlerni bir listede\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Tizimdeg\u0456 en b\u00fcy\u00fck elem\u0435ntni qaytar.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"11 ve 13 ile b\u00f6l\u00fcne bilen, n-den k\u00fc\u00e7\u00fck tamsay\u0131lar i\u00e7inde 7 raqam\u0131 qays\u0131 qadar kerek qaytar.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Bu funksiya l tizimni al\u0131p, l' tizimni qaytarad\u0131, \u015fe\u00f1ki\n    l' tizimi c\u00fcft indekslerde l'ge t\u0131pk\u0131-t\u0131pk\u0131s\u0131na benzer, tek c\u00fcft indekslerdeki q\u0131ymetleri\n    l tizimindeki c\u00fcft indekslerdeki q\u0131ymetlerge teng, amma s\u0131ralan\u011fan.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    \u00fc\u00e7 simvoln\u0131\u00f1 top-ba\u015f\u0131n\u0131 ayland\u0131r\u0131p kodlan\u011fan simvol tizesini qaytar\u0131r.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib n-ci Fibonachi san\u0131 ve ayn\u0131 zamanda asal olan san\u0131n\u0131 qaytarad\u0131r.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero tamsay\u0131lar dizisini kiritme olaraq qabul etedi.\n    E\u011fer dizideki \u00fc\u00e7 ay\u0131r-ayr\u0131 element s\u0131f\u0131r\u011fa te\u00f1e sumaya sahib olsa, True qaytarad\u0131, aksi halda False qaytarad\u0131.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Tasavvur eti\u00f1iz, \u00e7oq uzun ve d\u00fcmd\u00fcz bir yol bar. \n    n ma\u015fna sol t\u0259r\u0259fd\u0259n sa\u011fa do\u011fru ketey, ayn\u0131 zamanda ba\u015fqa bir n ma\u015fna \n    sa\u011f t\u0259r\u0259fd\u0259n sola do\u011fru ketey. \u0130ki ma\u015fna toplanmas\u0131 birbirinden pek uzaq ba\u015flay. \n    Barl\u0131q ma\u015fnalar ayn\u0131 h\u0131zda hareket etey. Sol t\u0259r\u0259fd\u0259n sa\u011fa do\u011fru ketken ma\u015fna \n    sa\u011f t\u0259r\u0259fd\u0259n sola do\u011fru ketken ma\u015fna\u011fa ur\u011fanda, bu iki ma\u015fna toqqu\u015fqan deyley. \n    Ancak, ma\u015fnalar sonsuz sa\u011flam ve g\u00fc\u00e7l\u00fcdir; sonu\u00e7ta, toqqu\u015fmam\u0131\u015f kibi \n    yollar\u0131na devam eteyler.\n    \n    Bu funksiya bel\u0259 toqqu\u015fuvlar\u0131n san\u0131n\u0131 \u00e7\u0131qar\u0131r.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Elementlerni 1-ge artt\u0131r\u0131p qaytar.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    `pairs_sum_to_zero` tamsay\u0131lar dizisini giri\u015f olaraq al\u0131r.\n    \u018fg\u0259r dizide iki f\u0259rqli element s\u0131f\u0131r toplarsa, do\u011fru qaytar\u0131r, \u0259ks halda yalan.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Girdi nomeri x-ni ba\u015fqa numeral sistemen\u00e4 \u00f6g\u00fcst\u00fcr.\n    \u00d6g\u00fc\u015ft\u00fcrgendenn so\u00f1 string temsilini qaytar.\n    Numeral sistemeleri 10-dan ki\u00e7ikdir.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Berilgen yan uzunl\u0131\u011f\u0131 ve biq'l\u0131qn\u0131\u00f1 y\u00fcksekli\u011fi i\u00e7\u00fcn \u00fc\u00e7bucaqn\u0131\u00f1 alan\u0131n\u0131 qaytar.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Fib4 s\u0131ras\u0131, Fibbonacci s\u0131ras\u0131na o\u015fay bir s\u0131rad\u0131r ve \u015f\u00f6yle tariflenedi:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    L\u00fctfen fib4 s\u0131ras\u0131n\u0131n n-ci elementini tezkaretmek i\u00e7\u00fcn bir funksiya yaz\u0131\u00f1\u0131z. Rekursiya qullanmay\u0131n\u0131z.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Elementlerin median\u0131n\u0131 l tiziminden qaytar.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Berilgen qatar\u0131n palindrome olup olma\u011fan\u0131n tek\u015feredi\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"2^n mod p qaytar.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    her bir herfni alfavit boyun\u00e7a 5 orun\u011fa s\u00fcr\u00fc\u015f\u00fcruv bilen kodlan\u011fan yipni qaytar\u0131r.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels \u2013 bu, qatarn\u0131 al\u0131p, on\u0131\u00f1 i\u00e7indegi unl\u0131 seslerni al\u0131p tifelgen qatar qaytar\u011fan bir fuksiya.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Eger de l listesindegi b\u00fct\u00fcn raqamlar t e\u015figinden a\u015fa\u011f\u0131 bolsa, True qaytar.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"\u0130ki san\u0131 qo\u015f\u0131\u00f1\u0131z: x ve y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    \u0130ki s\u00f6zni\u00f1 bir-birine ayni simvollar\u0131 olup olma\u011fan\u0131n t\u0131k\u015f\u0131r.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"n-inci Fibonacci san\u0131n\u0131 qaytar.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Qavuslar \"<\" ve \">\" simvollar\u0131ndan ibaret bir tizedir.\n    Her a\u00e7\u0131l\u011fan qavus\u011fa qar\u015f\u0131l\u0131q kelsen yap\u0131l\u011fan qavus bar olsa, True qaytar.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Elementler monoton artqan ya da azal\u011fan bolsa, True qaytar.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"\u0130ki listede ortaq olan qaytar\u0131l\u011fan ve biricik elementlerni s\u0131ralap ber.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"n-n\u0131\u00f1 en b\u00fcy\u00fck sad\u0259 b\u00f6lenini qay\u0131tar. Farz et n > 1 ve sad\u0259 de\u00f1ildir.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n 1-den n-gece olan sanlarn\u0131 toplayan bir fuksiya.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Ay\u0131rmalar \"\" belgilerinden ibaret bitip. Her bir a\u00e7\u0131q ay\u0131rman\u0131\u00f1 qar\u015f\u0131s\u0131nda ya\u00f1maqta ay\u0131rma olsa, True qaytar\u0131la.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs polinom coeffitsiyentlerini temsil ete.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Bu polinomn\u0131\u00f1 t\u00fcrevini ayn\u0131 \u015fekilde qaytar.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"FibFib sanlar t\u0131zmas\u0131 Fibbonacci t\u0131zmas\u0131na o\u015fay\u011fan t\u0131zmad\u0131r, ve o a\u015fag\u0131da keltirilgen kibi tariflengen:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    FibFib sanlar t\u0131zmas\u0131n\u0131n n-inci elementini tezi ve effektiv hesaplayat\u0131r\u011fan bir funktsiya yaz\u0131\u00f1\u0131z.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nK\u00f6prok test vaziyetlerini ekle.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Butun san\u0131n x raqamlar\u0131n\u0131 dair\u0259vi d\u0259yi\u015fdirin, raqamlar\u0131 sa\u011fa shift q\u0259d\u0259r d\u0259yi\u015fdirin v\u0259 n\u0259tic\u0259ni simvol qatar\u0131 olaraq qaytar\u0131n. \u018fg\u0259r shift raqamlar\u0131n\u0131n say\u0131ndan \u00e7ox olarsa, raqamlar\u0131 t\u0259rsin\u0259 \u00e7evirin.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"C\u00fcmleni Q\u0131r\u0131m Tatar tili\u011fine tercime et:\n\nG\u00f6rev\n    Bir fonksiya yaz\u0131\u00f1\u0131z, bu fonksiya bir yipni kabul etip, faqat b\u00fcy\u00fck harflerni\u00f1 ASCII kodlar\u0131n\u0131\u00f1 cemi olarak qaytar\u0131r.\n\n    Misaller:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Bu vazifede, size meyve sepetinde da\u011f\u0131t\u0131lan elmalar ve portakallar say\u0131s\u0131n\u0131 temsil eden bir string verilecek. Bu sepet elma, portakal ve mango meyvelerini i\u00e7erir. Meyve sepetindeki toplam meyve say\u0131s\u0131n\u0131 ve elma ile portakal say\u0131s\u0131n\u0131 temsil eden string verilerek, sepetin i\u00e7indeki mango meyvelerinin say\u0131s\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn. \u00d6rne\u011fin:\nfruit_distribution -> 19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"A\u011fac\u0131n buda\u011f\u0131n\u0131 temsil eden ve negatif olmayan tam say\u0131 d\u00fc\u011f\u00fcmleri olan bir dizi verildi\u011finde,\ng\u00f6reviniz d\u00fc\u011f\u00fcmlerden birini kopar\u0131p geri d\u00f6nd\u00fcrmektir.\nKopar\u0131lan d\u00fc\u011f\u00fcm en k\u00fc\u00e7\u00fck \u00e7ift de\u011fere sahip d\u00fc\u011f\u00fcm olmal\u0131d\u0131r.\nE\u011fer ayn\u0131 en k\u00fc\u00e7\u00fck \u00e7ift de\u011fere sahip birden fazla d\u00fc\u011f\u00fcm bulunursa, en k\u00fc\u00e7\u00fck indekse sahip d\u00fc\u011f\u00fcm geri d\u00f6nd\u00fcr\u00fclmelidir.\n\nKopar\u0131lan d\u00fc\u011f\u00fcm bir liste \u015feklinde geri d\u00f6nd\u00fcr\u00fclmelidir, [ en k\u00fc\u00e7\u00fck de\u011fer, indeksi ].\nE\u011fer \u00e7ift de\u011ferler yoksa veya verilen dizi bo\u015fsa, [] geri d\u00f6nd\u00fcr\u00fcn.\n\n\u00d6rnek1:\n    Girdi: [4,2,3]\n    \u00c7\u0131kt\u0131: [2, 1]\n    A\u00e7\u0131klama: 2 en k\u00fc\u00e7\u00fck \u00e7ift de\u011fere sahiptir ve 2 en k\u00fc\u00e7\u00fck indekse sahiptir.\n\n\u00d6rnek2:\n    Girdi: [1,2,3]\n    \u00c7\u0131kt\u0131: [2, 1]\n    A\u00e7\u0131klama: 2 en k\u00fc\u00e7\u00fck \u00e7ift de\u011fere sahiptir ve 2 en k\u00fc\u00e7\u00fck indekse sahiptir.\n\n\u00d6rnek3:\n    Girdi: []\n    \u00c7\u0131kt\u0131: []\n\n\u00d6rnek4:\n    Girdi: [5, 0, 3, 0, 4, 2]\n    \u00c7\u0131kt\u0131: [0, 1]\n    A\u00e7\u0131klama: 0 en k\u00fc\u00e7\u00fck de\u011fere sahiptir, fakat iki tane s\u0131f\u0131r vard\u0131r,\n             bu y\u00fczden en k\u00fc\u00e7\u00fck indekse sahip olan ilk s\u0131f\u0131r se\u00e7ilecektir.\n\nK\u0131s\u0131tlamalar:\n    * 1 <= d\u00fc\u011f\u00fcmlerin uzunlu\u011fu <= 10000\n    * 0 <= d\u00fc\u011f\u00fcm de\u011feri\"\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Berilgen arr tam sanlar massivi, massivni palindrom qilish uchun ne\u00e7teden az elementni de\u00f1i\u015ftirmek kerekligini tap\u0131\u00f1\u0131z. Palindromik massiv \u2013 bu, arqa ve ald\u0131n\u011fa oqu\u011fanda bir xil oqul\u011fan massivdir. Bir de\u00f1i\u015fiklikte, siz bir elementni herqanday ba\u015fqa elementke de\u00f1i\u015ftire bilersiz.\n\nMeselen:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"3 ba\u015fl\u0131q san\u0131n k\u00f6peltmesi ol\u011fan san\u0131 bermi, emese yoqmu ekendigin qaytar\u011fan funksiya yaz\u0131\u00f1\u0131z. 100-dan kicik ol\u011fan\u0131ni bilemiz.\nMisal:\nis_multiply_prime == True\n30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Sizni\u00f1 vazifeniz n\u00f6mere x n-ni\u00f1 basit q\u00fcvveti olsa, true qaytarmaq ve ba\u015fqa allarda false qaytarmaq.\nx n-ni\u00f1 basit q\u00fcvveti olsa, eger n**int=x\nMeselen:\nis_simple_power => true\nis_simple_power => true\nis_simple_power => true\nis_simple_power => false\nis_simple_power => false\nis_simple_power => false\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Sizege vazife berildi: bir funksiya yaz\u0131\u00f1\u0131z, o funksiya \n    onalt\u0131l\u0131q san\u0131 string olarak kabul etip, \n    onalt\u0131l\u0131q raqamlar aras\u0131nda asal olanlar\u0131n\u0131 saymaq.\n    Onalt\u0131l\u0131q raqamlar: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Asal sanlar: 2, 3, 5, 7, 11, 13, 17, ...\n    Siz \u015fu raqamlar\u0131n say\u0131s\u0131n\u0131 belgilersiz: 2, 3, 5, 7, \n    B, D.\n    Not: girizilen mal\u00fcmat her zaman do\u011fru ya da bo\u015f string olaca\u011f\u0131n\u0131 \n    ve A, B, C, D, E, F simvollar\u0131n\u0131n her zaman b\u00fcy\u00fck harfler olaca\u011f\u0131n\u0131 farz etip olas\u0131\u00f1\u0131z.\n    Misallar:\n    Num = \"AB\" ol\u011fanda netice 1 olmal\u0131.\n    Num = \"1077E\" ol\u011fanda netice 2 olmal\u0131.\n    Num = \"ABED1A33\" ol\u011fanda netice 4 olmal\u0131.\n    Num = \"123456789ABCDEF0\" ol\u011fanda netice 6 olmal\u0131.\n    Num = \"2020\" ol\u011fanda netice 2 olmal\u0131.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Size decimal formada berilecek ve sizin vazifeniz onu ikilik formata \u00e7evirmek olacaq. Funksiya bit string qaytarmaq kerek, her bir karakter binary raqamni temsil etecek. Stringdeki her bir karakter '0' ya da '1' olacaq.\n\nStringni ba\u015finda ve so\u00f1unda 'db' degi\u00e7 art\u0131 karakterler olacaq. Bu art\u0131 karakterler formatqa yard\u0131m et\u00fcv i\u00e7\u00fcn bar.\n\nMisallar:\ndecimal_to_binary   # \"db1111db\" qaytar\u0131r\ndecimal_to_binary   # \"db100000db\" qaytar\u0131r\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"Sizge s tizgini berilgen.\n    Sizni\u00f1 vazifeniz tizginnin bahtl\u0131m\u0131 yoqsa bahts\u0131zm\u0131 ekendigin tek\u015fermek.\n    Tizgin bahtl\u0131 say\u0131lad\u0131r eger onun uzunl\u0131\u011f\u0131 en az 3 bols\u0131 ve her 3 ketme-ket herip ay\u0131rmal\u0131 bols\u0131.\n    Meselen:\n    is_happy => Yalqan\n    is_happy => Yalqan\n    is_happy => Do\u011fru\n    is_happy => Yalqan\n    is_happy => Do\u011fru\n    is_happy => Yalqan\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Bu semestrin so\u00f1ki aftas\u0131 ve muallim talebelere ballar\u0131n\u0131 bermek kerek. Muallim \u00f6z balland\u0131rma algoritmini yapqan edi. Yaln\u0131z bir mesele bar, o balland\u0131rma algoritminin kodunu yoqot\u0131p qoy\u011fan. Size bir qator \u00f6\u011frencilerni\u00f1 GPA\u2019lar\u0131n\u0131 berdi ve sizden bir funksiya yaz\u0131p, a\u015fa\u00f1\u0131daki cedvelge esasen harf ballar\u0131n \u00e7\u0131karman\u0131zn\u0131 istedi:\n\n             GPA       |    Harf bal\u0131\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Misal:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Bir fonktsiya yaz\u0131\u00f1\u0131z, \u043el bir yipni kabul etsin ve \u043el yipni\u00f1 uzunl\u0131\u011f\u0131 prost\u0131 say\u0131 olsa True, aksi takdirde False qaytars\u0131n.\n    Misallar:\n    prime_length == True\n    prime_length == True\n    prime_length == True\n    prime_length == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Pozitiv but\u00fcn n\u00f6m\u00fcr n berilgen, n-oquv pozitiv but\u00fcn n\u00f6m\u00fcrlerni\u00f1 ba\u015f\u0131nda ya da so\u00f1unda 1 bar olanlar\u0131n\u0131\u00f1 san\u0131n\u0131 qaytar.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Berilgen musbat butun san N, on\u0131\u00f1 raqamlar\u0131n\u0131\u00f1 c\u00e4mi\u00f1i ikkilik sistemada qaytar\u0131\u00f1\u0131z.\n\n    Misal\n        N = 1000 bolsa, raqamlar\u0131n\u0131\u00f1 c\u00e4mi 1 olacaq, netice \"1\" olmal\u0131d\u0131r.\n        N = 150 bolsa, raqamlar\u0131n\u0131\u00f1 c\u00e4mi 6 olacaq, netice \"110\" olmal\u0131d\u0131r.\n        N = 147 bolsa, raqamlar\u0131n\u0131\u00f1 c\u00e4mi 12 olacaq, netice \"1100\" olmal\u0131d\u0131r.\n\n    \u00d6zger\u00fcv\u00e7iler:\n        @N butun san\n             Chekl\u00e4wler: 0 \u2264 N \u2264 10000.\n    Netice:\n         ikkilik san format\u0131nda bir yip\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Bo\u015f olma\u011fan tam sanlar tizimsi berilgen. Tek indekslerde ol\u011fan c\u00fct elementlerni qo\u015f.\n\n    Misallar:\n        qo\u015fuv ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    Bir funksiyan\u0131 yaz\u0131n\u0131z ki, bu funksiyan\u0131 bir sat\u0131r al\u0131p onun tertiplenmi\u015f versiyas\u0131n\u0131 qaytar\u0131\u00f1\u0131z.\n    Sat\u0131rn\u0131\u00f1 tertiplenmi\u015f versiyas\u0131, har bir s\u00f6z\u00fc\n    yeni bir s\u00f6zge almasht\u0131r\u0131l\u011fan sat\u0131rd\u0131r, bu yeni s\u00f6zde barl\u0131q i\u015faretler\n    ascii q\u0131ymetlerine k\u00f6re artqan tertipte t\u0131z\u0131l\u011fan.\n    Qayd: Sat\u0131rda s\u00f6zlerni\u00f1 tertibini ve bo\u015fluqlarn\u0131 saqlap qalman\u0131z kerek.\n\n    Meselen:\n    anti_shuffle 'Hi' qaytar\u0131p beredi\n    anti_shuffle 'ehllo' qaytar\u0131p beredi\n    anti_shuffle 'Hello !!!Wdlor' qaytar\u0131p beredi\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    Sizege 2 \u00f6l\u00e7emli mal\u00fcmat berilgen, i\u00e7 i\u00e7e listler \u015feklinde, bu matritsaga o\u015fa\u015f, amma matritsalardan farql\u0131 olaraq, er bir sat\u0131rda er t\u00fcrl\u00fc s\u00fctun san\u0131 olabilir. Berilgen lst ve x tamsay\u0131, listedeki x tamsay\u0131lar\u0131n\u0131 bulun ve [, ...] \u015feklindeki koordinatlar listesini qaytar\u0131\u00f1, her bir tuplam koordinat\u0131d\u0131r, 0'dan ba\u015flay\u0131p. Koordinatlar\u0131 sat\u0131rlara g\u00f6re artan tertipte s\u0131rala\u00f1. Ayr\u0131ca, sat\u0131rdaki koordinatlar\u0131 s\u00fctunlara g\u00f6re azalan tertipte s\u0131rala\u00f1.\n\nMisallar:\nget_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1) == [,,,,]\nget_row == []\nget_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Verilgen musbet inteyler massivini qaytar\u0131p, on\u0131 sortla\u011fannan so\u00f1 kopyas\u0131n\u0131 qaytar\u0131\u00f1\u0131z,\n    berilgen massivni artqan tartipte sortla\u00f1\u0131z eger cemi teke bolsa,\n    ya da kemsigen tartipte eger cemi juft bolsa.\n\n    Not:\n    * berilgen massivni de\u00f1i\u015ftirmeyin.\n\n    Misallar:\n    * sort_array => []\n    * sort_array => [5]\n    * sort_array => [0, 1, 2, 3, 4, 5]\n    * sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Bir funksiya yarat\u0131p, on\u0131\u00f1 ismini `encrypt` qoy\u0131\u00f1\u0131z ve on\u0131\u00f1 bir argument olaraq qabul etken qatar\u0131n\u0131 \u015fifreleyip qaytar\u011fan\u0131n\u0131 sa\u011flay\u0131\u00f1\u0131z. Alfavitni \u00f6yle bir \u015fekilde aylan\u011fan olsun ki, herfler eki yerge eki marta art\u0131ls\u0131n. Mesela:\n`encrypt` 'lm' qaytar\u0131r\n`encrypt` 'ewhjklnop' qaytar\u0131r\n`encrypt` 'kj' qaytar\u0131r\n`encrypt` 'ix' qaytar\u0131r\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    Sana butun sanlardan ibaret bir liste berildi.\n    next_smallest funksiyas\u0131n\u0131 yaz ki, bu funksiya listenin 2-ci en ki\u00e7ik elementini qaytars\u0131n.\n    E\u011fer b\u00f6yle bir element yoqsa, None qaytars\u0131n.\n    \n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Size bir s\u04e7zler tizimi beriledi, ve sizni\u00f1 vazifeniz b\u0131kk\u0131nl\u0131q s\u0430yl\u0430maq. B\u0131kk\u0131nl\u0131q \"Men\" s\u04e7ziyle b\u0430\u015fl\u0430\u011f\u0430n cumledir. Cumleler '.', '?' ya da '!' belgileryle ay\u0131r\u0131l\u011fan.\n\n    Meselen:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Bir funksiya yaz\u0131\u00f1\u0131z ki, bir mesajn\u0131 al\u0131p, onu \u015funday kodlas\u0131n ki, ol mesajdaki b\u00fct\u00fcn ariflerni\u00f1 kefiyini de\u00f1i\u015ftirsin hem mesajdaki b\u00fct\u00fcn \u00fcnl\u00fclerni ingiliz elifbas\u0131nda 2 yer ileride bulunan arifle de\u00f1i\u015ftirsin. \n\nSadece ariflerni\u00f1 olmas\u0131n\u0131 farz edi\u00f1iz.\n\nMisallar:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"Sizege butun sanlardan ibaret bir tizim berildi.\n    Siz en boyuq asal san\u0131 tap\u0131p, onun raqamlar\u0131n\u0131\u00f1 cemi qaytar\u0131\u00f1\u0131z.\n\n    Misallar:\n    lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] i\u00e7\u00fcn netice 10 olmal\u0131\n    lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] i\u00e7\u00fcn netice 25 olmal\u0131\n    lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] i\u00e7\u00fcn netice 13 olmal\u0131\n    lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] i\u00e7\u00fcn netice 11 olmal\u0131\n    lst = [0,81,12,3,1,21] i\u00e7\u00fcn netice 3 olmal\u0131\n    lst = [0,8,1,2,1,7] i\u00e7\u00fcn netice 7 olmal\u0131\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Berilgen lugatqa kelsek, e\u011fer b\u00fct\u00fcn a\u00e7q\u0131\u00e7lar ki\u00e7ik xarflernen ya da b\u00fct\u00fcn a\u00e7q\u0131\u00e7lar b\u00fcy\u00fck xarflernen yaz\u0131l\u011fan bolsa, True qaytar; aks\u0131 halda False qaytar.\nFunksiya berilgen lugat bo\u015f bolsa, False qaytarmaq kerek.\nMisallar:\ncheck_dict_case True qaytarmaq kerek.\ncheck_dict_case False qaytarmaq kerek.\ncheck_dict_case False qaytarmaq kerek.\ncheck_dict_case False qaytarmaq kerek.\ncheck_dict_case True qaytarmaq kerek.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Funksiyan\u0131 icra etki, s\u0131f\u0131rdan b\u00fcy\u00fck intejerni als\u0131n ve n-den ki\u00e7ik ol\u011fan birinci n asal sandan ibaret massiv qaytars\u0131n.\n    meselen:\n    count_up_to => [2,3]\n    count_up_to => [2,3,5,7]\n    count_up_to => []\n    count_up_to => [2,3,5,7,11,13,17,19]\n    count_up_to => []\n    count_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Funksiyan\u0131 tamamlap, eki integerni al\u0131p, olar\u0131n\u0131\u00f1 birlik raqamlar\u0131n\u0131\u00f1 has\u0131l\u0131s\u0131n\u0131 qaytar\u0131\u00f1\u0131z.\n    Kir\u00fc daima do\u011fru ol\u011fan\u0131n\u0131 farzedi\u00f1iz.\n    Misallar:\n    multiply 16-n\u0131 qaytarmaq kerek.\n    multiply 72-ni qaytarmaq kerek.\n    multiply 0-ni qaytarmaq kerek.\n    multiply 20-ni qaytarmaq kerek.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Berilgen s y\u0131p\u0131, juqar\u0131 re\u00f1kli unl\u0131larn\u0131 c\u00fct indekslerde sanap \u00e7\u0131q\u0131n.\n\n    Misal \u00fccin:\n    count_upper 1 qaytara\n    count_upper 0 qaytara\n    count_upper 0 qaytara\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Berilgen musbat butun say\u0131 n, siz n qatl\u0131q ta\u015flardan ibaret bir qabar\u0131q yasav\u0131z kerek.\n    Birinci qatda n ta\u015f bar.\n    Keyingi qattaki ta\u015flar san\u0131:\n        - e\u011fer n tegsiz bolsa, keyingi tegsiz say\u0131.\n        - e\u011fer n tege bolsa, keyingi tege say\u0131.\n    Her bir qatqa ta\u015flar san\u0131n tizzikte qaytar\u0131n, m\u0131nda indeks i'deki element-ci qattaki ta\u015flar san\u0131n\u0131 temsil etedi.\n\n    Misallar:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Sizege verg\u00fcl ya da bo\u015fluqlar ile ayr\u0131l\u011fan s\u00f6zler qatar\u0131 beriledi. Sizin vazifeniz qatarn\u0131 s\u00f6zlerge b\u00f6lip, s\u00f6zler massivin\u0131 qaytarmaq.\n\nMeselen:\nwords_string == [\"Merhaba\", \"benim\", \"ad\u0131m\", \"John\"]\nwords_string == [\"Bir\", \"iki\", \"\u00fc\u00e7\", \"d\u00f6rt\", \"be\u015f\", \"alt\u0131\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Bu funksiyan\u0131\u00f1 vazifesi eki pozitiv san x ve y al\u0131p, [x, y] aral\u0131\u011f\u0131nda en b\u00fcy\u00fck c\u00fct tam san\u0131 qaytarmaq. E\u011fer b\u00f6yle bir san yoq ise, funksiyan\u0131 -1 qaytarmal\u0131.\n\nMisal \u00fc\u015f\u00fcn:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"Sizege eki m\u00fcsbet tamsay\u0131 n ve m berildi, ve sizin vazifeniz n'den m'ge qadar tamsay\u0131lar\u0131n ortalamas\u0131n\u0131 hesaplamakt\u0131r. \nCevapn\u0131 en yaq\u0131n tamsay\u0131\u011fa yuvarlap, on\u0131 ikilik sisteme \u00f6g\u00fcr\u00fcn.\nEger n, m'den b\u00fcy\u00fck bolsa, -1 qaytar\u0131\u00f1\u0131z.\nMisal:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Pozitiv tam sanlardan ibaret x berilgen. He\u00e7 bir cifrli r\u0259q\u0259mi olmayan\n    barl\u0131q elementlerni tertiplen\u0433\u0435\u043d t\u0131zimnen qaytars\u0131n.\n    \n    Not: Qaytar\u0131l\u011fan t\u0131zim artqan t\u0259rtipte tertiplengen bo\u0142u kerek.\n    \n    Mesela:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Berilgen butun sanlar massivinde, 1 ve 9 aral\u0131\u011f\u0131nda bulunan sanlarni tizlik, neticede al\u0131ngan massivni ters \u00e7evir, ve sonra her bir rakamni onun muvaf\u0131q isimi bilen de\u011fi\u015ftir: \"Bir\", \"\u0130ki\", \"\u00dc\u00e7\", \"D\u00f6rt\", \"Be\u015f\", \"Alt\u0131\", \"Yedi\", \"Sekiz\", \"Dokuz\".\n\nMisal uchun:\n  arr = [2, 1, 1, 4, 5, 8, 2, 3]\n        -> arrni tizlik -> [1, 1, 2, 2, 3, 4, 5, 8]\n        -> arrni ters \u00e7evir -> [8, 5, 4, 3, 2, 2, 1, 1]\n  netice [\"Sekiz\", \"Be\u015f\", \"D\u00f6rt\", \"\u00dc\u00e7\", \"\u0130ki\", \"\u0130ki\", \"Bir\", \"Bir\"]\n\n  E\u011fer massiv bo\u015ftur ise, bo\u015f massiv qaytart:\n  arr = []\n  netice []\n\n  E\u011fer massivde herhang\u0131 bir garip san bar ise, onu g\u00f6zard\u0131 et:\n  arr = [1, -1, 55]\n        -> arrni tizlik -> [-1, 1, 55]\n        -> arrni ters \u00e7evir -> [55, 1, -1]\n  netice ['Bir']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Funksiya f-ni n parametri olarak qabul etsin ve n ol\u00e7ekli bir list qaytars\u0131n, \u00f6yle ki i indeksindegi elementni\u00f1 q\u0131ymeti eger i \u00e7ift ise i-ni\u00f1 faktoriali,\n    yoxsa 1-den i-ge qadar olan reqamlarni\u00f1 cemi olsun.\n    i 1-den ba\u015flay.\n    i-ni\u00f1 faktoriali 1-den i-ge qadar olan reqamlarni\u00f1 \u00e7o\u011faltmas\u0131d\u0131r.\n    Misal:\n    f == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Pozitiv n butun san\u0131 berilgen, 1 den n ge qadar aral\u0131qtaki \u00e7ift ve tek\n    butun san palindromlarn\u0131\u00f1 say\u0131s\u0131n\u0131 qaytaratuv\u00e7\u0131 bir tuplam qaytar\u0131\u00f1\u0131z.\n\n    Misal1:\n\n        Input: 3\n        Output:\n        \u0130zahat:\n        Butun san palindromlar\u0131: 1, 2, 3. Bunlarn\u0131\u00f1 birisi \u00e7ift, ve ikisi tek.\n\n    Misal2:\n\n        Input: 12\n        Output:\n        \u0130zahat:\n        Butun san palindromlar\u0131: 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Bunlarn\u0131\u00f1 d\u00f6rdi \u00e7ift, ve alt\u0131s\u0131 tektir.\n\n    Not:\n        1. 1 <= n <= 10^3\n        2. Qaytar\u0131l\u011fan tuplamda \u00e7ift ve tek butun san palindromlar\u0131n\u0131\u00f1 say\u0131s\u0131 s\u0131raynen berilgen.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Bir `count_nums` funksiyas\u0131n\u0131 yaz\u0131\u00f1\u0131z, bu funksiya integerlerden te\u015fkil topamn\u0131 qab\u0131l etip,\n    raqamlar\u0131n\u0131\u00f1 cemi 0-dan b\u00fcy\u00fck olan elementlerni\u00f1 san\u0131n\u0131 qaytar\u0131r.\n    Eger bir raqam manfiy olsa, on\u0131\u00f1 birinci imzal\u0131 raqam\u0131 manfiy olur:\n    mesele, -123 imzal\u0131 raqamlar\u0131 -1, 2 ve 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Bizde N-integir arr[1], arr[2], ..., arr[N] elementlerinden ibaret 'arr' massivimiz bar. \n    Massivdeki so\u00f1lar rasgele tertipte olduklar\u0131. Sizin vazifeniz berilgen massivde \n    a\u015fag\u0131daki ameliyaatn\u0131 yap\u0131p, massivni artma tertibinde tertiplep oluv-almad\u0131\u011f\u0131n\u0131 \n    belilemek:\n        Size massivde herqanday miqdarda sa\u011fa s\u00fcr\u00fc\u015f ameliyaat\u0131n\u0131 yapma\u011fa izin berildi.\n\n    Bir sa\u011fa s\u00fcr\u00fc\u015f ameliyaat\u0131 massivdeki b\u00fct\u00fcn elementlerni bir pozitsiya\u011fa sa\u011fa s\u00fcrmek demek.\n    Massivni\u00f1 so\u00f1ki elementi massivni\u00f1 ba\u015flan\u011f\u0131\u00e7 pozitsiyas\u0131na k\u00f6\u00e7\u00fcr\u00fclecek, yani 0-c\u0131 indekske.\n\n    E\u011fer yuqarda\u011f\u0131 ameliyaatn\u0131 yap\u0131p, tertiplengen massivni al\u0131p oluv-alsa, netice True qaytar\u0131\u00f1,\n    aksi halda False qaytar\u0131\u00f1.\n    Berilgen massiv bo\u015f olsa, netice True qaytar\u0131\u00f1.\n\n    Not: Berilgen listede unique elementler barl\u0131\u011f\u0131n\u0131 garantiye al\u0131ngan.\n\n    M\u0131sal:\n\n    move_one_ball ==> True\n    A\u00e7\u0131klama: 2 sa\u011fa s\u00fcr\u00fc\u015f ameliyaat\u0131n\u0131 yap\u0131p, berilgen massiv artma tertibinde\n              tertiplengen ola bilir.\n    move_one_ball ==> False\n    A\u00e7\u0131klama: Berilgen massivni herqanday miqdarda sa\u011fa s\u00fcr\u00fc\u015f\n              ameliyaat\u0131n\u0131 yap\u0131p artma tertibinde tertiplep oluv-almaz.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Bu meselede, iki sanlar listesini al\u0131p, elementlerini de\u00f1i\u015ftirme yap\u0131p yapamayaca\u011f\u0131n\u0131 belirleyen bir funksiyan\u0131 implementatsiya edeceksiniz ki, lst1 yal\u00f1\u0131zca \u00e7ift sanlardan ibaret bir liste olsun. lst1 ve lst2 aras\u0131nda de\u00f1i\u015ftirilebilecek elementler say\u0131s\u0131nda hert\u00fcrl\u00fc s\u0131n\u0131rlama yoq.\n\nEger lst1 ve lst2 aras\u0131nda elementleri de\u00f1i\u015ftirip, lst1'ni\u00f1 b\u00fct\u00fcn elementlerini \u00e7ift yapmaq m\u00fcmkin ise, \"Evet\" qaytar\u0131n. Aksi takdirde, \"Yoq\" qaytar\u0131n.\n\nMeselenin misalleri:\nexchange => \"EVET\"\nexchange => \"YOQ\"\n\nInput listelerdi\u00f1 bo\u015f olmayaca\u011f\u0131 farzedile.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Bo\u015fluq ile ay\u0131r\u0131l\u011fan ki\u00e7ik xarflerni temsil etken bir yibni k\u00f6stergen halde, en k\u00f6p tekrarlan\u011fan xarfni ve mun\u0131\u00f1 say\u0131s\u0131n\u0131 ihtiva etken bir lu\u011fat qaytar\u0131\u00f1\u0131z.\nBirne\u00e7e xarfni\u00f1 birdey say\u0131 bar ise, olarn\u0131\u00f1 bar\u0131s\u0131n\u0131 qaytar\u0131\u00f1\u0131z.\n\nMisal:\nhistogram == {'a': 1, 'b': 1, 'c': 1}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'b': 4}\nhistogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"G\u00f6rev\n    Size iki s ve c qatar berilgen, s qatar\u0131ndaki c qatar\u0131ndaki herhangi bir belgige teng belgilerni \u00f6\u00e7\u00fcv gerek.\n    Ondan so\u00f1 netice qatar\u0131n\u0131n palindrom ol\u011fan\u0131n tek\u015fer.\n    Bir qatar geriyge ve ilerge oqu\u011fanda bir-dey bolsa, o palindrom dep atala.\n    Siz netice qatar\u0131n\u0131 ve tek\u015fer\u00fcv i\u00e7in Do\u011fru\/Yanl\u0131\u015f olan bir tuple qaytarma\u011fa kerek.\n    Misal\n    s = \"abcde\", c = \"ae\" i\u00e7in, netice) olmal\u0131\n    s = \"abcdef\", c = \"b\"  i\u00e7in, netice) olmal\u0131\n    s = \"abcdedcba\", c = \"ab\" i\u00e7in, netice) olmal\u0131\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Berilgen qatarlar tizmeleri icinde, her bir qatar faqat raqamlardan ibaret, bir tizme qaytar\u0131\u00f1\u0131z.\n    \u00c7\u0131qt\u0131 tizmelerini\u00f1 her bir elementi i, \"kiritilgen tizmeni\u00f1 i'ci qatar\u0131nda ne\u00e7e t\u0259k raqam bar\"\n    \u015feklinde olmal\u0131, ve her bir i, kiritilgen tizmeni\u00f1 i'ci qatar\u0131nda t\u0259k raqamlar san\u0131 ile\n    almasht\u0131r\u0131lmal\u0131.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Berilgen butun sanlardan ibaret nums massivinde, nums massivini\u00f1 i\u00e7indeki bo\u015f olmayan herqanday alt-massivni\u00f1 minimum cemi tap\u0131\u00f1\u0131z.\n    Misal\n    minSubArraySum == 1\n    minSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Sizge t\u00fcz biken quduqlar tarmas\u0131 berildi. Her sat\u0131r bitta quduqn\u0131 temsil etedi, \nve sat\u0131rdaki her 1 suyun bitta birligini temsil etedi. \nHer quduqn\u0131 suvin\u0131 \u00e7ikarmaq \u00fccin bir vedr\u0259si bar, ve bar\u00e7a vedr\u0259l\u0259r bir hil s\u0131y\u0131m\u011fa iye.\nSizni\u00f1 vazifeniz - vedr\u0259l\u0259rni qullan\u0131p quduqlarn\u0131 bo\u015faltmaq.\nVedr\u0259l\u0259rni ne\u00e7e kerekli sayda t\u00fc\u015f\u00fcrgenizni \u00e7\u0131qarmaq.\n\nMisal1:\n    Kirit\u00fc: \n        tarmak : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        vedr\u0259 s\u0131y\u0131m\u0131 : 1\n    Natija: 6\n\nMisal2:\n    Kirit\u00fc: \n        tarmak : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        vedr\u0259 s\u0131y\u0131m\u0131 : 2\n    Natija: 5\n\nMisal3:\n    Kirit\u00fc: \n        tarmak : [[0,0,0], [0,0,0]]\n        vedr\u0259 s\u0131y\u0131m\u0131 : 5\n    Natija: 0\n\nCheklavlar:\n    * bar\u00e7a quduqlar bir hil uzunluqqa iye\n    * 1 <= tarmak uzunl\u0131\u011f\u0131 <= 10^2\n    * 1 <= tarmak[:,1] uzunlu\u011fu <= 10^2\n    * tarmak[i][j] -> 0 | 1\n    * 1 <= s\u0131y\u0131m <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Bu Kata-da, siz s\u0131f\u0131rdan yuxar\u0131 tam sanlardan ibaret massivni ularning ikilik temsilat\u0131ndaki birlerin say\u0131s\u0131na g\u00f6re artan tartipte s\u0131ralamal\u0131s\u0131n\u0131z. Birlerin say\u0131s\u0131 bir-birine benzegen sanlar \u00fc\u00e7\u00fcn, onluq de\u011ferine g\u00f6re s\u0131ralay\u0131n\u0131z.\n\nBu \u015feilde icra edilmesi kerek:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Verilgen s tizgisi ve bir tabiiy n\u00f6m\u00fcr n ol\u011fan\u0131\u00f1\u0131zda, sizge bir funksiya implementatsiya etmek vazifesi berildi,\n    bu funksiya s tizgisindegi aynen n say\u0131da unda\u015flar ihtiva etken b\u00fct\u00fcn s\u00f6zlerni qaytar\u011fan bir liste qaytarmaq kerek,\n    bu s\u00f6zler s tizgisinde k\u00f6reli\u015f t\u0259rtibinde olmal\u0131.\n    Eger s tizgisi bo\u015f ise, funksiya bo\u015f bir liste qaytarmaq kerek.\n    Not: girdi tizgisi faqat harfler ve bo\u015fluqlar ihtiva etken dep farz etilgen.\n    Misaller:\n    select_words ==> [\"little\"]\n    select_words ==> [\"Mary\", \"lamb\"]\n    select_words ==> []\n    select_words ==> [\"world\"]\n    select_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"Sizege bir s\u00f6z berildi. Sizin vazifeniz, s\u00f6zning sa\u011f taraf\u0131ndan eki undusht\u0131\u00f1 aras\u0131nda tur\u011fan en yaq\u0131n \u00fcnl\u00fcni tapmaq.\n\nBa\u015f\u0131nda ve so\u00f1unda tur\u011fan \u00fcnl\u00fcler hesaplanmay. \u00dcstki \u015fartqa uyan \u00fcnl\u00fc tap\u0131lmasa, bo\u015f sat\u0131r qaytar\u0131\u00f1\u0131z.\n\nBerilgen sat\u0131r t\u0131rnaqlardan ibaret ingliz harflerini ihtiva etecek dep farz ete alas\u0131z.\n\nMisallar:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Verilmi\u015f arr tam say\u0131lar massivi ve m\u00fcsb\u0259t k tam say\u0131 verilg\u0259n, qaytar\u0131\u00f1\u0131z \n    arr i\u00e7indekilerden en y\u00fcksek k say\u0131n\u0131\u00f1 s\u0131ralan\u011fan tizimni.\n\n    Misal1:\n\n        Kiri\u015f: arr = [-3, -4, 5], k = 3\n        \u00c7\u0131kt\u0131: [-4, -3, 5]\n\n    Misal2:\n\n        Kiri\u015f: arr = [4, -4, 4], k = 2\n        \u00c7\u0131kt\u0131: [4, 4]\n\n    Misal3:\n\n        Kiri\u015f: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        \u00c7\u0131kt\u0131: [2]\n\n    Not:\n        1. Massivni\u00f1 uzunl\u0131\u011f\u0131 [1, 1000] aras\u0131nda olacaq.\n        2. Massivdegi elementler [-1000, 1000] aras\u0131nda olacaq.\n        3. 0 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Bo\u015f olmayan tamsay\u0131lar listesini g\u00f6z \u00f6n\u00fcnde bulundurarak, \u00e7ift pozisiyalarda bulunan tek elemanlar\u0131n toplam\u0131n\u0131 qaytar\u0131n.\n\n    Misaller:\n    \u00e7\u00f6z\u00fcm ==> 12\n    \u00e7\u00f6z\u00fcm ==> 9\n    \u00e7\u00f6z\u00fcm ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Bo\u015f olmayan bir tamsay\u0131lar dizisi arr ve bir tamsay\u0131 k verildi\u011finde, arr'nin ilk k eleman\u0131ndan en fazla iki rakaml\u0131 olan elemanlar\u0131n toplam\u0131n\u0131 d\u00f6nd\u00fcr\u00fcn.\n\nMisal:\n\n    Girdi: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    \u00c7\u0131kt\u0131: 24 # 21 + 3'\u00fcn toplam\u0131\n\nK\u0131s\u0131tlamalar:\n    1. 1 <= len <= 100\n    2. 1 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Pozitiv tamsay\u0131 n berilgen, Collatz s\u0131ralamas\u0131nda tek raqamlar ol\u011fan tertiplengen bir listeni qaytar.\n\nCollatz faraziyesi matematika\u011fa aid bir faraziyedir, ve \u015fu \u015fekilde tan\u0131mlan\u011fan bir s\u0131ralama\u011fa degenir: istal\u011fen bir pozitiv tamsay\u0131 n ile ba\u015flay. Ondan so\u00f1 her bir terim aldaqi terimden \u015fu \u015fekilde al\u0131n\u0131p: eger aldaqi terim \u00e7ift bolsa, ald\u0131n\u011f\u0131 terimni\u00f1 yar\u0131s\u0131 kibi al\u0131n\u0131r. Eger aldaqi terim tek bolsa, ald\u0131n\u011f\u0131 terimni\u00f1 3 katta\u011f\u0131 ve birni\u00f1 \u00fcst\u00fcne al\u0131n\u0131r. Faraziye \u015fundaki, n ne olsada, s\u0131ralama her zaman 1'e yeti\u015fir.\n\nNot:\n1. Collatz [1] dir.\n2. qaytar\u0131l\u011fan liste artan tertipte tertiplengen.\n\nMesela:\nget_odd_collatz [1, 5] qaytar\u0131r # 5 i\u00e7\u00fcn Collatz s\u0131ralamas\u0131 [5, 16, 8, 4, 2, 1] dir, yani tek raqamlar yaln\u0131z 1 ve 5.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"Sizge berilgen tarih strin\u011fini tek\u015firgecek ve e\u011fer tarih do\u011fr\u0131 bolsa True, aksi takdirde False qaytaracaq bir funksiya yazman\u0131z kerek.\nTarih a\u015fa\u011f\u0131daki qaidelerge uysa, do\u011fr\u0131 dep say\u0131lad\u0131:\n1. Tarih strin\u011fi bo\u015f olmamal\u0131.\n2. Kun san\u0131 1-den az ya da 1, 3, 5, 7, 8, 10, 12 aylarda 31-den yuqar\u0131 olmamal\u0131. 4, 6, 9, 11 aylarda kun san\u0131 1-den az ya da 30-dan yuqar\u0131 olmamal\u0131. 2. ayda kun san\u0131 1-den az ya da 29-dan yuqar\u0131 olmamal\u0131.\n3. Ay san\u0131 1-den az ya da 12-den yuqar\u0131 olmamal\u0131.\n4. Tarih \u015fu formatta olmal\u0131: aa-gg-yyyy\n\nmisal i\u00e7\u00fcn:\nvalid_date => True\n\nvalid_date => False\n\nvalid_date => False\n\nvalid_date => True\n\nvalid_date => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"A\u015fa\u011f\u0131daki c\u00fcmleyi Crimean Tatar diline terc\u00fcme ediniz:\n\n    Sizge eki interval berildi,\n    her bir interval eki intejir c\u00fcften ibaret. Meselen, interval = =.\n    Berilgen intervallar yumul\u011fan, bu demek interval\n    ba\u015flama ve bitmeni de i\u00e7ine alad\u0131.\n    Her berilgen interval \u00fc\u00e7\u00fcn, onun ba\u015flamas\u0131 bitmesinden ki\u00e7ik ya da beraberdir dep faraz etile.\n    Sizin vazifeniz bu eki intervalni\u00f1 kesi\u015fimini\u00f1 uzunlu\u011f\u0131n\u0131\u00f1 asal say\u0131 ol\u0131p olma\u011fan\u0131n belirlemek.\n    Misal, intervallarn\u0131\u00f1, kesi\u015fimi\n    olup, onun uzunlu\u011f\u0131 1'dir ki, bu asal say\u0131 de\u011fildir.\n    E\u011fer kesi\u015fimini\u00f1 uzunlu\u011fu asal say\u0131 olsa, \"Evet\" qaytar\u0131n,\n    aksi halde, \"Yoq\" qaytar\u0131n.\n    E\u011fer eki interval kesi\u015fmese, \"Yoq\" qaytar\u0131n.\n\n    [girdi\/\u00e7\u0131kt\u0131] numuneler:\n    intersection,) ==> \"Yoq\"\n    intersection,) ==> \"Yoq\"\n    intersection,) ==> \"Evet\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    Size berilgen integerlerden ibaret bir arr massiv ve sizge qaytarmaq kerek\n    her bir integerning kattal\u0131qlar\u0131n\u0131\u00f1 c\u00e4misi, massivdeki \n    her bir san i\u015faretlerini\u00f1 k\u00f6beytmesige k\u00f6beytilgen.\n    Qaytarman\u0131z: e\u011fer arr bo\u015f bolsa None qaytar\u0131\u00f1\u0131z.\n\n    Misal:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Berilgen tor ile N sat\u0131r ve N s\u00fctun ve m\u00fcspet tamsay\u0131 k, torun her h\u00fccresinde bir de\u011fer bar. [1, N * N] aral\u0131\u011f\u0131ndaki her tamsay\u0131 torun h\u00fccrelerinde tam olarak bir kez g\u00f6r\u00fcn\u00fcr.\n\nTor i\u00e7inde uzunlu\u011fu k olan en k\u00fc\u00e7\u00fck yolu tapmaq laz\u0131ms\u0131n. Herhangi bir h\u00fccreden ba\u015flayabilirsin ve her ad\u0131mda kom\u015fu h\u00fccrelerden birine ge\u00e7ebilirsin, yani mevcut h\u00fccrenle kenar payla\u015fan h\u00fccrelere gidebilirsin.\nUnutma ki uzunlu\u011fu k olan bir yol, tam olarak k h\u00fccreyi ziyaret etmek demektir.\nTor d\u0131\u015f\u0131na \u00e7\u0131kamazs\u0131n.\nUzunlu\u011fu k olan bir yol A, yol B'den k\u00fc\u00e7\u00fckt\u00fcr diye kabul edilir e\u011fer A ve B'nin ge\u00e7ti\u011fi h\u00fccrelerin de\u011ferlerinden yap\u0131lan s\u0131ral\u0131 listeler lexikografik olarak lst_A, lst_B'den k\u00fc\u00e7\u00fckse, yani \u00f6yle bir tamsay\u0131 indeks i var ki lst_A[i] < lst_B[i] ve her j i\u00e7in lst_A[j] = lst_B[j] vard\u0131r.\nCevab\u0131n e\u015fsiz oldu\u011fu garanti edilir.\nMinimum yolun ge\u00e7ti\u011fi h\u00fccrelerin de\u011ferlerinin s\u0131ral\u0131 listesini d\u00f6nd\u00fcr.\n\nMisallar:\n\n    Girdi: tor = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n    \u00c7\u0131kt\u0131: [1, 2, 1]\n\n    Girdi: tor = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n    \u00c7\u0131kt\u0131: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Herkes Fibonacci tizimlesini biley, so\u00f1ki bir ka\u00e7 yuzy\u0131lda matematik\u00e7iler taraf\u0131ndan derinden incelendi. Amma, adamlarn\u0131\u00f1 bimegen \u015feysi Tribonacci tizimlesidir.\nTribonacci tizimlesi \u015fu tekrar formula ile tan\u0131mlan\u011fan:\ntri = 3\ntri = 1 + n \/ 2, e\u011fer n \u00e7ift olsa.\ntri =  tri + tri + tri, e\u011fer n tek olsa.\nMesela:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n           = 2 + 3 + 3 = 8 \nSize nolu bir m\u00fcsbet olmayan tamsay\u0131 verildi, siz Tribonacci tizimlesinin ilk n + 1 adam\u0131n\u0131 qaytarmaq zorundas\u0131n\u0131z.\nMisallar:\ntri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Pozitiv tam say n berilgen, tek t\u0259k raqamlar\u0131n\u0131\u00f1 hasilini qaytar\u0131\u00f1\u0131z.\n    Eger b\u00fct\u00fcn raqamlar c\u00fcft bolsa, 0 qaytar\u0131\u00f1\u0131z.\n    M\u0131sal i\u00e7\u00fcn:\n    digits == 1\n    digits == 0\n    digits == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"Sizege raqamlar t\u0131zmas\u0131 berildi.\n    Sizge berilgen t\u0131zmadaki raqamlar kvadratlar\u0131n\u0131\u00f1 cemi kerek,\n    \u0259vv\u0259lce t\u0131zmadaki her bir elementni yuxar\u0131 tamsay\u0131\u011fa yuvarla\u00f1\u0131z.\n    Misallar:\n    Eger lst = [1,2,3] bolsa, netice 14 olmal\u0131\n    Eger lst = [1,4,9] bolsa, netice 98 olmal\u0131\n    Eger lst = [1,3,5,7] bolsa, netice 84 olmal\u0131\n    Eger lst = [1.4,4.2,0] bolsa, netice 29 olmal\u0131\n    Eger lst = [-2.4,1,1] bolsa, netice 6 olmal\u0131\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Bir funksiya yarat\u0131p, elementni\u00f1 eng zurlan\u011fan indeksini qaytar\u011fan, bu element on\u0131\u00f1 ald\u0131ndaki elementten b\u00fcy\u00fck ya da teng emes. Eger b\u00f6yle bir element yoqsa, -1 qaytar\u0131ls\u0131n. Berilgen massivde dublikat q\u0131ymetler bolmayacaq.\n\nMisallar:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Funktsiya yarat\u0131p, integerlerni, floatlarn\u0131 ya da ger\u00e7ek raqamlar\u0131 temsil etken stringlerni qab\u0131l etsin ve berilgen de\u011fi\u015fken tipinde en b\u00fcy\u00fck de\u011fi\u015fkeni qaytars\u0131n. Eger de kiymetler te\u00f1s\u0259, None qaytars\u0131n. Not: Eger ger\u00e7ek raqam string olaraq temsil etilgen bolsa, onl\u0131q n\u00f6qtesi . ya da , ola bilir.\n\ncompare_one \u00e2 -> 2.5\ncompare_one \u00e2 -> \"2,3\"\ncompare_one \u00e2 -> \"6\"\ncompare_one \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Berilgen n sa\u00adn\u0131n\u0131\u00f1 aynen 4 m\u00fcsbet \u00e7ift sa\u00adn\u0131n\u0131\u00f1 cemi ol\u0131p olamayaca\u011f\u0131n de\u011ferlendiri\u00f1iz\n    Misal\n    is_equal_to_sum_even == Yanl\u0131\u015f\n    is_equal_to_sum_even == Yanl\u0131\u015f\n    is_equal_to_sum_even == Do\u011fru\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Braziliyal\u0131q faktorialn\u0131\u00f1 tarif\u0131 \u015fe: \n    brazilian_factorial = n! *! *! * ... * 1!\n    bu yerde n > 0\n\n    M\u0131sal i\u00e7\u00fcn:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Berilgen matnni\u00f1 aral\u0131q belgisini\u00f1 yerini und\u0131rl\u0131q belgisinen de\u011fi\u015ftir, \n    ve e\u011fer matnda 2-den ziyade ard arda aral\u0131q belgi varsa, \n    onda b\u00fct\u00fcn ard arda aral\u0131q belgilerini tire belgisinen de\u011fi\u015ftir.\n    \n    fix_spaces == \"Example\"\n    fix_spaces == \"Example_1\"\n    fix_spaces == \"_Example_2\"\n    fix_spaces == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Bir funksiyan\u0131 yarat\u0131n\u0131z, bu funksiya fayl ismini k\u00f6stergen bir s\u0131z\u0131nt\u0131n\u0131 al\u0131p,\n    fayl ismi ge\u00e7erli olsa 'Evet', aksi takdirde 'Hay\u0131r' qaytar\u0131r.\n    Fayl ismi ge\u00e7erli dep say\u0131l\u011fan\u0131 i\u00e7\u00fcn a\u015faq\u0131da\u011f\u0131 \u015fartlar\u011fa uymal\u0131:\n    - Fayl isminde \u00fc\u00e7t\u0259n fazla raqam olmamal\u0131.\n    - Fayl isminde tam bir n\u00f6kte '.' olmal\u0131.\n    - N\u00f6kteden evelki q\u0131s\u0131m bo\u015f olma\u011fan ve bu b\u00f6l\u00fcm latin elifbesindeki bir arif ile ba\u015flama\u011f\u0131 kereklidir.\n    - N\u00f6kteden so\u00f1ki q\u0131s\u0131m \u015fu kibi olmal\u0131: ['txt', 'exe', 'dll']\n    Misallar:\n    file_name_check # => 'Evet'\n    file_name_check # => 'Hay\u0131r'\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"Bu funksiya bir integerler dizisini alacaq. Dizideki b\u00fct\u00fcn \u00f6\u011feler i\u00e7in, eger indeks 3 kerefesi olsa, funksiya integer \u00f6\u011feni kvadratlayacaq ve eger indeks 4 kerefesi ve 3 kerefesi olmasa, integer \u00f6\u011feni kubalayacaq. Funksiya indeksi ne 3, ne 4 kerefesi olmayan \u00f6\u011feleri de\u00f1i\u015ftirmeyecek. Funksiya so\u00f1unda b\u00fct\u00fcn \u00f6\u011felerin toplam\u0131n\u0131 qaytaracaq.\n\nMisallar:\nEger lst = [1,2,3] olsa, netice 6 bolmal\u0131\nEger lst = [] olsa, netice 0 bolmal\u0131\nEger lst = [-1,-5,2,-1,-5] olsa, netice -126 bolmal\u0131\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Size berilgen c\u00fcmle, c\u00fcmlede ayr\u0131q s\u00f6zler bar, ve sizge orijinal c\u00fcmledeki s\u00f6zlerni\u00f1 uzunl\u0131qlar\u0131 prime raqamlar ol\u011fan s\u00f6zlerni qaytarmaq kerek, yeni c\u00fcmleni\u00f1 tertibi orijinal c\u00fcmledekiyle bir olmal\u0131.\n\n    Misal1:\n        Kirim: c\u00fcmle = \"Bu bir s\u0131nav\"\n        \u00c7\u0131qt\u0131: \"bir\"\n\n    Misal2:\n        Kirim: c\u00fcmle = \"haydi y\u00fczmeye gidelim\"\n        \u00c7\u0131qt\u0131: \"y\u00fczmeye\"\n\n    \u015eartlar:\n        * 1 <= uzunl\u0131\u011f\u0131 <= 100\n        * c\u00fcmlede faqat heripler bar\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"To solve the problem, we need to implement a function that checks if the product of two fractions \\ and \\ is a whole number. Here's a step-by-step approach to achieve this:\n\n1. **Parse the Input Strings:** Convert the fraction strings into their numerator and denominator components.\n2. **Multiply the Fractions:** Compute the product of the two fractions.\n3. **Check for Whole Number:** Determine if the resulting product is a whole number.\n\nHere's the detailed implementation:\n\n```python\ndef simplify:\n    # Helper function to parse a fraction string \"a\/b\" into\n    def parse_fraction:\n        numerator, denominator = map)\n        return numerator, denominator\n    \n    # Parse the fractions\n    num_x, den_x = parse_fraction\n    num_n, den_n = parse_fraction\n    \n    # Multiply the fractions: *\n    # This is equivalent to \/\n    product_numerator = num_x * num_n\n    product_denominator = den_x * den_n\n    \n    # Check if the product numerator is divisible by the product denominator\n    if product_numerator % product_denominator == 0:\n        return True\n    else:\n        return False\n\n# Test cases\nprint)  # True\nprint)  # False\nprint)  # False\n```\n\n### Explanation:\n1. **Parsing the Fractions:**\n   - We use the `parse_fraction` helper function to split each fraction string into its numerator and denominator. This function converts the string components to integers for further calculations.\n\n2. **Multiplying the Fractions:**\n   - The product of two fractions \\ results in \\. We compute the product of the numerators and the product of the denominators.\n\n3. **Checking for Whole Number:**\n   - To determine if the fraction \\ is a whole number, we simply check if the numerator is divisible by the denominator. If it is, the result is a whole number.\n\nThis approach ensures that we correctly identify if the product of the two given fractions is a whole number and handles the fractions as per the problem's requirements.\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Berilgen tamsay\u0131lar dizisini,\n    onlar\u0131n raqamlar\u0131 cemi artan tartipta sortlay\u0131c\u0131 funksiya yaz\u0131\u00f1\u0131z.\n    Not: e\u011fer bir ne\u00e7e itemn\u0131\u00f1 raqamlar\u0131 cemi bir-birine benzer olsa,\n    onlar\u0131 orijinal dizideki indekslerine g\u00f6re tartipteyiniz.\n\n    Mesela:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Massivni\u00f1 elementleri aras\u0131nda 10-dan b\u00fcy\u00fck ve her iki, birinci hem de so\u00f1ki raqamlar\u0131 tek olan elementlerni sanay eden bir funksiya yaz\u0131\u00f1\u0131z. Meselen:\nspecialFilter => 1 \nspecialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    Sizge bir m\u00fcspet but\u00fcn say\u0131 n berildi. Siz n uzunlu\u011funda bir but\u00fcn say\u0131 massiv a yaratmal\u0131s\u0131n\u0131z.\n        Her bir i i\u00e7\u00fcn, a[i] = i * i - i + 1 k\u0131m\u0131t\u0131n\u0131 olmal\u0131. \u00fc\u00e7l\u00fclerin say\u0131s\u0131n\u0131 tap\u0131p qaytar\u0131\u00f1\u0131z, buradaki i < j < k ve \n    a[i] + a[j] + a[k] 3'ge b\u00f6l\u00fcngen.\n\n    Misal:\n        Giriz\u00fc: n = 5\n        \u00c7\u0131qt\u0131: 1\n        \u0130zahat: \n        a = [1, 3, 7, 13, 21]\n        Tek do\u011fru \u00fc\u00e7l\u00fck.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Funksiya qabul etken s\u00f6zler tizimlisini parametr sifat\u0131nda qab\u0131l etsin,\n    uzunl\u0131\u011f\u0131 tek olan s\u00f6zlerni ondan \u00f6\u00e7irsin,\n    ve neticeni s\u0131ralan\u011fan tizlikte qaytars\u0131n,\n    Tizim her zaman s\u00f6zler tizimi ve asla raqamlar massivi olmayacaq,\n    ve ol takrarlamalar i\u00e7erip olabiler.\n    Tizimni\u00f1 tertibi her bir s\u00f6zni\u00f1 uzunl\u0131\u011f\u0131na k\u00f6re artqan tertipte olmal\u0131, ve siz\n    tizimni bu qaid\u00e4 boyun\u00e7a s\u0131ralan\u011fan halda qaytarma\u011fa kereksiz.\n    E\u011fer eki s\u00f6zni\u00f1 uzunl\u0131\u011f\u0131 bir-birine te\u00f1e bolsa, tizimni alfavit boyun\u00e7a s\u0131ralan\u011fan halda qaytar\u0131\u00f1\u0131z.\n    Funksiya s\u0131ralan\u011fan tertipte s\u00f6zler tizimini qaytarmal\u0131.\n    B\u00fct\u00fcn s\u00f6zlerni\u00f1 bir-birine te\u00f1e uzunl\u0131qta olaca\u011f\u0131n\u0131 farzedse\u00f1iz bolar.\n    Mesela:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Sade bir program, eger n sade edi olsa, x ni\u00f1 qiymetini qaytarmaq kerek ve aks halda y ni\u00f1 qiymetini qaytarmaq kerek.\n\nMisallar:\nx_or_y == 34\nx_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Menimce, hepimiz, nihayet bir uzun m\u00fcddet k\u00fctken vaqiyan\u0131\u00f1 neticesi belli ol\u011fan so\u00f1ki duy\u011fulard\u0131 hat\u0131rlaym\u0131z. \u015eu vaq\u0131ttaki duy\u011fular\u0131 ve fikirleri mutlaka yaz\u0131p, taqdir etmek laz\u0131m. Sizin vazifeniz, bir ki\u015finin bir s\u0131ra ma\u00e7lar\u0131n neticelerini do\u011fru tahmin edip etmegenini belirmek. Size, her indeksi bir ma\u00e7\u0131 k\u00f6stergen iki bir uzunluql\u0131qta ballar ve tahminler massivleri berildi. Her tahminni\u00f1 ne qadar yaq\u0131n ol\u011fan\u0131n\u0131 k\u00f6sterip bercek ayn\u0131 uzunluql\u0131qta bir massiv qaytar\u0131\u00f1\u0131z. Eger tahmin do\u011fru bolsa, deger 0\u2019d\u0131r, ve eger do\u011fru bolsa, tahmin ve netice aras\u0131ndaki mutlaq farkt\u0131r.\n\nmisal:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Sizge bir s\u0131n\u0131f ad\u0131 ve kiyme listesi berilecek.\n    Bu kiymeler s\u0131n\u0131fa qo\u015fum\u00e7a s\u0131n\u0131flar yuklemek i\u00e7\u00fcn qullan\u0131lacaq. \n    Kiymeni\u00f1 g\u00fcc\u00fc \u015foyle hesaplan\u0131r: CAP kiymeni\u00f1 ad\u0131nda bol\u011fan b\u00fcy\u00fck arflerni\u00f1 \n    say\u0131s\u0131d\u0131r, ve SM kiymeni\u00f1 ad\u0131nda bol\u011fan k\u00fc\u00e7\u00fck arflerni\u00f1 say\u0131s\u0131d\u0131r, \n    g\u00fc\u00e7 CAP - SM fraction\u0131nen beriledi. \n    Siz en g\u00fc\u00e7l\u00fc kiymeni tap\u0131p, bu formatta bir yaz\u0131 qaytarma\u011f\u0131n\u0131z kerek: \n    ClassName.StrongestExtensionName.\n    Eger ikiden art\u0131q kiyme bir y\u00fcze g\u00fc\u00e7e sahib olsa, siz listede birinci\n    kelgenini saylaman\u0131z kerek.\n    Mesela, eger sizge \"Slices\" s\u0131n\u0131f\u0131 ve kiymelerni\u00f1 listesi berilse: \n    ['SErviNGSliCes', 'Cheese', 'StuFfed'] siz 'Slices.SErviNGSliCes' qaytarma\u011f\u0131n\u0131z \n    kerek \u00e7\u00fcnki 'SErviNGSliCes' en g\u00fc\u00e7l\u00fc kiymedir.\n    Misal:\n    Strongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Size 2 s\u00f6z beriledi. \u0130kinci s\u00f6z ya da on\u0131\u00f1 herhangi bir rotatsiyas\u0131 birinci s\u00f6zde i\u00e7 s\u00f6z bolsa, True qaytarmaq kerek:\n    cycpattern_check => Yanl\u0131\u015f\n    cycpattern_check => Do\u011fru\n    cycpattern_check => Yanl\u0131\u015f\n    cycpattern_check => Do\u011fru\n    cycpattern_check => Yanl\u0131\u015f\n    cycpattern_check => Do\u011fru\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Berilgen tamsay\u0131. Tiyin qaytar\u0131\u00f1\u0131z, anda eki va tek sanlar san\u0131 moskemesinen keltirilgen.\n\n     Misal:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Beregen m\u00fcsbet but\u00fcn say\u0131 \u00fc\u00e7\u00fcn on\u0131\u00f1 rim raqam\u0131 ekvivalentini s\u0131m olarak al\u0131n ve onu ki\u00e7ik heriflerle qaytar\u0131\u00f1.\nK\u0131s\u0131tlamalar: 1 <= num <= 1000\n\nMisallar:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Bir funksiya yaz\u0131\u00f1\u0131z, o stringler tizimcesini qabul etsin.\n    Tizimce turlu s\u00f6zlerni i\u00e7erir. En ziyade unikal simvollar\u011fa ega bol\u011fan\n    s\u00f6zni qaytar\u0131\u00f1\u0131z. Birka\u00e7 string en ziyade unikal simvollar\u011fa ega bolsa,\n    leksikografik tertipte birinci keleni qaytar\u0131\u00f1\u0131z.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Sen a\u00e7 tav\u015fans\u0131n ve zaten belli say\u0131da havu\u00e7 yedin,\nama \u015fimdi g\u00fcn\u00fcn yemeklerini tamamlamak i\u00e7in daha fazla havu\u00e7 yemen gerekiyor.\nBir dizi d\u00f6nd\u00fcrmelisin: [ yemeklerinden sonra yedi\u011fin toplam havu\u00e7 say\u0131s\u0131,\n                          yemeklerinden sonra kalan havu\u00e7 say\u0131s\u0131 ]\nE\u011fer yeterli kalan havu\u00e7 yoksa, kalan b\u00fct\u00fcn havu\u00e7lar\u0131 yiyeceksin ama h\u00e2l\u00e2 a\u00e7 kalacaks\u0131n.\n\n\u00d6rnek:\n* eat -> [11, 4]\n* eat -> [12, 1]\n* eat -> [11, 0]\n* eat -> [7, 0]\n\nDe\u011fi\u015fkenler:\n@number : tamsay\u0131\n    yedi\u011fin havu\u00e7 say\u0131s\u0131.\n@need : tamsay\u0131\n    yemen gereken havu\u00e7 say\u0131s\u0131.\n@remaining : tamsay\u0131\n    stokta mevcut olan kalan havu\u00e7 say\u0131s\u0131.\n\nK\u0131s\u0131tlamalar:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\n\u0130yi e\u011flenceler :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    \u0130ki operator ve operand listesi berilgen. Birinci liste as\u0131yl\u0131 algebra amellerine, eki\u00f1ci liste ise tamsay\u0131lar\u011fa i\u00e7ine al\u0131p turad\u0131r. Berilgen eki listeni qullan\u0131p algebraik ifadeni quru ve bu ifadenin bahas\u0131n\u0131 qaytarmaq.\n\nAs\u0131yl\u0131 algebra amelleri:\nQo\u015fuv \n\u00c7\u0131qaruv \nK\u00f6beyt\u00fcv \nTam b\u00f6l\u00fcv \n\u00dcst\u00fc \n\nMisal:\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nnetice = 2 + 3 * 4 - 5\n=> netice = 9\n\nNot:\n    Operator listesini\u00f1 uzunl\u0131\u011f\u0131 operand listesini\u00f1 uzunl\u0131\u011f\u0131ndan bir kemsedir.\n    Operand - m\u00fcsbiy tamsay\u0131lar listesidir.\n    Operator listesinde hi\u00e7 bolma\u011fanda bir operator, ve operand listeside hi\u00e7 bolma\u011fanda eki operand bar.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Sizege s \u0131s\u0131m berilgen.\n    eger s[i] bir herf bolsa, onu\u00f1 registrini tersine \u00e7evirin: yuqar\u0131dan a\u015fa\u00f1\u011fa ya da tersine,\n    eksin\u00e7e, onu oz hal\u0131nda qald\u0131r\u0131n.\n    Eger \u0131s\u0131mda bir herf yoq bolsa, \u0131s\u0131mn\u0131 tersine \u00e7evirin.\n    Funksiya neticelengen \u0131s\u0131mn\u0131 qaytarmaq ker\u00e7ek.\n    Misallar:\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Berilgen 'text' simvol qatar\u0131n\u0131\u00f1 md5 hash ekvivalentini qaytar\u0131\u00f1\u0131z.\n    Eger 'text' bo\u015f simvol qatar\u0131 bolsa, None qaytar\u0131\u00f1\u0131z.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    \u0130ki m\u00fcsbet tam say\u0131 a ve b berilgen, a ve b aras\u0131nda bulunan c\u00fcft raqamlar\u0131 artma s\u0131ras\u0131na k\u00f6re qaytar\u0131\u00f1\u0131z.\n\nM\u0131sal \u00fc\u015f\u00fcn:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]