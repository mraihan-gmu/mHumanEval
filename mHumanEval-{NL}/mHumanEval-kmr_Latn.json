[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Here is the translation of the given sentence into Northern Kurdish:\n\n\"Li l\u00eesteya hejmar\u00ean dawi, kontrol bike ka her du hejmar\u00ean li hev n\u00eaz\u00eektir in ji astengiya dan\u00eey\u00ea.\"\n\nExample:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input\u00ea v\u00ea f\u00eanksiyona yek r\u00eazok e ku t\u00ea de gelek kom\u00ean t\u00eepan\u00ean malper\u00ea hene. Armanc\u00ea te ew e ku ew koman bi r\u00eazok\u00ean cuda biger\u00een\u00ee u l\u00eestey\u00ea wan veger\u00eenin\u00ee.\n    Kom\u00ean cuda hene bi pi\u015ftgiriy\u00ea \u00fb ne di nava hev de hene.\n    Her h\u00ee\u00e7 cawiy\u00ea di r\u00eazok\u00ea de tune ye.\n    Nim\u00fbne:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Heke hejmareke floating point ya poz\u00eet\u00eef hat\u00ee b\u00eenin, ew dikare b\u00ea veqetandin \n    \u00fb be\u015feke tevahi\n    \u00fb be\u015feyan.\n\n    Be\u015feya decimal a hejmarke veger\u00eene.\n    Nim\u00fbne:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ez li ser v\u00ea devok\u00ea h\u00fbnerek li ser hesaba bank\u00ea ku bi sifir balans dest p\u00ea dike, day\u00een \u00fb rakirin\u00ea dan\u00een \u00fb rakirin\u00ea day\u00een \u00fb rakirin\u00ea day\u00een \u00fb rakirin\u00ea day\u00een \u00fb rakirin\u00ea day\u00een \u00fb rakirin\u00ea dikim. Kar\u00fbbar\u00ea we ew e ku agahdar\u00ee bidin ku da ku hertim balans\u00ea ya hesaba ji sifir\u00ea b\u00eatir dike, \u00fb di v\u00ea ketiya de f\u00fbnksiyona hewce ye ku rast bibe. Heke ne, ew div\u00ea rast be. Nim\u00fbne:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Ji bo l\u00eesteya t\u00eakildar\u00ean hejmar\u00ean veguhezt\u00ee, Berhemjen\u00ee li ser navenda ev dataset hesib bike.\n    Berhemjen\u00ee navenda, di navenda her\u00ee navenda:\n    MAD = berhemjen\u00ee | x - x_mean |\n    Nim\u00fbne:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" L\u00eahevokek 'delimeter' di navbera her du ti\u015ft\u00ean p\u00ea\u015fp\u00ea\u015f\u00ee y\u00ean l\u00eesteya t\u00eakildar 'numbers' de biniv\u00eese.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" H\u00eenerek ev f\u00fbnksiyona t\u00ea dike str\u00eengek ku gelek kom\u00ean parantez\u00ean t\u00eabir\u00ee \u00fb bi navbera wan destn\u00ee\u015fan dike.\n    Ji bo her komek, derketina astengiya her\u00ee dir\u00eaj ya parantez\u00ean t\u00eabigerin n\u00ee\u015fan bide.\n    M\u00eenak\u00ee,) niv\u00eena her\u00ee z\u00eade y\u00ean t\u00eabir\u00ee du ast\u00ean hene l\u00ea)) s\u00ea ast\u00ean hene.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filtereke r\u00eazeya t\u00eakiliy\u00ean t\u00eaketin\u00ea ten\u00ea bo y\u00ean ku t\u00eakiliya taybet\u00ee girtineke.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Ji bo lista ti\u015ft\u00ean hejmar\u00ee, pa\u015fve tupek\u00ee ku tevahiya k\u00eejan \u00fb berhem\u00ea hem\u00fb hejmar\u00ean di lista de di nav de heye veger\u00eene.\n    K\u00eej\u00ee vala div\u00ea 0 be \u00fb berhem vala div\u00ea 1 be.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Ji l\u00eesteya hejmar\u00ean vehat\u00ee, l\u00eesteya her\u00ee z\u00eadeya berdewam \u00e7\u00eabikin ku heta demeke di r\u00eaz\u00ea de hatib\u00fb d\u00eetin.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Ji bo testkirina stringek eger palindrome be \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" H\u00fbn du r\u00eaz\u00ean t\u00eep \u00ean a \u00fb b t\u00eakevin pi\u015ft\u00ee ku ten\u00ea ji 1 \u00fb 0 re p\u00eak t\u00eane.\n    Li ser van t\u00eakevin binary XOR bike \u00fb encam\u00ea j\u00ee wek\u00ee r\u00eaz\u00ea t\u00eep\u00ea veger\u00eenin.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Ji l\u00eesteya r\u00eaz\u00ean, ew r\u00eaza ku dir\u00eajtir e veger\u00eene. Di rew\u015fa ku gelek r\u00eaz\u00ean bi hevah\u00ee dir\u00eaj in, y\u00ea yekem veger\u00eene. Di rew\u015fa ku l\u00eesteya input vala be, None veger\u00eene.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Vegere her\u00eam\u00ea her\u00ee mezin a herdu hejmaran a \u00fb b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" L\u00eesteya hem\u00fb p\u00ea\u015fve\u00e7\u00fbnek\u00ean ji kurtir\u00een bo dir\u00eajtir\u00een a r\u00eazevan\u00ea ya daxistin\u00ea veger\u00eene.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Herf\u00ean hejmar\u00ean ji sifir\u00ea heta n'\u00ea tev\u00ee di navbera wan de bi vala veqet\u00ee bikin.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Ji bo r\u00eazokek, bizan \u00e7end t\u00eep\u00ean c\u00fbda t\u00ea de hene.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Her\u00eam\u00ea v\u00ea f\u00eelter\u00ea t\u00eep e ku d\u00eemen\u00ean muz\u00eek\u00ee di formata taybet\u00ee ya ASCII de n\u00ee\u015fan dide.\nKar\u00ea we ew e ku v\u00ea t\u00eep\u00ea biguher\u00eenin \u00fb l\u00eesteya hejmar\u00ean z\u00eade bikin ku diyar dikin \u00e7end d\u00eemen her notek dim\u00eenin.\n\nEw hem\u00fb al\u00eekar\u00eeyan hene:\n'o' - nota tevah\u00ee, \u00e7ar d\u00eemen dim\u00eene\n'o|' - nota n\u00eev, du d\u00eemen dim\u00eene\n'.|' - nota \u00e7arrek, yek d\u00eemen dim\u00eene\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" D\u00eetin \u00e7end caran ku tekena taybet di xet\u00ea or\u00eej\u00eenal de d\u00eetin dibe. Derbar\u00ea helwest\u00ean dihevketin\u00ea j\u00ee bin\u00eare.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Here is the translation of your sentence into Northern Kurdish:\n\n\"Input ji r\u00eazok\u00ean d\u00eej\u00eetal\u00ean 'zero' heta 'nine' bi space-veqetand\u00ee t\u00ea.\n    Hilbijartin\u00ean derbasdar in 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' \u00fb 'nine'.\n    String\u00ea veger\u00eenin ku hejmaran ji her bi\u00e7\u00fbk\u00ee re heta her mezin\u00ee ve r\u00eaz bike.\"\n\nPlease let me know if you need any adjustments or additional translations!\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Ji l\u00eesteya hejmaran y\u00ean ku di navbera xwe de her\u00ee n\u00eaz\u00eek in, du hejmaran hilbij\u00earin \u00fb bi r\u00eaza xwe veger\u00eenin.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Bersiveke hejmareke, transformasyonek x\u00eaz\u00ee bike ser v\u00ea bersiv\u00ea,\n    w\u00ea watey\u00ea ku pi\u00e7\u00fbktir\u00een hejmar d\u00ea bibe 0 \u00fb mezintr\u00een d\u00ea bibe 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" L\u00eesteya daney\u00ean python\u00ea ya hatiye day\u00een ten\u00ea ji bo hejmara t\u00eep\u00ean integer filtr bikin.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Dir\u00eajahiya r\u00eaza dayikb\u00fby\u00ee veger\u00eene\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Ji bo hejmarek n, mezin\u200c\u062a\u0631\u06cc\u0646 hejmarek bib\u00eene ku n bi hev re ya heje, ku ji n\u00ea k\u00eam be\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Here is the translation of the given sentence into Northern Kurdish:\n\nL\u00eesteya faktoran\u00ean pir\u00eemekan ya hejmar\u00ea ya day\u00een li ser r\u00eaza ji her\u00ee bi\u00e7\u00fbk\u00ea bo her\u00ee mezin.\nHer yek ji faktoran dema ku ji factorazasyon\u00ea de \u00e7end caran t\u00ea d\u00eetin, hema ew qas caran heye di l\u00eestey\u00ea de.\nHejmara t\u00eakel\u00ee div\u00ea wek\u00ee hilber\u00eena hem\u00fb faktoran wekhev be.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Ji lista hejmar\u00ean tevahi, hem\u00fb ti\u015ft\u00ean ku pirr caran t\u00eane d\u00eetin, j\u00ea bide.\n    R\u00eaza van ti\u015ftan ku dim\u00eenin wek ku di t\u00eaketin\u00ea de b\u00fb, wisa bim\u00eene.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Ji bo r\u00eaza-zek\u00ee ya d\u00eeyay\u00ee, t\u00eepan\u00ean bi\u00e7\u00fbk biguher\u00eenin ser t\u00eepan\u00ean mezin \u00fb t\u00eepan\u00ean mezin biguher\u00eenin ser t\u00eepan\u00ean bi\u00e7\u00fbk.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" L\u00eesteya r\u00eaz\u00ean bi hev ve gir\u00eaday\u00ee bike bo r\u00eazek\u00ea.\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" L\u00eesteyek t\u00eaketin\u00ea ya r\u00eazok\u00ean ten\u00ea ji bo y\u00ean ku bi p\u00ea\u015fb\u00een\u00eeyek\u00ea dest p\u00ea dikin p\u00ea\u015fk\u00ea\u015f bikin.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Ten\u00ea hejmar\u00ean poz\u00eet\u00eef\u00ean t\u00ea de veger\u00eene.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Eger hejmar\u00ea dane prime be, rast\u00ee vegere, \u00fb heke ne be, xelet vegere.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Pol\u00eenom\u00ea bi koeff\u00ees\u00eeyan\u00ean xs di xeyan\u00ea de qada dike.\n    veger\u00eene xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"Ev f\u00fbnksiyon dikare listek l bibe \u00fb listek l' veger\u00eene ku\n    l' bi l' yeksan e li index\u00ean ku bi s\u00ea ve nepar\u00eaz\u00ee dikin, l\u00ea nirx\u00ean w\u00ea li index\u00ean ku bi s\u00ea ve par\u00eaz\u00ee dikin wek nirx\u00ean index\u00ean hevpeyman a l' in, l\u00ea herweha r\u00eaz kirin.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Li ser d\u00eemen\u00ea li benda yekane y\u00ean r\u00eaz kir\u00ee veger\u00eenin\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Elemana her\u00ee mez\u00een li l\u00eestey\u00ea veger\u00eenin.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Hejmara carek\u00ee ku hejmar\u00ea 7'\u00ea di hejmar\u00ean k\u00eamter ji n de dibe ku bi 11 an j\u00ee 13 y\u00eane, veger\u00eene.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"Ev f\u00fbnksiyon l\u00eesteya l\u00eal\u00ea dike \u00fb l\u00eesteya l\u00eal\u00ea' dide, wisa ku\n    l\u00eal\u00ea' li indeks\u00ean t\u00fbk li h\u00eaman l\u00eal\u00ea ye, l\u00ea giyan\u00ean w\u00ea li indeks\u00ean cift bi\n    giyan\u00ean indeks\u00ean cift \u00ean l\u00eal\u00ea ye, l\u00ea li r\u00eaza kir\u00ee ne.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    Guhertoya r\u00eazik\u00ean s\u00ea t\u00eepanan bi \u015fikl\u00ea vegerandin\u00ea.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib n-\u00ea y\u00ea ku hejmarek\u00ea Fibonacci ye \u00fb wisa j\u00ee hejmarek\u00ea bingeh\u00een e, vedigere.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero l\u00eesteya hejmar\u00ean t\u00eep\u00ean tevlihev dike wek\u00ee input.\n    Ger s\u00ea endam\u00ean c\u00fbda li l\u00eestey\u00ea hene ku kom\u00ean wan sifir dibe, ew raste dide, \u00fb ger nebe, ew raste nedide.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Fikir bike ku r\u00eayek heye ku x\u00eazika rast \u00fb dir\u00eaj e b\u00eadaw\u00ee.\n    n erebeyan ji \u00e7ep\u00ea bo rast\u00ea r\u00ea didin; heman dem\u00ea, kom\u00ea din ji n erebeyan\n    ji rast\u00ea bo \u00e7ep\u00ea r\u00ea didin.  Du kom\u00ean erebeyan di destp\u00eaka de ji hev z\u00fbran dir\u00eajin.\n    Hem\u00fb erebey\u00ean bi heman lez\u00ea re tevger dikin.  Du erebeyan di navbera du araban de dema ku erebeyeke ji \u00e7ep\u00ea bo rast\u00ea av\u00eat dike \u00fb erebeyeke ku ji rast\u00ea bo \u00e7ep\u00ea av\u00eat dike, t\u00ea deyn.  \n    L\u00eabel\u00ea, erebeyan p\u00ea\u015fxistiyan \u00fb h\u00eazdar in b\u00eadaw\u00ee; ji ber v\u00ea yek\u00ea, ew bi r\u00eaya xwe di tevgera xwe de di\u00e7e wek\u00ee ku ew ne deyn.\n    \n    Ev fonksiyon hejmar\u00ea deynan t\u00eaxistin\u00ea dide derve.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"L\u00eestey\u00ea veger\u00eene bi p\u00eevan\u00ean ku bi 1 z\u00eade kirin.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    `pairs_sum_to_zero` lista hejmar\u00ean tevgeran wek\u00ee input\u00ea t\u00ea hildan.\nGer di lista de du heyam\u00ean cuda y\u00ean ku hejmarek zero bidin hebe, ew rast\u00ee dide, \u00fb heke nebin, ew rast nake.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Guhertina hewcey\u00ee ya binar\u00ee ya hejmarek\u00ea x ya binar\u00ee.\n    Veger\u00eenin r\u00eaza t\u00eep\u00ea pi\u015ft\u00ee veguhastin\u00ea.\n    Hejmara binar\u00ee k\u00eamter ne ji 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Eger dir\u00eajahiya al\u00eekek \u00fb bilindiyek were b\u00eajin, erdahiy\u00ea ji bo s\u00eago\u015feyek vegere.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"R\u00eazik\u00ea hejmar\u00ea Fib4 yek r\u00eazik e ku bi r\u00eazik\u00ea Fibonacci re t\u00eakildar e \u00fb wek\u00ee ber\u00ea ve, ev reng e:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    Ji kerema xwe yek f\u00fbnksiyon biniv\u00eesin ku bi kar\u00eaz\u00eey\u00ea j\u00eabir\u00ee p\u00eevan\u00ean n-yem\u00een ya r\u00eazik\u00ea hejmar\u00ea fib4\u00ea hesib bike. Recursion ne bikar b\u00eene.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Veber\u00ea nav\u00een a wan ti\u015ftan di l\u00eaz\u00ea l de veger\u00eene.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Li dia kontrol dike ka eger r\u00eazok ji wan peyv\u00ean dan\u00ee palindrom e.\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Vegere 2^n mod p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    Di nav alfabey\u00ea de her t\u00eep\u00ea bi 5 t\u00eepan vegerandin derdixe string\u00ea.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels yek\u00ea fonksiyon\u00ea ku xet\u00eadike \u00fb xet\u00ea b\u00ea dengd\u00ear vegerandine.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Ger heke hem\u00fb hejmar\u00ean di l\u00eestey\u00ea l de bin asteng\u00ea t be, rast derx\u00eene.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Du hejmar x \u00fb y z\u00eade bike.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Ji kerema xwe kontrol bike ka du peyv t\u00eakiliya heman t\u00eepan hene.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Hejmara Fibonacci a n-\u00een veger\u00eene.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Brackets r\u00eaza \"<\" \u00fb \">\" ye.\n    Eger her a\u00e7keriya bracketek bi bracketek g\u0131rt\u00ee y\u00ea berhevkar heb\u00fbbe, rast\u00ee veger\u00eene.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Ger hewcey\u00ean l\u00eestey\u00ea ya p\u00ea\u015f\u00eev an j\u00ee k\u00eam bikevin, rast\u00ee veger\u00eene.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Veger\u00eene l\u00eesteya hevpar\u00ean yekane y\u00ean r\u00eazkir\u00ee ji bo du l\u00eesteyan.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Guhertin faktora sereke y\u00ea her\u00ee mezin a n'y\u00ea veger\u00eenin. Qeb\u00fbl bikin ku n > 1 e \u00fb n prime n\u00eene.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n yek funciyoneke ku hejmare ji 1\u00ee heta n\u00ee z\u00eade dike.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" T\u00eer\u00eaj\u00ea ya parantez\u00ea \"\" e.\n    Ger her parantez\u00ea vebij\u00eark hevrast bikaribe, rast e.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs koef\u00eesiyent\u00ean pol\u00een\u00f4meyek\u00ee n\u00ee\u015fan dide.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Ferz\u00eeya v\u00ea pol\u00een\u00f4mey\u00ea di heman \u015f\u00eawaz\u00ea de vegere.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"R\u00eazeya hejmar\u00ean FibFib r\u00eazeya ku bi Fibonacci wekhev e ku wek\u00ee v\u00ea re t\u00ea d\u00eetin:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Ji kerema xwe f\u00fbnksiyonek biniv\u00ees\u00eenin da ku bi away\u00ea kar\u00eeger\u00ea y\u00ea n-em\u00een a r\u00eazeya hejmar\u00ean fibfib\u00ea hesib bike.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nTest\u00ean z\u00eadetir l\u00ea bike.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Herfan\u00ean hejmarek\u00ea ya x bi r\u00eay\u00ean govend\u00ee biger\u00eenin, herfan\u00ean bi r\u00eay\u00ean rastan biger\u00eenin \u00fb encam\u00ea wek\u00ee r\u00eazdar\u00ee veger\u00eenin. \nGer shift ji hejmar\u00ean hejmar\u00ea mezintir be, herfan\u00ean veger\u00eenin.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Kar\n    Wek\u00ee fonksiyonek biniv\u00eese ku str\u00eengek wek\u00ee input gire dike \u00fb hem\u00fb koda ASCII-y\u00ean t\u00eepan mezin \u00ean\n    t\u00eep\u00ean mezin bi hev re dike \u00fb wan dide.\n\n    Nim\u00fbne:\n        digitSum => 0\n        digitSum => 131\n        digitSum => 67\n        digitSum => 69\n        digitSum => 131\n        digitSum => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    Di v\u00ea kar\u00ea de, h\u00fbn\u00ea r\u00eazokek bist\u00eenin ku hejmarek s\u00eavek \u00fb hinaran n\u00ee\u015fan dide ku di kerahiyeke f\u00eak\u00ee de belav b\u00fbne; ev kerahi t\u00ea de s\u00eavek, hinaran \u00fb mango hene. H\u00fbn\u00ea r\u00eazok\u00ea bist\u00eenin ku hejmarek tevah\u00ee hinar \u00fb s\u00eavek n\u00ee\u015fan dide \u00fb hejmarek tevah\u00ee f\u00eak\u00eeyan di kerahiy\u00ea de n\u00ee\u015fan dide; ev hejmarek mango f\u00eak\u00ee di kerahiy\u00ea de n\u00ee\u015fan dide.\nBikaran\u00een:\nfruit_distribution -> 19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"Hing\u00ea li gor\u00ee arrayek ku \u015faxa dar\u00ea n\u00ee\u015fan dide ku t\u00eep\u00ean integer\u00ean ne-negatif hene,\nkar\u00ea te ev e ku yek ji t\u00eep\u00ean wan \u00e7ek bik\u00ee \u00fb w\u00ea t\u00eep\u00ea veger\u00ee.\nT\u00eepa \u00e7ekkir\u00ee div\u00ea t\u00eep\u00ea be ku k\u00eam\u00eena nirxa jor\u00een heye.\nGelo gelek t\u00eep\u00ean bi heman k\u00eam\u00eena nirxa jor\u00een hene, ya t\u00eep\u00ea veger\u00eene ku k\u00eam\u00eena index\u00ea heye.\n\nT\u00eepa \u00e7ekkir\u00ee div\u00ea li ser listek\u00ea veger\u00eene [ k\u00eam\u00eena nirx, index\u00ea w\u00ea ],\nGelo nirx\u00ean jor\u00een tunin an arrayek\u00ea ya dan\u00ee vala ye, [ ] veger\u00eene.\n\nM\u00eenak\u00ea 1:\n    Input: [4,2,3]\n    Output: [2, 1]\n    P\u00eanase: 2 k\u00eam\u00eena nirx\u00ea jor\u00een heye, \u00fb 2 k\u00eam\u00eena index\u00ea heye.\n\nM\u00eenak\u00ea 2:\n    Input: [1,2,3]\n    Output: [2, 1]\n    P\u00eanase: 2 k\u00eam\u00eena nirx\u00ea jor\u00een heye, \u00fb 2 k\u00eam\u00eena index\u00ea heye.\n\nM\u00eenak\u00ea 3:\n    Input: []\n    Output: []\n\nM\u00eenak\u00ea 4:\n    Input: [5, 0, 3, 0, 4, 2]\n    Output: [0, 1]\n    P\u00eanase: 0 k\u00eam\u00eena nirx\u00ea heye, l\u00ea 0 y\u00ean du hene,\n             ji ber v\u00ea yek\u00ea me y\u00ea yekem\u00een 0 yan bijartin, ku k\u00eam\u00eena index\u00ea heye.\n\nP\u00eadiviy\u00ean:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\"\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    Eger arrayek\u00ea arr ya ji hejmaran hebe, hinek\u00ea ya k\u00eamtir\u00een y\u00ean t\u00eakildar a ku div\u00eat biguherin da arrayek bi palindromic bikin bib\u00eenin. Arrayek palindromic arrayek\u00ea ye ku pi\u015ft\u00ee ve \u00fb p\u00ea\u015f de wusa xwendin e. Di guher\u00eena yek\u00ea de, te dikar\u00ee yek elemant bi her elemant\u00ea din biguher\u00een.\n\nBi misal:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Here is the translated sentence in Northern Kurdish:\n\n\"Fons\u00eeyek biniv\u00ees ku ger hejmarek\u00ea y\u00ea day\u00een ji s\u00ea hejmarek\u00ean p\u00ee\u015feha yekb\u00fbn\u00ea be, rast\u00ee veger\u00eene, \u00fb bi rast\u00ee veger\u00eene. Zan\u00een\u00ea ku k\u00eamtir\u00ee ji 100-\u00ea ye. M\u00eenak:\nis_multiply_prime == Rast\n30 = 2 * 3 * 5\"\n\nIf you need further assistance or any more translations, feel free to ask!\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"Kar\u00ea te ew e ku f\u00fbnksiyonek biniv\u00ees\u00ee ku rast\u00ee bid\u00ea heke hejmarek x h\u00eaza h\u00easana n-\u00ea be \u00fb di doza din de xelet bid\u00ea.\nx y\u00ea h\u00eaza h\u00easana n-\u00ea ye heke n**int=x be\nM\u00eenake:\nis_simple_power => rast\nis_simple_power => rast\nis_simple_power => rast\nis_simple_power => xelet\nis_simple_power => xelet\nis_simple_power => xelet\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"Here's the translation of the provided sentence into Northern Kurdish:\n\n\"Tu kar\u00ea te hatiye ku f\u00eelterek biniv\u00ees\u00ee ku jimarek\u00ea hexadesmal wek\u00ee r\u00eazokek wergire \u00fb jimareya hexadesmal \u00ean prime bide. Jimarek\u00ean hexadesmal in 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Jimarek\u00ean prime in 2, 3, 5, 7, 11, 13, 17,... Ji ber v\u00ea yek\u00ea tu hewcey\u00ee ku jimareya y\u00ean di bin de ye diyar bik\u00ee: 2, 3, 5, 7, B, D. N\u00eem\u00fbne: h\u00fbn dikin ku input hema rast e an j\u00ee r\u00eazok\u00ea vala e, \u00fb sembol\u00ean A, B, C, D, E, F hem\u00fb wek\u00ee mezin in. N\u00eem\u00fbne: Ji bo num = \"AB\" derdixe 1. Ji bo num = \"1077E\" derdixe 2. Ji bo num = \"ABED1A33\" derdixe 4. Ji bo num = \"123456789ABCDEF0\" derdixe 6. Ji bo num = \"2020\" derdixe 2.\"\n\nNote: The translation captures the essence of the original text, but as with any technical translation, some specific terms might need further clarification depending on the target audience's familiarity with the subject matter.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"Hun hejmara ku t\u00ea de form\u00ea desimal\u00ea de t\u00ea dane \u00fb p\u00ee\u015fta we ye ku ew biguhez\u00eenin formata bin\u00ear\u00ee. Fonksiyona div\u00ea stringek veger\u00eene, ku her t\u00eep bin\u00eareke n\u00ee\u015fan didin. Her t\u00eep di string\u00ea de d\u00ea '0' an '1' be.\n\nD\u00ea du t\u00eepan z\u00eadetir 'db' li destp\u00eak\u00ea \u00fb li dawiya string\u00ea de be. T\u00eep\u00ean z\u00eadetir ne ji bo al\u00eekar\u00eeya form\u00ea ye.\n\nM\u00eenak\u00ean:\ndecimal_to_binary   # veger dike \"db1111db\"\ndecimal_to_binary   # veger dike \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"H\u00fbn dan\u00eenek r\u00eazkirin\u00ea s h\u00fbn\u00ea bidin.\nKar\u00ea we ye kontrol bike ku r\u00eazkirina xwe\u015f e an na.\nR\u00eazkirin\u00ea xwe\u015f e heke dir\u00eajahiya w\u00ea her\u00ee k\u00eam 3 be \u00fb her s\u00ea t\u00eepan berhevkir\u00ee cuda bin.\nMisal\u00ean:\nis_happy => Na\nis_happy => Na\nis_happy => Er\u00ea\nis_happy => Na\nis_happy => Er\u00ea\nis_happy => Na\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"Ev hefteya daw\u00ee ya semestr\u00ea ye \u00fb mamost\u00ea div\u00ea notan bidin xwendekaran. Mamost\u00ea algoritma xwe ya ji bo notan \u00e7\u00eakir\u00ee ye. Pirsgir\u00eaka yekane ew e ku koda ku w\u00ee ji bo notan bikar an\u00ee winda kir\u00ee ye. W\u00ee listek ji bo GPAn xwendekaran daye te \u00fb tu div\u00ee f\u00fbnksiyonek biniv\u00ees\u00ee ku dikare listek not\u00ean t\u00eep\u00ea bi kar an\u00eey\u00ea ji bo GPAn veke\u015f\u00eene. Bi r\u00eaya tabloya j\u00ear\u00een:\n\n             GPA       |    Nota t\u00eep\u00ea\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Nim\u00fbne:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Funk\u00eesyonek biniv\u00eese ku r\u00eazokek were bigre \u00fb ger der\u00eazaya r\u00eazok\u00ea hejmar\u00eak bingeh\u00een be rast\u00ee True veger\u00eene an\u00een herwiha False.\nNim\u00fbneyan\nprime_length == Rast\nprime_length == Rast\nprime_length == Rast\nprime_length == N\u00earast\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Ji bo yek hejmar\u00ea poz\u00eet\u00eef n, hejmara hejmar\u00ean poz\u00eet\u00eef y\u00ean \u00ean n-hejmara ku bi 1 dest p\u00ea dikin an j\u00ee bi 1 qediya dikin veger\u00eenin.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Eger r\u00eazimana poz\u00eet\u00eef N b\u00ea, tevahiya cem\u00ea hejmar\u00ean w\u00ea di bin\u00eare de veger\u00eene.\n\n    Nim\u00fbne\n        Ji bo N = 1000, cem\u00ea hejmaran \u00ea 1 e \u00fb derketin d\u00ea \"1\" be.\n        Ji bo N = 150, cem\u00ea hejmaran \u00ea 6 e \u00fb derketin d\u00ea \"110\" be.\n        Ji bo N = 147, cem\u00ea hejmaran \u00ea 12 e \u00fb derketin d\u00ea \"1100\" be.\n\n    Guhertoy\u00ean:\n        @N hejmar\n             S\u00eenor: 0 \u2264 N \u2264 10000.\n    Derketin:\n         r\u00eazehejmara bin\u00earan\u00ee\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Dane lista yekem\u00ee ji hejmar\u00ean t\u00eep\u00ea lst. yekem \u00e7alak\u00ean tenik y\u00ean ku li mijar\u00ean naven\u00eenin bin.\n\n    Nim\u00fbneyan:\n        add ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    V\u00ea xet\u00ea bi Kurmanc\u00ee werger\u00eene:\n\n\"Funk\u00eesyonek b\u00eanv\u00ees\u00eene ku r\u00ea\u00e7 berde, \u00fb r\u00ea\u00e7eke amade kir\u00ee veger\u00eene.\n    R\u00ea\u00e7eke amade kir\u00ee ya r\u00ea\u00e7\u00ea, r\u00ea\u00e7ek e ku hem\u00fb peyv\n    bi peyv\u00ea n\u00fb ve qeb\u00fbl bikin ku hem\u00fb t\u00eepan di r\u00eaz\u00ea de bi q\u00eemeta ascii ve arezane.\n    N\u00ee\u015fe: Tu div\u00ea r\u00eaz\u00ea peyvan \u00fb vala y\u00ean di r\u00ea\u00e7\u00ea de bixebit\u00eene.\n\n    M\u00eenak ji bo nim\u00fbne:\n    anti_shuffle 'Hi' veger\u00eene\n    anti_shuffle 'ehllo' veger\u00eene\n    anti_shuffle 'Hello !!!Wdlor' veger\u00eene\"\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    H\u00fbn dan\u00eeneyek 2 p\u00ea\u015ferojeya, wek\u00ee l\u00eestey\u00ean nest, h\u00fbn dikarin bi matris re t\u00eakildar bikin, l\u00eabel\u00ea, di heman dem\u00ea de, her r\u00eazek dikare hejmar\u00ean st\u00fbnan y\u00ean cuda bi xwe hebin. H\u00fbn dan\u00eeneke lst \u00fb hejmar\u00eak x h\u00fbn heye, her weha hejmar\u00ean x di l\u00eestey\u00ea de bib\u00eenin, \u00fb l\u00eestey\u00ean tupl\u00ean veger\u00eenin, [, ...] wek\u00ee ku her tupl yek r\u00eazeya koordinat e -, bi 0 dest p\u00ea dike. Koordinatan ji r\u00eaz\u00ean ber bi r\u00eaz\u00ean bi r\u00eazkirina z\u00eade r\u00eaz bikin. Her weha, koordinat\u00ean r\u00eaz\u00ea bi st\u00fbnan di r\u00eazgirtina k\u00eamtir\u00een de r\u00eaz bikin.\n\nM\u00eenak\u00ean:\nget_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1) == [,,,,]\nget_row == []\nget_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Miroveke joreke amade ji t\u00eep\u00ean hejmareke ne-negatifan, kopiyeke joreke amade pa\u015f\u00ea r\u00eaz kirin\u00ea veger\u00eene.\n    H\u00fbn joreke amade bi r\u00eaza zayenda r\u00eaz dikin eger tev\u00ee xurt e,\n    an joreke bi r\u00eaza daxuyan\u00ee r\u00eaz dikin eger tev\u00ee z\u00fbtir e.\n\n    N\u00ee\u015fe:\n    * joreke amade nekevin.\n\n    Nim\u00fbne:\n    * sort_array => []\n    * sort_array => [5]\n    * sort_array => [0, 1, 2, 3, 4, 5]\n    * sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Here is the translated text in Northern Kurdish:\n\n\"Fonkesyoneke \u00e7\u00eabike bi nav\u00ea encrypt ku dizewata r\u00eakeveke wek\u00ee argument \u00fb\n    stringek\u00ee bi \u015f\u00eefre kir\u00ee vegere. Alfabe div\u00ea wekhev bike ku t\u00eepan bi du cih di du deran de biguher\u00eene.\n    M\u00eenak\u00ee:\n    encrypt dibe 'lm'\n    encrypt dibe 'ewhjklnop'\n    encrypt dibe 'kj'\n    encrypt dibe 'ix'\"\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    H\u00fbn dikarin r\u00eazokek amaran bidin.\n    F\u00fbnksiyona next_smallest niv\u00eesin ku d\u00eejmin\u00ea 2-em\u00een y\u00ean k\u00eamtir\u00een y\u00ea r\u00eazok\u00ea veger\u00eene.\n    Veger\u00eene None ger tu elemek w\u00ee reng\u00ee tune be.\n\n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    H\u00fbn bi str\u00eey\u00ea peyvan \u00ead\u00ee bibin, \u00fb kar\u00ea we ew e ku hejmar\u00ea tarsiy\u00ean bibin. Tars\u00ee j\u00eamall\u00eeyeke ku bi peyv\u00ea \"Ez\" dest p\u00ea dike. J\u00eamall\u00eeyan bi '.', '?' an j\u00ee '!' t\u00eane \u015firandin.\n\nB\u00eernek:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Here is the translation of the provided sentence into Northern Kurdish:\n\n\"Fonk\u00eesyonek\u00ee biniv\u00eese ku peyameke digire \u00fb w\u00ea encode dike \nku hem\u00fb t\u00eep\u00ean heman\u00ee biguhez\u00eene, hem\u00fb dengb\u00eaj\u00ean peyamek\u00ea \nbi t\u00eep\u00ea ku 2 c\u00eeh p\u00ea\u015f\u00ee w\u00ee dengb\u00eaj\u00ea di alfabey\u00ea \u00cengil\u00eez\u00ee de xuya dibe \nbiguhere. \nTeq\u00eena ten\u00ea t\u00eep\u00ean.\"\n\nExamples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"H\u00fbn r\u00eaza hejmar\u00ean tevlihev h\u00fbn\u00ea bidin.\n    H\u00fbn p\u00eadiv\u00ee ye ku mezinr\u00een nirxa p\u00ea\u015fman diyar bikin \u00fb tevahiya hejmar\u00ean w\u00ea vegerin.\n\n    Nim\u00fbneyan:\n    Ji bo lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] encam div\u00ea be 10\n    Ji bo lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] encam div\u00ea be 25\n    Ji bo lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] encam div\u00ea be 13\n    Ji bo lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] encam div\u00ea be 11\n    Ji bo lst = [0,81,12,3,1,21] encam div\u00ea be 3\n    Ji bo lst = [0,8,1,2,1,7] encam div\u00ea be 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Here is the translation of the given text into Northern Kurdish:\n\nEger ferhenga te bigire, bi rast\u00ee veger\u00eene True eger hem\u00fb miftey\u00ean t\u00ea dikan beyan\u00ee bin, an j\u00ee hem\u00fb miftey\u00ean t\u00ea dikan beyan\u00ee mez\u00een bin, h\u00een\u00e7\u00ee veger\u00eene False. Fonksiyona te div\u00ea veger\u00eene False eger ferhenga te vala be.\nNim\u00fbneyan:\ncheck_dict_case div\u00ea veger\u00eene True.\ncheck_dict_case div\u00ea veger\u00eene False.\ncheck_dict_case div\u00ea veger\u00eene False.\ncheck_dict_case div\u00ea veger\u00eene False.\ncheck_dict_case div\u00ea veger\u00eene True.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Here is the translation of the sentence into Northern Kurdish:\n\n\"Fonk\u00eesyonek bi kar b\u00eene ku hejmar\u00eeke ne-negat\u00eev\u00ea t\u00ea de bike \u00fb arrayek\u00ea ji hejmar\u00ean yekem\u00een y\u00ean n prime y\u00ean ku k\u00eamtir n in veger\u00eene.\nm\u00eenaka:\ncount_up_to => [2,3]\ncount_up_to => [2,3,5,7]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17,19]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17]\"\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Here is the translation of the sentence into Northern Kurdish:\n\n**T\u00eamam bike v\u00ee f\u00fbnksiyona ku du hejmar\u00ean t\u00eakevin diwe \u00fb hilberdana y\u00ean yektay\u00ean wan veger\u00eene.**\n**Guman bike ku agahdariya t\u00eakevin\u00ea her dem rast e.**\n**M\u00eenak\u00ean:**\n**multiply div\u00ea 16 veger\u00eene.**\n**multiply div\u00ea 72 veger\u00eene.**\n**multiply div\u00ea 0 veger\u00eene.**\n**multiply div\u00ea 20 veger\u00eene.**\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Dibe stringek s, hejmareya deng\u00ean mezin \u00ean serok\u00ea li indekseke tenik bidin.\n\n    M\u00eenak:\n    count_upper dibe 1\n    count_upper dibe 0\n    count_upper dibe 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Bihor\u00ee her\u00eam\u00eeyek\u00ee n, div\u00ea tu pilek\u00ea bi astey\u00ean n y\u00ean keviran \u00e7\u00eak\u00ee. \n    Asta yekem n keviran heye.\n    Jimara keviran li asta p\u00ea\u015f\u00een:\n        - Hejmara pa\u015f\u00een eger n t\u00eev bibe.\n        - Hejmara pa\u015f\u00een eger n c\u00fbdah\u00ee bibe.\n    Jimara keviran li her asta bi listek\u00ea veger\u00eene, ku ti\u015ft\u00ea li index\u00ea\n    i jimara keviran li asta n\u00ee\u015fan dide.\n\n    Nim\u00fbne:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Te r\u00eaza peyvan\u00ean ku bi komay\u00ean an c\u00eeh\u00ean vala ve parvebike were day\u00een. Kar\u00ea te ew e ku r\u00eaza bibij\u00eere \u00fb w\u00ea pi\u015ftrast bike.\n\nMisal:\nwords_string == [\"Hi\", \"nav\u00ea\", \"min\", \"John\", \"e\"]\nwords_string == [\"Yek\", \"du\", \"s\u00ea\", \"\u00e7ar\", \"p\u00eanc\", \"\u015fe\u015f\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Ev f\u00fbnksiyona du hejmar\u00ean poz\u00eet\u00eef x \u00fb y t\u00ea dike \u00fb pi\u00e7\u00fbktir\u00een hejmar\u00ea tev\u00ee yekem\u00een hejmar\u00ea d\u00eest\u00ee y\u00ea ku di navbera [x, y] de ye veger\u00eenine. Heke ew hejmar tune be, f\u00fbnksiyona div\u00ea -1 veger\u00eene.\n\nM\u00eenaka:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"H\u00fbn du hejmar\u00ean poz\u00eet\u00eef n \u00fb m derxistin, \u00fb kar\u00eeya we ew e ku hejmar\u00ean ji n heta m bi navberin. Bersiva xwe heta hejmar\u00ea n\u00eaz\u00eek bikin \u00fb w\u00ea ji bo bin\u00ear\u00ee bin\u00earin.\nHeke n ji m mezintir be, -1 veger\u00eenin.\nM\u00eenak:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Dema ku l\u00eesteya hejmar\u00ean poz\u00eet\u00eev y\u00ean x day\u00een, l\u00eesteyek bi r\u00eaz kir\u00ee ya hem\u00fb t\u00eepan veger\u00eenin ku tu amadeh\u00ean d\u00eej\u00eet\u00eev\u00ean z\u00fbtir n\u00eenin.\n\nN\u00ee\u015fe: L\u00eesteya veger\u00ee nay\u00ea div\u00eat bi r\u00eaza her\u00ee z\u00eade n\u00een.\n\nBo nim\u00fbne:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Eger ku c\u00eevanek hejmar\u00ean utom, hejmar\u00ean di navbera 1 \u00fb 9 de bin ve r\u00eaz bikin, r\u00eaza dagirin, \u00fb pa\u015f\u00ea her hejmar bi nav\u00ea w\u00ea y\u00ean \"Yek\", \"Du\", \"S\u00ea\", \"\u00c7ar\", \"P\u00eanc\", \"\u015ee\u015f\", \"Heft\", \"He\u015ft\", \"Ne\" biguher\u00eenin.\n\nM\u00eenak\u00ea:\n\n  arr = [2, 1, 1, 4, 5, 8, 2, 3]\n        -> arr r\u00eaz bike -> [1, 1, 2, 2, 3, 4, 5, 8]\n        -> arr dagire -> [8, 5, 4, 3, 2, 2, 1, 1]\n  veger\u00eene [\"He\u015ft\", \"P\u00eanc\", \"\u00c7ar\", \"S\u00ea\", \"Du\", \"Du\", \"Yek\", \"Yek\"]\n\n  Eger ku c\u00eevan vala be, c\u00eevanek vala veger\u00eenin:\n  arr = []\n  veger\u00eene []\n\n  Eger ku c\u00eevan hejmar\u00ean xer\u00eeb hebe, w\u00ee riya bike:\n  arr = [1, -1, 55]\n        -> arr r\u00eaz bike -> [-1, 1, 55]\n        -> arr dagire -> [55, 1, -1]\n  veger\u00eene ['Yek']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Kar\u00fbbar\u00ea f\u00ea bikar b\u00eene ku n'\u00ea wek\u00ee parametre digire,\n    \u00fb li ser\u00ea n'e kelemek li ser\u00ea mezinah\u00ee n'\u00ea veger\u00eenine, wek\u00ee ku nirx\u00ea t\u00eakel\u00ea li index i factorial\u00ea i'\u00ea eger i t\u00eak e\n    an j\u00ee yekem\u00ean hejmaran ji 1 heta i'\u00ea.\n    i dest p\u00ea dikin ji 1.\n    factorial\u00ea i'\u00ea j\u00ee yekem\u00ean hejmaran ji 1 heta i'\u00ea.\n    Nim\u00fbne:\n    f == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Dema ku n-yekem\u00ee ya poz\u00eet\u00eef hat\u00ee, tuple-eke veger\u00eene ku hejmar\u00ean palindrom\u00ean t\u00ee-\u00fb-tek \u00fb t\u00ee-\u00fb-tek y\u00ean ku di di navbera de t\u00eane, t\u00eakevin.\n\nM\u00eenake1:\n\n    Input: 3\n    Output:\n    R\u00fbpel:\n    Integer palindrome in 1, 2, 3. yek ji wan t\u00ee-\u00fb-teke, \u00fb du ji wan t\u00ee-\u00fb-teke.\n\nM\u00eenake2:\n\n    Input: 12\n    Output:\n    R\u00fbpel:\n    Integer palindrome in 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. \u00e7ar ji wan t\u00ee-\u00fb-teke, \u00fb \u015fe\u015f ji wan t\u00ee-\u00fb-teke.\n\nNot:\n    1. 1 <= n <= 10^3\n    2. tuple-eke veger\u00eene ku hejmar\u00ean palindrom\u00ean integer y\u00ean t\u00ee-\u00fb-tek \u00fb t\u00ee-\u00fb-tek bi r\u00eaze.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Here is the translation of the given sentence into Northern Kurdish:\n\n```\nFonk\u00eesyonek biniv\u00eese count_nums ku arrayek ji hejmar\u00ean tevahi t\u00ea wergirtin \u00fb hejmara par\u00e7e y\u00ean ku komkujiy\u00ean wan > 0 t\u00ea de bide vegerandin.\nGer hejmarek neget\u00eev be, ew\u00ea r\u00eazeya yekem\u00ee ya t\u00ea sign bikar b\u00eene neget\u00eev:\nM\u00eenak\u00ee, -123 r\u00eazeya sign dike -1, 2 \u00fb 3.\n```\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Me arrayek 'arr' ji N hejmaran arr[1], arr[2], ..., arr[N] heye. Hejmara di array\u00ea de bi awayek\u00ee rastdiger\u00ee t\u00eane r\u00eaz kirin. Kar\u00ea te ev e ku b\u00eay\u00eeka ku ew array bi r\u00eaza nede\u015fand\u00ee li benda bik\u00ee:\n    Tu dikar\u00ee kar\u00ea shift\u00ea rast\u00ea \u00e7end caran bi kar b\u00een\u00ee.\n\nYek shift\u00ea rast\u00ea ya wate shiftkirina hem\u00fb p\u00eevan\u00ean array\u00ea bi yek r\u00eaz\u00ea li r\u00eaza rast\u00ea ye. Dawiya p\u00eevan\u00ea ya array\u00ea d\u00ea ber\u00ea v\u00ea array\u00ea t\u00ea, wate, indexa 0. \n\nGer tu dikar\u00ee bi karan\u00eena v\u00ea kar\u00ea array\u00ea bi r\u00eaza nede\u015fand\u00ee bist\u00ee, d\u00ea rast be, heke na, d\u00ea xelet be.\nGer array\u00ea ya hatiye day\u00een vala be d\u00ea rast be.\n\nT\u00eab\u00een\u00ee: L\u00eesteya hatiye day\u00een bi p\u00eevan\u00ean taybet\u00ee ye.\n\nM\u00eenak\u00ean:\n    \nmove_one_ball==>Rast\nRave: Bi karan\u00eena 2 shift\u00ea rast\u00ea, r\u00eaza nede\u015fand\u00ee ya v\u00ea array\u00ea t\u00ea day\u00een.\nmove_one_ball==>Xelet\nRave: Neh\u00eale ku r\u00eaza nede\u015fand\u00ee ji bo v\u00ea array\u00ea bi karan\u00eena her \u00e7end shift\u00ean rast\u00ea.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Di v\u00ea pirsgir\u00eak\u00ea de, h\u00fbn \u00ea f\u00fbnksiyonek bi c\u00eeh bikin ku du l\u00eestey\u00ean hejmaran digire,\n\u00fb diyar dike ka b\u00ea guman e ku p\u00ea\u015fvebirina \u00e7alak\u00eeyan di navbera wan de j\u00eeyane \nda ku lst1 l\u00eesteya ten\u00ea hejmar\u00ean zewic\u00ee bibe.\nT\u00eak \u00e7\u00eakirina hejmar\u00ean lst1 \u00fb lst2 ya hejmaran tun\u00ee ne.\nHeke b\u00ea guman e ku \u00e7alak\u00eeyan di navbera lst1 \u00fb lst2 de j\u00eeyane ku hem\u00fb pergala lst1 bi zewic\u00ee bibin, \n\"ER\u00ca\" veger\u00eenin.\nHeke ne be, \"NA\" veger\u00eenin.\nBo nim\u00fbne:\nexchange => \"ER\u00ca\"\nexchange => \"NA\"\nT\u00eagih\u00ee\u015ftin ku l\u00eestey\u00ean input \u00ea b\u00ea ne bo\u015f be.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Ev hevok bi Kurmanc\u00ee wergerandin:\n\n\"Di v\u00ea xeta de ku t\u00eep\u00ean bi\u00e7\u00fbk \u00ean bi her\u00eef\u00ean jiyara bi her\u00eef\u00ean her\u00eef\u00ean jiyara p\u00ea\u015fk\u00ea\u015f dikin, fermaneke veger\u00een a di nav de her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean n\u00eaz\u00eek \u00fb her\u00eef\u00ean jiyara bi her\u00eef\u00ean jiyara p\u00ea\u015fk\u00ea\u015f dikin. Heke gelek her\u00eef hene ku hevl\u00ea dikin, hem\u00fbyan veger\u00eenin.\n\nM\u00eenake:\nhistogram == {'a': 1, 'b': 1, 'c': 1}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'b': 4}\nhistogram == {}\"\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"T\u00eepandin:\n    Em du r\u00eazok\u00ean s \u00fb c d\u00een, h\u00fbn div\u00ea hem\u00fb t\u00eepan di s de ku wek\u00ee t\u00eep\u00ean c nekin j\u00ea bibin,\n    pa\u015f\u00ea kontrol bikin ka r\u00eazkoka encam palindrome ye an na.\n    R\u00eazokek palindrome t\u00ea gotin ku herwiha p\u00ea\u015f \u00fb pa\u015f bixw\u00eene.\n    Div\u00ea h\u00fbn duhelek ku r\u00eazkoka encam \u00fb rast\/yalan bo kontrol\u00ea t\u00ea de bikin vegerin.\n    Nim\u00fbne:\n    Ji bo s = \"abcde\", c = \"ae\", encam div\u00ea be\n    Ji bo s = \"abcdef\", c = \"b\" encam div\u00ea be\n    Ji bo s = \"abcdedcba\", c = \"ab\", encam div\u00ea be\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Eger lista yek ji z\u00eeviyan hene, ku her z\u00eev\u00ee di t\u00eakel\u00eeya hejmaran de ye, listek veger\u00eene.\nHer ti\u015ft\u00ea i ya t\u00eaketin\u00ea div\u00ea \"hejmareke y\u00ean t\u00eer\u00ee y\u00ean di z\u00eev\u00eeya i ya t\u00eaketin\u00ea de ye.\" be ku hem\u00ee i'yan div\u00ea bi hejmareke y\u00ean t\u00eer\u00ee y\u00ean di z\u00eev\u00eeya i'ya t\u00eaketin\u00ea de ne, biguher\u00eene.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Dema ku arrayeke ji amadeger\u00ean tam\u00ee nums hebe, k\u00eam\u00eena k\u00eam a her sub-arrayek\u00ea ya nevala nums\u00ea bib\u00eene.\nM\u00eenake\nminSubArraySum == 1\nminSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    H\u00fbn bi r\u00fby\u00ea yek p\u00eadiv\u00ee bi gir\u00eed\u00eak rektangulerek\u00ee k\u00eav\u00e7er\u00een. Her r\u00eaz yek k\u00eav\u00e7er\u00een n\u00ee\u015fan dide, \u00fb her 1 di r\u00eazek\u00ea de yek yek\u00eeneya av\u00ea n\u00ee\u015fan dide. Her k\u00eav\u00e7er\u00een ger\u00eedarek\u00ee taybet\u00ee heye ku dikare ji w\u00ea av\u00ea bigire, \u00fb hem\u00fb ger\u00eedar hinek\u00ee hevd\u00fbdest. Kar\u00ea we ev e ku ger\u00eedar bikar b\u00eenin da ku k\u00eav\u00e7er\u00eenan vala bikin. H\u00fbn hejmar\u00ea caran n\u00ee\u015fan bidin ku p\u00eadiv\u00ee ye ger\u00eedar bi\u015f\u00eene j\u00ear.\n\nM\u00eenak1:\n    Input: \n        gir\u00eed : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        kapasit\u00ea ger\u00eedar : 1\n    Output: 6\n\nM\u00eenak2:\n    Input: \n        gir\u00eed : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        kapasit\u00ea ger\u00eedar : 2\n    Output: 5\n\nM\u00eenak3:\n    Input: \n        gir\u00eed : [[0,0,0], [0,0,0]]\n        kapasit\u00ea ger\u00eedar : 5\n    Output: 0\n\nS\u00eenor\u00ean:\n    * hem\u00fb k\u00eav\u00e7er\u00eenan heman dir\u00eajahiya hene\n    * 1 <= dir\u00eajahiya gir\u00eed\u00ea <= 10^2\n    * 1 <= dir\u00eajahiya gir\u00eed\u00ea di r\u00eazek\u00ea de <= 10^2\n    * gir\u00eed[i][j] -> 0 | 1\n    * 1 <= kapasit\u00ea <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Di v\u00ea Katay\u00ea de, h\u00fbn div\u00ea r\u00eaza hejmara ne-negat\u00eef\u00ean di bin\u00eareya wan de hejmarek\u00ean yekan t\u00eada neh\u00eanin bi r\u00eaz\u00ea. Ji bo hejmarek\u00ean yekan y\u00ean wusa, h\u00fbn div\u00ea li ser nirxa deq\u00ea r\u00eaz bikin.\n\nDiv\u00ea ew wek\u00ee v\u00ea watek\u00ea b\u00ea cihkirin:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Dane stringek s \u00fb hejmar\u00eak\u00ee xer\u00eek\u00ee n, we ye ku kar bike r\u00ea ve qeb\u00fbl bike\n    fonksiyoneke p\u00eak b\u00eene ku r\u00eazeyeke hem\u00fb peyvan bi s string\u00ea de ye ku bi temam\u00ee n peyvan de heb\u00fbn,\n    di r\u00eaza peyvan de ev peyvan di string\u00ea de.\n    Ger stringek s vala be w\u00ea fonksiyon div\u00ea r\u00eazeyek valay\u00ea bidine.\n    Nota: h\u00fbn dikarin qeb\u00fbl bikin ku string\u00ea hat\u00ee t\u00eab\u00een\u00ee ten\u00ea t\u00eep \u00fb k\u00fbr\u00een t\u00ea de t\u00ea.\n    Nim\u00fbneyan:\n    select_words ==> [\"little\"]\n    select_words ==> [\"Mary\", \"lamb\"]\n    select_words ==> []\n    select_words ==> [\"world\"]\n    select_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"H\u00fbn bi peyda kirina yek gotin\u00ea t\u00eane day\u00een. Kar\u00ea we ew e ku peyv\u00ean n\u00eaz\u00eektir\u00een b\u00eajin ku di navbera du dengb\u00eaj\u00ean de ji aliy\u00ea rast\u00ea peyva wek\u00ee peyde bikin.\n\nVowel di destp\u00eak \u00fb dawiy\u00ea de hesab nakin. P\u00ea\u015f\u00ee bo\u015f eger h\u00fbn tu dengb\u00eaj ku li ser v\u00ea \u015fert\u00ea re peyde nekirin.\n\nH\u00fbn dikarin guman bikirin ku r\u00eaza hat\u00ee da peyv\u00ean \u00cengil\u00eez\u00ee ten\u00ea t\u00ea.\n\nM\u00eenak:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Dane arrayek arr bi amade \u00fb integerek poz\u00eet\u00eef k, lista yekgr\u00eeng a k di arr de bi z\u00eadetir k hejmaran bi r\u00eaz kir\u00ee ye veger\u00eenin.\n\nNim\u00fbne1:\n\n    Input: arr = [-3, -4, 5], k = 3\n    Output: [-4, -3, 5]\n\nNim\u00fbne2:\n\n    Input: arr = [4, -4, 4], k = 2\n    Output: [4, 4]\n\nNim\u00fbne3:\n\n    Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Output: [2]\n\nT\u00eab\u00een\u00ee:\n    1. Dir\u00eajahiya array\u00ea d\u00ea di navbera [1, 1000] de be.\n    2. Element\u00ean di array\u00ea de d\u00ea di navbera [-1000, 1000] de be.\n    3. 0 <= k <= dir\u00eajahiya arr\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Ji bo l\u00eesteyek nevala am\u00fbreyan, yekem hilgirtin\u00ea ya hem\u00fb ti\u015ft\u00ean t\u00eer \u00fb liser poz\u00eesyonan ya tev\u00ee ra veger\u00eenin.\n\nMisalan:\nsolution ==> 12\nsolution ==> 9\nsolution ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Dema ku arrayek neqes a ji hejmarek\u00ee yan\u00ee integers \u00fb hejmarek\u00ee k heb\u00fbn, berdev\u00ea \n    cem\u00ea pergala taybet\u00ee y\u00ean ku bi ten\u00ea du hejmar\u00ean diger\u00ean di y\u00ean yekem\u00een k pergala arr de hene.\n\n    Nim\u00fbne:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # cem\u00ea 21 + 3\n\n    \u015eert\u00ean ku berdewam in:\n        1. 1 <= dir\u00eaj\u00eeya arr <= 100\n        2. 1 <= k <= dir\u00eaj\u00eeya arr\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Ji bo heramanek n pirr, lista r\u00eaz kir\u00ee b\u00eaje ku hejmar\u00ean t\u00fbj di r\u00eazgeha Collatz de hene.\n\n    Peymana Collatz peymankek di zimannasiy\u00ea de ye ku di vanan de t\u00eane gotin: bi her heramanek n pirr dest p\u00ea bike. Pi\u015ft\u00ee her term ji term\u00ea ber\u00ea ve t\u00ea wergirtin bi van r\u00eazekan: eger term\u00ea ber\u00ea cuda be, term\u00ea pa\u015f\u00een dema term\u00ea ber\u00ea y\u00ea yarmet\u00ee ye. Eger term\u00ea ber\u00ea t\u00fbj be, term\u00ea pa\u015f\u00een 3 carek term\u00ea ber\u00ea pirr 1 ye. Peymana ew e ku her\u00e7end n bi \u00e7i nirxek be, r\u00eazgeha her tim di 1 de digih\u00eaje.\n\n    Not:\n        1. Collatz [1] ye.\n        2. lista veger\u00eena di r\u00eaz\u00ea z\u00eadey\u00ee de ye.\n\n    Nim\u00fbne:\n    get_odd_collatz veger dike [1, 5] # R\u00eazgeha collatz ya bo 5 [5, 16, 8, 4, 2, 1] e, ji ber v\u00ea yek\u00ea hejmar\u00ean t\u00fbj ten\u00ea 1 \u00fb 5 ne.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"H\u00fbn div\u00ea fonksiyonek biniv\u00eesin ku tar\u00eexek day\u00een\u00ea rast bikin \u00fb\nger tar\u00eex rast be, True veger\u00eenin an j\u00ee False.\nTar\u00eex rast e heke hem\u00fb r\u00eaz\u00ean j\u00ear hate p\u00eak an\u00een:\n1. R\u00eaza tar\u00eex\u00ea vala nabe.\n2. Hejmara roj\u00ean ne div\u00ea k\u00eamtir be ji 1 an j\u00ee z\u00eadetir be ji 31 roj ji bo meh\u00ean 1, 3, 5, 7, 8, 10, 12. \u00fb hejmar\u00ea roj\u00ean ne div\u00ea k\u00eamtir be ji 1 an z\u00eadetir be ji 30 roj ji bo meh\u00ean 4, 6, 9, 11. \u00fb hejmar\u00ea roj\u00ean ne div\u00ea k\u00eamtir be ji 1 an z\u00eadetir be ji 29 roj ji bo meha 2.\n3. Meh\u00ean ne div\u00ea k\u00eamtir be ji 1 an z\u00eadetir be ji 12.\n4. Tar\u00eex div\u00ea di formata mm-dd-yyyy de be.\n\nbi nim\u00fbne:\nvalid_date => True\n\nvalid_date => False\n\nvalid_date => False\n\nvalid_date => True\n\nvalid_date => False\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"H\u00fbn du navbera dan\u00een,\n    ku her navbera yek\u00ee wek\u00ee cift\u00ee amade ye. Bo nim\u00fbne, navber = =.\n    Navber\u00ean dan\u00een girt\u00ee ne, ya'ni ku navbera\n    hem destp\u00eak \u00fb hem j\u00ee daw\u00ee t\u00ea de gir\u00eaday\u00ee ne.\n    Ji bo her navbera dan\u00een, t\u00ea guman kirin ku destp\u00eak\u00ea w\u00ea k\u00eam e an j\u00ee wekhev e bi daw\u00eey\u00ea w\u00ea.\n    Kar\u00ea we ye ku diyaranin ka dir\u00eajahiya berhevoka van du navberan hejmar\u00eak p\u00ea\u015fk\u00ea\u015f e.\n    Nim\u00fbne, berhevoka navber\u00ean, e\n    ku dir\u00eajahiya w\u00ea 1 e, ku ne hejmar\u00eak p\u00ea\u015fk\u00ea\u015f e.\n    Heke dir\u00eajahiya berhevoka hejmar\u00eak p\u00ea\u015fk\u00ea\u015f be, veger\u00eenin \"ER\u00ca\",\n    bi rast\u00ee, veger\u00eenin \"NA\".\n    Heke du navbera ne berhevok in, veger\u00eenin \"NA\".\n\n    [nim\u00fbneya t\u00eaketin\/derketin]:\n    berhevok,) ==> \"NA\"\n    berhevok,) ==> \"NA\"\n    berhevok,) ==> \"ER\u00ca\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    H\u00fbn arrayek arr a ji hejmar\u00ean tevgeran re didin \u00fb h\u00fbn p\u00eadiv\u00ee ye ku veger\u00eenin\n    hem\u00fb n\u00ee\u015fan\u00ean her hejmar\u00ea ya di array\u00ea de bi r\u00eaza 1, -1 an j\u00ee 0 xwed\u00ee ne, \n    hem\u00fb wan bi xwe bazdikin \u00fb mezm\u00fbn\u00ean wan bi popa hem\u00fb n\u00ee\u015fan\u00ean hejmaran \n    di array\u00ea de pirxistin\u00ea dikin.\n    Bin\u00eare: ji bo arr\u00ea vala None veger\u00eenin.\n\n    Nim\u00fbne:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Here is the translation of the given text into Northern Kurdish:\n\nDiyariya gel\u00eak bi k\u00eejan N satir \u00fb N kolon \u00fb hejmar\u00eak pozit\u00eef k\u00ea, her xan\u00eeya gel\u00eak di navber\u00ea h\u00eajay\u00eak de q\u00eemetek t\u00eane dan\u00een. Hem\u00fb hejmarek di navber\u00ea [1, N * N] de ya t\u00eakildar bi temam\u00ee di xan\u00eey\u00ean gel\u00eak de t\u00eadane.\n\nDiv\u00ea h\u00fbn \u015fop\u00ea her\u00ee k\u00eam a fireh\u00ee k li ser gel\u00eak bigirin. H\u00fbn dikarin ji her xan\u00eeyek dest p\u00ea bikirin, \u00fb di her gav\u00ea de h\u00fbn dikarin vegerin her xan\u00eey\u00ean kom\u015f\u00ee, bi gotin\u00ean din, h\u00fbn dikarin her xan\u00eey\u00ean ku par\u00e7e bi h\u00fbn re par\u00e7e dikin vegerin.\nJi kerema xwe qeyd bikin ku \u015fopek fireh\u00ee k w\u00ea gotin\u00eak ku bi temam\u00ee k xan\u00eey\u00ean me\u015f\u00een.\nH\u00fbn NIKARIN dervey\u00ee gel\u00eak bi\u00e7in.\n\u015eop\u00eak A dikare k\u00eamtir be ji \u015fop\u00eak B eger pi\u015ft\u00ee \u00e7\u00eakirina l\u00eestey\u00ean q\u00eemet\u00ean li ser xan\u00eey\u00ean ku A \u00fb B di derbas dikin, l\u00eest_A bi leks\u00eekograf\u00ee k\u00eamtir be ji l\u00eest_B, bi gotin\u00ean din, heye ku hejmarek index i ku l\u00eest_A[i] k\u00eamtir be ji l\u00eest_B[i] \u00fb ji bo her j me heye ku l\u00eest_A[j] = l\u00eest_B[j].\nHewce ye ku bersiv yekane ye.\nL\u00eesteyek q\u00eemet\u00ean li ser xan\u00eey\u00ean ku \u015fop\u00ea her\u00ee k\u00eam di derbas dikin vegerin.\n\nM\u00eenak\u00ean:\n\n    Input: gel\u00eak = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n    Output: [1, 2, 1]\n\n    Input: gel\u00eak = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n    Output: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Herkes r\u00eazeya Fibonacci dizane, ew ji h\u00eala m\u00eem\u00eestiy\u00ean di d\u00eesa 200 salan de z\u00eade xwendiye. L\u00ea, ti\u015ft\u00ean ku mirov nizanin r\u00eazeya Tribonacci ye.\nR\u00eazeya Tribonacci ji h\u00eala v\u00ea formula ve t\u00ea t\u00eagihi\u015ftin:\ntri = 3\ntri = 1 + n \/ 2, heke n jor e.\ntri = tri + tri + tri, heke n t\u00ee ye.\nBi\u015f\u00eenin:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n       = 2 + 3 + 3 = 8 \nTe heye hejmar\u00ea n\u00eaz\u00ee ya ne-sala 0 y\u00ea, p\u00eadiv\u00ee ye ku tu l\u00eesteyek ji y\u00ea n+1 hejmara y\u00ean r\u00eazeya Tribonacci ve bide.\nMisal:\ntri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Eger n-yek ji hejmar\u00ean pozitiv be, ber\u00e7avkirina hejmar\u00ean t\u00eer\u00eaj bidin.\n    Ger hem\u00ee hejmar\u00ean tevde hene, 0 veger\u00eenin.\n    M\u00eenak\u00ee:\n    hejmar\u00ean  == 1\n    hejmar\u00ean  == 0\n    hejmar\u00ean == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"H\u00fbn r\u00eaza hejmaran\u00ea diniv\u00eesin.\n    Div\u00ea h\u00fbn tevahiya hejmar\u00ean ku di r\u00eaz\u00ea de hene veger\u00eenin,\n    p\u00ea\u015f\u00ee her hejmar di r\u00eaz\u00ea de bi h\u00eaman\u00ee yekser bilind bikin.\n    Nim\u00fbney\u00ean:\n    Bo lst = [1,2,3] encam div\u00ea 14 be\n    Bo lst = [1,4,9] encam div\u00ea 98 be\n    Bo lst = [1,3,5,7] encam div\u00ea 84 be\n    Bo lst = [1.4,4.2,0] encam div\u00ea 29 be\n    Bo lst = [-2.4,1,1] encam div\u00ea 6 be\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Here is the translation of the sentence into Northern Kurdish:\n\nBik\u00ea functionek\u00ea ku her\u00ee mezin indeksa yekem a element\u00ea ku ne mezin e an j\u00ee wek\u00ee elementa ber\u00ea, veger\u00ea. Ger tu elementek\u00ee wilo tune be, ew\u00ea -1 veger\u00ea. L\u00eesteya dan\u00ee nay\u00ea dubl\u00eek\u00eat kirin.\n\nM\u00eenak:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Yek f\u00fbnksiyon \u00e7\u00eabike ku integer, float, yan\u00ee r\u00eazimana string ku jimareya rast\u00een n\u00ee\u015fan dide, qeb\u00fbl bike \u00fb guhertoya mezin di ti\u015ft\u00ean vebijarkiray\u00ee de veger\u00eene. Ger nirx\u00ean wekhev bin, w\u00ea None veger\u00eene.\nN\u00ee\u015fe: Ger jimareya rast\u00een wek string n\u00ee\u015fan bibe, nikareta floating point bi . yan , be.\n\ncompare_one \u00e2 -> 2.5\ncompare_one \u00e2 -> \"2,3\"\ncompare_one \u00e2 -> \"6\"\ncompare_one \u00e2 -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"P\u00ea\u015fniyar kirin ka hewce ye \u015firoveya n ji \u00e7ar hejmar\u00ean ducaran ya poz\u00eet\u00eev ve b\u00eane niv\u00ees\u00een\n    Nim\u00fbne\n    is_equal_to_sum_even == Naa\n    is_equal_to_sum_even == Naa\n    is_equal_to_sum_even == Er\u00ea\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Faktoryel\u00ea Brazil\u00ee y\u00ea d\u00eeyar dike:\n    faktoryela_brazil\u00ee = n! *! *! * ... * 1!\n    ku n > 0\n\n    M\u00eenak\u00ea:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Here is the translation of the given sentence into Northern Kurdish:\n\n\"Di textek\u00ea de, hem\u00fb valahiyan bi underscoreyan biguher\u00eenin, \n\u00fb heger di stringek\u00ea de ji 2 valahiya berdewam z\u00eadetir hebin, \new hengam valahiya berdewam bi - biguher\u00eenin \n\nfix_spaces == \"Example\"\nfix_spaces == \"Example_1\"\nfix_spaces == \"_Example_2\"\nfix_spaces == \"_Example-3\"\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Fonk\u00eesyonek \u00e7\u00eabike ku nav\u00ea pel\u00ea wek string\u00ea t\u00ea bike, \u00fb 'Er\u00ea' veger\u00eene ger nav\u00ea pel\u00ea derbasdar be, \u00fb 'Na' veger\u00eene ger nebe.\nNav\u00ea pel\u00ea derbasdar t\u00ea hesibandin ten\u00ea eger hem\u00fb \u015fert\u00ean j\u00ear\u00een t\u00ea ba\u015ftir\u00een:\n- Di nav\u00ea pel\u00ea de ne div\u00ea z\u00eadetir\u00ee ji s\u00ea hejmaran be.\n- Di nav\u00ea pel\u00ea de ten\u00ea yek nim\u00fb\u015fe '.' heye.\n- P\u00ea\u015f\u00ee dot-y\u00ea ne div\u00ea vala be, \u00fb div\u00ea ji t\u00eep\u00ean lat\u00een dest p\u00ea bike.\n- Pa\u015f\u00ee dot-y\u00ea div\u00ea yek ji van be: ['txt', 'exe', 'dll']\nNim\u00fbney\u00ean:\nfile_name_check # => 'Er\u00ea'\nfile_name_check # => 'Na'\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"Ev f\u00fbnksiyon d\u00ea listeya t\u00eep\u00ean hejmar\u00een\u00ea bist\u00eene. Ji bo hem\u00fb t\u00eakiliy\u00ean di l\u00eestey\u00ea de, f\u00fbnksiyonek d\u00ea hejmar\u00ea t\u00eakiliy\u00ea kare bikeger indeksa w\u00ea ji 3 re pirde ye \u00fb d\u00ea hejmar\u00ea t\u00eakiliy\u00ea kubik bikeger indeksa w\u00ea ji 4 re pirde ye \u00fb ji 3 re pirde nebe. F\u00fbnksiyonek d\u00ea t\u00eakiliy\u00ean di l\u00eestey\u00ea de ku indeks\u00ean wan ne ji 3 an 4 re pirde ne, nebiguhere. Pa\u015f\u00ea f\u00fbnksiyonek d\u00ea yekemtiya hem\u00fb t\u00eakiliy\u00ean veger\u00eene. \n\nM\u00eenak:\nBo lst = [1,2,3] derh\u00eaner div\u00ea 6 be\nBo lst = [] derh\u00eaner div\u00ea 0 be\nBo lst = [-1,-5,2,-1,-5] derh\u00eaner div\u00ea -126 be\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    Te re heq dike stringek ku r\u00eajeya r\u00eazefan de n\u00ee\u015fan dide,\n    r\u00eazefan heye hin peyiv di navber\u00ee c\u00eeh de ji hev veqet\u00eenin,\n    \u00fb h\u00fbn h\u00eavin stringek veger\u00eenin ku peyiv\u00ean ji r\u00eazefana or\u00eej\u00eenal\u00ea de heye,\n    ku dir\u00eajahiya wan hejmarek p\u00eer\u00eem e,\n    r\u00eazay\u00ea peyivan di string\u00ea n\u00fb de div\u00ea wek yekem\u00een bikar b\u00eene.\n\n    Nim\u00fbne1:\n        Input: sentence = \"Ev testek e\"\n        Output: \"e\"\n\n    Nim\u00fbne2:\n        Input: sentence = \"Em biken da ku av\u00ea bikin\"\n        Output: \"da ku\"\n\n    S\u00eenor\u00ean:\n        * 1 <= dir\u00eajahiya sentence <= 100\n        * sentence ten\u00ea t\u00eepan t\u00ea de\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"To translate the given technical task into Northern Kurdish, we can proceed as follows:\n\n---\n\nKar\u00ea te ye ku yek fons\u00eeyon \u00e7\u00eabik\u00ee ku ev t\u00eep\u00ean bikar b\u00eene\n    x * n. Fons\u00eeyon d\u00ea True veger\u00eene eger x * n p\u00ea\u015fniyazek rast e ku ji yekem\u00ee ya tevah\u00ee pir\u00e7 bikar b\u00eene \u00fb False\n    her wiha eger rast nabit. Heman x \u00fb n, t\u00eagihi\u015ftina r\u00eaze ya fraciyek\u00ea ne, \u00fb xwed\u00ee forma j\u00ear\u00een in,\n    <numerator>\/<denominator> ku hem numerator \u00fb hem denominator yekem\u00ee ya tevah\u00ee pir\u00e7 in.\n\n    H\u00fbn dikarin guman bikin ku x, \u00fb n fraciy\u00ean derbasdar in, \u00fb ne xwed\u00ee zero wek denominator in.\n\n    simplify = True\n    simplify = False\n    simplify = False\n\n---\n\nThis translation ensures that the technical details and the specific examples remain clear and understandable in Northern Kurdish.\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    Here is the translation of the given sentence into Northern Kurdish:\n\nJi bo niv\u00ees\u00een\u00ea f\u00fbnksiyek\u00ea, ku l\u00eesteya hejmar\u00ean tevger a t\u00eaday\u00ee bi r\u00eaza serperr\u00ea ya digel yekdiya dij\u00eetalan wan biniv\u00eese.\nT\u00eab\u00een\u00ee: Heke hin ti\u015ft\u00ean bi yekdiya yekdiya hebe, t\u00eabin\u00eey\u00ea wan li ser index\u00ea wan di l\u00eesteya or\u00eej\u00eenal de biniv\u00eese.\nMisal:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Fonk\u00eesyonek biniv\u00eese ku arrayek hejmaran wek input digire \u00fb hejmar\u00ea elemeyan li array\u00ea veger\u00eenin ku ji 10 z\u00eadetir in \u00fb hem dujem hem j\u00eamare yekem \u00fb pa\u015f\u00een y\u00ean hejmar\u00ea t\u00eenin ne.\nM\u00eenak:\nspecialFilter => 1 \nspecialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    H\u00fbn bi y\u00eak ji amaran n ya poz\u00eet\u00eef t\u00eane day\u00een. H\u00fbn div\u00ea r\u00eaza amaran a ya bi dir\u00eajahiya n biafir\u00eenin.\nJi bo her i, nirxa a[i] = i * i - i + 1 ye.\nBi\u015fop\u00eene hejmar\u00ea seyan ji a de ku i < j < k, \u00fb a[i] + a[j] + a[k] pirsa 3 e.\n\nM\u00eenak:\n    Input: n = 5\n    Output: 1\n    R\u00fbpelkirin:\n    a = [1, 3, 7, 13, 21]\n    Yekem seya derbasdar ye.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Here is the translation of the given sentence into Northern Kurdish:\n\n---\nFonk\u00eesyonek biniv\u00eese ku listek r\u00eazok ji bo parametreyan qeb\u00fbl bike,\n     r\u00eazok\u00ean ku dir\u00eajay\u00ean wan t\u00ee rehemek dir\u00eaj ne li j\u00ea rab\u00eene,\n     \u00fb listeke ku bi r\u00eazok\u00ea li ser r\u00eazak\u00ea r\u00eazok\u00ea veger\u00eene,\n     Liste h\u00eesa r\u00eazokan e \u00fb j\u00ee qet r\u00eazok\u00ean hejmaran n\u00eene,\n     \u00fb div\u00ea w\u00ea di xwe de dubl\u00eekat\u00ean j\u00ee hebin.\n     Reza listey\u00ea div\u00ea bi dir\u00eajahiya her peyv\u00ea biniv\u00eesin, \u00fb tu div\u00ea listey\u00ea bi w\u00ea r\u00eazok\u00ea r\u00eazok bike.\n     Heke du peyvan h\u00eaman dir\u00eajahiya hebin, listey\u00ea alfabey\u00ee r\u00eazok bike.\n     Fonk\u00eesyon div\u00ea listek r\u00eazokan di r\u00eazok\u00ea veger\u00eene.\n     Tu dikar\u00ee guman bik\u00ee ku hem\u00fb peyvan h\u00eaman dir\u00eajahiya hebin.\n     M\u00eenak\u00ee:\n     assert list_sort => [\"aa\"]\n     assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Bernameya h\u00easaneke ku div\u00ea nirx\u00ea x\u00ea bideger\u00eene ger n hejmar\u00eak\u00ea serkeft\u00ee be \u00fb nirx\u00ea y\u00ea bideger\u00eene ger n nebe.\n\nM\u00eenak:\nji bo x_or_y == 34\nji bo x_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Ez difikirim ku em hem\u00fb ew hestiy\u00ea b\u00eer dikirin dema berhem\u00ean hin b\u00fbyer\u00ean dir\u00eaj hate zan\u00een. Hest \u00fb ti\u015ft\u00ean ku h\u00fbn di w\u00ee dem\u00ea de hene, bi temam\u00ee \u015fayeste ne ku biniv\u00eesin \u00fb bi hev re bandor bikin. Kar\u00ea we ew e ku diyar bikin ka kesek derbar\u00ea encam\u00ean hevsengiy\u00ean hejmar\u00ean hevaftiyan rast\u00ee gotiye. H\u00fbn bi du r\u00eaz\u00ean n\u00ee\u015fan \u00fb hi\u015fmend hene ku dir\u00eaj\u00eeya wan wekhev e, ku her jimare n\u00ee\u015fana hevsengiyek e. V\u00ea r\u00eaz bi hev re veger\u00eenin ku n\u00ee\u015fan dide \u00e7iqas hi\u015fmek ji n\u00ee\u015fan\u00ea cuda ye. Ger wan rast\u00ee gotibe, nirx 0 e, \u00fb ger nebin, nirx cuda ya n\u00ee\u015fan \u00fb hi\u015fmend e.\n\nM\u00eenak:\n\ncompare -> [0, 0, 0, 0, 3, 3]\ncompare -> [4, 4, 1, 0, 0, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"H\u00fbn nav\u00ea yek \u00e7\u00een\u00ee \u00fb listek p\u00eavekan\u00ea li vir deyn. P\u00eavekan \u00ea ne ji bo barkirina \u00e7\u00eenan\u00ean z\u00eadetir ji \u00e7\u00eena sereke bikaran\u00een. H\u00eaza p\u00eavek\u00ea wek\u00ee v\u00ea yek\u00ea t\u00ea hesibandin: CAP hejmara t\u00eep\u00ean mezin \u00ean li nav\u00ea p\u00eavek\u00ea ye, \u00fb SM hejmara t\u00eep\u00ean pi\u00e7\u00fbk \u00ean li nav\u00ea p\u00eavek\u00ea ye, h\u00eaz ji xelat\u00ea CAP - SM t\u00ea dan\u00een. H\u00fbn div\u00ea p\u00eaveka her\u00ee xurt bib\u00eenin \u00fb stringek bi v\u00ee form\u00ea vegerin: ClassName.StrongestExtensionName. Ger du an j\u00ee z\u00eadetir p\u00eavek\u00ean bi h\u00eaza wusa hebe, h\u00fbn div\u00ea p\u00eaveka yekem\u00een li l\u00eestey\u00ea hilbij\u00earin.\nM\u00eenak\u00ee, heger h\u00fbn \"Slices\" wek\u00ee \u00e7\u00een \u00fb l\u00eesteyek ji p\u00eavekan: ['SErviNGSliCes', 'Cheese', 'StuFfed'] were deyn, h\u00fbn div\u00ea \"Slices.SErviNGSliCes\" vegerin ji ber ku 'SErviNGSliCes' p\u00eaveka her\u00ee xurt e.\nM\u00eenak\u00ee:\nji bo Strongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"H\u00fbn bi 2 peyv t\u00ean day\u00een. Div\u00ea h\u00fbn rast b\u00eenin ku h\u00fbn\u00ea peyva duyem\u00een an j\u00ee her \u00e7arxkirina w\u00ea peyva yekem\u00een de di binpeyva de ye.\n\n    cycpattern_check => Neh\u00eale\n    cycpattern_check => Rast e\n    cycpattern_check => Neh\u00eale\n    cycpattern_check => Rast e\n    cycpattern_check => Neh\u00eale\n    cycpattern_check => Rast e\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Ji bo hejmar\u00ea ku tije ye, tupl\u00eak veger\u00eene ku hejmarek am\u00fbr\u00ean tevnav\u00ee \u00fb am\u00fbr\u00ean ne tevnav\u00ee t\u00ea de heye.\n\n     Nim\u00fbne:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Ji bo hejmareke pozit\u00eef, yekem\u00een hejmarek\u00ee rom\u00ee wek\u00ee r\u00eazok\u00ea biger\u00eenin,\n    \u00fb w\u00ea bi t\u00eep\u00ean pi\u00e7\u00fbkda vegerin.\n    S\u00eenor: 1 <= hejmar <= 1000\n\n    Nim\u00fbne:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"F\u00fbnksiyonek biniv\u00eese ku r\u00eazika r\u00eazok\u00ean xwe\u015f bibe.\n    R\u00eazika di navbera peyv\u00ean cuda de ten\u00ea peyv\u00ean cuda t\u00ea de ye. Peyva bi hejmareke z\u00eade y\u00ean t\u00eep\u00ean taybetan veger\u00eene.\n    Heke r\u00eazok\u00ean pirjimar\u00ean t\u00eep\u00ean taybet hene, w\u00ea y\u00ea ya di r\u00eaza lexikograf\u00eek de y\u00ea yekem derdixe.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Tu tav\u015f\u00ea b\u00ear\u00ee ye, \u00fb tu xwe ha\u015f\u00eer dikeve \u00e7end g\u00eezik\u00ee hav\u00eeyan\u00ee,\n    l\u00ea niha p\u00eaw\u00eest e ku tu z\u00eadetir g\u00eezik\u00ee bixw\u00ee ku xwarin\u00ean roj\u00ea temam bike.\n    Tu div\u00ea arrayek veger\u00eeni [ hejmar\u00ea tevah\u00ee y\u00ean g\u00eezik\u00ean ku pi\u015ft\u00ee xwarin\u00ean te xwarin, \n                                hejmar\u00ea g\u00eezik\u00ean ku pi\u015ft\u00ee xwarin\u00ean te may\u00een ] \n    eger g\u00eezik\u00ean may\u00een t\u00eara nebin, tu hem\u00fb g\u00eezik\u00ean may\u00een dixw\u00ee, l\u00ea h\u00een j\u00ee b\u00ear\u00ee dib\u00ee.\n\n    Nim\u00fbne:\n    * eat -> [11, 4]\n    * eat -> [12, 1]\n    * eat -> [11, 0]\n    * eat -> [7, 0]\n\n    Guhertoy\u00ean:\n    @hejmar : integer\n        hejmar\u00ea g\u00eezik\u00ean ku tu xwar\u00ee.\n    @p\u00eaw\u00eest\u00ee : integer\n        hejmar\u00ea g\u00eezik\u00ean ku tu p\u00eaw\u00eest\u00ee b\u00ea xwarin.\n    @may\u00een : integer\n        hejmar\u00ea g\u00eezik\u00ean may\u00een ku di stock de hene\n\n    S\u00eenor:\n    * 0 <= hejmar <= 1000\n    * 0 <= p\u00eaw\u00eest\u00ee <= 1000\n    * 0 <= may\u00een <= 1000\n\n    Xweza\u015f\u00ee b\u00ee :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Eger du l\u00eeste hene operator \u00fb operand. L\u00eesteya yekem operasyone algebra y\u00ean bingeh\u00een \u00ean, \u00fb l\u00eesteya duyem j\u00ee l\u00eesteya hejmar\u00ean tam e. Bi karan\u00eena v\u00ea du l\u00eesteyan, t\u00eakiliyeke aljebra\u00e7\u00ee biafir\u00eene \u00fb n\u00ee\u015fan\u00ea v\u00ea t\u00eakiliy\u00ea veger\u00eene.\n\nOperasyone algebra y\u00ean bingeh\u00een:\nTevl\u00eekirin \nJ\u00eabirin \n\u00c7arpandin \nTewandin \nC\u00eegirandin \n\nM\u00eenak:\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nencam = 2 + 3 * 4 - 5\n=> encam = 9\n\nNot:\n        Dir\u00eajahiya l\u00eesteya operator bi dir\u00eajahiya l\u00eesteya operand - yek\u00ea wekhev e.\n        Operand l\u00eesteya hejmar\u00ean ne-negat\u00eev e.\n        L\u00eesteya operator h\u00eaj\u00eek\u00ee yek operator heye, \u00fb l\u00eesteya operand h\u00eaj\u00eek\u00ee du operand hene.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Te re gotin\u00eak s\u00earrast dike.\n    Eger s[i] t\u00eep\u00eak be, rew\u015f\u00ea w\u00ea ji bisk\u00ee k\u00eamtir an jor kirin\u00ea biguhere, \n    heke ne, w\u00ea wek\u00ee xwe bih\u00eale.\n    Eger di r\u00eaza de t\u00eep tune be, r\u00eaza veger\u00eene.\n    F\u00fbnksiyonek div\u00ea r\u00eaza ku hat\u00ee ye veger\u00eene.\n    Nim\u00fbney\u00ean\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Eger 'text' r\u00eazek e, w\u00ea w\u00e9 md5 hash-\u00ea werger\u00eene.\n    Eger 'text' r\u00eazeyek vala be, w\u00ea None veger\u00eene.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Heke du amara poz\u00eet\u00eef a \u00fb b hebin, hejmar\u00ean tenik di navbera a \u00fb b de, bi r\u00eaza z\u00fb de vegerin.\n\nM\u00eenake:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]