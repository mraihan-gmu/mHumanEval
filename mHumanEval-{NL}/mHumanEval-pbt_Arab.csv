prompt,canonical_solution,test
"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" په ورکړل شوي لست کې شمیرې وګورئ چې آیا کومې دوه شمېرې له ورکړل شوي حد څخه نژدې دي.
    بېلګه:
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

"
"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" د دې فنکشن انپټ یو سټرنګ دی چې په کې د ځینو ګروپونو دننه پرانسیسونه شامل دي. ستاسو هدف دا دی چې دا ګروپونه په جلا سټرنګونو کې وویشئ او د هغوی لیست بېرته ورکړئ. جلا ګروپونه متوازن دي او په یو بل کې دننه نه وي. په انپټ سټرنګ کې هر ډول ځایونه باید نظر انداز شي.
بیلګه:
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    """"""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
"
"

def truncate_number(number: float) -> float:
    """""" د یو مثبت فلوټینګ پواینټ شمېره په ورکړل شوي ډول تجزیه کېدی شي:

    یو صحیح برخه او اعشاري برخې.

    د شمېر اعشاري برخه بیرته وګرځوئ.
    مثال:
    >>> truncate_number(3.5)
    0.5
    """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
"
"from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" تاسو ته د زیرمې او پیسو ایستلو عملیاتو لیست درکول کیږي په یو بانک حساب کې چې د صفر بیلانس سره پیل کیږي. ستاسو دنده دا ده چې معلومه کړئ که په کوم وخت کې د حساب بیلانس له صفر څخه ښکته شي، او په هغه وخت کې باید فنکشن ریښتیا بیرته ورکړي. که نه نو باید دروغ بیرته ورکړي.
بیلګه:
    >>> below_zero([1, 2, 3])
    False
    >>> below_zero([1, 2, -4, 5])
    True
    """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
"
"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" Given the complexity and the need for accuracy in translating technical terminology, here's the translation of the provided text into Southern Pashto:

د ورکړل شوي شمېرنونو د لیست لپاره، د دې ډاټا سیټ د منځنۍ شاوخوا منځنۍ مطلق انحراف محاسبه کړئ.
منځنۍ مطلق انحراف د هر عنصر او یو مرکزي نقطې ترمنځ د اوسط مطلق توپیر دی:
MAD = اوسط | x - x_mean |
مثال:
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

"
"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" په هر دوه پرله‌پسې عناصرو کې د 'delimeter' شمېرې دننه کړئ.
    >>> intersperse([], 4)
    []
    >>> intersperse([1, 2, 3], 4)
    [1, 4, 2, 4, 3]
    """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
"
"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" د دې فنکشن انپټ یو سټرینګ دی چې د ځایونو په واسطه جلا شویو ګروپونو لپاره د دننه پرانتسزونو نمایندګي کوي.
    د هر ګروپ لپاره، د پرانتسزونو تر ټولو ژور کچې نمایندګي تولید کړئ.
    مثلاً) دوه کچې ژوروالی لري، پداسې حال کې چې)) درې کچې لري.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
"
"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" د ننوتل شوې تارونو یوې لست څخه یواځې هغه تارونه چاڼ کړئ چې ټاکلې فرعي تار لري
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
"
"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" د یو ورکړل شوي د شمېرونو د لیست لپاره، یو ټوپل بېرته ورکړئ چې د ټولو شمېرونو د مجموعې او حاصل ضرب څخه جوړ وي.
    خالي مجموعه باید ۰ وي او خالي حاصل ضرب باید ۱ وي.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
"
"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" د ورکړل شوي عددونو له لیست څخه، تر ټاکلي وخته پورې په سلسله کې تر ټولو لوی عنصر پیدا او لیست یې جوړ کړئ.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    [1, 2, 3, 3, 3, 4, 4]
    """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
"
"

def is_palindrome(string: str) -> bool:
    """""" د ورکړل شوي تار د کلمې ازموینه وکړئ چې ایا دا یو ""پالینډروم"" دی. """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    ''
    >>> make_palindrome('cat')
    'catac'
    >>> make_palindrome('cata')
    'catac'
    """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
"
"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" In Southern Pashto, the translation of the given sentence would be:

دواړه ننوتونه د تارونو a او b یوازې د 1ونو او 0ونو څخه جوړ دي.
    په دې ننوتونو باندې باینری XOR ترسره کړئ او پایله هم د تار په توګه واپس کړئ.
    >>> string_xor('010', '110')
    '100'
    """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
"
"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" د تارونو له لیست څخه، تر ټولو اوږد تار بیرته ورکړئ. که چیرې څو تارونه د یو شان اوږدوالي ولري، نو لومړی یې بیرته ورکړئ. که چیرې د ورودی لیست خالي وي، نو هیڅ یو بیرته مه ورکوئ.
    >>> longest([])

    >>> longest(['a', 'b', 'c'])
    'a'
    >>> longest(['a', 'bb', 'ccc'])
    'ccc'
    """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
"
"

def greatest_common_divisor(a: int, b: int) -> int:
    """""" د دوه عددونو a او b د لویترين مشترک تقسیم کوونکی بیرته ورکړئ.
    >>> greatest_common_divisor(3, 5)
    1
    >>> greatest_common_divisor(25, 15)
    5
    """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
"
"from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" د ورکړل شوي تار د ټولو مخکېنیو لیست د لنډ څخه تر اوږده پورې بېرته ورکړئ.
    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
"
"

def string_sequence(n: int) -> str:
    """""" یو تار بیرته ورکړئ چې له ۰ څخه تر n پورې شامل شمیرې په سپیس سره جلا کړي.
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
"
"

def count_distinct_characters(string: str) -> int:
    """""" د یوې تار په ورکړه، پیدا کړئ چې دا څو بېلابېل توري لري
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
"
"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" د دې فنکشن لپاره انپټ یوه لړۍ ده چې په ځانګړي ASCII فارمیټ کې د موسیقي نوټونه ښیي.
ستاسو دنده داده چې دا لړۍ تجزیه کړئ او د اعدادو لیست بیرته ورکړئ چې د هر نوټ څومره وخت دوام کوي.

دلته یو لیجنډ دی:
'o' - بشپړ نوټ، څلور بیتونه دوام کوي
'o|' - نیم نوټ، دوه بیتونه دوام کوي
'.|' - څلورمه برخه نوټ، یو بیت دوام کوي

    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """"""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
"
"

def how_many_times(string: str, substring: str) -> int:
    """""" په اصلي تار کې یوه ورکړل شوې فرعي تار څو ځله موندلی شئ. د تکرار کېدو موارد هم وشمېرئ.
    >>> how_many_times('', 'a')
    0
    >>> how_many_times('aaa', 'a')
    3
    >>> how_many_times('aaaa', 'aa')
    3
    """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" In Southern Pashto, the translation would be:

ورودی د شمېرو یوه د تشې په واسطه جلا شوې سلسله ده د 'صفر' نه تر 'نه' پورې.
    د اعتبار وړ انتخابونه 'صفر', 'یو', 'دو', 'دری', 'څلور', 'پنځه', 'شپږ', 'اووه', 'اته' او 'نه' دي.
    سلسله د عددونو سره له کوچني نه تر لوی پورې په ترتیب سره بیرته ورکړئ.
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" د ورکړل شوې شمېرو له لیست څخه دوه نژدې شمیرې وټاکئ او بېرته يې په ترتیب سره ورکړئ.
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

"
"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" د عددونو ورکړل شوی لیست، په دې لیست باندې یو خطي بدلون تطبیق کړئ،
    داسې چې تر ټولو کوچنی عدد به ۰ شي او تر ټولو لوی به ۱ شي.
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
"
"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" د ورکړل شوي ليست څخه يوازې د پایتون عددونه فلټر کړئ.
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
"
"

def strlen(string: str) -> int:
    """""" د ورکړل شوي تار اوږدوالی بېرته ورکړئ
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
"
"

def largest_divisor(n: int) -> int:
    """""" د یو ورکړل شوي عدد n لپاره، تر ټولو لوی عدد موندل چې n یې په مساوي ډول ویشي، خو له n څخه کوچنی وي.
    >>> largest_divisor(15)
    5
    """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
"
"from typing import List


def factorize(n: int) -> List[int]:
    """""" Here is the translation of the provided text into Southern Pashto:

د ورکړل شوي عدد لومړني عوامل په کوچنۍ نه تر لوې اندازې پورې امر سره په لیست کې راستانه کړئ.
    هر یو عامل باید په فهرست کې هغه شمېر ځلې راشي لکه څومره ځلې چې په فکتورایزیشن کې راځي.
    داخلي عدد باید د ټولو عوامل د حاصل ضرب سره برابر وي.
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
"
"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" د اعدادو له لیست څخه، ټول هغه عناصر لرې کړئ چې له یو ځل زیات راځي.
    د پاتې عناصرو ترتیب لکه څنګه چې په ورودي کې دی، هماغسې وساتئ.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
"
"

def flip_case(string: str) -> str:
    """""" د يو ورکړل شوي تار لپاره، کوچني توري په لویو توريو او لوی توري په کوچنیو توريو بدله کړئ.
    >>> flip_case('Hello')
    'hELLO'
    """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
"
"from typing import List


def concatenate(strings: List[str]) -> str:
    """""" د سټرینګونو لیست په یوه واحد سټرینګ کې یوځای کړئ
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
"
"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" د ورکړل شوي مخکښ سره پیلیدونکي د تارونو لست فلټر کړئ.
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
"
"

def get_positive(l: list):
    """"""په لیست کې یواځې مثبت شمېرې واپس کړئ.
    >>> get_positive([-1, 2, -4, 5, 6])
    [2, 5, 6]
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    [5, 3, 2, 3, 9, 123, 1]
    """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

"
"

def is_prime(n):
    """"""د ورکړل شوي عدد په اړه که اولي عدد وي، نو ریښتیا وګرځوئ، او که نه نو غلط.
    >>> is_prime(6)
    False
    >>> is_prime(101)
    True
    >>> is_prime(11)
    True
    >>> is_prime(13441)
    True
    >>> is_prime(61)
    True
    >>> is_prime(4)
    False
    >>> is_prime(1)
    False
    """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

"
"import math


def poly(xs: list, x: float):
    """"""
    په نقطه x کې د xs coefficients لرونکي polynomial ارزوي.
    xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n بیرته راګرځوي
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"

def sort_third(l: list):
    """"""د دې فنکشن یوه لیست l اخلي او یو لیست l' بیرته ورکوي داسې چې
    l' په هغو شاخصونو کې چې په درې نه ویشل کیږي، له l سره یو شان وي، په داسې حال کې چې د هغو شاخصونو ارزښتونه چې په درې ویشل کیږي
    د l د اړونده شاخصونو ارزښتونو سره برابر دي، خو ترتیب شوي دي.
    >>> sort_third([1, 2, 3])
    [1, 2, 3]
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    [2, 6, 3, 4, 8, 9, 5]
    """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

"
"

def unique(l: list):
    """"""په یو لیست کې بیرته ترتیب شوي ځانګړي عناصر را وګرځوئ.
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

"
"

def max_element(l: list):
    """"""په لست کې تر ټولو لوړه عنصر بېرته ورکړئ.
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
"
"

def fizz_buzz(n: int):
    """"""دې شمېرې ته د ۷ شمېرې په څومره ځله راڅرګندېږي په هغو شمېرې کې چې له n څخه کم وي او د ۱۱ یا ۱۳ په واسطه وېشل کېږي.
    >>> fizz_buzz(50)
    0
    >>> fizz_buzz(78)
    2
    >>> fizz_buzz(79)
    3
    """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

"
"

def sort_even(l: list):
    """"""دغه فعله يو ليست l اخلي او يو ليست l' بيرته ورکوي داسې چې
    l' په طاق شمېرو کې له l سره يو شان وي، او په جفت شمېرو کې يې ارزښتونه د l د جفت شمېرو له ارزښتونو سره برابر وي، خو په ترتيب سره.
    >>> sort_even([1, 2, 3])
    [1, 2, 3]
    >>> sort_even([5, 6, 3, 4])
    [3, 6, 5, 4]
    """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

"
"

def encode_cyclic(s: str):
    """"""
    کدی شوي تار بېرته راګرځوي په درېیو کرکټرونو باندې د ډلو په بدلون سره.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

"
"

def prime_fib(n: int):
    """"""
    prime_fib n-م نمبر بیرته ورکوي چې فبوناچي نمبر وي او هم لومړنی وي.
    >>> prime_fib(1)
    2
    >>> prime_fib(2)
    3
    >>> prime_fib(3)
    5
    >>> prime_fib(4)
    13
    >>> prime_fib(5)
    89
    """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

"
"

def triples_sum_to_zero(l: list):
    """"""
    د ""triples_sum_to_zero"" یوه لست د عددونو په توګه اخلي.
    دا ریښتیا بیرته ورکوي که په لست کې درې جلا عناصر وي چې
    مجموع یې صفر وي، او غلط که نه.

    >>> triples_sum_to_zero([1, 3, 5, 0])
    False
    >>> triples_sum_to_zero([1, 3, -2, 1])
    True
    >>> triples_sum_to_zero([1, 2, 3, 7])
    False
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    True
    >>> triples_sum_to_zero([1])
    False
    """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

"
"

def car_race_collision(n: int):
    """"""
    تصور وکړئ چې یوه سړک ده چې په بشپړه توګه سیده او بې پایانه اوږده کرښه ده.
    n موټرونه له کیڼ څخه ښي لور ته روان دي؛ په ورته وخت کې، د مختلفو n موټرونو یوه بله ډله
    له ښي څخه کیڼ لور ته روان دي. دا دوه ډلې موټرونه په پیل کې له یو بل څخه ډیر لرې دي.
    ټول موټرونه په یوه سرعت سره حرکت کوي. ویل کیږي چې دوه موټرونه ټکر کوي کله چې یو موټر
    چې له کیڼ څخه ښي لور ته حرکت کوي، د یو موټر سره چې له ښي څخه کیڼ لور ته حرکت کوي ټکر وکړي.
    خو، موټرونه بې پایانه قوي او محکم دي؛ د پایلې په توګه، دوی په خپل مسیر کې داسې حرکت ته دوام ورکوي
    لکه څنګه چې دوی ټکر نه وي کړی.

    دا فنکشن د داسې ټکرونو شمیرې ته ځواب ورکوي.
    """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

"
"

def incr_list(l: list):
    """"""سترجع فھرست چې عناصر پکې په یو زیات شوي وي.
    >>> incr_list([1, 2, 3])
    [2, 3, 4]
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [6, 4, 6, 3, 4, 4, 10, 1, 124]
    """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

"
"

def pairs_sum_to_zero(l):
    """"""
    په دې جمله جنوبي پښتو ته وژباړئ:
pairs_sum_to_zero یو د عددونو لیست د انپټ په توګه اخلي.
    دا راستنوي True که په لیست کې دوه بېل عناصر وي چې
    مجموع یې صفر وي، او False که نه وي.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

"
"

def change_base(x: int, base: int):
    """"""په عددي اساس کې د انپټ شمېر x بدل کړئ.
    د بدلون وروسته د سلسلې استازیتوب بیرته ورکړئ.
    عددي اساسونه له ۱۰ څخه کم دي.
    >>> change_base(8, 3)
    '22'
    >>> change_base(8, 2)
    '1000'
    >>> change_base(7, 2)
    '111'
    """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

"
"

def triangle_area(a, h):
    """"""په د یو اړخ اوږدوالي او لوړوالی سره د مثلث ساحه ترلاسه کړئ.
    >>> triangle_area(5, 3)
    7.5
    """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

"
"

def fib4(n: int):
    """"""د Fib4 شمېرو لړۍ یوه لړۍ ده چې د فبوناکسي لړۍ سره ورته ده چې په لاندې ډول تعریف شوې ده:
    fib4 -> 0
    fib4 -> 0
    fib4 -> 2
    fib4 -> 0
    fib4 -> fib4 + fib4 + fib4 + fib4.
    لطفاً یوه دنده ولیکئ چې د fib4 شمېرو لړۍ n-يم عنصر په مؤثره توګه محاسبه کړي. له تکرار څخه استفاده مه کوئ.
    >>> fib4(5)
    4
    >>> fib4(6)
    8
    >>> fib4(7)
    14
    """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

"
"

def median(l: list):
    """"""د لست l په عناصرو کې منځنی ارزښت راستون کړئ.
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

"
"

def is_palindrome(text: str):
    """"""
    Given the complexity of accurately translating technical terms into Southern Pashto, here's a close approximation:

""کولای شي وګوري چې ورکړل شوې لیکنه پالیندروم ده که نه""

Please note that technical terms like ""palindrome"" might not have a direct equivalent in Pashto, so they are often used as-is or explained in context.
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

"
"

def modp(n: int, p: int):
    """"""د ۲^n د پ له مخې بیرته ورکړئ.
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

"
"

def encode_shift(s: str):
    """"""
    په الفبې کې هر توری په پنځه ځایه بدلولو سره کوډ شوی تار بیرته راګرځوي.
    """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""
    takes as input string encoded with encode_shift function. Returns decoded string.
    """"""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

"
"

def remove_vowels(text):
    """"""
    ""remove_vowels یوه دنده ده چې تار اخلي او تار پرته له غږونو بیرته ورکوي.""
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"

def below_threshold(l: list, t: int):
    """"""که ټول شمېرې په لیست l کې د حد t څخه کمې وي، نو ریښتیا راستن کړئ.
    >>> below_threshold([1, 2, 4, 10], 100)
    True
    >>> below_threshold([1, 20, 4, 10], 5)
    False
    """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

"
"

def add(x: int, y: int):
    """"""دواړه شمېرې x او y پکې اضافه کړئ
    >>> add(2, 3)
    5
    >>> add(5, 7)
    12
    """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

"
"

def same_chars(s0: str, s1: str):
    """"""
    وګورئ چې ایا دوه ټکي یو شان کرکټرونه لري.
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
    True
    >>> same_chars('abcd', 'dddddddabc')
    True
    >>> same_chars('dddddddabc', 'abcd')
    True
    >>> same_chars('eabcd', 'dddddddabc')
    False
    >>> same_chars('abcd', 'dddddddabce')
    False
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
    False
    """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

"
"

def fib(n: int):
    """"""n-يم فيبوناکي شمېره بېرته راوړه.
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

"
"

def correct_bracketing(brackets: str):
    """""" In Southern Pashto, the translation would be:

بريکېټونه د ""<"" او "">"" تار دی.
که هر پرانستونکی بريکېټ يو تړونکی بريکېټ ولري، نو ریښتیا بیرته ورکړئ.

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"

def monotonic(l: list):
    """"""که د لیست عناصر په تسلسل سره زیاتېږي یا کمېږي، نو True واپس کړه.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

"
"

def common(l1: list, l2: list):
    """"""دواړو لیستونو لپاره د ګډو یکتا عناصرو ترتیب شوي بیرته ورکړئ.
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

"
"

def largest_prime_factor(n: int):
    """"""د n تر ټولو لوی لومړی عامل بیرته ورکړئ. فرض کړئ چې n > 1 دی او لومړی نه دی.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

"
"

def sum_to_n(n: int):
    """"""sum_to_n یوه دنده ده چې له ۱ څخه تر n پورې شمیرې جمع کوي.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

"
"

def correct_bracketing(brackets: str):
    """""" Sure, here's the translation of the given sentence into Southern Pashto:

براکټونه د """" یو تار دی.
    که هر پرانیستی براکټ یو تړل شوی براکټ ولري، نو ریښتیا بیرته ورکړه.

    >>> correct_bracketing(""("")
    False
    >>> correct_bracketing(""()"")
    True
    >>> correct_bracketing(""(()())"")
    True
    >>> correct_bracketing("")(()"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

"
"

def derivative(xs: list):
    """""" په دې جمله کې xs د يوه چندجمله‌اې ضريبونه ښيي.
    xs[0] + xs[1] * x + xs[2] * x^2 + ....
     د دې چندجمله‌اې فرعي چندجمله‌اې په همدې بڼه کې وګرځوئ.
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

"
"

def fibfib(n: int):
    """"""د فیب فب عددونو لړۍ یوه داسې لړۍ ده چې د فبوناکي له لړۍ سره ورته والی لري او په لاندې ډول تعریف شوې ده:
    fibfib == ۰
    fibfib == ۰
    fibfib == ۱
    fibfib == fibfib + fibfib + fibfib.
    لطفاً یوه داسې دنده ولیکئ چې په مؤثره توګه د فیب فب عددونو لړۍ n-یم عنصر محاسبه کړي.
    >>> fibfib(1)
    0
    >>> fibfib(5)
    4
    >>> fibfib(8)
    24
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

"
"
FIX = """"""
نوری ازمیښی قضیی زیاتی کړی.
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count(""abcde"")
    2
    >>> vowels_count(""ACEDY"")
    3
    """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def circular_shift(x, shift):
    """"""د عدد x د ګوتو پر سر ګرځول، ګوتې ښي اړخ ته د shift په واسطه وګرځوه او پایله د تار په ډول ورکړه.
که چیرې shift د ګوتو له شمېر څخه زیات وي، ګوتې برعکس وګرځوه.
    >>> circular_shift(12, 1)
    ""21""
    >>> circular_shift(12, 2)
    ""12""
    """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def digitSum(s):
    """"""Here's the translation of the given sentence into Southern Pashto:

دنده:
    یوه فنکشن ولیکئ چې یو تار د انپوت په توګه اخلي او یوازې د لوړو حروفو د ASCII کوډونو مجموعه بیرته راولي.

    مثالونه:
        digitSum => 0
        digitSum => 131
        digitSum => 67
        digitSum => 69
        digitSum => 131
        digitSum => 153
    """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

"
"
def fruit_distribution(s,n):
    """"""
    په دې کار کې، تاسو ته به یو تار درکړل شي چې د مڼو او نارنجو شمېر استازیتوب کوي چې په میوو کې وېشل شوي دي. دا ټوکرۍ مڼې، نارنج او ام میوې لري. تاسو ته به یو تار درکړل شي چې د مڼو او نارنجو ټول شمېر استازیتوب کوي او یو عدد چې په ټوکرۍ کې د ټولو میوو شمېر استازیتوب کوي. د ټوکرۍ په میوو کې د ام میوو شمېر بیرته ورکړئ.
بیلګې لپاره:
fruit_distribution -> 19 - 5 - 6 = 8
fruit_distribution -> 3 - 0 - 1 = 2
fruit_distribution -> 100 - 2 - 3 = 95
fruit_distribution -> 120 - 100 - 1 = 19
    """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
"
"
def pluck(arr):
    """"""
    په پښتو کې دا جمله داسې ژباړل کیږي:

""د یوې ونې د څانګې یو صف چې غیر منفي عددونه لري ورکړل شوی
ستا دنده دا ده چې یو له نډونو څخه راوباسي او بیرته یې ورکړه.
هغه نډ چې راایستل کیږي باید هغه وي چې تر ټولو کوچنی جفت عدد ولري.
که چېرې څو نډونه د یو شان کوچني جفت عددونه لري، نو هغه نډ چې تر ټولو کوچنی شاخص لري، راوباسه.

راایستل شوی نډ باید په یوه لیست کې ورکړل شي، [ کوچنی ارزښت، د هغه شاخص ],
که هېڅ جفت ارزښتونه نه وي یا ورکړل شوی صف خالي وي، نو [] بیرته ورکړه.

مثال 1:
    داخلول: [4,2,3]
    محصول: [2, 1]
    توضیحات: 2 تر ټولو کوچنی جفت ارزښت لري، او 2 تر ټولو کوچنی شاخص لري.

مثال 2:
    داخلول: [1,2,3]
    محصول: [2, 1]
    توضیحات: 2 تر ټولو کوچنی جفت ارزښت لري، او 2 تر ټولو کوچنی شاخص لري.

مثال 3:
    داخلول: []
    محصول: []

مثال 4:
    داخلول: [5, 0, 3, 0, 4, 2]
    محصول: [0, 1]
    توضیحات: 0 تر ټولو کوچنی ارزښت لري، خو دوه صفرونه شته،
              نو مونږ به لومړی صفر غوره کړو، چې تر ټولو کوچنی شاخص لري.

محدودیتونه:
    * 1 <= د نډونو اوږدوالی <= 10000
    * 0 <= د نډ ارزښت""
    """"""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

"
"
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

"
"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"
def smallest_change(arr):
    """"""
    د صحیحو اعدادو یوه لړۍ arr په پام کې ونیسئ، لږ تر لږه څو عناصر باید بدل شي چې لړۍ palindromic شي. یوه palindromic لړۍ داسې لړۍ ده چې په شا او مخکې یو شان لوستل کیږي. په یوه بدلون کې، تاسو کولی شئ یو عنصر په بل عنصر بدل کړئ.

د بېلګې په توګه:
smallest_change == 4
smallest_change == 1
smallest_change == 0
    """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

"
"
def total_match(lst1, lst2):
    '''
    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.

    Examples
    total_match([], []) â -> []
    total_match(['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi']
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin']
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi']
    total_match(['4'], ['1', '2', '3', '4', '5']) â -> ['4']
    '''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

"
"
def is_multiply_prime(a):
    """"""Here is the translation of the provided sentence into Southern Pashto:

یوه فعله ولیکئ چې که ورکړل شوی عدد د ۳ اولي عددونو ضرب وي ریښتیا بیرته ورکړي، او که نه نو ناسم.
په دې پوهیدل چې له ۱۰۰ نه کم دی.
مثال:
is_multiply_prime == ریښتیا
۳۰ = ۲ * ۳ * ۵
    """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

"
"
def is_simple_power(x, n):
    """"""ستاسې دنده دا ده چې يو فنکشن وليکئ کوم چې که يو شمېر x د n ساده توان وي ريښتونی او په نورو حالتونو کې ناسم راګرځوي.
    x د n ساده توان دی که n**int=x وي.
    د بيلګې په توګه:
    is_simple_power => true
    is_simple_power => true
    is_simple_power => true
    is_simple_power => false
    is_simple_power => false
    is_simple_power => false
    """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

"
"
def hex_key(num):
    """"""تاسو ته دنده درکړل شوې ده چې يوه فعاله وليکئ چې يو هيکساديکېمل شمېره د تار په توګه ترلاسه کوي او د هيکساديکېمل عددونو شمېرنه کوي کوم چې اولي عددونه دي.
هيکساديکېمل عددونه دي 0، 1، 2، 3، 4، 5، 6، 7، 8، 9، A، B، C، D، E، F.
اول عددونه دي 2، 3، 5، 7، 11، 13، 17،...
نو تاسو بايد د لاندې عددونو شمېرنه وکړئ: 2، 3، 5، 7، B، D.
يادونه: تاسو فرض کولی شئ چې ورودی هميشه صحيح يا خالی تار دی، او سمبولونه A، B، C، D، E، F هميشه لوی حروف دي.
بېلګې:
د num = ""AB"" لپاره، پايله بايد 1 وي.
د num = ""1077E"" لپاره، پايله بايد 2 وي.
د num = ""ABED1A33"" لپاره، پايله بايد 4 وي.
د num = ""123456789ABCDEF0"" لپاره، پايله بايد 6 وي.
د num = ""2020"" لپاره، پايله بايد 2 وي.
    """"""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

"
"
def decimal_to_binary(decimal):
    """"""تاسو ته به په عشاري بڼه کې یو عدد درکړل شي او ستاسو دنده دا ده چې دا عدد په دوه ګوني بڼه تبدیل کړئ. فنکشن باید یوه ریسم ورکړي، چې هر کرکتر به یو دوه ګونی عدد ښکاره کوي. په ریسم کې هر کرکتر به '0' یا '1' وي.

په ریسم کې به د پیل او پای په برخه کې دوه اضافي کرکترونه 'db' وي. دا اضافي کرکترونه د بڼه بندي لپاره دي.

بیلګې:
decimal_to_binary   # ""db1111db"" برگرداند
decimal_to_binary   # ""db100000db"" برگرداند
    """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def is_happy(s):
    """"""تاسو ته یوه سلسله s درکول شوې ده.
ستاسو دنده ده چې وګورئ آیا سلسله خوشحاله ده که نه.
سلسله هغه وخت خوشحاله ده چې اوږدوالی یې لږترلږه ۳ وي او هر ۳ پرله پسې حروف بېل وي.
د بېلګې په توګه:
is_happy => غلط
is_happy => غلط
is_happy => رښتیا
is_happy => غلط
is_happy => رښتیا
is_happy => غلط
    """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
"
"
def numerical_letter_grade(grades):
    """"""دا د سیمستر وروستۍ اونۍ ده او ښوونکی باید زده کوونکو ته درجې ورکړي. ښوونکې خپل شخصي الگوریتم د درجې ورکولو لپاره جوړ کړی دی. یوازینۍ ستونزه دا ده چې هغې هغه کود له لاسه ورکړی چې د درجې ورکولو لپاره یې کارولی و. هغې تاسو ته د ځینو زده کوونکو د GPA لیست درکړی او تاسو باید یو فنکشن ولیکئ چې کولی شي د لاندې جدول په کارولو سره د لیکونو درجې لیست تولید کړي:

             GPA       |    د لیکونو درجه
              4.0                A+
            > 3.7                A 
            > 3.3                A- 
            > 3.0                B+
            > 2.7                B 
            > 2.3                B-
            > 2.0                C+
            > 1.7                C
            > 1.3                C-
            > 1.0                D+ 
            > 0.7                D 
            > 0.0                D-
              0.0                E
    

    مثال:
    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']
    """"""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def prime_length(string):
    """"""Here's the translation of the given sentence into Southern Pashto:

يوه دنده وليکئ چې يو لړۍ اخلي او بيرته راستنيږي True که د لړۍ اوږدوالی يو اولي عدد وي او False که نه
    بيلګې:
    prime_length == True
    prime_length == True
    prime_length == True
    prime_length == False
    """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

"
"
def starts_one_ends(n):
    """"""
    په ورکړل شوي مثبت عدد n باندې، د n-عددي مثبتو عددي شمېرې شمېرې چې له 1 سره پیل یا پای ته رسېږي، را وګرځوئ.
    """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def solve(N):
    """"""د یو مثبت عدد N په ورکړې سره، د دې عدد د ارقامو مجموع په دوه ګوني سیستم کې بیرته ورکړئ.

    مثال
        که N = 1000 وي، د ارقامو مجموع به 1 وي او نتیجه به ""1"" وي.
        که N = 150 وي، د ارقامو مجموع به 6 وي او نتیجه به ""110"" وي.
        که N = 147 وي، د ارقامو مجموع به 12 وي او نتیجه به ""1100"" وي.

    متغیرونه:
        @N عدد
             محدودیتونه: 0 ≤ N ≤ 10000.
    نتیجه:
         د دوه ګوني عدد یوه رشته
    """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

"
"
def add(lst):
    """"""د یو غیر خالي لست شمېرو سره lst. د زوجي عناصرو چې په طاق شاخصونو کې دي جمع کړئ.

    مثالونه:
        add ==> 2 
    """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
"
"
def anti_shuffle(s):
    """"""
    داسې يوه فنګشن وليکه چې يو سټرینګ اخلي او د دې يو ترتيب شوی ورژن بيرته ورکوي.
    د سټرینګ ترتيب شوی ورژن هغه دی چې ټولې الفاظ
    په نوې کلمې بدلېږي چې ټول کرکټرونه په کې د اسکي ارزښت پر بنسټ په صعودي ترتيب کې وي.
    يادونه: ته بايد د جملې په ترتيب کې د الفاظو او تشو ځایونو ترتيب وساتې.

    د بېلګې په توګه:
    anti_shuffle بيرته ورکوي 'Hi'
    anti_shuffle بيرته ورکوي 'ehllo'
    anti_shuffle بيرته ورکوي 'Hello !!!Wdlor'
    """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def get_row(lst, x):
    """"""
    تاسو ته دوه بعدي ډاټا درکول شوې، لکه په لستونو کې چې دننه شوي وي، 
    دا د میټریکس سره ورته دی، خو میټریکسونو برخلاف، 
    هره قطار کې ممکنه ده چې مختلف شمیر ستنو ولري.
    که چېرته تاسو ته lst او یو عدد x درکړل شي، نو په لست کې
    د x عدادونه پیدا کړئ، او د جوړه لست بیرته ورکړئ، [, ...] داسې چې 
    هره جوړه یو همغږي وي -، چې له 0 څخه پیل کیږي.
    همغږي په پیل کې د قطارونو له مخې په زیاتیدونکي ترتیب سره ترتیب کړئ.
    همدا شان، د قطارونو همغږي د ستنو له مخې په کموالی ترتیب سره ترتیب کړئ.
    
    بېلګې:
    get_row([
      [1,2,3,4,5,6],
      [1,2,3,4,1,6],
      [1,2,3,4,5,1]
    ], 1) == [,,,,]
    get_row == []
    get_row == []
    """"""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def sort_array(array):
    """"""
    د غیر منفي اعدادو یوه صف ورکړل شوې ده، د ورکړل شوې صف یوه کاپي بیرته ورکړئ وروسته له دې چې ترتیب شوي وي.
تاسو به ورکړل شوې صف په صعودي ترتیب کې تنظیم کړئ که د مجموعه جفت وي،
یا یې په نزولي ترتیب کې تنظیم کړئ که د مجموعه طاق وي.

یادونه:
* ورکړل شوې صف مه بدلوئ.

بیلګې:
* sort_array => []
* sort_array => [5]
* sort_array => [0, 1, 2, 3, 4, 5]
* sort_array => [6, 5, 4, 3, 2, 1, 0]
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"
def encrypt(s):
    """"""په جنوبي پښتو کې دا جمله داسې ژباړل کېږي:

د کوډ کولو یوه دنده جوړه کړئ چې یو تار د دلیل په توګه اخلي او یو تار بیرته ورکوي چې د الفبې په څرخېدو سره کوډ شوی وي. 
الفباء باید په داسې ډول وڅرخول شي چې حروف په دوه ضرب دوه ځایونو کې ښکته شي.
د بېلګې په توګه:
encrypt بیرته 'lm' ورکوي
encrypt بیرته 'ewhjklnop' ورکوي
encrypt بیرته 'kj' ورکوي
encrypt بیرته 'ix' ورکوي
    """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def next_smallest(lst):
    """"""
    تاسو ته د عددي عناصرو یو لیست درکړل شوی دی.
    د `next_smallest` په نامه یو فنکشن ولیکئ چې د لیست دوهم کوچنی عنصر بیرته درکړي.
    که داسې عنصر شتون ونلري، نو `None` بیرته ورکړئ.
    
    next_smallest == 2
    next_smallest == 2
    next_smallest == None
    next_smallest == None
    """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def is_bored(S):
    """"""
    تاسو ته د کلمو یوه لیکنه درکړل شي، او ستاسو دنده دا ده چې د ستړیاوو شمیر وکړئ. ستړیا یوه جمله ده چې د ""زه"" کلمې سره پیل کیږي. جملې د '.', '?' یا '!' په واسطه بیلېږي.

لکه د مثال په توګه:
    >>> is_bored(""Hello world"")
    0
    >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
    1
    """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def any_int(x, y, z):
    '''
    Create a function that takes 3 numbers.
    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
    Returns false in any other cases.
    
    Examples
    any_int(5, 2, 7) â -> True
    
    any_int(3, 2, 2) â -> False

    any_int(3, -2, 1) â -> True
    
    any_int(3.6, -2.2, 2) â -> False
  

    
    '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

"
"
def encode(message):
    """"""
    Here is the translation of the provided text into Southern Pashto:

يوه وظيفه وليکئ چې يو پېغام اخلي، او په داسې ډول کوډ کوي چې د ټولو حرفونو حالت بدل کړي، په پېغام کې ټولې څپې د انګليسي الفبې په حساب دوه ځایه مخکې راتلونکي حرف سره بدلوي.
يوازې حروف په نظر کې ونيول شي.

بيلګې:
    >>> encode('test')
    'TGST'
    >>> encode('This is a message')
    'tHKS KS C MGSSCGG'
    """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def skjkasdkd(lst):
    """"""تاسو ته د اعدادو یو لیست درکول شوی.
    تاسو باید تر ټولو لوی ابتدائي عدد پیدا کړئ او د هغې د عددونو مجموعه واپس کړئ.

    مثالونه:
    د lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] لپاره نتیجه باید 10 وي
    د lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] لپاره نتیجه باید 25 وي
    د lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] لپاره نتیجه باید 13 وي
    د lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] لپاره نتیجه باید 11 وي
    د lst = [0,81,12,3,1,21] لپاره نتیجه باید 3 وي
    د lst = [0,8,1,2,1,7] لپاره نتیجه باید 7 وي
    """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
"
"
def check_dict_case(dict):
    """"""
    په دې جملې په جنوبی پښتو ژبه وژباړئ.

که یو قاموس ورکړل شي، نو دغه قاموس صحیح دی که ټول کلي ګانې په ټیټه لیک یا په لوړه لیک کې وي، او که نه وي نو غلط دی.
دا کار باید غلط وښيي که ورکړل شوی قاموس خالی وي.
مثالونه:
check_dict_case باید صحیح وښيي.
check_dict_case باید غلط وښيي.
check_dict_case باید غلط وښيي.
check_dict_case باید غلط وښيي.
check_dict_case باید صحیح وښيي.
    """"""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

"
"
def count_up_to(n):
    """"""د یوه غیر منفي عدد لپاره یوه دنده پلي کړئ چې د لومړي n لومړی عددونه چې ابتدايي عددونه دي او د n څخه لږ دي، بیرته ورکوي.
د بېلګې په توګه:
count_up_to => [2,3]
count_up_to => [2,3,5,7]
count_up_to => []
count_up_to => [2,3,5,7,11,13,17,19]
count_up_to => []
count_up_to => [2,3,5,7,11,13,17]
    """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

"
"
def multiply(a, b):
    """"""دنده بشپړه کړئ چې دوه عددونه اخلي او د هغوی د واحدونو د شمیرو ضرب بیرته ورکوي.
فرض کړئ چې ورودی تل سم دی.
بیلګې:
multiply باید 16 بیرته ورکړي.
multiply باید 72 بیرته ورکړي.
multiply باید 0 بیرته ورکړي.
multiply باید 20 بیرته ورکړي.
    """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

"
"
def count_upper(s):
    """"""
    په داسې حال کې چې تاسو ته د s نومی تار درکړل شي، په جفت شاخصونو کې د لویو تورو غږونو شمېر وکړئ.

    د بېلګې په توګه:
    count_upper ۱ راګرځوي
    count_upper ۰ راګرځوي
    count_upper ۰ راګرځوي
    """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def closest_integer(value):
    '''
    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Examples
    >>> closest_integer(""10"")
    10
    >>> closest_integer(""15.3"")
    15

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For Exampleclosest_integer(""14.5"") should
    return 15 and closest_integer(""-14.5"") should return -15.
    '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

"
"
def make_a_pile(n):
    """"""
    د یو مثبت عدد n په ورکړو سره، ته باید د n کچو د تیږو یوه ډله جوړه کړې.
    لومړی کچه n تیږې لري.
    په راتلونکې کچه کې د تیږو شمېر دی:
        - که n طاق وي، نو راتلونکی طاق عدد.
        - که n جوړه وي، نو راتلونکی جوړه عدد.
    د هرې کچې د تیږو شمېر په یو لیست کې واپس کړه، چې په کوم کې عنصر په شاخص i کې د کچې د تیږو شمېر څرګندوي.

    مثالونه:
    >>> make_a_pile(3)
    [3, 5, 7]
    """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def words_string(s):
    """"""
    تاسو ته به د کلمو یوتار درکړل شي چې د کامو یا فاصلې په واسطه جلا شوی وي. ستا دنده داده چې تار په کلمو وویشئ او د کلمو یو ارایه واپس کړئ.

د بېلګې په توګه:
words_string == [""Hi"", ""my"", ""name"", ""is"", ""John""]
words_string == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

"
"
def choose_num(x, y):
    """"""دغه فعالیت دوه مثبتي شمېرې x او y اخلي او په [x, y] ټولګه کې تر ټولو لوی جفت عدد بېرته ورکوي. که په دغه ټولګه کې داسې عدد موجود نه وي، نو فعالیت باید -1 بېرته ورکړي.

بیلګې:

choose_num = 14
choose_num = -1
    """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

"
"
def rounded_avg(n, m):
    """"""تاسو ته دوه مثبت عددونه n او m درکړل شوي دي، او ستاسو دنده دا ده چې د n نه تر m پورې د عددونو اوسط محاسبه کړئ.
ځواب تر نږدې عدد پورې راټول کړئ او هغه عدد ته په بائنري کې بدل کړئ.
که n له m څخه زیات وي، -1 واپس کړئ.
مثال:
rounded_avg => ""0b11""
rounded_avg => -1
rounded_avg => ""0b1111""
rounded_avg => ""0b11010""
    """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

"
"
def unique_digits(x):
    """"""Given a list of positive integers x. yow wapas karrha shuda sorted list dy tol elements che d kaam even digit nadi lari.

Note: Wapas karrha shuda list ba sorted wi pa barhta order k.

Masalan:
    >>> unique_digits([15, 33, 1422, 1])
    [1, 15, 33]
    >>> unique_digits([152, 323, 1422, 10])
    []
    """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def by_length(arr):
    """"""
    د یو عددی آرایه په ورکولو سره، هغه عددي ترتیب کړئ چې د 1 او 9 ترمنځ دي،
آرایه بیرته واړوئ، او بیا هر عدد د دې نوم سره بدل کړئ لکه ""یو""، ""دوه""، ""درې""، ""څلور""، ""پنځه""، ""شپږ""، ""اووه""، ""اته""، ""نه"".

مثال لپاره:
    arr = [2, 1, 1, 4, 5, 8, 2, 3]   
         -> آرایه ترتیب کړئ -> [1, 1, 2, 2, 3, 4, 5, 8] 
         -> آرایه بیرته واړوئ -> [8, 5, 4, 3, 2, 2, 1, 1]
    بیرته ورکړئ [""اته"", ""پنځه"", ""څلور"", ""درې"", ""دوه"", ""دوه"", ""یو"", ""یو""]
    
    که آرایه خالي وي، خالي آرایه بیرته ورکړئ:
    arr = []
    بیرته ورکړئ []

    که په آرایه کې کوم عجیب شمیر وي، له پامه یې وغورځوئ:
    arr = [1, -1 , 55] 
         -> آرایه ترتیب کړئ -> [-1, 1, 55]
         -> آرایه بیرته واړوئ -> [55, 1, -1]
    بیرته ورکړئ = ['یو']
    """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

"
"
def f(n):
    """""" To translate the given sentence into Southern Pashto, here is the translation:

د f دنده پلي کړئ چې n د پارامتر په توګه اخلي،
او د n اندازه یو لیست بیرته راګرځوي، داسې چې په i شاخص کې د عنصر ارزښت د i فاکتور وي که i جفت وي
یا د 1 څخه تر i پورې د شمېرو مجموعه وي که نه.
i له 1 څخه پیل کیږي.
د i فاکتور د 1 څخه تر i پورې د شمېرو ضرب دی.
بیلګه:
f == [1، 2، 6، 24، 15]
    """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
"
"
def even_odd_palindrome(n):
    """"""
    د یو مثبت عدد n په ورکړې سره، یو ټپل راولي چې د هغه عدد د جفت او طاق عددي پالیندرم شمېر لري چې د په رینج کې راځي، شمول.

بیلګه 1:

وروردي: 3
نتاج:
تشریح:
عددي پالیندرمونه 1, 2, 3 دي. یو یې جفت دی، او دوه یې طاق دي.

بیلګه 2:

وروردي: 12
نتاج:
تشریح:
عددي پالیندرمونه 1, 2, 3, 4, 5, 6, 7, 8, 9, 11 دي. څلور یې جفت دي، او 6 یې طاق دي.

یادونه:
1. 1 <= n <= 10^3
2. بېرته ورکړل شوی ټپل د جفت او طاق عددي پالیندرمونو شمېر لري.
    """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def count_nums(arr):
    """"""
    په سوېلي پښتو کې دغه جمله داسې ژباړل شوې ده:

د count_nums په نوم یوه دنده ولیکئ چې د عددونو یوه صف اخلي او د هغو عناصرو شمېر بیرته ورکوي چې د عددونو مجموعه یې له ۰ څخه زیاته وي.
که یو عدد منفي وي، نو لومړی نښه لرونکی عدد به یې منفي وي:
لکه -123 چې نښه لرونکي عددونه یې -1، 2، او 3 دي.
    >>> count_nums([]) == 0
    >>> count_nums([-1, 11, -11]) == 1
    >>> count_nums([1, 1, 2]) == 3
    """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def move_one_ball(arr):
    """"""Here is the translation of the given sentence into Southern Pashto:

موږ د N عددونو یو 'arr' نومي آرے لرو arr[1], arr[2], ..., arr[N]. په آرے کې عددونه په تصادفي ډول سره به وي. ستاسو وظیفه داده چې معلومه کړئ چې آیا ممکنه ده چې د ورکړل شوي آرے څخه په غیر کمیدونکي ترتیب سره یو آرے ترلاسه کړئ د لاندې عملیات ترسره کولو سره:
تاسو ته اجازه ده چې د ښي خوا اړول عملیات هر څومره ځله ترسره کړئ.

د ښي خوا اړول عملیات مانا لري چې د آرے ټول عناصر یو ځای په ښي لورې اړول. د آرے وروستی عنصر به د آرے په پیل کې یعنې 0مې نمبر ته لیږدول شي.

که دا ممکنه وي چې د پورته عملیات ترسره کولو سره مرتب آرے ترلاسه شي نو بیا ریښتیا بیرته ورکړئ او که نه نو دروغ.
که ورکړل شوې آرے خالي وي نو بیا ریښتیا بیرته ورکړئ.

یادونه: ورکړل شوی لست تضمین شوی دی چې یکتا عناصر به ولري.

د مثال لپاره:

move_one_ball==>ریښتیا
تشریح: د 2 ځلې ښي اړول عملیات ترسره کولو سره، غیر کمیدونکی ترتیب ترلاسه کیدی شي.

move_one_ball==>دروغ
تشریح: دا ممکنه نه ده چې د ورکړل شوي آرے څخه غیر کمیدونکی ترتیب ترلاسه شي د هر ډول ښي اړولو عملیات ترسره کولو سره.
                
    """"""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
"
"
def exchange(lst1, lst2):
    """"""په دې ستونزه کې، تاسو به یوه دنده پلي کړئ چې دوه د شمېرونو لیستونه اخلي، 
او ټاکي چې ایا د دې امکان شته چې د عناصرو تبادله ترمنځ ترسره کړئ ترڅو lst1 یوازې د حتی شمېرونو لیست وګرځي. 
په lst1 او lst2 کې د تبادله شوو عناصرو په شمېر باندې هیڅ محدودیت نشته.
که چیرې د lst1 ټول عناصر د تبادلې له لارې حتی کېدای شي، ""YES"" بیرته ورکړئ.
بلکه، ""NO"" بیرته ورکړئ.
د مثال په توګه:
exchange => ""YES""
exchange => ""NO""
دا ګمان کېږي چې د ورودی لیستونه به خالي نه وي.
    """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

"
"
def histogram(test):
    """"""په سویلي پښتو کې د جملې ژباړه:

""یو تار چې د ټیټ حروفو سره جلا شوی ځایونه ښیي، یو ډکشنري بیرته ورکړئ چې د زیات تکرار سره لیکنه او د هغې اړوند شمېر لري. که څو لیکنې یو شان تکرار ولري، ټول یې بیرته ورکړئ.

مثال:
histogram == {'a': 1, 'b': 1, 'c': 1}
histogram == {'a': 2, 'b': 2}
histogram == {'a': 2, 'b': 2}
histogram == {'b': 4}
histogram == {}""

    """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

"
"
def reverse_delete(s,c):
    """"""موږ ته دوه تارونه s او c راکړل شوي دي، تاسو باید په s کې ټول هغه حروف حذف کړئ چې په c کې هر حروف سره برابر وي
بیا وګورئ که پایله تار palindrome دی.
یو تار هغه وخت palindrome بلل کیږي که چیرې دا په شا او مخ کې یو شان لوستل کیږي.
تاسو باید یو دوه ګونی چې د پایله تار او د چک لپاره ریښتیا/غلط لري، بیرته ورکړئ.
بیلګه
د s = ""abcde"" لپاره، c = ""ae""، پایله باید
د s = ""abcdef"" لپاره، c = ""b"" پایله باید
د s = ""abcdedcba"" لپاره، c = ""ab""، پایله باید
    """"""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
"
"
def odd_count(lst):
    """"""په دې جمله کې، چې هره جمله یوازې له شمیرو څخه جوړه شوې، یوه لیست بیرته ورکړئ.
    د تولیدي لیست هر عنصر i باید ""د جمله i په ان پټ کې د طاق شمېرو شمېر"" وي. 
    چیرې چې ټول i باید د ان پټ په i جمله کې د طاق شمیرو په شمېر بدل شي.

    >>> odd_count(['1234567'])
    [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
    >>> odd_count(['3',""11111111""])
    [""the number of odd elements 1n the str1ng 1 of the 1nput."",
     ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
    """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def minSubArraySum(nums):
    """"""
    د عددونو یو آرایه په پام کې ونیسئ، د دې آرایی څخه د هر غیر خالي فرعي آرایی لږ تر لږه مجموعه پیدا کړئ.
    بیلګه
    minSubArraySum == 1
    minSubArraySum == -6
    """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
"
"
def max_fill(grid, capacity):
    import math
    """"""
    تاسو ته د څاګانو يو مستطيل گرېډ درکول کېږي. هر قطار يو څاه ښيي،
او هر ۱ په قطار کې د اوبو يو واحد ښيي.
هر څاه ته يو اړونده بالټۍ شته چې له هغې څخه اوبه ايستل کيدای شي،
او ټولې بالټۍ يو شان ظرفيت لري.
ستاسو دنده دا ده چې د بالټۍ په کارولو سره څاګانې خالي کړئ.
پايله د هغه وختونو شمېر دی چې تاسو ته بالټۍ ټيټول پکار دي.

مثال ۱:
    داخلې: 
        گرېډ: [[۰,۰,۱,۰], [۰,۱,۰,۰], [۱,۱,۱,۱]]
        د بالټۍ ظرفيت: ۱
    پايله: ۶

مثال ۲:
    داخلې: 
        گرېډ: [[۰,۰,۱,۱], [۰,۰,۰,۰], [۱,۱,۱,۱], [۰,۱,۱,۱]]
        د بالټۍ ظرفيت: ۲
    پايله: ۵

مثال ۳:
    داخلې: 
        گرېډ: [[۰,۰,۰], [۰,۰,۰]]
        د بالټۍ ظرفيت: ۵
    پايله: ۰

محدودیتونه:
    * ټول څاګانې يو شان اوږدوالي لري
    * ۱ <= د گرېډ اوږدوالی <= ۱۰^۲
    * ۱ <= د گرېډ هر قطار اوږدوالی <= ۱۰^۲
    * گرېډ[i][j] -> ۰ | ۱
    * ۱ <= ظرفيت <= ۱۰
    """"""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

"
"
def sort_array(arr):
    """"""
    په دې کاتا کې، ته باید د غیر منفي عددونو یو ارایه د دوی د باینري تمثیل کې د یوګانو د شمېر په ترتیب سره په صعودي ډول مرتب کړې.
    د ورته یوګانو شمېر لپاره، د عدد د ډیسیمال ارزښت په اساس ترتیب کړه.

    دا باید داسې پلی شي:
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def select_words(s, n):
    """"""لاندې جملې په جنوبي پښتو کې وژباړئ:

```plaintext
د یو تار s او یو طبیعي شمیره n په درلودلو سره، تاسو ته دنده درکړل شوې چې یو فنکشن تطبیق کړئ چې یو لیست بیرته راولي چې ټولې هغه کلمې له تار s څخه پکې شاملې وي چې په دقیق ډول n کنسونټونه لري، په هماغه ترتیب چې دا کلمې په تار s کې څرګندیږي.
که تار s خالي وي نو فنکشن باید یو خالي لیست بیرته راولي.
یادونه: تاسو فرض کولی شئ چې ورودی تار یوازې حروف او ځایونه لري.
مثالونه:
select_words ==> [""little""]
select_words ==> [""Mary"", ""lamb""]
select_words ==> []
select_words ==> [""world""]
select_words ==> [""Uncle""]
```
    """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

"
"
def get_closest_vowel(word):
    """"""تاسو ته یو لغت درکړل شوی دی. ستاسو دنده دا ده چې د لغت د ښي اړخ څخه تر ټولو نږدې غږیز چې د دوه صامتونو تر منځ واقع وي، ومومئ.

پیل او اخر کې غږیزونه په پام کې نه نیول کیږي. که تاسو داسې غږیز ونه موندو، نو خالي تار بیرته ورکړئ.

تاسو دې فرض کړئ چې ورکړل شوی تار یوازې انګلیسي حروف لري.

مثالونه:
get_closest_vowel ==> ""u""
get_closest_vowel ==> ""U""
get_closest_vowel ==> """"
get_closest_vowel ==> """"
    """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

"
"
def maximum(arr, k):
    """"""
    د عددونو یوه لړۍ arr او یو مثبت عدد k په پام کې نیولو سره، د اوږدوالي k سره یو ترتیب شوی لیست بیرته ورکړئ چې په arr کې اعظمي k عددونه لري.

مثال 1:

    Input: arr = [-3, -4, 5], k = 3
    Output: [-4, -3, 5]

مثال 2:

    Input: arr = [4, -4, 4], k = 2
    Output: [4, 4]

مثال 3:

    Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1
    Output: [2]

یادونه:
    1. د لړۍ اوږدوالی به د [1، 1000] په حدودو کې وي.
    2. په لړۍ کې عناصر به د [-1000، 1000] په حدودو کې وي.
    3. 0 <= k <= د لړۍ اوږدوالی
    """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

"
"
def solution(lst):
    """"""د غیر خالي عددي لست په ورکړې حال کې، د ټولو هغو طاق عناصرو مجموعه راوړي چې په جفت مقامونو کې وي.

    مثالونه
    حل ==> 12
    حل ==> 9
    حل ==> 0
    """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

"
"
def add_elements(arr, k):
    """"""
    په لاندې جمله په سویلي پښتو ژباړه وکړئ:

د صحیح عددونو یوه غیرخالي صف arr او یو صحیح عدد k په نظر کې ونیسئ، له arr څخه د k لومړنیو عناصرو څخه د هغو عناصرو مجموعه بیرته را وګرځوئ چې تر دوه عدده زیات نه وي.

  مثال:

    انپټ: arr = [111,21,3,4000,5,6,7,8,9], k = 4
    اوټپټ: 24  # د 21 + 3 مجموعه

  محدودیتونه:
    1. 1 <= د arr اوږدوالی <= 100
    2. 1 <= k <= د arr اوږدوالی
    """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def get_odd_collatz(n):
    """"""
    د یو مثبت عدد n په ورکولو سره، یو ترتیب شوي لیست ورکړئ چې په کلاتز سلسله کې فردي شمیرې لري.

    د کلاتز مفروضه په ریاضیاتو کې یوه مفروضه ده چې یوه سلسله تعریفوي په لاندې ډول: د هر مثبت عدد n سره پیل وکړئ. بیا هر شرط د تیرو شرطونو څخه په لاندې ډول ترلاسه کیږي: که چیرې تیرو شرطونو جفت وي، نو بل شرط د تیرو شرطونو نیمایي دی. که چیرې تیرو شرطونو فرد وي، نو بل شرط 3 ځله د تیرو شرطونو جمع 1 دی. مفروضه دا ده چې پرته له دې چې n کوم ارزښت وي، سلسله به تل 1 ته ورسیږي.

    یادونه: 
        1. Collatz [1] دی.
        2. ورکړل شوی لیست په زیاتیدونکي ترتیب کې ترتیب شوی دی.

    د مثال په توګه:
    get_odd_collatz [1, 5] ورکوي # د 5 لپاره کلاتز سلسله [5, 16, 8, 4, 2, 1] ده، نو فردي شمیرې یوازې 1 او 5 دي.
    """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def valid_date(date):
    """"""تاسو باید یوه دنده ولیکئ چې ورکړل شوې نېټه تار تایید کړي او که نېټه سمه وي نو True او که نا سمه وي نو False بیرته ورکړي.
نېټه هغه وخت سمه ده که لاندې ټول قواعد پوره کړي:
1. نېټه تار خالي نه وي.
2. د ورځو شمېر د میاشتې 1،3،5،7،8،10،12 لپاره له 1 څخه کم یا له 31 ورځو څخه زیات نه وي. او د میاشتې 4،6،9،11 لپاره له 1 څخه کم یا له 30 ورځو څخه زیات نه وي. او د میاشتې 2 لپاره له 1 څخه کم یا له 29 ورځو څخه زیات نه وي.
3. میاشتې له 1 څخه کم یا له 12 څخه زیات نه وي.
4. نېټه باید په دې بڼه وي: mm-dd-yyyy

لکه د بیلګې په توګه:
valid_date => True

valid_date => False

valid_date => False

valid_date => True

valid_date => False
    """"""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
"
"
def split_words(txt):
    '''
    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    Examples
    split_words(""Hello world!"") â -> [""Hello"", ""world!""]
    split_words(""Hello,world!"") â -> [""Hello"", ""world!""]
    split_words(""abcdef"") == 3 
    '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
"
"
def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) â -> True
    is_sorted([1, 2, 3, 4, 5]) â -> True
    is_sorted([1, 3, 2, 4, 5]) â -> False
    is_sorted([1, 2, 3, 4, 5, 6]) â -> True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) â -> True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) â -> False
    is_sorted([1, 2, 2, 3, 3, 4]) â -> True
    is_sorted([1, 2, 2, 2, 3, 4]) â -> False
    '''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

"
"
def intersection(interval1, interval2):
    """"""تاسو ته دوه وقفې درکړل شوي،
    چیرې چې هره وقفه د عددونو یوه جوړه ده. د بېلګې په توګه، وقفه = =.
    ورکړل شوي وقفې تړلې دي چې معنی یې دا ده چې وقفه
    دواړه پیل او پای پکې شامل دي.
    د هرې ورکړل شوې وقفې لپاره، ګومان کیږي چې د هغې پیل د پای سره مساوي یا له هغې څخه کم وي.
    ستاسو دنده دا ده چې معلومه کړئ چې د دې دوو وقفونو د تقاطع اوږدوالی لومړی عدد دی که نه.
    مثال، د وقفونو، تقاطع دی
    چې اوږدوالی یې 1 دی، چې لومړی عدد نه دی.
    که د تقاطع اوږدوالی لومړی عدد وي، ""YES"" ولیکئ،
    که نه، ""NO"" ولیکئ.
    که دوه وقفې سره تقاطع نه کوي، ""NO"" ولیکئ.

    [ورودي/وتني] نمونې:
    intersection،) ==> ""NO""
    intersection،) ==> ""NO""
    intersection،) ==> ""YES""
    """"""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

"
"
def prod_signs(arr):
    """"""
    Sure, I can help with that. Here's the translation of the provided sentence into Southern Pashto:

تاسو ته د عددونو يوه صف arr درکړل شوې ده او تاسو ته پکار دي چې د عددونو د شدتونو مجموعه بيرته ورکړئ چې د صف هرې شمېره کې د نښو د حاصل ضرب په واسطه ضرب شوې وي، چې د 1، -1 يا 0 په شکل کې څرګندېږي.
نوټ: د خالي صف لپاره هیڅ شی مه ستنوه.

بیلګه:
    >>> prod_signs([1, 2, 2, -4]) == -9
    >>> prod_signs([0, 1]) == 0
    >>> prod_signs([]) == None
    """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def minPath(grid, k):
    """"""
    په سدرني پښتو ژبه کې دغه جمله وژباړئ:

    د N قطارونو او N کالمونو سره یو جال ورکړل شوی دی او یو مثبت عدد k،
    د جال هره خانه یو ارزښت لري. په [1, N * N] رینج کې هره شمیره په کره توګه په جال کې 
    یو ځل ښکاري.

    تاسو باید د جال په کې لږ تر لږه د k اوږدوالي لار پیدا کړئ. تاسو کولی شئ 
    له هرې خانې څخه پیل وکړئ، او په هر ګام کې تاسو کولی شئ خپلو ګاونډیو 
    خانې ته حرکت وکړئ، په بل عبارت، تاسو کولی شئ هغه خانې ته لاړ شئ چې 
    د ستاسو اوسني خانې سره یو څنډه شریکه کوي.
    مهرباني وکړئ یادونه وکړئ چې د k اوږدوالي لار په دې معنی ده چې دقیقاً 
    k خانې لیدل شوې دي.
    تاسو نشئ کولی د جال څخه بهر لاړ شئ.
    یوه لار A د یوې لار B څخه لږه ګڼل کیږي 
    که چیرې د هغو ارزښتونو ترتیب شوي لیستونه چې A او B یې تیریږي (راځئ 
    چې هغوی ته lst_A او lst_B ووایو) وروسته له دې چې جوړ شول، lst_A 
    له lst_B څخه په لغوي توګه لږه وي، په بل عبارت، هلته یو عدد 
    شاخص i شتون لري چې lst_A[i] < lst_B[i] او 
    د هر j لپاره موږ لرو lst_A[j] = lst_B[j].
    دا تضمین شوې ده چې ځواب یکتا دی.
    د هغو ارزښتونو ترتیب شوی لیست بیرته ورکړئ چې لږ تر لږه د لارې په اوږدو کې تیریږي.

    مثالونه:

        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3
        Output: [1, 2, 1]

        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1
        Output: [1]
    """"""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

"
"
def tri(n):
    """"""هر څوک د فیبوناچي سلسله پېژني، دا د تیرو څو پیړیو په اوږدو کې د ریاضیدانانو لخوا په ژوره توګه مطالعه شوې ده. خو څه چې خلک نه پوهیږي هغه د ټری بوناچي سلسله ده. د ټری بوناچي سلسله د لاندې بیا تکرار سره تعریف کیږي:
tri = ۳
tri = ۱ + n / ۲، که n جفت وي.
tri =  tri + tri + tri، که n طاق وي.
د مثال په توګه:
tri = ۱ + = ۲
tri = ۳
tri = tri + tri + tri
           = ۲ + ۳ + ۳ = ۸ 
تاسو ته یو غیر منفي عدد n درکړل شوی، تاسو باید د ټری بوناچي سلسلې لومړني n + ۱ عددونه بیرته ورکړئ.
مثالونه:
tri = [۱، ۳، ۲، ۸]
    """"""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
"
"
def digits(n):
    """"""د یو مثبت عدد n په ورکړې سره، د طاق شمیرو ضرب بیرته ورکړئ.
    که چیرته ټولې شمیرې جفت وي، نو 0 بیرته ورکړئ.
    د مثال په توګه:
    digits == 1
    digits == 0
    digits == 15
    """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

"
"
def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') â -> True
    is_nested('[]]]]]]][[[[[]') â -> False
    is_nested('[][]') â -> False
    is_nested('[]') â -> False
    is_nested('[[][]]') â -> True
    is_nested('[[]][[') â -> True
    '''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

"
"

def sum_squares(lst):
    """"""تاسو ته د شمېرو يو ليست درکول کېږي.
تاسو ته په ورکړل شوي ليست کې د مربع شوو شمېرو مجموع واپس راوړل پکار دي،
اول بايد هر عنصر په ليست کې پورته عدد ته راورسوئ.
مثالونه:
که ليست [1,2,3] وي، نو نتيجه بايد 14 وي
که ليست [1,4,9] وي، نو نتيجه بايد 98 وي
که ليست [1,3,5,7] وي، نو نتيجه بايد 84 وي
که ليست [1.4,4.2,0] وي، نو نتيجه بايد 29 وي
که ليست [-2.4,1,1] وي، نو نتيجه بايد 6 وي
    

    """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def check_if_last_char_is_a_letter(txt):
    '''
    Create a function that returns True if the last character
    of a given string is an alphabetical character and is not
    a part of a word, and False otherwise.
    Note: ""word"" is a group of characters separated by space.

    Examples:
    check_if_last_char_is_a_letter(""apple pie"") â -> False
    check_if_last_char_is_a_letter(""apple pi e"") â -> True
    check_if_last_char_is_a_letter(""apple pi e "") â -> False
    check_if_last_char_is_a_letter("""") â -> False 
    '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def can_arrange(arr):
    """"""دا يوه دنده جوړ کړئ چې هغه ستر شاخص بيرته وګرځوي چې عنصر له هغه عنصر نه زيات نه وي چې سمدلاسه تر دې مخکې راځي. که داسې عنصر شتون ونه لري نو -1 بيرته وګرځوئ. ورکړل شوې سلسله به تکراري ارزښتونه ونه لري.

بیلګې:
can_arrange = 3
can_arrange = -1
    """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

"
"
def largest_smallest_integers(lst):
    '''
    Create a function that returns a tuple (a, b), where 'a' is
    the largest of negative integers, and 'b' is the smallest
    of positive integers in a list.
    If there is no negative or positive integers, return them as None.

    Examples:
    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)
    largest_smallest_integers([]) == (None, None)
    largest_smallest_integers([0]) == (None, None)
    '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
"
"
def compare_one(a, b):
    """"""
    په سدرن پښتو کې، دا جمله په لاندې ډول ژباړل کېږي:

```
یو فنکشن جوړ کړئ چې انتجرونه، فلوټونه، یا د ریښتینو شمیرو استازیتوب کوونکي سټیرنګونه اخلي، او په ورکړل شوي متغیر ډول کې لوی متغیر بیرته ورکوي.
که ارزښتونه مساوي وي، نو هیڅ هم بیرته مه ورکوئ.
نوټ: که یو ریښتینی نمبر د سټیرنګ په توګه استازیتوب کیږي، فلوټینګ پواینټ ممکن . یا , وي.

compare_one -> ۲.۵
compare_one -> ""۲,۳""
compare_one -> ""۶""
compare_one -> هیڅ هم نه
```
    """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def is_equal_to_sum_even(n):
    """"""To translate the given sentence into Southern Pashto, here is the translation:

""ارزیابی کړئ چې آیا ورکړل شوی عدد n د دقیقاً ۴ مثبتو جوړو عددونو د مجموعې په توګه لیکل کیدی شي
    بېلګه
    is_equal_to_sum_even == غلط
    is_equal_to_sum_even == غلط
    is_equal_to_sum_even == رښتیا""
    """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
"
"
def special_factorial(n):
    """"""د برازیلی فاکټوریل داسې تعریف شوی دی:
    برازیلی_فاکټوریل = n! *! *! * ... * 1!
    چیرته چې n > 0

    د بېلګې په توګه:
    >>> special_factorial(4)
    288

    The function will receive an integer as input and should return the special
    factorial of this integer.
    """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

"
"
def fix_spaces(text):
    """"""
    Given a string text, replace all spaces in it with underscores, 
    and if a string has more than 2 consecutive spaces, 
    then replace all consecutive spaces with - 
    
    fix_spaces == ""Example""
    fix_spaces == ""Example_1""
    fix_spaces == ""_Example_2""
    fix_spaces == ""_Example-3""

دا یوه لیکنه ده، چې په هغې کې ټول ځایونه په ټکو بدلېږي،
او که په لیکنه کې د دوو څخه زیات پرله‌پسې ځایونه وي،
نو ټول پرله‌پسې ځایونه په - بدلېږي.

    fix_spaces == ""Example""
    fix_spaces == ""Example_1""
    fix_spaces == ""_Example_2""
    fix_spaces == ""_Example-3""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

"
"
def file_name_check(file_name):
    """"""په جنوبي پښتو کې دغه جمله داسې ژباړل کیږي:

يوه دنده جوړه کړئ چې يو تار اخلي چې د يو فایل نوم څرګندوي، او 'هو' بيرته ورکوي که د فایل نوم سم وي، او 'نه' بيرته ورکوي که نه وي.
د فایل نوم هغه وخت سم ګڼل کيږي که او یوازې که ټول لاندې شرطونه پوره کړي:
- په فایل نوم کې باید له درېو عددي کرکټرونو څخه زیات نه وي.
- د فایل نوم باید يو ټکي ولري.
- د ټکي مخکې برخه بايد خالي نه وي، او د ليکنې له يوې توري څخه پيل شي چې د لاتيني الفبې وي.
- د ټکي وروسته برخه بايد له دې څخه يوه وي: ['txt', 'exe', 'dll']
مثالونه:
file_name_check # => 'هو'
file_name_check # => 'نه'
    """"""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

"
"


def sum_squares(lst):
    """"""دغه فعالیت به یو لړ ټوله شمېرو واخلي. د لړ ټولو ننوتلو لپاره، فعالیت به د هغه عدد مربع کړي که د هغه شاخص د ۳ په څو چنده کې وي او د هغه عدد به مکعب کړي که د هغه شاخص د ۴ په څو چنده کې وي او د ۳ په څو چنده کې نه وي. فعالیت به د لړ هغه ننوتلو نه بدلوي چې شاخص یې د ۳ او ۴ په څو چنده کې نه وي. فعالیت به بیا د ټولو ننوتلو مجموعه واپس کړي.

مثالونه:
د lst = [1,2,3] لپاره نتیجه باید ۶ وي
د lst = [] لپاره نتیجه باید ۰ وي
د lst = [-1,-5,2,-1,-5] لپاره نتیجه باید -۱۲۶ وي
    """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
"
"
def words_in_sentence(sentence):
    """"""
    تاسو ته یو تار درکول کیږي چې یو جمله استازیتوب کوي،
    جمله ځینې ټکي لري چې د ځای په واسطه جلا شوي دي،
    او تاسو باید یو تار بیرته ورکړئ چې له اصلي جملې څخه هغه ټکي لري،
    د کومو اوږدوالی چې ابتدايي شمیرې وي،
    په نوي تار کې د ټکو ترتیب باید د اصلي جملې په شان وي.

    مثال1:
        ورودی: جمله = ""دا یو ازموینه ده""
        وتنه: ""یو""

    مثال2:
        ورودی: جمله = ""راځه لاړ شو د لامبو لپاره""
        وتنه: ""لاړ شو""

    محدودیتونه:
        * 1 <= len <= 100
        * جمله یوازې توري لري
    """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

"
"
def simplify(x, n):
    """"""To translate the provided text into Southern Pashto, here it is:

ستاسو دنده دا ده چې یوه دنده جوړه کړئ چې د x * n څرګندونه ساده کړي. دنده به ریښتیا بیرته کړي که چیرې x * n یوه بشپړه شمېره ته ارزیابي شي او بل وخت به غلط بیرته کړي. دواړه x او n د یوې برخې په بڼه دي، او لاندې بڼه لري، <نومرېټر>/<ډېنامېټر> چیرې چې دواړه نومرېټر او ډېنامېټر مثبتې بشپړې شمېرې دي.

تاسو کولی شئ فرض وکړئ چې x او n معتبرې برخې دي، او د دوی ډېنامېټر په صفر کې نه دی.

simplify = ریښتیا
simplify = غلط
simplify = غلط
    """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

"
"
def order_by_points(nums):
    """"""
    په سدره پښتو کې دې جمله دې ته وژباړه:

یوه فعله ولیکه چې ورکړل شوی د عددي لیست په صعودي ترتیب سره تنظیم کړي د دوی د ارقامو د مجموعې له مخې. یادونه: که څو توکي د دوی د ارقامو د مجموعې له مخې برابر وي، د اصلي لیست په ترتیب یې تنظیم کړه.

د مثال په توګه:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def specialFilter(nums):
    """"""داسې یوه فعاله ولیکئ چې د شمېرو یو صف په داخل کې اخلي او بیرته 
    د صف د عناصرو شمېر ورکوي چې له ۱۰ څخه لوی وي او د شمېر دواړه 
    لومړی او آخري عدد یې طاق وي.
    د مثال په توګه:
    specialFilter => 1 
    specialFilter => 2
    """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

"
"
def get_max_triples(n):
    """"""
    تاسو ته یو مثبت عدد n درکړل شوی دی. تاسو باید د n اوږدوالي سره یو عددي لړ a رامینځته کړئ.
د هر i لپاره، د a[i] ارزښت = i * i - i + 1 دی.
د لړ درې ګوني شمیر راګرځوئ چیرې چې i < j < k، 
او a[i] + a[j] + a[k] د 3 یوه ضریب وي.

بیلګه:
ورودی: n = 5
وتیجه: 1
توضیح:
a = [1, 3, 7, 13, 21]
یوازینی معتبر درې ګونی دی.
    """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
"
"
def bf(planet1, planet2):
    '''
    There are eight planets in our solar system: the closerst to the Sun 
    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    Uranus, Neptune.
    Write a function that takes two planet names as strings planet1 and planet2. 
    The function should return a tuple containing all planets whose orbits are 
    located between the orbit of planet1 and the orbit of planet2, sorted by 
    the proximity to the sun. 
    The function should return an empty tuple if planet1 or planet2
    are not correct planet names. 
    Examples
    bf(""Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"")
    bf(""Earth"", ""Mercury"") ==> (""Venus"")
    bf(""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"")
    '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

"
"
def sorted_list_sum(lst):
    """"""Here's the translation of the provided sentence into Southern Pashto:

```pashto
یو فنکشن ولیکئ چې د تارونو لیست د پارامیټر په توګه مني،
    هغه تارونه حذف کړئ چې اوږدوالی یې طاق وي،
    او پایله شوی لیست په ترتیب سره بیرته ورکړئ،
    لیست تل د تارونو لیست دی او هیڅکله د شمېرو ارایه نه ده،
    او دا ممکن تکرارونه ولري.
    د لیست ترتیب باید د هرې کلمې د اوږدوالي په ترتیب سره وي، او تاسو باید لیست د دې قاعدې له مخې مرتب کړئ.
    که چیرې دوه کلمې ورته اوږدوالی ولري، لیست په الفبایي ترتیب سره مرتب کړئ.
    فنکشن باید په ترتیب سره د تارونو لیست بیرته ورکړي.
    تاسو فرض کولی شئ چې ټولې کلمې به ورته اوږدوالی ولري.
    د بېلګې په توګه:
    assert list_sort => [""aa""]
    assert list_sort => [""ab"", ""cd""]
```
    """"""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

"
"
def x_or_y(n, x, y):
    """"""یو ساده پروګرام چې باید د x ارزښت بیرته راکړي که n یو اولي عدد وي او باید د y ارزښت بیرته راکړي که نه وي.

بیلګې:
د x_or_y لپاره == 34
د x_or_y لپاره == 5
    
    """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

"
"
def double_the_difference(lst):
    '''
    Given a list of numbers, return the sum of squares of the numbers
    in the list that are odd. Ignore numbers that are negative or not integers.
    
    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10
    double_the_difference([-1, -2, 0]) == 0
    double_the_difference([9, -2]) == 81
    double_the_difference([0]) == 0  
   
    If the input list is empty, return 0.
    '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

"
"
def compare(game,guess):
    """"""زه فکر کوم چې موږ ټول هغه احساس په یاد لرو کله چې د یو اوږد انتظار شوي پیښې پایله په پای کې څرګنده شي. هغه احساسات او فکرونه چې تاسو په دغه وخت کې لرئ، حتماً د یادولو او پرتله کولو وړ دي.
ستاسو دنده دا ده چې معلوم کړئ چې یو شخص د یو شمېر لوبو پایلې سمې اټکل کړې دي که نه.
تاسو ته دوه مساوي اوږدوالي لرونکي د نمرو او اټکلونو لړۍ درکول کېږي، چې هر شاخص یوه لوبه ښيي.
یو داسې لړۍ بیرته ورکړئ چې اوږدوالی یې هماغومره وي او ښيي چې هر اټکل څومره غلط و. که یې سم اټکل کړی وي، ارزښت یې 0 دی، او که نه، نو ارزښت یې د اټکل او نمرې تر منځ مطلق توپیر دی.

مثالونه:

compare -> [0,0,0,0,3,3]
compare -> [4,4,1,0,0,6]
    """"""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def Strongest_Extension(class_name, extensions):
    """"""تاسو ته به د یوې ټولګي نوم او د پراخونو یوه لیست درکړل شي.
پراخونه د دې لپاره کارول کیږي چې اضافي ټولګي ته بار کړي. د پراخونې قوت داسې دی: فرض کړئ CAP په پراخونې نوم کې د لویو حروفو شمیر دی، او SM په پراخونې نوم کې د کوچنیو حروفو شمیر دی، قوت د CAP - SM په برخه کې ورکول کیږي.
تاسو باید ترټولو قوي پراخونه ومومئ او په دې بڼه یو تار بیرته ورکړئ: ClassName.StrongestExtensionName.
که دوه یا زیاتو پراخونو سره یو شان قوت وي، تاسو باید هغه یو غوره کړئ چې په لیست کې لومړی راځي.
د بیلګې په توګه، که تاسو ته د ""Slices"" په نوم ټولګي او د پراخونو لیست درکړل شي: ['SErviNGSliCes', 'Cheese', 'StuFfed'] نو تاسو باید 'Slices.SErviNGSliCes' بیرته ورکړئ ځکه چې 'SErviNGSliCes' ترټولو قوي پراخونه دی.
بیلګه:
که Strongest_Extension == 'my_class.AA'
    """"""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
"
"
def cycpattern_check(a , b):
    """"""تاسو ته ۲ کلمې درکول کېږي. تاسو ته پکار ده چې ریښتیا بیرته ورکړئ که دویمه کلمه یا د هغې د دوران څخه کومه یوه د اولې کلمې په منځ کې وي.

    cycpattern_check => دروغ
    cycpattern_check => ریښتیا
    cycpattern_check => دروغ
    cycpattern_check => ریښتیا
    cycpattern_check => دروغ
    cycpattern_check => ریښتیا

    """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

"
"
def even_odd_count(num):
    """"""د یو عدد ورکول شوې دي. هغه ټوپله بیرته ورکړئ چې په ترتیب سره د زوج او فرد عددونو شمېر لري.

     بېلګه:
        even_odd_count ==>
        even_odd_count ==>
    """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def int_to_mini_roman(number):
    """"""
    د یو مثبت عدد په ورکړه، د هغې رومن شمېره معادل په تار کې ترلاسه کړئ،
    او دا په کوچنیو حروفو کې بېرته ورکړئ.
    محدودیتونه: 1 <= عدد <= 1000

    بېلګې:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

"
"
def find_max(words):
    """"""داسې یوه دنده ولیکئ چې د تارونو یوه لست مني.
    په لست کې مختلفې کلمې شاملې دي. هغه کلمه بیرته ورکړئ چې زیات شمېر ځانګړي حروف لري.
    که څو تارونه زیات شمېر ځانګړي حروف ولري، هغه بیرته ورکړئ کوم چې په لغوي ترتیب کې لومړی راځي.

    find_max == ""string""
    find_max == ""enam""
    find_max == ""aaaaaaa""
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"
def eat(number, need, remaining):
    """"""
    تاسو يو وږي خرگوش ياست، او تاسې د يو شمېر گازرو لا مخکې خوړلي دي،
خو اوس تاسې د ورځې د خوړو بشپړولو لپاره نوره گازرې خوړل پکار دي.
تاسې بايد يو ارې [ د خوړلو وروسته د ټولو خوړل شوو گازرو شمېر،
د خوړلو وروسته پاتې شوې گازرې ] 
بيرته ورکړئ.
که پاتې شوې گازرې بسنه نه کوي، نو تاسې به ټولې پاتې شوې گازرې وخورئ، خو بيا به هم وږي ياست.

مثال:
* eat -> [11, 4]
* eat -> [12, 1]
* eat -> [11, 0]
* eat -> [7, 0]

بدلونونه:
@number : عدد
    د خوړل شوو گازرو شمېر.
@need : عدد
    د خوړلو لپاره اړين گازرې.
@remaining : عدد
    په ذخيره کې پاتې شوو گازرو شمېر.

محدوديتونه:
* 0 <= number <= 1000
* 0 <= need <= 1000
* 0 <= remaining <= 1000

خوند واخلئ :)
    """"""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

"
"
def do_algebra(operator, operand):
    """"""
    په داسې حال کې چې دوه لیستونه ورکړل شوي، یو یې د عملیاتو لیست او بل یې د عددونو لیست دی. لومړی لیست د بنسټیزو الجبري عملیاتو لیست دی، او دویم لیست د عددونو لیست دی. د دې دوو ورکړل شویو لیستونو څخه کار واخلئ څو الجبري عبارت جوړ کړئ او د دې عبارت ارزونه بیرته ورکړئ.

    د بنسټیزو الجبري عملیاتو ډولونه:
    جمع 
    تفریق 
    ضرب 
    د فرش تقسیم 
    توان 

    مثال:
    د عملیاتو لیست: ['+', '*', '-']
    د عددونو لیست: [2, 3, 4, 5]
    پایله: ۲ + ۳ * ۴ - ۵
    => پایله: ۹

    یادونه:
        د عملیاتو لیست اوږدوالی د عددونو لیست اوږدوالی څخه یو کم دی.
        عددونه لیست د غیر منفي عددونو څخه جوړ دی.
        د عملیاتو لیست لږ تر لږه یو عملیات لري، او د عددونو لیست لږ تر لږه دوه عددونه لري.

    """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def solve(s):
    """"""تاسو ته یو تار s درکړل شوی دی.
    که s[i] یو حرف وي، نو د هغه حالت به له کوچني څخه لوی ته یا له لوی څخه کوچني ته واړوي.
    که نه وي، نو هغه څنګه چې دی هغسې یې پرېږده.
    که تار هیڅ حرف ونه لري، نو تار بیرته واړوه.
    فنکشن باید د نتیجې تار واپس کړي.
    مثالونه
    solve = ""4321""
    solve = ""AB""
    solve = ""#A@c""
    """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
"
"
def string_to_md5(text):
    """"""
    د 'text' نومي تار ورکړل شوی، د هغې md5 هش برابر تار بيرته ورکړئ.
    که 'text' یو خالي تار وي، نو هیڅ بيرته ورکړئ.

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def generate_integers(a, b):
    """"""
    د دوه مثبتو عددونو a او b په ورکولو سره، د a او b تر منځ موجودې جفتې عددي شمیرې په صعودي ترتیب کې بیرته ورکړه.

د مثال په توګه:
generate_integers => [2, 4, 6, 8]
generate_integers => [2, 4, 6, 8]
generate_integers => []
    """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
