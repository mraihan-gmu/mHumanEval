[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Nyocha ma \u1ecd b\u1ee5r\u1ee5 na n'ime ndep\u1ee5ta nd\u1ecb e nyere nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5, \u1ecd b\u1ee5r\u1ee5 na \u1ecdn\u1ee5\u1ecdg\u1ee5 ab\u1ee5\u1ecd \u1ecd b\u1ee5la d\u1ecb nso kar\u1ecba oke e nyere. \nIhe at\u1ee5:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ntinye na \u1ecdr\u1ee5 a b\u1ee5 mkp\u1ee5r\u1ee5okwu nke nwere \u1ecdt\u1ee5t\u1ee5 \u00ecgw\u00e8 nke mgbak\u1ecd na mwep\u1ee5 nke parentheses. Ebumnuche g\u1ecb b\u1ee5 \u1ecbkewa \u00ecgw\u00e8 nd\u1ecb ah\u1ee5 ka \u1ecd b\u1ee5r\u1ee5 nkebi akw\u1ee5kw\u1ecd d\u1ecb iche iche wee weghachite ndep\u1ee5ta nke nd\u1ecb ah\u1ee5.\n    \u00ccgw\u00e8 nd\u1ecb d\u1ecb iche iche d\u1ecb nhata ma \u1ecd b\u1ee5gh\u1ecb na etinyere ha n\u2019ime ibe ha.\n    T\u1ee5fuo oghere \u1ecd b\u1ee5la d\u1ecb na mkp\u1ee5r\u1ee5okwu ntinye.\n    Ihe at\u1ee5:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" E nyekwara \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 mgba \u1ecdk\u1ee5 d\u1ecb mma, a p\u1ee5r\u1ee5 \u1ecbk\u1ecdwa ya n'ime ak\u1ee5k\u1ee5 integer na ak\u1ee5k\u1ee5 mkp\u1ee5r\u1ee5.\n\nWeghachite ak\u1ee5k\u1ee5 mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ah\u1ee5.\nNke a b\u1ee5 ihe at\u1ee5:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Inyeere g\u1ecb ndep\u1ee5ta nke \u1ecdr\u1ee5 nkw\u1ee5nye na nkw\u1ee5p\u1ee5 na aka\u1ee5nt\u1ee5 \u1ee5l\u1ecd ak\u1ee5 nke na-amalite na\n    \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 efu. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbch\u1ecdp\u1ee5ta ma \u1ecd b\u1ee5r\u1ee5 na n\u2019oge \u1ecd b\u1ee5la, ego d\u1ecb na aka\u1ee5nt\u1ee5 ah\u1ee5 daa n'okpuru efu,\n    na n\u2019oge ah\u1ee5 \u1ecdr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi True. Ma \u1ecd b\u1ee5gh\u1ecb ya, \u1ecd ga-alaghachi \u1ee5gha.\n    Ihe Nketa:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Maka ndep\u1ee5ta enyere nke n\u1ecdmba ntinye, na-agbak\u1ecd Mean Absolute Deviation\n    gburugburu nkezi nke dataset a.\n    Mean Absolute Deviation b\u1ee5 \u1ecdd\u1ecbiche nk\u1ecbt\u1ecb n'etiti ihe \u1ecd b\u1ee5la\n    ihe ma na-etiti:\n    MAD = nk\u1ecbt\u1ecb | x - x_mean |\n    Ihe at\u1ee5:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Tinye n\u1ecdmba 'delimeter' n'etiti ihe ab\u1ee5\u1ecd sochiri ibe ha na ndep\u1ee5ta ntinye 'numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Ntinye na \u1ecdr\u1ee5 a b\u1ee5 eriri e gosiri \u1ecdt\u1ee5t\u1ee5 \u00ecgw\u00e8 maka parentheses j\u1ee5r\u1ee5 \u1ecdn\u1ee5 site na oghere.\n    Maka otu \u00ecgw\u00e8 \u1ecd b\u1ee5la, p\u1ee5ta \u1ecdkwa kas\u1ecb ala nke \u1ecbda nke parentheses.\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5,) nwere \u1ecdkwa ab\u1ee5\u1ecd kachas\u1ecb nke \u1ecbda ebe)) nwere at\u1ecd.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Mee ka ndep\u1ee5ta n'\u1ecbntanet\u1ecb nke eriri okwu ghara ichefu naan\u1ecb nd\u1ecb nwere otu ak\u1ee5k\u1ee5 e nyere.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Maka ndep\u1ee5ta nd\u1ecb \u1ecd b\u1ee5la nke integers, weghachite tuple nke nwere ng\u1ee5k\u1ecdta na ngwaah\u1ecba nke integers niile d\u1ecb na ndep\u1ee5ta ah\u1ee5.\n    Ng\u1ee5k\u1ecdta efu kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 0 na ngwaah\u1ecba efu kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Site ndep\u1ee5ta nke \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 mmad\u1ee5 enyere, mep\u1ee5ta ndep\u1ee5ta nke ihe kachas\u1ecb elu ach\u1ecdtara ruo oge enyere na usoro ah\u1ee5.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Lelee ma e nyeworo ah\u1ecbr\u1ecbokwu ah\u1ee5 b\u1ee5 palindrome. \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Tinye b\u1ee5 eriri ab\u1ee5\u1ecd a na b nke mejup\u1ee5tara naan\u1ecb 1s na 0s.\nMeghar\u1ecba binary XOR na ntinye a ma weghachite nsonaaz\u1ee5 d\u1ecbkwa ka eriri.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" N\u2019ime ndep\u1ee5ta nke nk\u1ecdwa, weghachite nke kachas\u1ecb ogologo. Weghachite nke mb\u1ee5 ma \u1ecd b\u1ee5r\u1ee5 na e nwere \u1ecdt\u1ee5t\u1ee5 nk\u1ecdwa nke otu ogologo. Weghachite \"\u1ecc d\u1ecbgh\u1ecb\" ma \u1ecd b\u1ee5r\u1ee5 na ndep\u1ee5ta ntinye d\u1ecb n\u2019efu.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Weghach\u1ecb ihe nkewa kachas\u1ecb nke ab\u1ee5\u1ecd \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 a na b.\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Weghachite ndep\u1ee5ta nke mkp\u1ee5r\u1ee5okwu niile site na nke kachas\u1ecb mkp\u1ee5mkp\u1ee5 ruo na nke kachas\u1ecb ogologo nke eriri ntinye.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Weghachi otu eriri nwere \u1ecdn\u1ee5\u1ecdg\u1ee5 na-ekewa site na oghere malite na 0 ruo n g\u1ee5nyere ya.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Ebe oji n'ah\u1ecbr\u1ecb, ch\u1ecdp\u1ee5ta ole mkp\u1ee5r\u1ee5 edemede d\u1ecb iche iche \u1ecd nwere.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Ntinye \u1ecbr\u1ee5 \u1ecdr\u1ee5 a b\u1ee5 eriri na-an\u1ecdchite anya ak\u1ecd na \u1ee5da n'\u1ee5d\u1ecb ASCII p\u1ee5r\u1ee5 iche.\n    \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbkp\u1ecdchaa eriri a ma weghachite ndep\u1ee5ta nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 integer nke na-an\u1ecdchite anya otu ugboro ole ka \u1ee5da \u1ecd b\u1ee5la na-ad\u1ecbru.\n\n    Nke a b\u1ee5 nk\u1ecdwa:\n    'o' - ak\u1ecd dum, na-ad\u1ecbru ugboro an\u1ecd\n    'o|' - ak\u1ecd \u1ecdkara, na-ad\u1ecbru ugboro ab\u1ee5\u1ecd\n    '.|' - ak\u1ecd otu \u1ee5z\u1ecd n'\u1ee5d\u1ecb ah\u1ee5, na-ad\u1ecbru ugboro otu\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Ch\u1ecdp\u1ee5ta ugboro ole enweere ike \u1ecbch\u1ecdta otu mkp\u1ee5r\u1ee5okwu n'ime ah\u1ecbr\u1ecbokwu mb\u1ee5. G\u1ee5\u1ecdkwa ebumnuche na-agbak\u1ecd.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Tinye b\u1ee5 ah\u1ecbr\u1ecb ah\u1ecbr\u1ecb nke n\u1ecdmba sitere na 'zero' ruo 'nine'.\n    Nh\u1ecdr\u1ecd ziri ezi b\u1ee5 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', na 'nine'.\n    Weghachite ah\u1ecbr\u1ecb ah\u1ee5 nwere n\u1ecdmba haziri site na nke kacha nta ruo na nke kacha ukwuu.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Site na ndep\u1ee5ta \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 e nyere, h\u1ecdr\u1ecd ma weghachite ab\u1ee5\u1ecd nke d\u1ecb nso na ibe ha ma weghachite ha n\u2019usoro.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Nye ndep\u1ee5ta n\u1ecdmba, tinye mgbanwe ah\u1ecbr\u1ecb na ndep\u1ee5ta ah\u1ee5,\n    ka \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nta b\u1ee5r\u1ee5 0 na nke kachas\u1ecb elu b\u1ee5r\u1ee5 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Z\u1ecdp\u1ee5ta ndep\u1ee5ta enyere nke \u1ecd b\u1ee5la n'ime \u1ee5kp\u1ee5r\u1ee5 python naan\u1ecb maka n\u1ecdmba.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Weghachi ogologo nke eriri enyere.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Maka \u1ecdn\u1ee5\u1ecdg\u1ee5 n enyere, ch\u1ecdta \u1ecdn\u1ee5\u1ecdg\u1ee5 kachas\u1ecb ukwuu nke na-ekewa n nke \u1ecdma, nke d\u1ecb obere kar\u1ecba n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Weghachite ndep\u1ee5ta nke ihe gbawara agbawa nke n\u1ecdmba enyere na usoro site na nke kacha nta ruo na nke kacha ibu.\n    Onye \u1ecd b\u1ee5la n\u2019ime ihe nd\u1ecb ah\u1ee5 kwes\u1ecbr\u1ecb iji n\u1ecdmba ugboro ole \u1ecd p\u1ee5tara na nkewa.\n    N\u1ecdmba ntinye kwes\u1ecbr\u1ecb \u1ecbd\u1ecb na nha n\u2019otu ihe niile gbawara agbawa.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" N'isi ndep\u1ee5ta nke n\u1ecdmba, wep\u1ee5 ihe niile nke na-emeghar\u1ecbr\u1ecb kar\u1ecba otu ugboro.\n   Mee ka usoro ihe nd\u1ecb f\u1ecdd\u1ee5r\u1ee5 ka ah\u1ee5 d\u1ecb ka nke ntinye.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Maka ah\u1ecbr\u1ecb edemede enyere, gbanwee mkp\u1ee5r\u1ee5edemede nta gaa mkp\u1ee5r\u1ee5edemede ukwu ma gbanwee mkp\u1ee5r\u1ee5edemede ukwu gaa mkp\u1ee5r\u1ee5edemede nta.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Jik\u1ecdta ndep\u1ee5ta eriri n'ime otu eriri.\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" H\u1ee5nanya ndep\u1ee5ta ntinye nke eriri naan\u1ecb maka nd\u1ecb na-amalite na mbido enyere.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Weghachi naan\u1ecb \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 d\u1ecb mma n'ime ndep\u1ee5ta ah\u1ee5.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Weghachite eziokwu ma \u1ecd b\u1ee5r\u1ee5 na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 enyere b\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 b\u1ee5 isi, ma \u1ecd b\u1ee5gh\u1ecb ya, weghachite \u1ee5gha.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Enyocha polynomial nwere coefficients xs na isi ebe x.\n    laghachi xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"A na-ar\u1ee5 \u1ecdr\u1ee5 a were ndep\u1ee5ta l wee weghachite ndep\u1ee5ta l' nke d\u1ecb ka\n    l' b\u1ee5 otu ihe ah\u1ee5 na l na mpaghara ebe enwegh\u1ecb nkewa na at\u1ecd, ebe \u1ecd b\u1ee5 na uru ya na mpaghara nke ekewa na at\u1ecd b\u1ee5\n    otu ihe na uru nke mpaghara a na l, ma \u1ecd b\u1ee5 edebere ah\u1ecbr\u1ecb.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Weghachi ihe nd\u1ecb p\u1ee5r\u1ee5 iche na ndep\u1ee5ta sorted.\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Weghach\u1ecb ihe kachas\u1ecb n'ime ndep\u1ee5ta.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Weghachi \u1ecdn\u1ee5\u1ecdg\u1ee5 oge nke \u1ecdn\u1ee5\u1ecdg\u1ee5 iri asaa na-ap\u1ee5ta na n\u1ecdmba nd\u1ecb d\u1ecb n'okpuru n nke a na-ekewa site na iri na otu ma \u1ecd b\u1ee5 iri na at\u1ecd.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"\u1ee4d\u1ecb \u1ecdr\u1ee5 a na-ewe ndep\u1ee5ta l ma na-eweghachi ndep\u1ee5ta l' nke nwere \n    ka l' d\u1ecb ka l na \u1ecdd\u1ee5 odd, ebe \u1ee5kp\u1ee5r\u1ee5 ya na \u1ecdd\u1ee5 even h\u00e0 d\u1ecb ka\n    \u1ee5kp\u1ee5r\u1ee5 nke \u1ecdd\u1ee5 even nke l, ma ha ahazi.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    na-eweghachi eriri koodu site na \u1ecbgbagha \u00ecgw\u00e8 at\u1ecd n'otu oge.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib na-eweghachite \u1ecdn\u1ee5\u1ecdg\u1ee5 n nke b\u1ee5 Fibonacci \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 na \u1ecd b\u1ee5kwa \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 mb\u1ee5.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    `triples_sum_to_zero na-ewere ndep\u1ee5ta nke integers d\u1ecb ka ntinye.\n\u1ecc na-eweghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na e nwere ihe at\u1ecd p\u1ee5r\u1ee5 iche na ndep\u1ee5ta ah\u1ee5 na\n\u1ecb na-agbak\u1ecdta na efu, na \u1eccb\u1ee5gh\u1ecb ma \u1ecd b\u1ee5gh\u1ecb ya.`\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    Chee \u1ee5z\u1ecd nke d\u1ecb n\u2019ah\u1ecbr\u1ecb kw\u1ee5 \u1ecdt\u1ecd na-ad\u1ecbru mgbe niile. \n    n \u1ee5gb\u1ecdala ji aga n\u2019aka ekpe gaa n\u2019aka nri; n'otu oge ah\u1ee5, \u1ecdkara \u1ecdz\u1ecd nke n \u1ee5gb\u1ecdala\n    na-aga n\u2019aka nri gaa n\u2019aka ekpe.  \u1ee4gb\u1ecdala ab\u1ee5\u1ecd ah\u1ee5 malitere na ebe d\u1ecb anya na ibe ha.\n    \u1ee4gb\u1ecdala niile na-agba \u1ecds\u1ecd na otu \u1ecds\u1ecd.  A na-ekwu na \u1ee5gb\u1ecdala ab\u1ee5\u1ecd na-ak\u1ee5 ibe ha\n    ma \u1ecd b\u1ee5r\u1ee5 na \u1ee5gb\u1ecdala na-agba n\u2019aka ekpe gaa n\u2019aka nri na-agbak\u1ee5 \u1ee5gb\u1ecdala na-agba\n    n\u2019aka nri gaa n\u2019aka ekpe. Agbanyegh\u1ecb, \u1ee5gb\u1ecdala nd\u1ecb ah\u1ee5 siri ike nke ukwuu; n'ihi nke a, ha na-aga n'ihu \n    n'\u1ee5z\u1ecd ha d\u1ecbka ha anagh\u1ecb agbakas\u1ecb.\n\n    \u1eccr\u1ee5 a na-emep\u1ee5ta \u1ecdn\u1ee5\u1ecdg\u1ee5 nke nd\u1ecb d\u1ecb ot\u00fa ah\u1ee5 na-agbak\u1ee5 \u1ecdn\u1ee5.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Weghachite ndep\u1ee5ta nwere ihe nd\u1ecb ebelatara otu.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    `pairs_sum_to_zero` na-enweta ndep\u1ee5ta nke n\u1ecdmba niile d\u1ecb ka ntinye.\n\u1ecc na-alaghachi eziokwu ma \u1ecd b\u1ee5r\u1ee5 na e nwere ihe ab\u1ee5\u1ecd d\u1ecb iche iche na ndep\u1ee5ta ah\u1ee5\nna-agbak\u1ecdta na efu, ma na-alaghachi \u1ee5gha ma \u1ecd b\u1ee5gh\u1ecb ya.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Gbanwee isi \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nke n\u1ecdmba ntinye x ka \u1ecd b\u1ee5r\u1ee5 isi.\n    weghachite akara edemede mgbe mgbanwe ah\u1ee5 gas\u1ecbr\u1ecb.\n    \u1ecdn\u1ee5\u1ecdg\u1ee5 isi d\u1ecb n'okpuru 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"E nyewere ogologo otu ak\u1ee5k\u1ee5 na \u1ecbr\u1ecb elu, laghachi ebe maka triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Nkeji n\u1ecdmba Fib4 b\u1ee5 usoro yiri usoro Fibonacci nke a k\u1ecdwara d\u1ecb ka nd\u1ecb a:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    Biko dee \u1ecdr\u1ee5 nke na-ak\u1ecdwagh\u1ecb iji ch\u1ecdp\u1ee5ta ihe nke n na usoro n\u1ecdmba fib4. Ejila recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Weghachi median nke ihe nd\u1ecb d\u1ecb na ndep\u1ee5ta l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Na-enyocha ma eriri enyere b\u1ee5 palindrome.\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Z\u1ecdghachi 2^n modulu p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    na-eweghachi eriri koodu site n'\u1ecbkwaga mkp\u1ee5r\u1ee5edemede \u1ecd b\u1ee5la site na 5 na alfabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels b\u1ee5 \u1ecdr\u1ee5 nke na-ewe ah\u1ecbr\u1ecbokwu ma na-eweghachi ah\u1ecbr\u1ecbokwu na-enwegh\u1ecb \u1ee5daume.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Weghachi eziokwu ma \u1ecd b\u1ee5r\u1ee5 na n\u1ecdmba niile d\u1ecb na ndep\u1ee5ta l d\u1ecb n'okpuru oke t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"T\u1ee5nyere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ab\u1ee5\u1ecd x na y.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Lelee ma okwu ab\u1ee5\u1ecd ah\u1ee5 nwere otu mkp\u1ee5r\u1ee5 edemede.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Weghachi n\u1ecdmba Fibonacci nke n.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Brackets b\u1ee5 usoro nke \"<\" na \">\". \n    Laghachite Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na braket mmeghe \u1ecd b\u1ee5la nwere braket mmechi kwek\u1ecdr\u1ecd.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Weghach\u1ecb True ma \u1ecd b\u1ee5r\u1ee5 na ihe nd\u1ecb d\u1ecb n'ime ndep\u1ee5ta ah\u1ee5 na-abawanye ma \u1ecd b\u1ee5 na-ebelata n'otu n'otu.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Weghachite okwu nd\u1ecb jik\u1ecdr\u1ecd \u1ecdn\u1ee5 si n'ime list ab\u1ee5\u1ecd were hazie ya.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Weghachite ezigbo mgb\u1ecdr\u1ecdgw\u1ee5 kacha ukwuu nke n. Chee na n > 1 ma \u1ecd b\u1ee5gh\u1ecb ezigbo mgb\u1ecdr\u1ecdgw\u1ee5.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n b\u1ee5 \u1ecdr\u1ee5 na-agbak\u1ecdta \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 site na 1 ruo n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Nk\u1ecdwa b\u1ee5 eriri nke \"\".\n    Laghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na bracket mmeghe \u1ecd b\u1ee5la nwere bracket mmechi kwek\u1ecdr\u1ecd.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs na-an\u1ecdchite anya coefficients nke polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Laghachi nkwek\u1ecdr\u1ecbta nke polynomial a n'\u1ee5d\u1ecb ah\u1ee5.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"Usoro \u1ecdn\u1ee5\u1ecdg\u1ee5 FibFib b\u1ee5 usoro yiri usoro Fibonacci nke ak\u1ecdwap\u1ee5tara d\u1ecb ka nd\u1ecb a:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Biko dee \u1ecdr\u1ee5 nke ga-ekenye ncha n'\u1ee5z\u1ecd d\u1ecb ir\u00e8 iji gbak\u1ecd\u1ecd ak\u1ee5k\u1ee5 n nke usoro \u1ecdn\u1ee5\u1ecdg\u1ee5 FibFib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nTinye \u1ecdt\u1ee5t\u1ee5 ule nd\u1ecb \u1ecdz\u1ecd.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Gbanwee mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5 nke n\u1ecdmba x, gbanwee mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5 gaa n'aka nri site na \u1ecbgbanwe\n    ma weghachi nsonaaz\u1ee5 ah\u1ee5 d\u1ecb ka eriri.\n    \u1ecc b\u1ee5r\u1ee5 na mgbanwe ah\u1ee5 kar\u1ecbr\u1ecb \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5, weghachi mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5 ah\u1ee5 ka ha d\u1ecb n'usoro nt\u1ee5ghar\u1ecb.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Jiri okwu a n'as\u1ee5s\u1ee5 Igbo:\n\nBiko dee \u1ecdr\u1ee5 nke na-anabata otu edemede d\u1ecb ka ntinye na na-ewep\u1ee5ta ng\u1ee5k\u1ecdta nke koodu ASCII nke mkp\u1ee5r\u1ee5edemede nd\u1ecb nwere nnukwu ab\u1ee5r\u1ee5 naan\u1ecb.\n\n\u1ee4f\u1ecdd\u1ee5 ihe at\u1ee5:\n- digitSum => 0\n- digitSum => 131\n- digitSum => 67\n- digitSum => 69\n- digitSum => 131\n- digitSum => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    N\u2019ime \u1ecdr\u1ee5 a, a ga-enye g\u1ecb ihe edeturu nke na-an\u1ecdchi anya \u1ecdn\u1ee5\u1ecdg\u1ee5 ap\u1ee5l na oroma nd\u1ecb a na-ekesa n\u2019ime akpa mkp\u1ee5r\u1ee5 osisi. Akpa a nwere ap\u1ee5l, oroma, na mkp\u1ee5r\u1ee5 mangoro. Ebe e nyere edeturu nke na-an\u1ecdchi anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 niile nke oroma na ap\u1ee5l na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 anagh\u1ecb agbanwe agbanwe nke na-an\u1ecdchi anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 niile nke mkp\u1ee5r\u1ee5 osisi n\u2019ime akpa ah\u1ee5, zaghachi \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 mkp\u1ee5r\u1ee5 mangoro d\u1ecb n\u2019ime akpa ah\u1ee5.\nNke a b\u1ee5 ihe at\u1ee5:\nfruit_distribution ->19 - 5 - 6 = 8\nfruit_distribution -> 3 - 0 - 1 = 2\nfruit_distribution -> 100 - 2 - 3 = 95\nfruit_distribution -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    \"E nyere g\u1ecb usoro nke na-an\u1ecdchi anya alaka osisi nwere mkp\u1ee5r\u1ee5 nd\u1ee5 integer na-ad\u1ecbgh\u1ecb mma\n    \u1ecdr\u1ee5 g\u1ecb b\u1ee5 igbutu otu n'ime mkp\u1ee5r\u1ee5 nd\u1ee5 ah\u1ee5 ma weghachite ya.\n    Mkp\u1ee5r\u1ee5 nd\u1ee5 igbutu kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 mkp\u1ee5r\u1ee5 nd\u1ee5 nwere akara ab\u1ee5\u1ecd kacha nta.\n    \u1ecc b\u1ee5r\u1ee5 na ach\u1ecdr\u1ecd \u1ecdt\u1ee5t\u1ee5 mkp\u1ee5r\u1ee5 nd\u1ee5 nwere akara ab\u1ee5\u1ecd kacha nta, weghachite mkp\u1ee5r\u1ee5 nd\u1ee5 nke nwere ndeksi kacha nta.\n\n    Mkp\u1ee5r\u1ee5 nd\u1ee5 igbutu kwes\u1ecbr\u1ecb inweghachite na ndep\u1ee5ta, [ akara_kacha_nta, ndeksi_ya ],\n    \u1ecc b\u1ee5r\u1ee5 na enweghi akara ab\u1ee5\u1ecd ma \u1ecd b\u1ee5 usoro enyere ad\u1ecbgh\u1ecb, weghachite [].\n\n    Nk\u1ecdwa1:\n        Ntinye: [4,2,3]\n        Nwep\u1ee5ta: [2, 1]\n        Nk\u1ecdwa: 2 nwere akara ab\u1ee5\u1ecd kacha nta, na 2 nwere ndeksi kacha nta.\n\n    Nk\u1ecdwa2:\n        Ntinye: [1,2,3]\n        Nwep\u1ee5ta: [2, 1]\n        Nk\u1ecdwa: 2 nwere akara ab\u1ee5\u1ecd kacha nta, na 2 nwere ndeksi kacha nta. \n\n    Nk\u1ecdwa3:\n        Ntinye: []\n        Nwep\u1ee5ta: []\n    \n    Nk\u1ecdwa4:\n        Ntinye: [5, 0, 3, 0, 4, 2]\n        Nwep\u1ee5ta: [0, 1]\n        Nk\u1ecdwa: 0 b\u1ee5 akara kacha nta, mana e nwere akara ab\u1ee5\u1ecd, \n                     ya mere any\u1ecb ga-ah\u1ecdr\u1ecd akara mb\u1ee5, nke nwere ndeksi kacha nta.\n\n    Nh\u1ecdr\u1ecd:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\"\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    E nyere g\u1ecb ndep\u1ee5ta arr nke integers, ch\u1ecdta \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kacha nta nke ihe nd\u1ecb ah\u1ee5 nke\n    a ga-agbanwe iji mee ka ndep\u1ee5ta ah\u1ee5 b\u1ee5r\u1ee5 palindrome. Ndep\u1ee5ta palindrome b\u1ee5 ndep\u1ee5ta nke\n    a na-ag\u1ee5 otu ihe ah\u1ee5 n\u2019az\u1ee5 na n\u2019ihu. N'ime otu mgbanwe, \u1ecb nwere ike \u1ecbgbanwe otu ihe gaa na ihe \u1ecdz\u1ecd \u1ecd b\u1ee5la.\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    smallest_change == 4\n    smallest_change == 1\n    smallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"Dee \u1ecdr\u1ee5 nke na-ewep\u1ee5ta eziokwu ma \u1ecd b\u1ee5r\u1ee5 na n\u1ecdmba enyere b\u1ee5 mkpok\u1ecdta nke n\u1ecdmba mb\u1ee5 at\u1ecd\n    na \u1ee5gha ma \u1ecd b\u1ee5gh\u1ecb ya.\n    \u1ecamara na d\u1ecb ntak\u1ecbr\u1ecb na 100.\n    Nk\u1ecdwa:\n    is_multiply_prime == Eziokwu\n    30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"\u1eccr\u1ee5 g\u1ecb b\u1ee5 ide \u1ecdr\u1ee5 nke na-agbazi eziokwu ma \u1ecd b\u1ee5r\u1ee5 na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 x b\u1ee5 ike d\u1ecb mfe nke n ma \u1ee5gha n'\u1ecdn\u1ecdd\u1ee5 nd\u1ecb \u1ecdz\u1ecd.\nx b\u1ee5 ike d\u1ecb mfe nke n ma \u1ecd b\u1ee5r\u1ee5 na n**int=x\nD\u1ecb ka ihe at\u1ee5:\nis_simple_power => eziokwu\nis_simple_power => eziokwu\nis_simple_power => eziokwu\nis_simple_power => \u1ee5gha\nis_simple_power => \u1ee5gha\nis_simple_power => \u1ee5gha\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"A na-ar\u1ee5 g\u1ecb \u1ecdr\u1ee5 \u1ecbde \u1ecdr\u1ee5 nke na-enweta n\u1ecdmba hexadecimal d\u1ecbka eriri ma na-ag\u1ee5 n\u1ecdmba nke mkp\u1ee5r\u1ee5edemede hexadecimal nd\u1ecb b\u1ee5 nd\u1ecb b\u1ee5 isi. Mkp\u1ee5r\u1ee5edemede hexadecimal b\u1ee5 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. N\u1ecdmba b\u1ee5 isi b\u1ee5 2, 3, 5, 7, 11, 13, 17,... Ya mere \u1ecb ga-ekpebi \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke mkp\u1ee5r\u1ee5edemede nd\u1ecb a: 2, 3, 5, 7, B, D. R\u1ecbba ama: i nwere ike iche na ntinye b\u1ee5 eziokwu mgbe niile ma \u1ecd b\u1ee5 eriri efu, na akara A, B, C, D, E, F b\u1ee5 mgbe niile na nnukwu akw\u1ee5kw\u1ecd. Nd\u1ecb at\u1ee5: Maka num = \"AB\" ihe mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 1. Maka num = \"1077E\" ihe mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 2. Maka num = \"ABED1A33\" ihe mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 4. Maka num = \"123456789ABCDEF0\" ihe mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 6. Maka num = \"2020\" ihe mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 2.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"\u1eca ga-enweta n\u1ecdmba n'\u1ee5d\u1ecb decimal, na \u1ecdr\u1ee5 g\u1ecb b\u1ee5 \u1ecbgbanwe ya ka \u1ecd b\u1ee5r\u1ee5\n    \u1ee5d\u1ecb binary. \u1eccr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi otu eriri, ebe akara \u1ecd b\u1ee5la n\u1ecdchiri anya n\u1ecdmba binary.\n    Akara \u1ecd b\u1ee5la na eriri ah\u1ee5 ga-ab\u1ee5 '0' ma \u1ecd b\u1ee5 '1'.\n\n    Enwere diakritik ab\u1ee5\u1ecd \u1ecdz\u1ecd 'db' na mmalite na na njedebe nke eriri ah\u1ee5.\n    Diakritik nd\u1ecb \u1ecdz\u1ecd n\u1ecd ebe ah\u1ee5 iji nyere aka na nhazi.\n\n    Nd\u1ecb at\u1ee5:\n    decimal_to_binary   # laghachiri \"db1111db\"\n    decimal_to_binary   # laghachiri \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"E nyere g\u1ecb eriri s.\n\u1eccr\u1ee5 g\u1ecb b\u1ee5 ilele ma eriri ah\u1ee5 b\u1ee5 nke obi \u1ee5t\u1ecd ma \u1ecd b\u1ee5 na \u1ecd b\u1ee5gh\u1ecb.\nEriri obi \u1ee5t\u1ecd b\u1ee5 nke nwere ogologo d\u1ecbka opekata mpe 3 na mkp\u1ee5r\u1ee5edemede at\u1ecd na-esote ibe ha b\u1ee5 nd\u1ecb d\u1ecb iche iche.\nD\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\nis_happy => Ugha\nis_happy => Ugha\nis_happy => Eziokwu\nis_happy => Ugha\nis_happy => Eziokwu\nis_happy => Ugha\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u1ecc b\u1ee5 izu ikpeaz\u1ee5 nke semest\u00e0 na onye nkuzi nwere inye akara\n    \u1ee5m\u1ee5 akw\u1ee5kw\u1ecd. Onye nkuzi ah\u1ee5 enwewo usoro nke ya maka inye akara.\n    Nsogbu b\u1ee5 na, \u1ecd tufuru koodu \u1ecd na-eji maka inye akara.\n    \u1ecc nyere g\u1ecb ndep\u1ee5ta nke GPAs maka \u1ee5f\u1ecdd\u1ee5 \u1ee5m\u1ee5 akw\u1ee5kw\u1ecd, \u1ecb ga-edep\u1ee5ta\n    \u1ecdr\u1ee5 ga-enye ndep\u1ee5ta nke akara mkp\u1ee5r\u1ee5 akw\u1ee5kw\u1ecd dabere na teb\u1ee5l nd\u1ecb a:\n             GPA       |    Akara mkp\u1ee5r\u1ee5\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Ihe at\u1ee5:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Here is the translated sentence in Igbo:\n\nDee \u1ecdr\u1ee5 nke na-ewe eriri ma na-eweghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na ogologo eriri b\u1ee5 n\u1ecdmba mb\u1ee5 ma \u1ecd b\u1ee5 Ikpeaz\u1ee5 n'\u1ee5z\u1ecd \u1ecdz\u1ecd.\nIhe at\u1ee5\nprime_length == Eziokwu\nprime_length == Eziokwu\nprime_length == Eziokwu\nprime_length == Ikpeaz\u1ee5\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Nye \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 n d\u1ecb mma, nye \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke n\u1ecdmba d\u1ecb mma nke n-digit na-amalite ma \u1ecd b\u1ee5 na-ad\u1ecb na nso 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"Ebe a b\u1ee5 nt\u1ee5ghar\u1ecb nke okwu ah\u1ee5 n'Igbo:\n\nOnye enyere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ziri ezi N, t\u1ee5ghar\u1ecba \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 mkpok\u1ecdta nke mkp\u1ee5r\u1ee5edemede ya n'ime binary.\n\n\u1ee4f\u1ecdd\u1ee5 ihe at\u1ee5:\n- Maka N = 1000, mkpok\u1ecdta mkp\u1ee5r\u1ee5edemede ga-ab\u1ee5 1, nsonaaz\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \"1\".\n- Maka N = 150, mkpok\u1ecdta mkp\u1ee5r\u1ee5edemede ga-ab\u1ee5 6, nsonaaz\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \"110\".\n- Maka N = 147, mkpok\u1ecdta mkp\u1ee5r\u1ee5edemede ga-ab\u1ee5 12, nsonaaz\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \"1100\".\n\nNd\u1ecb agbakwunyere:\n- @N integer\n  Mkp\u1ecdchi: 0 \u2264 N \u2264 10000.\nNsonaaz\u1ee5:\n  eriri nke n\u1ecdmba binary\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"E nyere g\u1ecb ndep\u1ee5ta nke enwegh\u1ecb ihe \u1ecd b\u1ee5la nke integer lst. Tinye ihe nd\u1ecb d\u1ecb n'etiti na ebe d\u1ecb iche iche.\n\n    Ihe at\u1ee5:\n        tinye ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    De \u1ecdr\u1ee5 nke na-ewe eriri wee weghachite ns\u1ee5ghar\u1ecb ya nke edoziri n'usoro.\n    Ns\u1ee5ghar\u1ecb edoziri nke eriri b\u1ee5 eriri ebe a na-an\u1ecdchite anya okwu niile\n    site n'okwu \u1ecdh\u1ee5r\u1ee5 ebe a na-etinye aha niile n'usoro\n    n'usoro mgbako dabere na uru ascii.\n    Ihe: I kwes\u1ecb \u1ecbchekwa usoro okwu na oghere efu n'usoro ah\u1ecbr\u1ecbokwu ah\u1ee5.\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    anti_shuffle na-eweghachi 'Hi'\n    anti_shuffle na-eweghachi 'ehllo'\n    anti_shuffle na-eweghachi 'Hello !!!Wdlor'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    \u1eca na-enweta data d\u1ecb n'\u1ee5d\u1ecb ab\u1ee5\u1ecd, d\u1ecbka ndep\u1ee5ta e jik\u1ecdtara \u1ecdn\u1ee5, nke yiri matrix, mana, n'ad\u1ecbgh\u1ecb ka matrices, \u1ecd b\u1ee5la ah\u1ecbr\u1ecb nwere ike \u1ecbnwe \u1ecdt\u1ee5t\u1ee5 kol\u1ecdm d\u1ecb iche iche. Enwere lst, na integer x, ch\u1ecdta integers x na ndep\u1ee5ta ah\u1ee5, wee weghachite ndep\u1ee5ta nke tuples, [, ...] ka \u1ecd b\u1ee5r\u1ee5 na tuple \u1ecd b\u1ee5la b\u1ee5 ezigbo \u1ecdn\u1ecdd\u1ee5 -, na-amalite na 0. T\u1ecd\u1ecd \u1ecdn\u1ecdd\u1ee5 ah\u1ee5 site na ah\u1ecbr\u1ecb na \u1ecbr\u1ecb elu nke \u1ecdma. Kwa, t\u1ecd\u1ecd \u1ecdn\u1ecdd\u1ee5 nke ah\u1ecbr\u1ecb site na kol\u1ecdm na \u1ecbda ala nke \u1ecdma.\n\nNke a b\u1ee5 ihe at\u1ee5:\nget_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1) == [,,,,]\nget_row == []\nget_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    Edep\u1ee5tara otu n'ime integers na-enwegh\u1ecb \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 na-ad\u1ecbgh\u1ecb mma, laghachi otu oyiri nke otu a emere ka \u1ecd b\u1ee5r\u1ee5 nke \u1ecdma,\n\u1ecb ga-edozi otu a na usoro mgbagwoju elu ma \u1ecd b\u1ee5r\u1ee5 na ng\u1ee5k\u1ecdta b\u1ee5 odd,\nma \u1ecd b\u1ee5 dozie ya na usoro mgbada ma \u1ecd b\u1ee5r\u1ee5 na ng\u1ee5k\u1ecdta b\u1ee5 even.\n\nNkwup\u1ee5ta:\n* agagh\u1ecb edozi otu edep\u1ee5tara.\n\n\u1ee4f\u1ecdd\u1ee5 at\u1ee5:\n* sort_array => []\n* sort_array => [5]\n* sort_array => [0, 1, 2, 3, 4, 5]\n* sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"Mee \u1ecdr\u1ee5 encrypt nke na-ewe akara edemede d\u1ecbka nt\u1ee5nye na \n    na-eweghachi akara edemede na mkp\u1ee5r\u1ee5edemede na-at\u1ee5ghar\u1ecb. \n    Mkp\u1ee5r\u1ee5edemede kwes\u1ecbr\u1ecb \u1ecbt\u1ee5ghar\u1ecb n'\u1ee5z\u1ecd d\u1ecb ot\u00fa ah\u1ee5 ka mkp\u1ee5r\u1ee5edemede \n    na-agaghar\u1ecb ala site na ab\u1ee5\u1ecd kp\u1ecdmkwem ebe ab\u1ee5\u1ecd.\n    D\u1ecb ka \u1ecdm\u1ee5maat\u1ee5:\n    encrypt na-eweghachi 'lm'\n    encrypt na-eweghachi 'ewhjklnop'\n    encrypt na-eweghachi 'kj'\n    encrypt na-eweghachi 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    A na-enye g\u1ecb ndep\u1ee5ta nke integers.\n    Dee \u1ecdr\u1ee5 next_smallest nke na-eweghachi ihe nke ab\u1ee5\u1ecd kacha nta na ndep\u1ee5ta.\n    Weghachite None ma \u1ecd b\u1ee5r\u1ee5 na ihe d\u1ecb otu a ad\u1ecbgh\u1ecb ad\u1ecb.\n    \n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    \u1eca ga-enweta usoro okwu, \u1ecdr\u1ee5 g\u1ecb b\u1ee5 \u1ecbg\u1ee5 \u1ecdn\u1ee5\u1ecdg\u1ee5\n    nke mgbagha. Mgbagha b\u1ee5 ah\u1ecbr\u1ecbokwu na-amalite na okwu \"M\".\n    Ah\u1ecbr\u1ecbokwu na-ekewa site na '.', '?' ma \u1ecd b\u1ee5 '!'.\n   \n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    Dee \u1ecdr\u1ee5 nke na-ewe ozi, ma na-akp\u1ecdk\u1ecdta ya n'\u1ee5z\u1ecd d\u1ecb ot\u00fa a\nna \u1ecd na-agbanwe \u1ecdn\u1ecdd\u1ee5 mkp\u1ee5r\u1ee5edemede niile, na-edochap\u1ee5\nvowel niile na ozi ah\u1ee5 na mkp\u1ee5r\u1ee5edemede nke na-ap\u1ee5ta\nebe 2 n'ihu vowel ah\u1ee5 na bekee.\nChee na mkp\u1ee5r\u1ee5edemede naan\u1ecb.\n\n\u1ee4f\u1ecdd\u1ee5 at\u1ee5:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"A na-enye g\u1ecb ndep\u1ee5ta nke integers.\n\u1eca ch\u1ecdr\u1ecd \u1ecbch\u1ecdta uru mb\u1ee5 kachas\u1ecb elu ma laghachi na ng\u1ee5k\u1ecdta nke mkp\u1ee5r\u1ee5edemede ya.\n\nIhe at\u1ee5:\nMaka lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ng\u1ee5k\u1ecdta ya ga-ab\u1ee5 10\nMaka lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ng\u1ee5k\u1ecdta ya ga-ab\u1ee5 25\nMaka lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ng\u1ee5k\u1ecdta ya ga-ab\u1ee5 13\nMaka lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ng\u1ee5k\u1ecdta ya ga-ab\u1ee5 11\nMaka lst = [0,81,12,3,1,21] ng\u1ee5k\u1ecdta ya ga-ab\u1ee5 3\nMaka lst = [0,8,1,2,1,7] ng\u1ee5k\u1ecdta ya ga-ab\u1ee5 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Nye ah\u1ecbr\u1ecbokwu a n'as\u1ee5s\u1ee5 Igbo:\n\nNye akw\u1ee5kw\u1ecd okwu, laghachi Eziokwu ma \u1ecd b\u1ee5r\u1ee5 na igodo niile b\u1ee5 eriri na obere mkp\u1ee5r\u1ee5edemede ma \u1ecd b\u1ee5 igodo niile b\u1ee5 eriri na nnukwu mkp\u1ee5r\u1ee5edemede, ma \u1ecd b\u1ee5r\u1ee5 na \u1ecd b\u1ee5gh\u1ecb, laghachi As\u1ecb. \u1eccr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi As\u1ecb ma \u1ecd b\u1ee5r\u1ee5 na akw\u1ee5kw\u1ecd okwu enyere ad\u1ecbgh\u1ecb enwe ihe \u1ecd b\u1ee5la.\nIhe at\u1ee5:\ncheck_dict_case kwes\u1ecbr\u1ecb \u1ecblaghachi Eziokwu.\ncheck_dict_case kwes\u1ecbr\u1ecb \u1ecblaghachi As\u1ecb.\ncheck_dict_case kwes\u1ecbr\u1ecb \u1ecblaghachi As\u1ecb.\ncheck_dict_case kwes\u1ecbr\u1ecb \u1ecblaghachi As\u1ecb.\ncheck_dict_case kwes\u1ecbr\u1ecb \u1ecblaghachi Eziokwu.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"Mee at\u1ee5mat\u1ee5 nke na-ewe n\u1ecdmba nke na-ad\u1ecbgh\u1ecb mma ma na-eweghachi usoro nke mb\u1ee5 n n\u1ecdmba nd\u1ecb b\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 isi na-erugh\u1ecb n.\n d\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n count_up_to => [2,3]\n count_up_to => [2,3,5,7]\n count_up_to => []\n count_up_to => [2,3,5,7,11,13,17,19]\n count_up_to => []\n count_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Were translate ah\u1ecbr\u1ecbokwu a n'as\u1ee5s\u1ee5 Igbo:\n\n```\nMechie \u1ecdr\u1ee5 ah\u1ee5 nke na-ewe nri ab\u1ee5\u1ecd na-ere \u1ecdn\u1ee5 na nloghachi\nngwak\u1ecdta nke akara njedebe ha.\nT\u1ee5le na ntinye d\u1ecb mgbe nile.\nIhe at\u1ee5:\nmultiply ga-enweta 16.\nmultiply ga-enweta 72.\nmultiply ga-enweta 0.\nmultiply ga-enweta 20.\n```\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    Ebe a b\u1ee5 ah\u1ecbr\u1ecbokwu s, gbak\u1ecd\u1ecd \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nd\u1ecb na-ab\u1ee5gh\u1ecb mkp\u1ee5r\u1ee5edemede obere na mkp\u1ee5r\u1ee5edemede oluukwuu n\u1ecd na nd\u1ecdt\u1ecb \u1ecdb\u1ee5la.\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    count_upper na-alaghachi 1\n    count_upper na-alaghachi 0\n    count_upper na-alaghachi 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    Ebe a b\u1ee5 nseta okwu a na as\u1ee5s\u1ee5 Igbo:\n\nNyere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 integer d\u1ecb mma n, i kwes\u1ecb \u1ecbmep\u1ee5ta nnukwu okpukpu nke nwere \u1ecdkwa n nke nkume.\n    \u1ecckwa mb\u1ee5 nwere nkume n.\n    \u1eccn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nkume nke \u1ecdkwa na-esote b\u1ee5:\n        - \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nkume na-esote nke b\u1ee5 odd ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 odd.\n        - \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nkume na-esote nke b\u1ee5 even ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 even.\n    Weghachite \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nkume d\u1ecb na \u1ecdkwa \u1ecd b\u1ee5la n'ime ndep\u1ee5ta, ebe ihe d\u1ecb na index\n    i na-an\u1ecdchi anya \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nkume d\u1ecb na \u1ecdkwa.\n\n    Ihe at\u1ee5:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    A ga-enye g\u1ecb eriri okwu nke e kewap\u1ee5r\u1ee5 site na mkp\u1ee5r\u1ee5ak\u1ee5k\u1ee5 ma \u1ecd b\u1ee5 oghere. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbkewa eriri ah\u1ee5 n\u2019\u1ee5d\u1ecb okwu ma weghachite ndep\u1ee5ta nke okwu nd\u1ecb ah\u1ee5.\n\nD\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\nwords_string == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nwords_string == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"Nke a \u1ecdr\u1ee5 na-ewe n\u1ecdmba ab\u1ee5\u1ecd d\u1ecb mma x na y ma na-eweghachi n\u1ecdmba integer kacha ukwuu n'ime nso [x, y] nke b\u1ee5 \u1ecdb\u1ee5. \u1ecc b\u1ee5r\u1ee5 na enwegh\u1ecb \u1ecd b\u1ee5la n'ime n\u1ecdmba ah\u1ee5, \u1ecdr\u1ee5 ah\u1ee5 ga-eweghachi -1.\n\nN'ime ihe at\u1ee5:\nchoose_num = 14\nchoose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"E nyere g\u1ecb n\u1ecdmba ab\u1ee5\u1ecd d\u1ecb mma n na m, \u1ecdr\u1ee5 g\u1ecb b\u1ee5 \u1ecbgbak\u1ecd\n    nkezi nke n\u1ecdmba site na n ruo m.\n    Meghee az\u1ecbza ah\u1ee5 n'ak\u1ee5k\u1ee5 integer kachas\u1ecb nso ma gbanwee ya gaa na binary.\n    \u1ecc b\u1ee5r\u1ee5 na n kar\u1ecbr\u1ecb m, laghachi -1.\n    Nz\u1ecd\u1ee5kw\u1ee5:\n    rounded_avg => \"0b11\"\n    rounded_avg => -1\n    rounded_avg => \"0b1111\"\n    rounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"Nye ndep\u1ee5ta nke n\u1ecdmba d\u1ecb mma x. Weghachite ndep\u1ee5ta ah\u1ecdp\u1ee5tara nke niile\n    ihe nd\u1ecb na-enwegh\u1ecb n\u1ecdmba \u1ecdb\u1ee5la b\u1ee5 \u1ecdb\u1ee5.\n\n    R\u1ecbba ama: Ndep\u1ee5ta a weghachiri kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 nke ah\u1ecdp\u1ee5tara na usoro na-abawanye.\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Enyere usoro nke integers, hazie integers nd\u1ecb d\u1ecb n'etiti 1 na 9 g\u1ee5nyere,\n    t\u1ee5ghar\u1ecba usoro ah\u1ee5, ma dochie n\u1ecdmba \u1ecd b\u1ee5la na aha ya kwek\u1ecdr\u1ecd na ya site na\n    \"Otu\", \"Ab\u1ee5\u1ecd\", \"At\u1ecd\", \"An\u1ecd\", \"Ise\", \"Isii\", \"Asaa\", \"Asat\u1ecd\", \"Itolu\".\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n      usoro = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> hazie usoro -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> t\u1ee5ghar\u1ecba usoro -> [8, 5, 4, 3, 2, 2, 1, 1]\n      laghachi [\"Asat\u1ecd\", \"Ise\", \"An\u1ecd\", \"At\u1ecd\", \"Ab\u1ee5\u1ecd\", \"Ab\u1ee5\u1ecd\", \"Otu\", \"Otu\"]\n    \n      \u1ecc b\u1ee5r\u1ee5 na usoro ah\u1ee5 b\u1ee5 efu, laghachi usoro efu:\n      usoro = []\n      laghachi []\n    \n      \u1ecc b\u1ee5r\u1ee5 na usoro ah\u1ee5 nwere n\u1ecdmba na-ab\u1ee5gh\u1ecb nke a na-at\u1ee5 anya, eleghara ya anya:\n      usoro = [1, -1 , 55] \n            -> hazie usoro -> [-1, 1, 55]\n            -> t\u1ee5ghar\u1ecba usoro -> [55, 1, -1]\n      laghachi = ['Otu']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Mee \u1ecdr\u1ee5 nke \u1ecdr\u1ee5 f nke na-ewe n d\u1ecb ka ihe nzacha,\n    na-eweghachi ndep\u1ee5ta nke nha n, nke na-echekwa uru nke ihe d\u1ecb na index i b\u1ee5 factorial nke i ma \u1ecd b\u1ee5r\u1ee5 na i b\u1ee5 nke ab\u1ee5\u1ecd\n    ma \u1ecd b\u1ee5 ng\u1ee5k\u1ecdta nke \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 site na 1 ruo i \u1ecdz\u1ecd.\n    i na-amalite site na 1.\n    factorial nke i b\u1ee5 m\u1ee5m\u1ee5 nke n\u1ecdmba site na 1 ruo i.\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    f == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Ebe a b\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 zuru ezu n, laghachi tuple nke nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke integer palindromes d\u1ecb iche iche na nke d\u1ecb iche iche nke na-adaba n'ime oke, g\u1ee5nyere.\n\nNlereanya1:\n\n    Ntinye: 3\n    Ng\u1ee5p\u1ee5ta:\n    Nk\u1ecdwa:\n    Integer palindrome b\u1ee5 1, 2, 3. otu n'ime ha b\u1ee5 nke d\u1ecb iche, na ab\u1ee5\u1ecd b\u1ee5 nke d\u1ecb iche iche.\n\nNlereanya2:\n\n    Ntinye: 12\n    Ng\u1ee5p\u1ee5ta:\n    Nk\u1ecdwa:\n    Integer palindrome b\u1ee5 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. an\u1ecd n'ime ha b\u1ee5 nke d\u1ecb iche, na isii b\u1ee5 nke d\u1ecb iche iche.\n\nNd\u1ee5m\u1ecdd\u1ee5:\n    1. 1 <= n <= 10^3\n    2. tuple a laghachiri nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke integer palindromes d\u1ecb iche iche na nke d\u1ecb iche iche.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Here's the translation of the sentence into Igbo:\n\nDee \u1ecdr\u1ee5 `count_nums` nke na-anabata otu usoro nke n\u1ecdmba zuru oke ma na-eweghachi\n\u1ecdg\u1ee5g\u1ee5 nke ihe nd\u1ecb nwere ng\u1ee5k\u1ecdta nke mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5 > 0.\n\u1ecc b\u1ee5r\u1ee5 na n\u1ecdmba ah\u1ee5 b\u1ee5 nke na-ad\u1ecbgh\u1ecb mma, mgbe ah\u1ee5 mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5 mb\u1ee5 ya ga-ab\u1ee5 nke na-ad\u1ecbgh\u1ecb mma:\nnke a b\u1ee5, -123 nwere mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5 na-ad\u1ecbgh\u1ecb mma -1, 2, na 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"Any\u1ecb nwere oke 'arr' nke N integers arr[1], arr[2], ..., arr[N]. \n    \u1eccn\u1ee5 \u1ecdg\u1ee5g\u1ee5 d\u1ecb na oke ah\u1ee5 ga-ad\u1ecb n'usoro na-enwegh\u1ecb usoro. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbk\u1ecdwa ma\n    \u1ecd\u0300 ga-ekwe omume \u1ecbnweta oke nke d\u1ecb na usoro na-ebelata site n'\u1ecbme\n    ihe nd\u1ecb a na oke enyere:\n        \u1eca nwere ike ime \u1ecdr\u1ee5 mgbanaka aka nri oge \u1ecd b\u1ee5la.\n\n    Otu \u1ecdr\u1ee5 mgbanaka aka nri p\u1ee5tara \u1ecbgbanar\u1ecb ihe niile d\u1ecb na oke site na otu \n    \u1ecdn\u1ecdd\u1ee5 n'aka nri. Ihe ikpeaz\u1ee5 nke oke ga-agaghar\u1ecb na \u1ecdn\u1ecdd\u1ee5 izizi \n    nke oke i.e. 0th index.\n\n    \u1ecc b\u1ee5r\u1ee5 na \u1ecd ga-ekwe omume \u1ecbnweta oke ah\u1ecdp\u1ee5tara site n'\u1ecbme \u1ecdr\u1ee5 d\u1ecb n'elu\n    mgbe ah\u1ee5 laghachi True ma \u1ecd b\u1ee5gh\u1ecb laghachi False.\n    \u1ecc b\u1ee5r\u1ee5 na oke enyere ad\u1ecbgh\u1ecb, laghachi True.\n\n    Nt\u1ee5le: E kwere nkwa na ndep\u1ee5ta enyere nwere ihe p\u1ee5r\u1ee5 iche.\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n\n    move_one_ball==>True\n    Nk\u1ecdwa: Site n'ihe mgbanaka aka nri 2, usoro na-ebelata nwere ike\n                 inweta oke ah\u1ecdp\u1ee5tara.\n    move_one_ball==>False\n    Nk\u1ecdwa: \u1ecc gagh\u1ecb ekwe omume \u1ecbnweta usoro na-ebelata maka oke \n                enyere site n'\u1ecbme ihe mgbanaka aka nri \u1ecdb\u1ee5la.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"N'\u1ecdn\u1ecdd\u1ee5 a, \u1ecb ga-emejuputa \u1ecdr\u1ee5 nke na-ewep\u1ee5ta \u1ecdr\u1ee5 nke na-ewere ndep\u1ee5ta ab\u1ee5\u1ecd nke \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5, ma na-ekpebi ma o kwere omume \u1ecbme mgbanwe nke ihe n'etiti ha iji mee ka lst1 b\u1ee5r\u1ee5 ndep\u1ee5ta nke naan\u1ecb \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 \u1ecdb\u1ee5. Enwegh\u1ecb oke na \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 nke ihe nd\u1ecb a ga-agbanwe n'etiti lst1 na lst2. \u1ecc b\u1ee5r\u1ee5 na \u1ecd ga-ekwe omume \u1ecbgbanwe ihe n'etiti lst1 na lst2 iji mee ka ihe niile nke lst1 b\u1ee5r\u1ee5 \u1ecdb\u1ee5, t\u1ee5ghar\u1ecba \"EE\". Ma \u1ecd b\u1ee5gh\u1ecb ya, t\u1ee5ghar\u1ecba \"MBA\". D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\nexchange => \"EE\"\nexchange => \"MBA\"\nA na-at\u1ee5 anya na ndep\u1ee5ta ntinye ga-ab\u1ee5 na \u1ecd b\u1ee5gh\u1ecb efu.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Nyefee ah\u1ecbr\u1ecbokwu a n'as\u1ee5s\u1ee5 Igbo:\n\nEnwere ah\u1ecbr\u1ecbokwu na-egosi mkp\u1ee5r\u1ee5edemede nta nke ejik\u1ecdtara \u1ecdn\u1ee5 site n\u2019ime oghere, nye kwa akw\u1ee5kw\u1ecd ndek\u1ecd nke mkp\u1ee5r\u1ee5edemede nwere \u1ecdt\u1ee5t\u1ee5 ugboro na-egosi na \u1ecbg\u1ee5 na-ekwes\u1ecb ekwes\u1ecb. \u1ecc b\u1ee5r\u1ee5 na \u1ecdt\u1ee5t\u1ee5 mkp\u1ee5r\u1ee5edemede nwere otu \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ugboro, nye ha niile.\n\nIhe at\u1ee5:\nhistogram == {'a': 1, 'b': 1, 'c': 1}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'b': 4}\nhistogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"Any\u1ecb nyere ah\u1ecbr\u1ecbokwu ab\u1ee5\u1ecd s na c, \u1ecb ga-ehichap\u1ee5 akara niile d\u1ecb na s nke h\u00e0 nhata na akara \u1ecd b\u1ee5la d\u1ecb na c \nmgbe ah\u1ee5 lelee ma ah\u1ecbr\u1ecbokwu nsonaaz\u1ee5 ah\u1ee5 b\u1ee5 palindrome.\nA na-akp\u1ecd ah\u1ecbr\u1ecbokwu palindrome ma \u1ecd b\u1ee5r\u1ee5 na \u1ecd g\u1ee5r\u1ee5 otu ihe n'az\u1ee5 d\u1ecbka n'ihu.\nI kwesiri \u1ecblaghachi na tuple nke nwere ah\u1ecbr\u1ecbokwu nsonaaz\u1ee5 na True\/False maka nch\u1ecdp\u1ee5ta.\nIhe at\u1ee5\nMaka s = \"abcde\", c = \"ae\", nsonaaz\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5\nMaka s = \"abcdef\", c = \"b\" nsonaaz\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5\nMaka s = \"abcdedcba\", c = \"ab\", nsonaaz\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Ebe a na-enye ndep\u1ee5ta nke eriri okwu, ebe eriri okwu \u1ecd b\u1ee5la nwere naan\u1ecb mkp\u1ee5r\u1ee5edemede d\u1ecb na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5, laghachi na ndep\u1ee5ta.\n    Ihe \u1ecd b\u1ee5la i nke mmep\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 \"\u1ecdn\u1ee5\u1ecdg\u1ee5 nke ihe d\u1ecb iche iche n'ime eriri okwu i nke ntinye.\" ebe a ga-agbanwe ihe niile i's na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke mkp\u1ee5r\u1ee5edemede d\u1ecb na \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 d\u1ecb iche iche na eriri okwu nke i nke ntinye.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    E nyekwara g\u1ecb otu usoro nke integers nums, ch\u1ecdta ihe kacha nta n'ime onyinye \u1ecd b\u1ee5la nke anagh\u1ecb ad\u1ecb \u1ecdcha nke nums.\nIhe at\u1ee5\nminSubArraySum == 1\nminSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    A na-enye g\u1ecb otu grid nke nr\u1ee5gide nke nwere \u1ecdd\u1ecbd\u1ecb rech\u1ecbang\u1ee5. \u1ecck\u1ee5k\u1ecd \u1ecd b\u1ee5la na-an\u1ecdchi anya otu nr\u1ee5gide,\n    na 1 \u1ecd b\u1ee5la n'\u00f3k\u00e8 na-an\u1ecdchi anya otu unit nke mmiri.\n    Nr\u1ee5gide \u1ecd b\u1ee5la nwere obere ite nke nwere ike iji nweta mmiri site na ya,\n    na ite niile nwere ike iru otu \u1ee5gw\u1ecd.\n    \u1eccr\u1ee5 g\u1ecb b\u1ee5 iji ite nd\u1ecb ah\u1ee5 kpochap\u1ee5 mmiri site na nr\u1ee5gide nd\u1ecb ah\u1ee5.\n    Sinye \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ugboro \u1ecb ga-ebuli ite nd\u1ecb ah\u1ee5 ala.\n\n    Ihe at\u1ee5 1:\n        Ntinye: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            ikike_b\u1ecdket : 1\n        \u1eccp\u1ee5p\u1ee5: 6\n\n    Ihe at\u1ee5 2:\n        Ntinye: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            ikike_b\u1ecdket : 2\n        \u1eccp\u1ee5p\u1ee5: 5\n    \n    Ihe at\u1ee5 3:\n        Ntinye: \n            grid : [[0,0,0], [0,0,0]]\n            ikike_b\u1ecdket : 5\n        \u1eccp\u1ee5p\u1ee5: 0\n\n    Mkpebi:\n        * Nr\u1ee5gide niile nwere otu ogologo\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= ikike <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    N'\u1ecdr\u1ee5 a, \u1ecb ga-edozi usoro nke integer nd\u1ecb na-ad\u1ecbgh\u1ecb mma d\u1ecbka \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 otu na ns\u1ee5ghar\u1ecb ha binary na usoro na-abawanye. Maka otu \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 otu, dozie ha dabeere na uru nke decimal.\n\n\u1ecc ga-enwer\u1ecbr\u1ecb ka eme ya otu a:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"E nyere eriri s na n\u1ecdmba n, e nyere g\u1ecb \u1ecdr\u1ee5 \u1ecbmep\u1ee5ta \u1ecdr\u1ee5 nke na-eweghachi ndep\u1ee5ta nke okwu niile site na eriri s nke nwere kp\u1ecdmkwem n mkp\u1ee5r\u1ee5edemede, n'usoro okwu nd\u1ecb ah\u1ee5 p\u1ee5tara na eriri s.\n\u1ecc b\u1ee5r\u1ee5 na eriri s ad\u1ecbgh\u1ecb, \u1ecdr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbweghachi ndep\u1ee5ta efu.\nR\u1ecbba ama: \u1ecb nwere ike iche na eriri ntinye nwere naan\u1ecb mkp\u1ee5r\u1ee5edemede na oghere.\nIhe at\u1ee5:\nselect_words ==> [\"little\"]\nselect_words ==> [\"Mary\", \"lamb\"]\nselect_words ==> []\nselect_words ==> [\"world\"]\nselect_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"A s\u1ee5ghar\u1ecba ah\u1ecbr\u1ecbokwu a n'as\u1ee5s\u1ee5 Igbo.\n\nEnyere g\u1ecb okwu. \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbch\u1ecdta \u1ee5daume kacha nso nke d\u1ecb n'etiti mkp\u1ee5r\u1ee5okwu ab\u1ee5\u1ecd na-enwegh\u1ecb \u1ee5da site n'ak\u1ee5k\u1ee5 aka nri nke okwu ah\u1ee5.\n\n\u1ee4daume nd\u1ecb d\u1ecb na mbido na njedebe ad\u1ecbgh\u1ecb ag\u1ee5nye. Laghachi mkp\u1ee5r\u1ee5okwu efu ma \u1ecd b\u1ee5r\u1ee5 na \u1ecb ch\u1ecdtagh\u1ecb \u1ee5daume \u1ecd b\u1ee5la d\u1ecb n'okpuru \u1ecdn\u1ecdd\u1ee5 a.\n\n\u1eca nwere ike \u1ecbt\u1ee5 anya na okwu enyere nwere mkp\u1ee5r\u1ee5 edemede Bekee naan\u1ecb.\n\n\u1ee4f\u1ecdd\u1ee5 ihe at\u1ee5:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    Ebe anyi n\u2019enwe array arr nke integers na otu integer k d\u1ecb mma, weghachite ndep\u1ee5ta \nah\u1ee5 nke ogologo k nwere \u1ecdn\u1ee5\u1ecdg\u1ee5 kacha elu n\u2019ime arr.\n\n    Nkenke1:\n\n        Ntinye: arr = [-3, -4, 5], k = 3\n        \u1eccp\u1ee5p\u1ee5: [-4, -3, 5]\n\n    Nkenke2:\n\n        Ntinye: arr = [4, -4, 4], k = 2\n        \u1eccp\u1ee5p\u1ee5: [4, 4]\n\n    Nkenke3:\n\n        Ntinye: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        \u1eccp\u1ee5p\u1ee5: [2]\n\n    Nd\u1ee5m\u1ecdd\u1ee5:\n        1. Ogologo array ah\u1ee5 ga-ad\u1ecb na nso nke [1, 1000].\n        2. Ihe nd\u1ecb d\u1ecb na array ah\u1ee5 ga-ad\u1ecb n\u2019ime nso nke [-1000, 1000].\n        3. 0 <= k <= ogologo\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Ebe a b\u1ee5 list nke integers nke anagh\u1ecb ada ada, weghachite ng\u1ee5k\u1ecdta nke ihe niile d\u1ecb iche iche nke d\u1ecb na \u1ecdn\u1ecdd\u1ee5 \u1ecdb\u1ee5.\n\n    Nk\u1ecdwa\n    ngw\u1ecdta ==> 12\n    ngw\u1ecdta ==> 9\n    ngw\u1ecdta ==>0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Ebe \u1ecd b\u1ee5 na any\u1ecb nwere mbip\u1ee5ta nke integers arr na integer k, t\u1ee5ghar\u1ecba\n    ng\u1ee5k\u1ecdta nke ihe nd\u1ecb nwere naan\u1ecb n\u1ecdmba ab\u1ee5\u1ecd site na ihe nd\u1ecb mb\u1ee5 k nke arr.\n\n    Ihe at\u1ee5:\n\n        Ntinye: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Mputa: 24 # ng\u1ee5k\u1ecdta nke 21 + 3\n\n    Ihe mgbochi:\n        1. 1 <= ogologo <= 100\n        2. 1 <= k <= ogologo\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Ebe a b\u1ee5 nt\u1ee5ghar\u1ecb nke ah\u1ecbr\u1ecbokwu ah\u1ee5 n'as\u1ee5s\u1ee5 Igbo:\n\nEnwere n\u1ecdmba n d\u1ecb mma, weghachite ndep\u1ee5ta ahaziri nke nwere n\u1ecdmba ad\u1ecbgh\u1ecb agha na usoro collatz.\n\n    Akw\u1ee5kw\u1ecd ekwenti Collatz b\u1ee5 echiche n'usoro \u1ecdg\u1ee5g\u1ee5 nke na-emet\u1ee5ta usoro a kp\u1ecdmkwem\n    d\u1ecb ka nd\u1ecb a: bido na n\u1ecdmba \u1ecdb\u1ee5la d\u1ecb mma n. Mgbe ah\u1ee5, e nweta ak\u1ee5k\u1ee5 \u1ecd b\u1ee5la site na\n    ak\u1ee5k\u1ee5 gara aga d\u1ecb ka nd\u1ecb a: \u1ecd b\u1ee5r\u1ee5 na ak\u1ee5k\u1ee5 gara aga b\u1ee5 \u1ecdb\u1ee5, ak\u1ee5k\u1ee5 na-esote b\u1ee5 \u1ecdkara\n    nke ak\u1ee5k\u1ee5 gara aga. \u1ecc b\u1ee5r\u1ee5 na ak\u1ee5k\u1ee5 gara aga b\u1ee5 ad\u1ecbgh\u1ecb agha, ak\u1ee5k\u1ee5 na-esote b\u1ee5 3 ugboro\n    nke ak\u1ee5k\u1ee5 gara aga gbakwunyere 1. Ekwenti ah\u1ee5 b\u1ee5 na n'agbanyegh\u1ecb uru nke n, usoro ah\u1ee5 ga-eru 1 mgbe nile.\n\n    \u1eccr\u1ecbre:\n        1. Collatz b\u1ee5 [1].\n        2. ndep\u1ee5ta weghachiri ahaziri na usoro agba agba.\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    get_odd_collatz weghachite [1, 5] # Usoro collatz maka 5 b\u1ee5 [5, 16, 8, 4, 2, 1], ya mere n\u1ecdmba ad\u1ecbgh\u1ecb agha b\u1ee5 naan\u1ecb 1 na 5.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"\u1eca ga-ede \u1ecdr\u1ee5 nke na-enyocha otu edemede \u1ee5b\u1ecdch\u1ecb nyere ma\n    na-eweghachite eziokwu ma \u1ecd b\u1ee5r\u1ee5 na \u1ee5b\u1ecdch\u1ecb ziri ezi ma \u1ecd b\u1ee5r\u1ee5 na \u1ecd b\u1ee5gh\u1ecb, \u1ecd ga-eweghachite \u1ee5gha.\n    \u1eccnwa ziri ezi ma \u1ecd b\u1ee5r\u1ee5 na e mezuo iwu nd\u1ecb a niile:\n    1. Edemede \u1ee5b\u1ecdch\u1ecb ah\u1ee5 anagh\u1ecb efu.\n    2. \u1eccn\u1ee5\u1ecdg\u1ee5 \u1ee5b\u1ecdch\u1ecb ad\u1ecbgh\u1ecb erugh\u1ecb 1 ma \u1ecd b\u1ee5 kar\u1ecba 31 \u1ee5b\u1ecdch\u1ecb maka \u1ecdnwa 1, 3, 5, 7, 8, 10, 12. \u1eccn\u1ee5\u1ecdg\u1ee5 \u1ee5b\u1ecdch\u1ecb ad\u1ecbgh\u1ecb erugh\u1ecb 1 ma \u1ecd b\u1ee5 kar\u1ecba 30 \u1ee5b\u1ecdch\u1ecb maka \u1ecdnwa 4, 6, 9, 11. \u1eccn\u1ee5\u1ecdg\u1ee5 \u1ee5b\u1ecdch\u1ecb ad\u1ecbgh\u1ecb erugh\u1ecb 1 ma \u1ecd b\u1ee5 kar\u1ecba 29 maka \u1ecdnwa 2.\n    3. \u1eccnwa ad\u1ecbgh\u1ecb erugh\u1ecb 1 ma \u1ecd b\u1ee5 kar\u1ecba 12.\n    4. \u1ee4b\u1ecdch\u1ecb ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 n'\u1ee5d\u1ecb: mm-dd-yyyy\n\n    d\u1ecbka \u1ecdm\u1ee5maat\u1ee5: \n    valid_date => Eziokwu\n\n    valid_date => \u1ee4gha\n\n    valid_date => \u1ee4gha\n\n    valid_date => Eziokwu\n\n    valid_date => \u1ee4gha\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"E nyere g\u1ecb oge ab\u1ee5\u1ecd,\n    ebe oge \u1ecd b\u1ee5la b\u1ee5 di na nwunye nke n\u1ecdmba integer. D\u1ecbka \u1ecdm\u1ee5maat\u1ee5, oge = =.\n    Oge e nyere b\u1ee5 nke mechiri emechi nke p\u1ee5tara na oge\n    na-ag\u1ee5nye ma mbido na njedebe.\n    Maka oge \u1ecd b\u1ee5la e nyere, a na-at\u1ee5 anya na mbido ya d\u1ecb obere ma \u1ecd b\u1ee5 h\u00e0 nkwek\u1ecd na njedebe ya.\n    \u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbch\u1ecdp\u1ee5ta ma ogologo nke njik\u1ecd nke oge ab\u1ee5\u1ecd a\n    b\u1ee5 n\u1ecdmba b\u1ee5 isi.\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5, njik\u1ecd nke oge, b\u1ee5\n    nke ogologo ya b\u1ee5 1, nke b\u1ee5gh\u1ecb n\u1ecdmba b\u1ee5 isi.\n    \u1ecc b\u1ee5r\u1ee5 na ogologo njik\u1ecd b\u1ee5 n\u1ecdmba b\u1ee5 isi, wep\u1ee5ta \"EE\",\n    ma \u1ecd b\u1ee5gh\u1ecb ya, wep\u1ee5ta \"MBA\".\n    \u1ecc b\u1ee5r\u1ee5 na oge ab\u1ee5\u1ecd ah\u1ee5 anagh\u1ecb ejik\u1ecdta, wep\u1ee5ta \"MBA\".\n\n\n    [samples input\/output]:\n    njik\u1ecd,) ==> \"MBA\"\n    njik\u1ecd,) ==> \"MBA\"\n    njik\u1ecd,) ==> \"EE\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    A t\u1ee5nyere g\u1ecb \u1ecdt\u1ee5t\u1ee5 arr nke n\u1ecdmba dum na \u1ecbch\u1ecdr\u1ecd \u1ecblaghachi\n    ng\u1ee5k\u1ecdta nke ike nke n\u1ecdmba dum nke emet\u1ee5ta site na ngwaah\u1ecba nke ihe niile\n    nke otu n\u1ecdmba d\u1ecb n'ime \u1ecdt\u1ee5t\u1ee5 ah\u1ee5, nke a na-an\u1ecdchite anya ya site na 1, -1 ma \u1ecd b\u1ee5 0.\n    Nkwup\u1ee5ta: laghachi Otu maka \u1ecdt\u1ee5t\u1ee5 arr efu.\n\n    Ihe at\u1ee5:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    A t\u1ee5ghar\u1ecbr\u1ecb ah\u1ecbr\u1ecbokwu d\u1ecb na bekee gaa na as\u1ee5s\u1ee5 Igbo.\n\nNye grid nwere ah\u1ecbr\u1ecb N na usoro N na n\u1ecdmba d\u1ecb mma k, \n    otu \u1ecd b\u1ee5la na grid nwere uru. Onye \u1ecd b\u1ee5la n\u1ecd na nso [1, N * N] \n    g\u1ee5nyere na-egosi otu oge n'\u1ee5l\u1ecd \u1ee5l\u1ecd nke grid.\n\n    \u1eca ga-ach\u1ecdta \u1ee5z\u1ecd kacha nta nke ogologo k na grid. \u1eca nwere ike \u1ecbmalite \n    site na otu \u1ecd b\u1ee5la, na nz\u1ecd\u1ee5kw\u1ee5 \u1ecd b\u1ee5la \u1ecb nwere ike \u1ecbkwaga na \u1ecd b\u1ee5la \n    n'ime nd\u1ecb agbata obi, n'ikwu ya n'\u1ee5z\u1ecd \u1ecdz\u1ecd, \u1ecb nwere ike \u1ecbga \u1ee5l\u1ecd nd\u1ecb \n    na-ekek\u1ecdr\u1ecbta ak\u1ee5k\u1ee5 g\u1ecb na \u1ee5l\u1ecd ugbu a.\n    Biko mara na \u1ee5z\u1ecd nke ogologo k p\u1ee5tara izute kp\u1ecdmkwem \u1ee5l\u1ecd k (\u1ecd b\u1ee5gh\u1ecb \n    mkpa ka ha b\u1ee5r\u1ee5 ihe p\u1ee5r\u1ee5 iche).\n    \u1eca P\u1ee4GH\u1eca \u1ecbp\u1ee5 na grid.\n    A na-ewere \u1ee5z\u1ecd A ka obere kar\u1ecba \u1ee5z\u1ecd B ma \u1ecd b\u1ee5r\u1ee5 \n    na emechara ndep\u1ee5ta nke uru d\u1ecb na \u1ee5l\u1ecd nd\u1ecb A na B na-aga (ka any\u1ecb kp\u1ecd\u1ecd ha \n    lst_A na lst_B), lst_A na-erugh\u1ecb lst_B n'usoro lexicographically, n'ikwu ya \n    n'\u1ee5z\u1ecd \u1ecdz\u1ecd, enwere n\u1ecdmba index i ka nd\u1ecb lst_A[i] < lst_B[i] \n    na maka \u1ecd b\u1ee5la j any\u1ecb nwere lst_A[j] = lst_B[j].\n    \u1ecc na-ekwe nkwa na az\u1ecbza ah\u1ee5 b\u1ee5 nke p\u1ee5r\u1ee5 iche.\n    Zaghachi ndep\u1ee5ta nke uru nd\u1ecb d\u1ecb na \u1ee5l\u1ecd nd\u1ecb \u1ee5z\u1ecd kacha nta na-aga.\n\n    Ihe at\u1ee5:\n\n        Ntinye: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Mkp\u1ee5r\u1ee5: [1, 2, 1]\n\n        Ntinye: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Mkp\u1ee5r\u1ee5: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Onye obula maara usoro Fibonacci, a na-eme nnyocha omimi banyere ya site n'aka ndi omuma mgbakota onu n'ime nar\u1ecb af\u1ecd ole na ole gara aga. Ot\u00fa \u1ecd d\u1ecb, ihe nd\u1ecb mmad\u1ee5 anagh\u1ecb ama b\u1ee5 usoro Tribonacci. Usoro Tribonacci a na-ak\u1ecdwa ya site na nkwughachi:\ntri = 3\ntri = 1 + n \/ 2, ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 \u1ecdb\u1ee5.\ntri = tri + tri + tri, ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 \u1ecdn\u1ee5\u1ecdg\u1ee5 ad\u1ecbgh\u1ecb \u1ecdb\u1ee5.\nDi ka ihe at\u1ee5:\ntri = 1 + = 2\ntri = 3\ntri = tri + tri + tri\n         = 2 + 3 + 3 = 8 \nA na-enye g\u1ecb \u1ecdn\u1ee5\u1ecdg\u1ee5 nnabata na-ad\u1ecbgh\u1ecb nj\u1ecd, \u1ecb ga-alaghachi na ndep\u1ee5ta nke \u1ecdn\u1ee5\u1ecdg\u1ee5 mb\u1ee5 n + 1 nke usoro Tribonacci.\nIhe at\u1ee5:\ntri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Ebe e nyere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 d\u1ecb mma n, weghachite ngwaah\u1ecba nke mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5\u1ecdg\u1ee5 odd.\n    Weghachite 0 ma \u1ecd b\u1ee5r\u1ee5 na mkp\u1ee5r\u1ee5 \u1ecdn\u1ee5\u1ecdg\u1ee5 niile d\u1ecb \u1ecdb\u1ee5.\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    digits  == 1\n    digits  == 0\n    digits == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"A na-enye g\u1ecb ndep\u1ee5ta nke \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5.\n\u1eca ch\u1ecdr\u1ecd \u1ecblaghachi \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke n\u1ecdmba nd\u1ecb a square na ndep\u1ee5ta enyere,\ngbanye ihe at\u1ee5 \u1ecd b\u1ee5la na ndep\u1ee5ta ah\u1ee5 na n\u1ecdmba dum kachas\u1ecb elu mb\u1ee5.\nIhe at\u1ee5:\nMaka lst = [1,2,3] nt\u1ee5p\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 14\nMaka lst = [1,4,9] nt\u1ee5p\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 98\nMaka lst = [1,3,5,7] nt\u1ee5p\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 84\nMaka lst = [1.4,4.2,0] nt\u1ee5p\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 29\nMaka lst = [-2.4,1,1] nt\u1ee5p\u1ee5ta kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Here is the translation of the provided sentence into Igbo:\n\nMep\u1ee5ta \u1ecdr\u1ee5 nke na-eweghachi nnukwu ngosi nke ihe nke\nna-ab\u1ee5gh\u1ecb nnukwu ma \u1ecd b\u1ee5 h\u00e0 nha ihe na-esote ya ozugbo. \u1ecc b\u1ee5r\u1ee5\nna ihe d\u1ecb ot\u00fa ah\u1ee5 ad\u1ecbgh\u1ecb, weghachite -1. Ngwugwu enyere agagh\u1ecb enwe\n\u1ee5d\u1ecb akara ab\u1ee5\u1ecd.\n\nNke a b\u1ee5 ihe at\u1ee5:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    Mee \u1ecdr\u1ee5 nke na-ewe integers, floats, ma \u1ecd b\u1ee5 ah\u1ecbr\u1ecbokwu na-an\u1ecdchi anya n\u1ecdmba eziokwu, na na-agh\u1ecdta nnukwu mgbanwe na \u1ee5d\u1ecb mgbanwe enyere ya. Weghachite None ma \u1ecd b\u1ee5r\u1ee5 na \u1ee5kp\u1ee5r\u1ee5 ah\u1ee5 b\u1ee5 otu. \nCheta: \u1ecc b\u1ee5r\u1ee5 na a na-an\u1ecdchi anya n\u1ecdmba eziokwu d\u1ecb ka ah\u1ecbr\u1ecbokwu, otu nt\u1ee5p\u1ecd nt\u1ee5p\u1ecd nwere ike \u1ecbb\u1ee5 \".\" ma \u1ecd b\u1ee5 \",\".\n\ncompare_one -> 2.5\ncompare_one -> \"2,3\"\ncompare_one -> \"6\"\ncompare_one -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"Lelee ma e nwere ike ide n\u1ecdmba n a d\u1ecbka ng\u1ee5k\u1ecdta nke ezi n\u1ecdmba ab\u1ee5\u1ecd an\u1ecd kp\u1ecdmkwem.\n    Nlereanya\n    is_equal_to_sum_even == \u1ecc b\u1ee5 \u1ee5gha\n    is_equal_to_sum_even == \u1ecc b\u1ee5 \u1ee5gha\n    is_equal_to_sum_even == Eziokwu\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"A na-ak\u1ecdwa factorial Brazil d\u1ecbka:\n    brazilian_factorial = n! *! *! * ... * 1!\n    ebe n > 0\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Ebe a b\u1ee5 okwu ah\u1ee5 n'as\u1ee5s\u1ee5 Igbo:\n\nNye otu eriri ederede, dochie oghere niile d\u1ecb na ya na underscores, \nma \u1ecd b\u1ee5r\u1ee5 na eriri nwere kar\u1ecba oghere 2 na-esote ibe ha, \nwee dochie oghere niile na-esote ibe ha na - \n\nfix_spaces == \"Example\"\nfix_spaces == \"Example_1\"\nfix_spaces == \"_Example_2\"\nfix_spaces == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"Mee \u1ecdr\u1ee5 nke na-ewere eriri na-an\u1ecdchite anya aha fa\u1ecbl\u1ee5, na-alaghachi\n    'Ee' ma \u1ecd b\u1ee5r\u1ee5 na aha fa\u1ecbl\u1ee5 ah\u1ee5 b\u1ee5 ihe ziri ezi, na-alaghachi 'Mba' n'\u1ee5z\u1ecd \u1ecdz\u1ecd.\n    A na-ewere aha fa\u1ecbl\u1ee5 d\u1ecbka ihe ziri ezi ma \u1ecd b\u1ee5r\u1ee5 na naan\u1ecb ma \u1ecd b\u1ee5r\u1ee5 na ihe nd\u1ecb a niile na-emezu:\n    - Enwegh\u1ecb \u1ee5z\u1ecd kar\u1ecba mkp\u1ee5r\u1ee5 at\u1ecd na aha fa\u1ecbl\u1ee5 ah\u1ee5.\n    - Aha fa\u1ecbl\u1ee5 ah\u1ee5 nwere otu naan\u1ecb ihe mkp\u1ee5r\u1ee5 '.'\n    - Nkebi okwu tupu ihe mkp\u1ee5r\u1ee5 ah\u1ee5 ekwes\u1ecbgh\u1ecb \u1ecbb\u1ee5 efu, ma o na-amalite na akw\u1ee5kw\u1ecd ozi na\n    alfabeta Latin.\n    - Nkebi okwu mgbe ihe mkp\u1ee5r\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbb\u1ee5 otu n'ime nd\u1ecb a: ['txt', 'exe', 'dll']\n    Ihe at\u1ee5:\n    file_name_check # => 'Ee'\n    file_name_check # => 'Mba'\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\u1eccr\u1ee5 a ga-ewe ndep\u1ee5ta nke integers. Maka ihe niile d\u1ecb na ndep\u1ee5ta ah\u1ee5, \u1ecdr\u1ee5 ah\u1ee5 ga-eme ka integer ah\u1ee5 b\u1ee5r\u1ee5 square ma \u1ecd b\u1ee5r\u1ee5 na nt\u1ee5aka ya b\u1ee5 ugboro at\u1ecd ma ga-eme integer ah\u1ee5 b\u1ee5r\u1ee5 cube ma \u1ecd b\u1ee5r\u1ee5 na nt\u1ee5aka ya b\u1ee5 ugboro an\u1ecd ma \u1ecd b\u1ee5gh\u1ecb ugboro at\u1ecd. \u1eccr\u1ee5 ah\u1ee5 agagh\u1ecb agbanwe ihe nd\u1ecb d\u1ecb na ndep\u1ee5ta nke nt\u1ee5aka ha ab\u1ee5gh\u1ecb ugboro at\u1ecd ma \u1ecd b\u1ee5 an\u1ecd. \u1eccr\u1ee5 ah\u1ee5 ga-alaghachi na ng\u1ee5k\u1ecdta nke ihe niile d\u1ecb na ndep\u1ee5ta ah\u1ee5.\n\n\u1ee4f\u1ecdd\u1ee5 ihe at\u1ee5:\nMaka lst = [1,2,3] ng\u1ee5k\u1ecdta ga-ab\u1ee5 6\nMaka lst = [] ng\u1ee5k\u1ecdta ga-ab\u1ee5 0\nMaka lst = [-1,-5,2,-1,-5] ng\u1ee5k\u1ecdta ga-ab\u1ee5 -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    A na-enye g\u1ecb eriri nke na-an\u1ecdchite anya ah\u1ecbr\u1ecbokwu,\n    ah\u1ecbr\u1ecbokwu ah\u1ee5 nwere \u1ee5f\u1ecdd\u1ee5 okwu nd\u1ecb kewara site na oghere,\n    \u1ecb ga-enyekwa eriri nke nwere okwu nd\u1ecb sitere n'ah\u1ecbr\u1ecbokwu mb\u1ee5,\n    nd\u1ecb ogologo ha b\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 b\u1ee5 isi,\n    usoro okwu d\u1ecb na eriri \u1ecdh\u1ee5r\u1ee5 kwes\u1ecbr\u1ecb \u1ecbd\u1ecb ka nke mb\u1ee5.\n\n    Ihe at\u1ee5 1:\n        Ntinye: ah\u1ecbr\u1ecbokwu = \"This is a test\"\n        \u1eccp\u1ee5p\u1ee5: \"is\"\n\n    Ihe at\u1ee5 2:\n        Ntinye: ah\u1ecbr\u1ecbokwu = \"lets go for swimming\"\n        \u1eccp\u1ee5p\u1ee5: \"go for\"\n\n    Mgbochi:\n        * 1 <= ogologo <= 100\n        * ah\u1ecbr\u1ecbokwu nwere naan\u1ecb akw\u1ee5kw\u1ecd nd\u1ecb e dere na ya\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"To solve this problem, we'll need to implement a function that takes two fractions as input and determines if their product is a whole number. Here's the step-by-step approach to achieve this:\n\n1. Parse the fractions from their string representation.\n2. Convert these fractions into their numerical form.\n3. Multiply the fractions together.\n4. Check if the result is a whole number.\n\nLet's break down each step in detail:\n\n1. **Parsing the fractions**: Each fraction is given in the form \"numerator\/denominator\". We can split this string to get the numerator and denominator.\n\n2. **Convert to numerical form**: Once we have the numerator and denominator as strings, we convert them to integers.\n\n3. **Multiply the fractions**: To multiply two fractions, multiply the numerators together and the denominators together.\n\n4. **Check for whole number**: A fraction is a whole number if the numerator is divisible by the denominator without a remainder.\n\nNow, let's implement this in Python:\n\n```python\ndef simplify:\n    # Parse the fractions\n    x_num, x_den = map)\n    n_num, n_den = map)\n    \n    # Multiply the fractions\n    result_num = x_num * n_num\n    result_den = x_den * n_den\n    \n    # Check if the result is a whole number\n    return result_num % result_den == 0\n\n# Test cases\nprint)  # True\nprint)  # False\nprint) # False\n```\n\n### Explanation:\n\n- **Parsing**: We use `split` to separate the numerator and denominator. `map` is used to convert the split string parts into integers.\n- **Multiplication**: The numerators and denominators of the two fractions are multiplied separately.\n- **Whole number check**: We use the modulus operator `%` to check if the numerator of the result is divisible by the denominator without leaving a remainder.\n\nThis approach ensures that we correctly determine whether the product of two fractions results in a whole number.\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    De ngwa\u1ecdr\u1ee5 nke na-ahazi ndep\u1ee5ta nd\u1ecb e nyere nke integers n'usoro mgbagwoju na-esote ng\u1ee5k\u1ecdta nke mkpok\u1ecdta mkp\u1ee5r\u1ee5edemede ha.\n    Ihe edeturu: \u1ecd b\u1ee5r\u1ee5 na e nwere \u1ecdt\u1ee5t\u1ee5 ihe nwere ng\u1ee5k\u1ecdta mkp\u1ee5r\u1ee5edemede yiri nke ah\u1ee5,\n    ha ga-ahazi ha dabere na nhazi ha na ndep\u1ee5ta mb\u1ee5.\n\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"Dee \u1ecdr\u1ee5 nke na-anabata ndep\u1ee5ta nke n\u1ecdmba d\u1ecbka ntinye ma laghachi \nn\u1ecdmba nke ihe nd\u1ecb d\u1ecb na ndep\u1ee5ta nke kar\u1ecbr\u1ecb 10 na ma mb\u1ecbdo na njedebe \nihe ab\u1ee5\u1ecd nke n\u1ecdmba ah\u1ee5 b\u1ee5 \u1ecdn\u1ee5\u1ecdg\u1ee5 ad\u1ecbgh\u1ecb.\nD\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\nspecialFilter => 1 \nspecialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    A na-enye g\u1ecb \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 d\u1ecb mma n. \u1eca ga-emep\u1ee5ta integer array a nke ogologo ya b\u1ee5 n.\n        Maka onye \u1ecd b\u1ee5la i, uru nke a[i] = i * i - i + 1.\n        Laghachi na n\u1ecdmba nke triples nke a ebe i < j < k,\n    na a[i] + a[j] + a[k] b\u1ee5 \u1ecdt\u1ee5t\u1ee5 nke 3.\n\n    Ihe at\u1ee5:\n        Ntinye: n = 5\n        \u1eccp\u1ee5p\u1ee5: 1\n        Nk\u1ecdwa:\n        a = [1, 3, 7, 13, 21]\n        Naan\u1ecb triple ziri ezi b\u1ee5.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"Dee \u1ecdr\u1ee5 nke na-anabata ndep\u1ee5ta nke okwu d\u1ecb ka ihe ntinye,\n    wepu okwu nd\u1ecb nwere ogologo d\u1ecb iche iche na ya,\n    ma weghachite ndep\u1ee5ta nke d\u1ecb n'usoro,\n    Ndep\u1ee5ta ah\u1ee5 b\u1ee5 mgbe niile ndep\u1ee5ta okwu na \u1ecd b\u1ee5gh\u1ecb usoro n\u1ecdmba,\n    \u1ecd nwekwara ike \u1ecbnwe \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 ab\u1ee5\u1ecd.\n    Usoro ndep\u1ee5ta ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecbd\u1ecb n'usoro site n'ogologo okwu \u1ecd b\u1ee5la, na \u1ecb\n    kwes\u1ecbr\u1ecb \u1ecblaghachi ndep\u1ee5ta ah\u1ee5 d\u1ecb n'usoro ah\u1ee5.\n    \u1ecc b\u1ee5r\u1ee5 na okwu ab\u1ee5\u1ecd nwere otu ogologo, hazie ndep\u1ee5ta ah\u1ee5 site n'usoro ah\u1ecbr\u1ecbokwu.\n    \u1eccr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi ndep\u1ee5ta okwu d\u1ecb n'usoro.\n    I nwere ike \u1ecbt\u1ee5 anya na okwu niile ga-enwe otu ogologo.\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"Okwu mmemme d\u1ecb mfe nke kwes\u1ecbr\u1ecb \u1ecblaghachi uru x ma \u1ecd b\u1ee5r\u1ee5 na n b\u1ee5 n\u1ecdmba mb\u1ee5, nke kwes\u1ecbr\u1ecb \u1ecblaghachi uru y ma \u1ecd b\u1ee5gh\u1ecb ya.\n\n\u1ee4f\u1ecdd\u1ee5 ihe at\u1ee5:\nmaka x_or_y == 34\nmaka x_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Echere m na any\u1ecb niile echeta mmet\u1ee5ta ah\u1ee5 mgbe nsonaaz\u1ee5 ihe omume a na-eche ogologo oge b\u1ee5 ihe a maara n'ikpeaz\u1ee5. Mmet\u1ee5ta na echiche \u1ecb nwere n'oge ah\u1ee5 b\u1ee5 ihe kwes\u1ecbr\u1ecb \u1ecbk\u1ecdwa ma t\u1ee5nyere n'ezie.\n\u1eccr\u1ee5 g\u1ecb b\u1ee5 \u1ecbmata ma onye ah\u1ee5 z\u1ee5tara nsonaaz\u1ee5 egwuregwu ole na ole nke \u1ecdma.\nE nyere g\u1ecb ab\u1ee5\u1ecd n'ime nsonaaz\u1ee5 na am\u1ee5ma nke nha h\u00e0, ebe akara \u1ecd b\u1ee5la na-egosi otu egwuregwu.\nWeghachite ndep\u1ee5ta nke nha h\u00e0 na-egosi ot\u00fa onye ah\u1ee5 si kp\u1ecd\u1ecd ihe n'\u1ee5z\u1ecd ziri ezi. \u1ecc b\u1ee5r\u1ee5 na ha z\u1ee5tara nke \u1ecdma, uru ah\u1ee5 b\u1ee5 0, \u1ecd b\u1ee5r\u1ee5 na \u1ecd b\u1ee5gh\u1ecb, uru ah\u1ee5 b\u1ee5 \u1ecdd\u1ecbiche d\u1ecb n'etiti am\u1ee5ma na nsonaaz\u1ee5 ah\u1ee5.\n\n\u1ee5z\u1ecd at\u1ee5:\n\nt\u1ee5\u1ecd -> [0,0,0,0,3,3]\nt\u1ee5\u1ecd -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"A ga-enye g\u1ecb aha otu na ndep\u1ee5ta mgbat\u1ecb.\n    A ga-eji mgbat\u1ecb nd\u1ecb a ebuli klaas\u1ecb nd\u1ecb \u1ecdz\u1ecd n'ot\u00f9 a. Ike mgbat\u1ecb ah\u1ee5 d\u1ecb ka nd\u1ecb a:\n    Ka CAP b\u1ee5r\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 mkp\u1ee5r\u1ee5edemede ukwu d\u1ecb n'aha mgbat\u1ecb ah\u1ee5, na ka SM b\u1ee5r\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 mkp\u1ee5r\u1ee5edemede nta d\u1ecb n'aha mgbat\u1ecb ah\u1ee5, ike ah\u1ee5 b\u1ee5 oke CAP - SM.\n    I kwesiri \u1ecbch\u1ecdta mgbat\u1ecb kachas\u1ecb ike ma weghachite okwu n'\u1ee5d\u1ecb a: ClassName.StrongestExtensionName.\n    \u1ecc b\u1ee5r\u1ee5 na e nwere mgbat\u1ecb ab\u1ee5\u1ecd ma \u1ecd b\u1ee5 kar\u1ecba nwere otu ike, \u1ecb ga-ah\u1ecdr\u1ecd nke na-ab\u1ecba mb\u1ee5 na ndep\u1ee5ta.\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5, \u1ecd b\u1ee5r\u1ee5 na enyere g\u1ecb \"Slices\" d\u1ecbka klaas\u1ecb na ndep\u1ee5ta mgbat\u1ecb: ['SErviNGSliCes', 'Cheese', 'StuFfed'] mgbe ah\u1ee5 \u1ecb ga-eweghachi 'Slices.SErviNGSliCes' ebe 'SErviNGSliCes' b\u1ee5 mgbat\u1ecb kachas\u1ecb ike.\n    D\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\n    maka Strongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"Ebe a na-enye g\u1ecb okwu ab\u1ee5\u1ecd. \u1eca ga-ach\u1ecd \u1ecblaghachi True ma \u1ecd b\u1ee5r\u1ee5 na okwu nke ab\u1ee5\u1ecd ma \u1ecd b\u1ee5 nke \u1ecd b\u1ee5la n'ime nt\u1ee5ghar\u1ecb ya b\u1ee5 ak\u1ee5k\u1ee5 nke okwu mb\u1ee5.\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Enyere otu n\u1ecdmba integer. t\u1ee5ghar\u1ecba otu tuple nke nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 nke n\u1ecdmba ab\u1ee5\u1ecd na nke ad\u1ecbgh\u1ecb ab\u1ee5\u1ecd n'otu n'otu.\n\n     Ihe at\u1ee5:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Ebe a b\u1ee5 \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 d\u1ecb mma, nweta ng\u1ee5k\u1ecdta \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 Roman ya d\u1ecb ka eriri,\n    ma weghachite ya na mkp\u1ee5r\u1ee5edemede pere mpe.\n    \u1eccn\u1ecdd\u1ee5: 1 <= n\u1ecdmba <= 1000\n\n    Ihe at\u1ee5:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"Dee \u1ecdr\u1ee5 nke na-anabata ndep\u1ee5ta nke eriri okwu.\n    Ndep\u1ee5ta ah\u1ee5 nwere \u1ee5d\u1ecb okwu d\u1ecb iche iche. Weghachite okwu nwere\n    \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nke mkp\u1ee5r\u1ee5edemede p\u1ee5r\u1ee5 iche. \u1ecc b\u1ee5r\u1ee5 na \u1ecdt\u1ee5t\u1ee5\n    eriri nwere \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kachas\u1ecb nke mkp\u1ee5r\u1ee5edemede p\u1ee5r\u1ee5 iche, weghachite\n    nke na-ab\u1ecba mb\u1ee5 na odidi ederede.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    Here's the translation of the given text into Igbo:\n\n\u1eca b\u1ee5 ewu ah\u1ee5h\u1ee5, \u1ecb kwadolar\u1ecb n\u1ee5kar\u1ecbkar\u1ecb kar\u1ecdt,\n    mana ugbu a \u1ecb ch\u1ecdr\u1ecd iri kar\u1ecdt nd\u1ecb \u1ecdz\u1ecd iji mezue nri \u1ee5b\u1ecdch\u1ecb ah\u1ee5.\n    \u1ecb ga-az\u1ecdp\u1ee5ta otu ng\u1ee5k\u1ecdta [ \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kar\u1ecdt nd\u1ecb \u1ecb riri mgbe nri g\u1ecb,\n                                    \u1ecdn\u1ee5 \u1ecdg\u1ee5g\u1ee5 kar\u1ecdt nd\u1ecb f\u1ecdd\u1ee5r\u1ee5 mgbe nri g\u1ecb ]\n    \u1ecd b\u1ee5r\u1ee5 na enwegh\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecbkar\u1ecb\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    I nwere ndep\u1ee5ta ab\u1ee5\u1ecd: ihe ar\u1ee5 \u1ecdr\u1ee5 na ihe ar\u1ee5 \u1ecdr\u1ee5. Ndep\u1ee5ta mb\u1ee5 nwere \u1ecdr\u1ee5 algebra b\u1ee5 isi, na ndep\u1ee5ta nke ab\u1ee5\u1ecd b\u1ee5 ndep\u1ee5ta nke integers. Jiri ndep\u1ee5ta ab\u1ee5\u1ecd a ak\u1ecdwap\u1ee5ta okwu algebra ma laghachi nyocha nke okwu a.\n\nOru algebra b\u1ee5 isi:\nMgbakwunye\nMwep\u1ee5\nM\u1ee5baa\nKewaa ala\nM\u1ee5baa nke ab\u1ee5\u1ecd\n\nIhe at\u1ee5:\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nCheta:\n    Ogologo ndep\u1ee5ta ihe ar\u1ee5 \u1ecdr\u1ee5 b\u1ee5 otu na ogologo ndep\u1ee5ta ihe ar\u1ee5 \u1ecdr\u1ee5 bel\u1ee5s\u1ecd otu.\n    Ihe ar\u1ee5 \u1ecdr\u1ee5 b\u1ee5 ndep\u1ee5ta nke integers na-ad\u1ecbgh\u1ecb mma.\n    Ndep\u1ee5ta ihe ar\u1ee5 \u1ecdr\u1ee5 nwere opekata mpe otu ihe ar\u1ee5 \u1ecdr\u1ee5, na ndep\u1ee5ta ihe ar\u1ee5 \u1ecdr\u1ee5 nwere opekata mpe ihe ab\u1ee5\u1ecd.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"A na-enye g\u1ecb eriri s.\n    \u1ecd b\u1ee5r\u1ee5 na s[i] b\u1ee5 mkp\u1ee5r\u1ee5edemede, gbanwee \u1ecdn\u1ecdd\u1ee5 ya site na obere gaa n'ibu ma \u1ecd b\u1ee5 nke \u1ecdz\u1ecd,\n    ma \u1ecd b\u1ee5r\u1ee5 na \u1ecd b\u1ee5gh\u1ecb, hap\u1ee5 ya ka \u1ecd d\u1ecb.\n    \u1ecc b\u1ee5r\u1ee5 na eriri ah\u1ee5 enweghi mkp\u1ee5r\u1ee5edemede \u1ecd b\u1ee5la, gbanwee eriri ah\u1ee5.\n    \u1eccr\u1ee5 ah\u1ee5 kwes\u1ecbr\u1ecb \u1ecblaghachi eriri ah\u1ee5 nke mere.\n    Ihe at\u1ee5\n    solve = \"4321\"\n    solve = \"AB\"\n    solve = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Nye 'text' ka \u1ecd b\u1ee5r\u1ee5 eriri, t\u1ee5ghar\u1ecba ya n'ime eriri md5 hash kwek\u1ecdr\u1ecd. \u1ecc b\u1ee5r\u1ee5 na 'text' b\u1ee5 eriri efu, laghachi None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    E nyere g\u1ecb n\u1ecdmba ab\u1ee5\u1ecd d\u1ecb mma a na b, weghachite \u1ecdn\u1ee5\u1ecdg\u1ee5g\u1ee5 ziri ezi d\u1ecb n'etiti a na b, na usoro mgbago elu.\n\nD\u1ecbka \u1ecdm\u1ee5maat\u1ee5:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]