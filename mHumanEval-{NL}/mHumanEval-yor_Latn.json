[
    {
        "prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \u1e62ay\u1eb9wo boya ninu akoj\u1ecd aw\u1ecdn n\u1ecdmba ti a fun, \u1e63e eyikeyi aw\u1ecdn n\u1ecdmba meji sunm\u1ecd ara w\u1ecdn ju iw\u1ecdn-lile ti a fun l\u1ecd.\nApeere:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n",
        "canonical_solution":"for idx, elem in enumerate(numbers):\n    for idx2, elem2 in enumerate(numbers):\n        if idx != idx2:\n            distance = abs(elem - elem2)\n            if distance < threshold:\n                return True\nreturn False\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Gbigbasil\u1eb9 si i\u1e63\u1eb9\u0301 \u00e0y\u1ecdk\u00e0 y\u00ec\u00ed j\u1eb9\u0301 \u1ecd\u0300r\u1ecd\u0300 kan t\u00ed \u00f3 n\u00ed \u1ecd\u0300p\u1ecd\u0300 \u1eb9gb\u1eb9\u0301 \u00e0w\u1ecdn ak\u1ecdm\u1ecd t\u00f3 w\u1ecd ara w\u1ecdn. \u00c0w\u1ecdn \u00ecd\u00edl\u00e9 r\u1eb9 ni l\u00e1ti\n    y\u00e0 \u00e0w\u1ecdn \u1eb9gb\u1eb9\u0301 w\u1ecd\u0300ny\u00ed s\u00ed \u00e0w\u1ecdn \u1ecd\u0300r\u1ecd\u0300 t\u00f3 y\u00e0t\u1ecd\u0300 y\u00e0t\u1ecd\u0300 \u00e0ti pad\u00e0 f\u00fan \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn w\u1ecd\u0300ny\u00ed.\n    \u00c0w\u1ecdn \u1eb9gb\u1eb9\u0301 t\u00f3 y\u00e0t\u1ecd\u0300 j\u1eb9\u0301 t\u00ed w\u1ecd\u0301n p\u00e8s\u00e8 d\u00e1rad\u00e1ra \u00e0ti k\u00f2 w\u1ecd ara w\u1ecdn.\n    \u1e62e \u00e0\u00ecka \u00e0w\u1ecdn \u00e0\u00e0y\u00e8 kankan n\u00edn\u00fa \u1ecd\u0300r\u1ecd\u0300 \u00ecw\u1ecd\u0300ny\u00ed.\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"
    },
    {
        "prompt":"\n\ndef truncate_number(number: float) -> float:\n    \"\"\" Fun n\u1ecdmba foilingi to dara, o le pin si\n    apakan n\u1ecdmba pipe ati aw\u1ecdn onis\u1ecdri.\n\n    Pada apakan onis\u1ecdri ti n\u1ecdmba naa.\n    Apeere:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n",
        "canonical_solution":"    return number % 1.0\n",
        "test":"def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" A \u1e63e fun \u1ecd ni akoj\u1ecd aw\u1ecdn i\u1e63\u1eb9 ifipam\u1ecd ati yiy\u1ecd kuro lori ak\u1ecd\u1ecdl\u1eb9 banki kan ti o b\u1eb9r\u1eb9 p\u1eb9lu iw\u1ecdntunw\u1ecdnsi odo. I\u1e63\u1eb9 r\u1eb9 ni lati \u1e63e akiyesi ti ni eyikeyi aaye iw\u1ecdntunw\u1ecdnsi ak\u1ecd\u1ecdl\u1eb9 naa ba \u1e63ubu ni isal\u1eb9 odo, ati ni aaye y\u1eb9n i\u1e63\u1eb9 naa y\u1eb9 ki o pada True. Bib\u1eb9\u1eb9k\u1ecd, o y\u1eb9 ki o pada False.\nAp\u1eb9\u1eb9r\u1eb9:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n",
        "canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Fun atok\u1ecd aw\u1ecdn n\u1ecdmba ti a fi sii, \u1e63e i\u1e63iro Iyapa Alab\u1ecdde Gidi ni ayika apap\u1ecd ti akoj\u1ecd data yii.\n    Iyapa Alab\u1ecdde Gidi j\u1eb9 apap\u1ecd iyat\u1ecd gidi laarin \u1ecdk\u1ecd\u1ecdkan\n    nkan ati aaye aarin:\n    MAD = apap\u1ecd | x - x_mean |\n    Apeere:\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n",
        "test":"def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Fi n\u1ecdmba 'delimeter' laarin gbogbo aw\u1ecdn eroja meji ti o t\u1eb9le ni atok\u1ecd `numbers' ti a fi sii\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n",
        "canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" \u1eb8\u0300b\u1eb9\u0300 w\u1ecd\u0300ny\u00ed f\u00fan i\u1e63\u1eb9\u0301 \u00e0k\u1ecds\u00edl\u1eb9\u0300 y\u00ec\u00ed j\u1eb9\u0301 \u1ecd\u0300r\u1ecd\u0300 kan t\u00ed a \u1e63\u00e0p\u00e8j\u00fawe \u1ecd\u0300p\u1ecd\u0300 \u1eb9gb\u1eb9\u0301 f\u00fan \u00e0w\u1ecdn \u00e0gb\u00e9k\u00e1 \u00e0p\u1ecdn\u0300l\u00e9 t\u00ed a ya s\u1ecd\u0301t\u1ecd\u0300 p\u1eb9\u0300l\u00fa \u00e0w\u1ecdn \u00e0\u00e0y\u00e8.\n\n    F\u00fan \u1ecdk\u1ecd\u0300\u1ecd\u0300kan \u00e0w\u1ecdn \u1eb9gb\u1eb9\u0301 n\u00e1\u00e0, j\u00e1de \u00e8y\u00ed t\u00f3 jinl\u1eb9\u0300 j\u00f9 l\u1ecd l\u00e1ti in\u00fa \u00e0w\u1ecdn \u00e0gb\u00e9k\u00e1 \u00e0p\u1ecdn\u0300l\u00e9 n\u00e1\u00e0.\n    F\u00fan \u00e0p\u1eb9\u1eb9r\u1eb9,) n\u00ed \u00ecpele m\u00e9j\u00ec t\u00f3 p\u1ecd\u0301n j\u00f9 l\u1ecd n\u00edgb\u00e0 t\u00ed)) n\u00ed m\u1eb9\u0301ta.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
        "canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" F\u1eb9l\u1eb9ta atok\u1ecd ti aw\u1ecdn okun ti nw\u1ecdle fun aw\u1ecdn ti o ni abala \u1ecdr\u1ecd ti a fun.\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if substring in x]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Fun atok\u1ecd aw\u1ecdn n\u1ecdmba gidi ti a fun, pada tuple ti o ni apap\u1ecd ati \u1ecdja gbogbo aw\u1ecdn n\u1ecdmba inu atok\u1ecd naa.\n    Aw\u1ecdn apap\u1ecd ofo y\u1eb9 ki o j\u1eb9 deede si 0 ati \u1ecdja ofo y\u1eb9 ki o j\u1eb9 deede si 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n",
        "canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n",
        "test":"def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" N\u00edpa s\u00edso\u0301 \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan \u00ect\u00f2l\u00e9w\u00e0, \u1e63e \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn \u00e8r\u00f2j\u00e0 t\u00ed \u00f3 p\u1ecd\u0300j\u00f9 t\u00edt\u00ed di \u00ecgb\u00e0 t\u00ed a f\u00fan n\u00ed \u00ecl\u00e0n\u00e0 n\u00e1\u00e0.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" \u1e62e idanwo boya okun ti a fun ni j\u1eb9 palindrome. \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n",
        "canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Aw\u1ecdn ohun elo w\u1ecdny\u1eb9n j\u1eb9 aw\u1ecdn okun meji a ati b ti o ni 1s ati 0s nikan.\n    \u1e62e i\u1e63\u1eb9 XOR binary lori aw\u1ecdn w\u1ecdny\u1eb9n ati pada abajade naa bi okun kan naa.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n",
        "canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n",
        "test":"def check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"
    },
    {
        "prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" L\u00e1ti in\u00fa \u00e0k\u00f3j\u1ecd \u00e0w\u1ecdn ok\u00f9n, pad\u00e0 ok\u00f9n t\u00f3 g\u00f9n j\u00f9. Pad\u00e0 \u00e8k\u00edn\u00ed n\u00edgb\u00e0t\u00ed \u00e0w\u1ecdn ok\u00f9n p\u00fap\u00f2 b\u00e1 n\u00ed \u00ecw\u1ecd\u0300n t\u00f3 y\u00edye. Pad\u00e0 None t\u00ed \u00e0k\u00f3j\u1ecd \u00ecb\u1eb9\u0300r\u1eb9\u0300 b\u00e1 \u1e63\u00f3fo.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n",
        "canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n",
        "test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"
    },
    {
        "prompt":"\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Pada isiro apap\u1ecd ti o p\u1ecd jul\u1ecd ti aw\u1ecdn n\u1ecdmba meji a ati b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n",
        "test":"def check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Pada akoj\u1ecd gbogbo aw\u1ecdn asop\u1ecd lati kukuru si gigun jul\u1ecd ti okun ti a t\u1eb9 sii\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n",
        "canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"
    },
    {
        "prompt":"\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Pada okun kan ti o ni aw\u1ecdn n\u1ecdmba ti a ya s\u1ecdt\u1ecd nipas\u1eb9 aaye ti o b\u1eb9r\u1eb9 lati 0 titi de n p\u1eb9lu.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n",
        "test":"def check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"
    },
    {
        "prompt":"\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Ninu okun kan, wa iye aw\u1ecdn ohun kik\u1ecd alail\u1eb9gb\u1eb9 melo ti o ni.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n",
        "canonical_solution":"    return len(set(string.lower()))\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Ibi si i\u1e63\u1eb9-\u1e63i\u1e63e yii j\u1eb9 okun ti o nsoju aw\u1ecdn ak\u1ecdsil\u1eb9 orin ni \u1ecdna kika ASCII pataki kan.\n    I\u1e63\u1eb9 r\u1eb9 ni lati \u1e63e itum\u1ecd okun yii ki o si pada akoj\u1ecd aw\u1ecdn n\u1ecdmba g\u1eb9g\u1eb9bi iye igba ti ak\u1ecdsil\u1eb9 k\u1ecd\u1ecdkan\n    ti o k\u1eb9hin.\n\n    Eyi ni ilana:\n    'o' - ak\u1ecdsil\u1eb9 kikun, duro fun igba m\u1eb9rin\n    'o|' - ak\u1ecdsil\u1eb9 idaji, duro fun igba meji\n    '.|' - ak\u1ecdsil\u1eb9 m\u1eb9\u1eb9dogun, duro fun igba kan\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n",
        "canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n",
        "test":"def check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"
    },
    {
        "prompt":"\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Wa iye igba ti a le rii \u1eb9kunr\u1eb9r\u1eb9 ti a funni ninu okun atil\u1eb9ba. Ka aw\u1ecdn \u1ecdran ti o farapam\u1ecd.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n",
        "canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n",
        "test":"def check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Gb\u00f3l\u00f3h\u00f9n \u00eck\u00edni j\u1eb9\u0301 \u1ecd\u0300r\u1ecd\u0300 t\u00ed a y\u00e0 s\u00ed \u00e0\u00e0y\u00e8 k\u1ecd\u1ecdkan t\u00f3 n\u00ed \u00e0w\u1ecdn n\u01f9kan \u00ec\u1e63\u00edr\u00f2 l\u00e1ti 'zero' d\u00e9 'nine'.\n    \u00c0w\u1ecdn \u00e0\u1e63\u00e0y\u00e0n t\u00f3 t\u1ecd\u0301 j\u1eb9\u0301 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' \u00e0ti 'nine'.\n    Da \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn n\u01f9kan \u00ec\u1e63\u00edr\u00f2 pada p\u1eb9\u0300l\u00fa \u00e0w\u1ecdn n\u01f9kan t\u00f3 ti m\u1ecd\u0301 l\u00e1ti k\u00e9ker\u00e9 d\u00e9 \u0144l\u00e1.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n",
        "canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"
    },
    {
        "prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" L\u00e1ti in\u00fa \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn n\u1ecd\u0301mb\u00e0 t\u00ed a f\u00fan l\u1ecd\u0301w\u1ecd\u0301 y\u00e0n y\u00e0t\u1ecd\u0300 \u00e0w\u1ecdn m\u00e9j\u00ec t\u00f3 s\u00fan m\u1ecd\u0301 ara w\u1ecdn j\u00f9, k\u00ed o s\u00ec pad\u00e0 w\u00e1 f\u00fan w\u1ecdn n\u00ed t\u00edt\u1eb9\u0300le.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n",
        "canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n",
        "test":"def check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Fun akoj\u1ecd aw\u1ecdn n\u1ecdmba, lo iyipada laini si akoj\u1ecd y\u1eb9n,\n    ki n\u1ecdmba ti o kere jul\u1ecd yoo di 0 ati ti o tobi jul\u1ecd yoo di 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n",
        "canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n",
        "test":"def check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"
    },
    {
        "prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Y\u1ecdk\u00far\u00f2 ninu \u00e0t\u00f2j\u1ecd t\u00ed a f\u00fan f\u00fan \u00e0w\u1ecdn iye Python k\u00eck\u00ec f\u00fan \u00e0w\u1ecdn \u00e0d\u00e0k\u1ecd.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in values if isinstance(x, int)]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"
    },
    {
        "prompt":"\n\ndef strlen(string: str) -> int:\n    \"\"\" Pada ipari okun ti a funni\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n",
        "canonical_solution":"    return len(string)\n",
        "test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"
    },
    {
        "prompt":"\n\ndef largest_divisor(n: int) -> int:\n    \"\"\" Fun n\u1ecdmba kan n, wa n\u1ecdmba ti o tobi julo ti o pin n larinrin, ti o kere ju n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n",
        "canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n",
        "test":"def check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Pada akoj\u1ecd aw\u1ecdn ifosiwewe ak\u1ecdk\u1ecd ti n\u1ecdmba ti a fun ni ni a\u1e63\u1eb9 lati kekere jul\u1ecd si tobi jul\u1ecd.\n    \u1eb8k\u1ecd k\u1ecd\u1ecdkan ninu aw\u1ecdn ifosiwewe y\u1eb9 ki o \u1e63e akoj\u1ecdp\u1ecd ni igba m\u1eb9ta ti o ba ri ni isediwon.\n    N\u1ecdmba tit\u1eb9si y\u1eb9 ki o j\u1eb9 deede si \u1ecdja gbogbo aw\u1ecdn ifosiwewe.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n",
        "test":"def check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Lati inu akoj\u1ecd ti aw\u1ecdn n\u1ecdmba g\u00edg\u00f9n, y\u1ecd gbogbo aw\u1ecdn eroja ti o waye ju \u1eb9\u1eb9kan l\u1ecd.\n    Pa a\u1e63\u1eb9 aw\u1ecdn eroja ti o ku pap\u1ecd bi ninu abajade.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"
    },
    {
        "prompt":"\n\ndef flip_case(string: str) -> str:\n    \"\"\" Fun okun kan ti a fi fun, yipada aw\u1ecdn ohun kik\u1ecd kekere si aw\u1ecdn ohun kik\u1ecd nla ati aw\u1ecdn ohun kik\u1ecd nla si aw\u1ecdn ohun kik\u1ecd kekere.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n",
        "canonical_solution":"    return string.swapcase()\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Darap\u1ecd akoj\u1ecd aw\u1ecdn okun sinu okun kan \u1e63o\u1e63o\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n",
        "canonical_solution":"    return ''.join(strings)\n",
        "test":"def check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"
    },
    {
        "prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" F\u1ecdw\u1ecdsi atok\u1ecd igbew\u1ecdle aw\u1ecdn okun fun aw\u1ecdn ti o b\u1eb9r\u1eb9 p\u1eb9lu ak\u1ecdle ti a fun.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n",
        "canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n",
        "test":"def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"
    },
    {
        "prompt":"\n\ndef get_positive(l: list):\n    \"\"\"Da aw\u1ecdn n\u1ecdmba to daju nikan pada ninu akoj\u1ecd.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n",
        "canonical_solution":"    return [e for e in l if e > 0]\n",
        "test":"def check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"
    },
    {
        "prompt":"\n\ndef is_prime(n):\n    \"\"\"Da otit\u1ecd pada ti n\u1ecdmba ti a fun ba j\u1eb9 abay\u1ecd, ati eke bib\u1eb9\u1eb9k\u1ecd.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n",
        "canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"
    },
    {
        "prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    N \u1e63akiyesi polinomial p\u1eb9lu aw\u1ecdn asami xs ni aaye x.\n    pada xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n",
        "canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n",
        "test":"def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"
    },
    {
        "prompt":"\n\ndef sort_third(l: list):\n    \"\"\"I\u1e63\u1eb9\u0301 y\u00ec\u00ed gba \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 l, \u00f3 s\u00ec \u0144 pad\u00e0 \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 l' t\u00ed \u00f3 r\u00ed b\u1eb9\u0301\u1eb9\u0300 g\u1eb9\u0301g\u1eb9\u0301:\n    l' d\u00e1j\u00fa p\u00e9 \u00f3 j\u1ecd l n\u00ed \u00e0w\u1ecdn ibi t\u00ed n k\u00f2 pin s\u00ed m\u1eb9\u0301ta, n\u00edgb\u00e0 t\u00ed \u00e0w\u1ecdn iye r\u1eb9\u0300 n\u00ed \u00e0w\u1ecdn ibi t\u00ed \u00f3 pin s\u00ed m\u1eb9\u0301ta j\u1eb9\u0301\n    iye \u00e0w\u1ecdn ibi t\u00f3 b\u00e1\u00e0m\u1ecd\u0301 ti l, \u1e63\u00f9gb\u1ecd\u0301n t\u00ed w\u1ecd\u0301n ti \u1e63e t\u00f3t\u00f3.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n",
        "canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"
    },
    {
        "prompt":"\n\ndef unique(l: list):\n    \"\"\"Da pada aw\u1ecdn eroja alail\u1eb9gb\u1eb9 ti a ti to ni atok\u1ecd kan\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(list(set(l)))\n",
        "test":"def check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"
    },
    {
        "prompt":"\n\ndef max_element(l: list):\n    \"\"\"Da \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e8y\u00e0 t\u00f3 p\u1ecd\u0300 j\u00f9l\u1ecd pad\u00e0.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n",
        "canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"
    },
    {
        "prompt":"\n\ndef fizz_buzz(n: int):\n    \"\"\"Pada iye igba ti n\u1ecdmba 7 \u1e63e afihan ninu aw\u1ecdn n\u1ecdmba ti o kere ju n ti o pinpin nipas\u1eb9 11 tabi 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n",
        "canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n",
        "test":"def check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"
    },
    {
        "prompt":"\n\ndef sort_even(l: list):\n    \"\"\"\u1eccna i\u1e63\u1eb9\u0301 yii gba \u00e0t\u00f2k\u1ecd l o s\u00ec \u0144 da \u00e0t\u00f2k\u1ecd l' pada g\u1eb9\u0301g\u1eb9\u0301 b\u00ed\n    l' \u1e63e j\u1eb9\u0301 \u00ecw\u1ecd\u0300nt\u00fanw\u1ecd\u0300ns\u00ec p\u1eb9\u0300l\u00fa l n\u00ed \u00e0w\u1ecdn \u00e0k\u1ecd\u0301l\u00e9 \u00e0\u00ecp\u00e9, n\u00edgb\u00e0 t\u00ed \u00e0w\u1ecdn iye r\u1eb9\u0300 n\u00ed \u00e0w\u1ecdn \u00e0k\u1ecd\u0301l\u00e9 \u00e0f\u00e0\u00ecl\u00e0 j\u1eb9\u0301\n    iye \u00e0w\u1ecdn \u00e0k\u1ecd\u0301l\u00e9 \u00e0f\u00e0\u00ecl\u00e0 n\u00edn\u00fa l, \u1e63\u00f9gb\u1ecd\u0301n t\u00ed w\u1ecd\u0301n ti \u1e63e t\u00edt\u1ecd\u0300n\u00e0.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n",
        "canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n",
        "test":"def check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"
    },
    {
        "prompt":"\n\ndef encode_cyclic(s: str):\n    \"\"\"\n    da \u1ecdr\u1ecd ti a k\u00f3 pada pada nipa yiyi aw\u1ecdn \u1eb9gb\u1eb9 m\u1eb9ta ti aw\u1ecdn ohun kik\u1ecd.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"
    },
    {
        "prompt":"\n\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib n pada n\u1ecdmba k\u1eb9ta ti o j\u1eb9 n\u1ecdmba Fibonacci ati pe o tun j\u1eb9 ak\u1ecdk\u1ecd.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n",
        "canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n",
        "test":"def check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"
    },
    {
        "prompt":"\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero gba akoj\u1ecd ti aw\u1ecdn n\u1ecdmba g\u1eb9g\u1eb9 bi igbew\u1ecdle.\n    o pada True ti aw\u1ecdn eroja m\u1eb9ta ti o yat\u1ecd ba wa ninu akoj\u1ecd ti o\n    \u1e63aj\u1ecd si odo, ati pe o pada False bib\u1eb9\u1eb9k\u1ecd.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"
    },
    {
        "prompt":"\n\ndef car_race_collision(n: int):\n    \"\"\"\n    \u1e62e itum\u1ecd gbolohun yii si ede Yoruba.\n\nFoju inu wo opopona kan ti o j\u1eb9 laini g\u00edg\u00f9n g\u00edg\u00f9n ju ti ko ni opin l\u1ecd.\n    n \u00e0w\u1ecdn \u1ecdk\u1ecd\u0300 ay\u1ecd\u0301k\u1eb9\u0301l\u1eb9\u0301 kan n \u1e63\u00ed\u1e63e lati apa osi si apa otun; ni akoko kanna, \u1eb9gb\u1eb9\u0301 ori\u1e63iri\u1e63i ti n \u1ecdk\u1ecd\u0300 ay\u1ecd\u0301k\u1eb9\u0301l\u1eb9\u0301 kan n \u1e63\u00ed\u1e63e lati apa otun si apa osi. \u1eb8gb\u1eb9\u0301 mejeji ti \u1ecdk\u1ecd\u0300 ay\u1ecd\u0301k\u1eb9\u0301l\u1eb9\u0301 b\u1eb9r\u1eb9 ni ibi ti w\u1ecdn ti jinna pup\u1ecd si ara w\u1ecdn. Gbogbo \u1ecdk\u1ecd\u0300 ay\u1ecd\u0301k\u1eb9\u0301l\u1eb9\u0301 n r\u00ecn ni iyara kanna. A s\u1ecd pe \u1ecdk\u1ecd\u0300 meji ti k\u1ecdlu nigba ti \u1ecdk\u1ecd\u0300 ay\u1ecd\u0301k\u1eb9\u0301l\u1eb9\u0301 ti n r\u00ecn lati apa osi si apa otun ba \u1ecdk\u1ecd\u0300 ay\u1ecd\u0301k\u1eb9\u0301l\u1eb9\u0301 ti n r\u00ecn lati apa otun si apa osi. Sib\u1eb9sib\u1eb9, \u1ecdk\u1ecd\u0300 ay\u1ecd\u0301k\u1eb9\u0301l\u1eb9\u0301 naa j\u1eb9\u0301 \u1eb9ni \u00e0\u00ecn\u00edyelori ati alagbara gidi; bi abajade, w\u1ecdn t\u1eb9siwaju lati r\u00ecn ni \u1ecdna w\u1ecdn bi \u1eb9nipe w\u1ecdn ko k\u1ecdlu.\n\n    I\u1e63\u1eb9\u0301 yii n \u1e63e \u00e0b\u00e1j\u00e1de iye \u00eck\u1ecdlu b\u1eb9\u0301\u1eb9\u0300.\n    \"\"\"\n",
        "canonical_solution":"    return n**2\n",
        "test":"def check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"
    },
    {
        "prompt":"\n\ndef incr_list(l: list):\n    \"\"\"Da \u00e0k\u00f3j\u1ecd pada p\u1eb9\u0300l\u00fa \u00e0w\u1ecdn \u1eb9\u0300y\u00e0 t\u00ed a ti k\u00fan n\u00ed 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n",
        "canonical_solution":"    return [(e + 1) for e in l]\n",
        "test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"
    },
    {
        "prompt":"\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero ngba akoj\u1ecd ti aw\u1ecdn n\u1ecdmba g\u1eb9g\u1eb9 bi ohun elo.\n    o pada b\u1eb9\u1eb9ni ti o ba wa aw\u1ecdn eroja meji ti o yat\u1ecd ninu akoj\u1ecd ti\n    \u1e63aj\u1ecd si odo, ati rara bib\u1eb9\u1eb9k\u1ecd.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"
    },
    {
        "prompt":"\n\ndef change_base(x: int, base: int):\n    \"\"\"Yi ipil\u1eb9 n\u1ecdmba ti n\u1ecdmba ti a t\u1eb9 sii x pada si ipil\u1eb9.\n    pada si afij\u1eb9 \u1ecdr\u1ecd l\u1eb9hin iyipada naa.\n    aw\u1ecdn n\u1ecdmba ipil\u1eb9 kere ju 10 l\u1ecd.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n",
        "canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"
    },
    {
        "prompt":"\n\ndef triangle_area(a, h):\n    \"\"\"Fun gigun \u1eb9gb\u1eb9 kan ati giga, pada agbegbe fun onigun m\u1eb9ta.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n",
        "canonical_solution":"    return a * h \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"
    },
    {
        "prompt":"\n\ndef fib4(n: int):\n    \"\"\"Gbolohun yii ni ede Yoruba:\n\n\u00c0w\u1ecdn l\u1eb9s\u1eb9s\u1eb9 \u1ecdn\u00e0 Fib4 j\u1eb9 l\u1eb9s\u1eb9s\u1eb9 kan t\u00ed \u00f3 j\u00e9\u0323 b\u00ed l\u1eb9s\u1eb9s\u1eb9 Fibbonacci t\u00ed \u00f3 d\u00e1 s\u00edl\u00e8\u0323 b\u00e1y\u00ec\u00ed:\n    fib4 -> 0\n    fib4 -> 0\n    fib4 -> 2\n    fib4 -> 0\n    fib4 -> fib4 + fib4 + fib4 + fib4.\n    J\u1ecd\u0300w\u1ecd\u0301 k\u1ecd i\u1e63\u1eb9\u0301 kan t\u00f3 m\u00e1a \u1e63e i\u1e63iro \u00ecp\u00ednl\u1eb9\u0300 k\u1eb9rin n\u00ed l\u1eb9s\u1eb9s\u1eb9 \u1ecdn\u00e0 Fib4 n\u00edpas\u1eb9\u0300 \u1ecdna t\u00f3 \u1e63\u00f2ro p\u1eb9\u0300l\u00fa. M\u00e1 \u1e63e l\u00f2 \u00e0t\u00fan\u1e63e.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n",
        "canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n",
        "test":"def check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"
    },
    {
        "prompt":"\n\ndef median(l: list):\n    \"\"\"Pada median aw\u1ecdn eroja ninu akoj\u1ecd l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n",
        "canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"
    },
    {
        "prompt":"\n\ndef is_palindrome(text: str):\n    \"\"\"\n    \u1e62e ay\u1eb9wo boya okun ti a fun j\u1eb9 palindrome.\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n",
        "canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"
    },
    {
        "prompt":"\n\ndef modp(n: int, p: int):\n    \"\"\"Da 2^n pada ni modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n",
        "canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n",
        "test":"def check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"
    },
    {
        "prompt":"\n\ndef encode_shift(s: str):\n    \"\"\"\n    n pada asop\u1ecd ti a ti k\u1ecdja nipa gbigbe gbogbo kik\u1ecd nipas\u1eb9 5 ninu alfabeti.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n",
        "test":"def check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"
    },
    {
        "prompt":"\n\ndef remove_vowels(text):\n    \"\"\"\n    \"remove_vowels j\u1eb9 i\u1e63\u1eb9 ti o gba okun ati pada okun laisi aw\u1ecdn ohun.\"\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n",
        "canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n",
        "test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"
    },
    {
        "prompt":"\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Da True pada ti gbogbo aw\u1ecdn n\u1ecdmba ninu atok\u1ecd l ba wa ni isal\u1eb9 iye t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n",
        "canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"
    },
    {
        "prompt":"\n\ndef add(x: int, y: int):\n    \"\"\"Fi aw\u1ecdn n\u1ecdmba meji x ati y kun\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n",
        "canonical_solution":"    return x + y\n",
        "test":"def check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"
    },
    {
        "prompt":"\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    \u1e62ay\u1eb9wo boya aw\u1ecdn \u1ecdr\u1ecd meji ni aw\u1ecdn ohun kik\u1ecd kanna.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n",
        "canonical_solution":"    return set(s0) == set(s1)\n",
        "test":"def check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"
    },
    {
        "prompt":"\n\ndef fib(n: int):\n    \"\"\"Pada n\u1ecdmba Fibonacci n-th.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n",
        "test":"def check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Aw\u1ecdn agbas\u1ecd j\u1eb9 okun ti \"<\" ati \">\".\n    pada B\u1eb9\u1eb9ni ti gbogbo agb\u1ecdn \u1e63i\u1e63i ba ni agb\u1ecdn pipade ti o baamu.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"
    },
    {
        "prompt":"\n\ndef monotonic(l: list):\n    \"\"\"Da pada Otit\u1ecd ti aw\u1ecdn eroja akoj\u1ecd naa ba n p\u1ecd si tabi dinku ni imurasil\u1eb9.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n",
        "canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n",
        "test":"def check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"
    },
    {
        "prompt":"\n\ndef common(l1: list, l2: list):\n    \"\"\"Pada aw\u1ecdn eroja ti o w\u1ecdp\u1ecd ti a s\u1ecdt\u1ecd ati ti o ni alail\u1eb9gb\u1eb9 fun aw\u1ecdn akoj\u1ecd meji.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n",
        "canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n",
        "test":"def check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"
    },
    {
        "prompt":"\n\ndef largest_prime_factor(n: int):\n    \"\"\"Pada ifosiwewe atun\u1e63e ti o tobi jul\u1ecd ti n. \u1e62e akiyesi pe n > 1 ati pe kii \u1e63e ifosiwewe atun\u1e63e.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n",
        "test":"def check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"
    },
    {
        "prompt":"\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n j\u1eb9\u0301 i\u1e63\u1eb9\u0301 t\u00ed \u00f3 k\u00f3 \u00e0w\u1ecdn n\u01f9kan \u00ec\u1e63\u00edr\u00f2 l\u00e1ti 1 d\u00e9 n p\u1ecd\u0300.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n",
        "canonical_solution":"    return sum(range(n + 1))\n",
        "test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"
    },
    {
        "prompt":"\n\ndef correct_bracketing(brackets: str):\n    \"\"\" Aw\u1ecdn agb\u1ecdn j\u1eb9 okun ti \"\".\n    da pada Otit\u1ecd ti gbogbo agb\u1ecdn \u1e63i\u1e63i ni agb\u1ecdn pipade ti o baamu.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n",
        "canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n",
        "test":"def check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"
    },
    {
        "prompt":"\n\ndef derivative(xs: list):\n    \"\"\" xs \u1e63e a\u1e63oju aw\u1ecdn ifosiwewe ti polinomia.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Pada it\u1ecds\u1eb9 ti polinomia yii ni irisi kanna.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n",
        "canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n",
        "test":"def check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"
    },
    {
        "prompt":"\n\ndef fibfib(n: int):\n    \"\"\"Eto aw\u1ecdn n\u1ecdmba FibFib j\u1eb9 eto ti o j\u1ecdra si eto Fibbonacci ti a \u1e63alaye bi at\u1eb9le:\n    fibfib == 0\n    fibfib == 0\n    fibfib == 1\n    fibfib == fibfib + fibfib + fibfib.\n    Jowo k\u1ecd i\u1e63\u1eb9 kan lati \u1e63e i\u1e63iro ni ir\u1ecdrun aw\u1ecdn eroja n-ti eto n\u1ecdmba fibfib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n",
        "test":"def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"
    },
    {
        "prompt":"\nFIX = \"\"\"\nFi aw\u1ecdn idanwo di\u1eb9 sii kun.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef circular_shift(x, shift):\n    \"\"\"Yi aw\u1ecdn n\u1ecdmba inu x pada ni irisi iyipo, gbe aw\u1ecdn n\u1ecdmba l\u1ecd si apa \u1ecdtun nipas\u1eb9 iye ti a s\u1ecd\n    ki o si da abajade pada bi okun.\n    Ti iye gbigbe ba tobi ju n\u1ecdmba aw\u1ecdn n\u1ecdmba l\u1ecd, da aw\u1ecdn n\u1ecdmba pada ni irisi idakeji.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n",
        "canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef digitSum(s):\n    \"\"\"Gba \u1ecdr\u1ecd yii sinu Yoruba:\n\n\u1e62e i\u1e63\u1eb9 kan ti o gba okun bi igbew\u1ecdle ati pada apap\u1ecd aw\u1ecdn ohun kik\u1ecd nla nikan' aw\u1ecdn koodu ASCII.\n\n\u00c0p\u1eb9\u1eb9r\u1eb9:\n\n    digitSum => 0\n    digitSum => 131\n    digitSum => 67\n    digitSum => 69\n    digitSum => 131\n    digitSum => 153\n    \"\"\"\n",
        "canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef fruit_distribution(s,n):\n    \"\"\"\n    N\u00edn\u00fa i\u1e63\u1eb9\u0301 y\u00ec\u00ed, a \u00f3 f\u00fan \u1ecd n\u00ed okun kan t\u00ed \u00f3 d\u00far\u00f3 f\u00fan iye \u00e0w\u1ecdn \u00e0p\u00f9 \u00e0ti osan \n    t\u00ed a p\u00edn s\u00edn\u00fa ap\u1eb9\u0300r\u1eb9\u0300 ew\u00e9b\u1eb9\u0300 kan. Ap\u1eb9\u0300r\u1eb9\u0300 y\u00ec\u00ed n\u00ed \n    \u00e0p\u00f9, osan, \u00e0ti mangoro. Fi okun t\u00ed \u00f3 d\u00far\u00f3 f\u00fan apap\u1ecd\u0300 iye \u00e0w\u1ecdn \n    osan \u00e0ti \u00e0p\u00f9 \u00e0ti \u1eb9niy\u00e0n kan t\u00ed \u00f3 d\u00far\u00f3 f\u00fan apap\u1ecd\u0300 iye \u00e0w\u1ecdn ew\u00e9b\u1eb9\u0300 \n    n\u00edn\u00fa ap\u1eb9\u0300r\u1eb9\u0300 n\u00e1\u00e0, pad\u00e0 w\u00e1 iye \u00e0w\u1ecdn mangoro n\u00edn\u00fa ap\u1eb9\u0300r\u1eb9\u0300 n\u00e1\u00e0.\n    f\u00fan \u00e0p\u1eb9\u1eb9r\u1eb9:\n    pipin_ew\u00e9b\u1eb9\u0300 -> 19 - 5 - 6 = 8\n    pipin_ew\u00e9b\u1eb9\u0300 -> 3 - 0 - 1 = 2\n    pipin_ew\u00e9b\u1eb9\u0300 -> 100 - 2 - 3 = 95\n    pipin_ew\u00e9b\u1eb9\u0300 -> 120 - 100 - 1 = 19\n    \"\"\"\n",
        "canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"
    },
    {
        "prompt":"\ndef pluck(arr):\n    \"\"\"\n    Eyi ni gbolohun naa ni ede Yoruba:\n\n\"Fun \u00e0w\u00f2r\u00e1n kan t\u00f3 \u1e63\u00e0fih\u00e0n \u1eb9\u0300ka igi kan t\u00ed \u00f3 n\u00ed \u00e0w\u1ecdn \u1eb9\u0300ka t\u00ed k\u00f2 n\u00edyege\n    i\u1e63\u1eb9\u0301 r\u1eb9\u0300 ni l\u00e1ti fa \u1ecd\u0300kan n\u00edn\u00fa \u00e0w\u1ecdn \u1eb9\u0300ka n\u00e1\u00e0 y\u1ecd\u0300 \u00e0ti l\u00e1ti pad\u00e0 w\u00e1.\n    \u1eb8\u0300ka t\u00ed o fa y\u1ecd\u0300 y\u1eb9\u0301 k\u00ed \u00f3 j\u1eb9\u0301 \u1eb9\u0300ka t\u00ed \u00f3 n\u00ed iye t\u00f3 kere j\u00f9 t\u00f3 j\u1eb9\u0301 t\u00f3j\u00fa.\n    B\u00ed o b\u00e1 r\u00ed \u1ecd\u0300p\u1ecd\u0300 \u1eb9\u0300ka t\u00ed \u00f3 n\u00ed iye t\u00f3 kere t\u00f3 j\u1eb9\u0301 t\u00f3j\u00fa, a pad\u00e0 \u1eb9\u0300ka t\u00ed \u00f3 n\u00ed \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 k\u00e9r\u00e9 j\u00f9.\n\n    \u1eb8\u0300ka t\u00f3 fa y\u1ecd\u0300 y\u1eb9\u0301 k\u00ed \u00f3 j\u1eb9\u0301 n\u00edn\u00fa \u00e0w\u00f2r\u00e1n, [ iye t\u00f3 kere j\u00f9, \u00eck\u00e0ns\u00ed r\u1eb9\u0300 ],\n    B\u00ed k\u00f2 b\u00e1 s\u00ed iye t\u00f3 j\u1eb9\u0301 t\u00f3j\u00fa t\u00e0b\u00ed \u00e0w\u00f2r\u00e1n t\u00ed a f\u00fan j\u1eb9 \u00f2fo, pad\u00e0 [].\n\n    \u00c0p\u1eb9\u1eb9r\u1eb91:\n        \u00ccw\u1ecd\u0300n: [4, 2, 3]\n        \u00ccpad\u00e0: [2, 1]\n        \u00c0l\u00e0y\u00e9: 2 n\u00ed iye t\u00f3 kere j\u00f9 t\u00f3 j\u1eb9\u0301 t\u00f3j\u00fa, \u00e0ti 2 n\u00ed \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 t\u00f3 kere j\u00f9.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb92:\n        \u00ccw\u1ecd\u0300n: [1, 2, 3]\n        \u00ccpad\u00e0: [2, 1]\n        \u00c0l\u00e0y\u00e9: 2 n\u00ed iye t\u00f3 kere j\u00f9 t\u00f3 j\u1eb9\u0301 t\u00f3j\u00fa, \u00e0ti 2 n\u00ed \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 t\u00f3 kere j\u00f9.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb93:\n        \u00ccw\u1ecd\u0300n: []\n        \u00ccpad\u00e0: []\n\n    \u00c0p\u1eb9\u1eb9r\u1eb94:\n        \u00ccw\u1ecd\u0300n: [5, 0, 3, 0, 4, 2]\n        \u00ccpad\u00e0: [0, 1]\n        \u00c0l\u00e0y\u00e9: 0 ni iye t\u00f3 kere j\u00f9, \u1e63\u00f9gb\u1ecd\u0301n \u1eb9\u0300ka meji t\u00f3 n\u00ed 0,\n                     n\u00edtor\u00ed n\u00e1\u00e0 a y\u00e0n \u00e0k\u1ecd\u0301k\u1ecd\u0301 0, t\u00f3 n\u00ed \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 t\u00f3 kere j\u00f9.\n\n    \u00c0w\u1ecdn \u00ecd\u00e1j\u1ecd\u0301:\n        * 1 <= iye \u1eb9\u0300ka.length <= 10000\n        * 0 <= iye \u1eb9\u0300ka\"\n    \"\"\"\n",
        "canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n",
        "canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n",
        "test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"
    },
    {
        "prompt":"\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n",
        "canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n",
        "canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"
    },
    {
        "prompt":"\ndef will_it_fly(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    will_it_fly([1, 2], 5) \u00e2 -> False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    will_it_fly([3, 2, 3], 1) \u00e2 -> False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly([3, 2, 3], 9) \u00e2 -> True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    will_it_fly([3], 5) \u00e2 -> True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n",
        "canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"
    },
    {
        "prompt":"\ndef smallest_change(arr):\n    \"\"\"\n    N\u00edpa f\u00edfi s\u00edl\u00e8 \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn n\u01f9kan arr ti \u00e0w\u1ecdn \u00e0d\u00e1d\u00f3, r\u00ed \u00e0w\u1ecdn n\u01f9kan t\u00f3 k\u00e9r\u00e9 j\u00f9 t\u00ed \u00f3 n\u00edl\u00f2 l\u00e1ti y\u00ed pad\u00e0 l\u00e1ti j\u1eb9\u0301 k\u00ed \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 n\u00e1\u00e0 di palindromic. \u00c0k\u00f3j\u1ecdp\u1ecd\u0300 palindromic ni \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 t\u00ed a l\u00e8 ka n\u00ed oj\u00fakan \u00e0ti n\u00ed \u00e0y\u00edk\u00e1.\n\nN\u00ed \u00ecy\u00edpad\u00e0 kan, o l\u00e8 y\u00ed n\u01f9kan kan pad\u00e0 s\u00ed ey\u00ed m\u00ec\u00edr\u00e0n.\n\n\u00c0p\u1eb9\u1eb9r\u1eb9:\nsmallest_change == 4\nsmallest_change == 1\nsmallest_change == 0\n    \"\"\"\n",
        "canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"
    },
    {
        "prompt":"\ndef total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u00e2 -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u00e2 -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u00e2 -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u00e2 -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u00e2 -> ['4']\n    '''\n",
        "canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"
    },
    {
        "prompt":"\ndef is_multiply_prime(a):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 kan ti o pada si otit\u1ecd ti n\u1ecdmba ti a fun j\u1eb9 isodipupo aw\u1ecdn n\u1ecdmba ak\u1ecdk\u1ecd m\u1eb9ta\n    ati eke bib\u1eb9\u1eb9k\u1ecd.\n    M\u1ecd pe j\u1eb9 kere ju 100 l\u1ecd.\n    Ap\u1eb9\u1eb9r\u1eb9:\n    is_multiply_prime == Otit\u1ecd\n    30 = 2 * 3 * 5\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"
    },
    {
        "prompt":"\ndef is_simple_power(x, n):\n    \"\"\"I\u1e63\u1eb9\u0301 r\u1eb9 j\u1eb9\u0301 l\u00e1ti k\u1ecd\u0301 i\u1e63\u1eb9\u0301-\u1ecdn\u00e0 kan t\u00ed y\u00f3\u00f2 pad\u00e0 s\u00ed \u00f2t\u00edt\u1ecd\u0301 b\u00ed n\u01f9kan x b\u00e1 j\u1eb9\u0301 agb\u00e1ra t\u00ed \u00f3 r\u1ecdr\u00f9n ti n \u00e0ti ir\u1ecd\u0301 n\u00ed \u00e0w\u1ecdn \u00e0pap\u1ecd\u0300 m\u00ec\u00edr\u00e0n.\n    x j\u1eb9\u0301 agb\u00e1ra t\u00ed \u00f3 r\u1ecdr\u00f9n ti n b\u00ed n**int=x\n    Fun \u00e0p\u1eb9\u1eb9r\u1eb9:\n    is_simple_power => \u00f2t\u00edt\u1ecd\u0301\n    is_simple_power => \u00f2t\u00edt\u1ecd\u0301\n    is_simple_power => \u00f2t\u00edt\u1ecd\u0301\n    is_simple_power => ir\u1ecd\u0301\n    is_simple_power => ir\u1ecd\u0301\n    is_simple_power => ir\u1ecd\u0301\n    \"\"\"\n",
        "canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef iscube(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n",
        "canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"
    },
    {
        "prompt":"\ndef hex_key(num):\n    \"\"\"O ti wa ni i\u1e63\u1eb9 lati k\u1ecd i\u1e63\u1eb9 kan ti o gba n\u1ecdmba hexaadecimaal bi okun ati ka n\u1ecdmba aw\u1ecdn n\u1ecdmba hexaadecimaal ti o j\u1eb9 aw\u1ecdn n\u1ecdmba alakomeji. Aw\u1ecdn n\u1ecdmba hexaadecimaal j\u1eb9 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Aw\u1ecdn n\u1ecdmba alakomeji j\u1eb9 2, 3, 5, 7, 11, 13, 17,... Nitorinaa o ni lati pinnu n\u1ecdmba aw\u1ecdn n\u1ecdmba w\u1ecdnyi: 2, 3, 5, 7, B, D. Ak\u1ecdsil\u1eb9: o le ro pe input j\u1eb9 nigbagbogbo t\u1ecd tabi okun ofo, ati aw\u1ecdn aami A, B, C, D, E, F j\u1eb9 nigbagbogbo ni gbogbo \u1ecdr\u1ecd. Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9: Fun num = \"AB\" ni i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 1. Fun num = \"1077E\" ni i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 2. Fun num = \"ABED1A33\" ni i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 4. Fun num = \"123456789ABCDEF0\" ni i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 6. Fun num = \"2020\" ni i\u1e63el\u1ecdp\u1ecd y\u1eb9 ki o j\u1eb9 2.\n    \"\"\"\n",
        "canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"
    },
    {
        "prompt":"\ndef decimal_to_binary(decimal):\n    \"\"\"A o fun \u1ecd ni n\u1ecdmba kan ni f\u1ecd\u1ecdmu desimali ati i\u1e63\u1eb9 r\u1eb9 ni lati yi pada si\n    f\u1ecd\u1ecdmu b\u00edn\u00e1r\u00ec. I\u1e63\u1eb9 naa y\u1eb9 ki o pada okun kan, p\u1eb9lu \u1ecdk\u1ecd\u1ecdkan ti o nsoju n\u1ecdmba b\u00edn\u00e1r\u00ec.\n    Ok\u1ecdkan ninu okun naa yoo j\u1eb9 '0' tabi '1'.\n\n    Yio wa aw\u1ecdn \u1ecdr\u1ecd afikun meji 'db' ni ib\u1eb9r\u1eb9 ati ni opin okun naa.\n    Aw\u1ecdn \u1ecdr\u1ecd afikun wa lati ran p\u1eb9lu f\u1ecd\u1ecdmat.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    decimal_to_binary   # pada \"db1111db\"\n    decimal_to_binary   # pada \"db100000db\"\n    \"\"\"\n",
        "canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef is_happy(s):\n    \"\"\"O ti fun \u1ecd ni okun s.\n    I\u1e63\u1eb9 r\u1eb9 ni lati \u1e63ay\u1eb9wo boya okun naa dun tabi rara.\n    Okun kan dun ti ipari r\u1eb9 ba j\u1eb9 o kere ju 3 ati pe gbogbo l\u1eb9ta m\u1eb9ta to n t\u1eb9le ara w\u1ecdn yat\u1ecd.\n    Fun ap\u1eb9\u1eb9r\u1eb9:\n    is_happy => K\u00f2\n    is_happy => K\u00f2\n    is_happy => B\u1eb9\u0301\u1eb9\u0300ni\n    is_happy => K\u00f2\n    is_happy => B\u1eb9\u0301\u1eb9\u0300ni\n    is_happy => K\u00f2\n    \"\"\"\n",
        "canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"
    },
    {
        "prompt":"\ndef numerical_letter_grade(grades):\n    \"\"\"\u1eccs\u1eb9\u0301 t\u00f3 k\u1eb9\u0301y\u00ecn n\u00edn\u00fa \u1ecdd\u00fan \u00ecw\u00e9 y\u00ec\u00ed ni \u00f3 w\u00e0, \u00e0ti p\u00e9 ol\u00f9k\u1ecd\u0301 n\u00e1\u00e0 gb\u1ecd\u0301d\u1ecd\u0300 f\u00fan \u00e0w\u1ecdn ak\u1eb9\u0301k\u1ecd\u0300\u1ecd\u0301 \u00e0w\u1ecdn \u00e0m\u00ec w\u1ecdn. Ol\u00f9k\u1ecd\u0301 n\u00e1\u00e0 ti \u0144 \u1e63e alg\u1ecd\u0301r\u00edd\u00edm\u00f9 tir\u1eb9\u0300 f\u00fan f\u00edfi \u00e0m\u00ec. \u00d2un\u1e63o\u1e63o i\u1e63oro ni p\u00e9, \u00f3 ti p\u00e0d\u00e1n\u00f9 k\u00f3\u00f2d\u00f9 t\u00ed \u00f3 l\u00f2 f\u00fan f\u00edfi \u00e0m\u00ec. \u00d3 ti f\u00fan \u1ecd n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn GPA \u00e0w\u1ecdn ak\u1eb9\u0301k\u1ecd\u0300\u1ecd\u0301 kan, \u00f3 s\u00ec j\u1eb9\u0301 k\u00ed o k\u1ecd\u0301 i\u1e63\u1eb9\u0301-\u1e63i\u1e63e t\u00ed \u00f3 l\u00e8 \u1e63e \u00e0b\u00e1j\u00e1de \u00ect\u00f2j\u1ecd \u00e0w\u1ecdn \u00e0m\u00ec l\u1eb9\u0301t\u00e0 n\u00edpas\u1eb9\u0300 t\u00e1b\u00ecl\u00ec t\u00f3 t\u1eb9\u0300 l\u00e9 e:\n             \n             GPA       |    Am\u00ec l\u1eb9\u0301t\u00e0\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
        "canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef prime_length(string):\n    \"\"\"Ko i\u1e63\u1eb9 kan ti o gba okun ati pada True ti gigun okun naa ba j\u1eb9 n\u1ecdmba alakomeji tabi False bib\u1eb9\u1eb9k\u1ecd\nAw\u1ecdn ap\u1eb9\u1eb9r\u1eb9\nprime_length == True\nprime_length == True\nprime_length == True\nprime_length == False\n    \"\"\"\n",
        "canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"
    },
    {
        "prompt":"\ndef starts_one_ends(n):\n    \"\"\"\n    Fun n\u1ecdmba odidi rere n, pada iye aw\u1ecdn n\u1ecdmba ti aw\u1ecdn n\u1ecdmba odidi rere ti n-digit ti o b\u1eb9r\u1eb9 tabi pari p\u1eb9lu 1.\n    \"\"\"\n",
        "canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(N):\n    \"\"\"F\u00fan N t\u00ed \u00f3 j\u1eb9\u0301 \u00e0k\u00e0r\u00e0 \u00e0d\u00e0t\u1ecd\u0300, pad\u00e0 s\u00ed \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 g\u00edg\u00f9n \u00e0w\u1ecdn n\u01f9kan r\u1eb9\u0300 n\u00edn\u00fa \u00ec\u1e63\u1eb9\u0300d\u00e1 \u00e0t\u1eb9\u0301l\u1eb9w\u1ecd\u0301.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n        Fun N = 1000, \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn n\u01f9kan y\u00f3\u00f2 j\u1eb9\u0301 1, abajade n\u00e1\u00e0 y\u1eb9 k\u00ed \u00f3 j\u1eb9\u0301 \"1\".\n        Fun N = 150, \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn n\u01f9kan y\u00f3\u00f2 j\u1eb9\u0301 6, abajade n\u00e1\u00e0 y\u1eb9 k\u00ed \u00f3 j\u1eb9\u0301 \"110\".\n        Fun N = 147, \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn n\u01f9kan y\u00f3\u00f2 j\u1eb9\u0301 12, abajade n\u00e1\u00e0 y\u1eb9 k\u00ed \u00f3 j\u1eb9\u0301 \"1100\".\n\n    \u00c0w\u1ecdn \u00f2n\u0300k\u00e0:\n        @N \u00e0k\u00e0r\u00e0\n            \u00c0w\u1ecdn \u00e0\u00ecl\u00e8k\u00f2: 0 \u2264 N \u2264 10000.\n    \u00c0b\u00e1j\u00e1de:\n        \u1ecd\u0300kan n\u01f9kan \u00ec\u1e63\u1eb9\u0300d\u00e1 \u00e0t\u1eb9\u0301l\u1eb9w\u1ecd\u0301.\n    \"\"\"\n",
        "canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"
    },
    {
        "prompt":"\ndef add(lst):\n    \"\"\"Ti a ba fun akoj\u1ecd ti kii \u1e63e ofo ti aw\u1ecdn n\u1ecdmba odidi lst, \u1e63afikun aw\u1ecdn eroja ti o j\u1eb9 paapaa ti w\u1ecdn ba wa ni aw\u1ecdn it\u1ecdka odd.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n        add ==> 2 \n    \"\"\"\n",
        "canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"
    },
    {
        "prompt":"\ndef anti_shuffle(s):\n    \"\"\"\n    ```python\nKo ak\u1ecdsori kan ti o gba okun kan ki o si da pada \u1eb9ya ti a \u1e63eto r\u1eb9.\n    \u1eb8ya ti a \u1e63eto ti okun, j\u1eb9 okun nibi gbogbo aw\u1ecdn \u1ecdr\u1ecd\n    j\u1eb9 ti a r\u1ecdpo nipas\u1eb9 \u1ecdr\u1ecd tuntun nibi gbogbo aw\u1ecdn ohun kik\u1ecd ti \u1e63eto ni\n    a\u1e63\u1eb9 ti n p\u1ecd si da lori iye ascii.\n    Ak\u1ecdsil\u1eb9: O y\u1eb9 ki o pa a\u1e63\u1eb9 aw\u1ecdn \u1ecdr\u1ecd ati aw\u1ecdn aaye ofo ni gbolohun naa.\n\n    Fun ap\u1eb9\u1eb9r\u1eb9:\n    anti_shuffle pada 'Hi'\n    anti_shuffle pada 'ehllo'\n    anti_shuffle pada 'Hello !!!Wdlor'\n```\n    \"\"\"\n",
        "canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef get_row(lst, x):\n    \"\"\"\n    O ti fun \u1ecd ni data on\u00edh\u00e1m\u1eb9\u0301rin, g\u1eb9\u0301g\u1eb9\u0301 b\u00ed \u00e0w\u1ecdn \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 n\u00edn\u00fa \u00e0w\u1ecdn \u00e0k\u00f3j\u1ecdp\u1ecd\u0300, \n    \u1eb9\u0300y\u00ed t\u00ed \u00f3 j\u1ecd m\u00e1tr\u00eds\u00ed, b\u00edi\u1e63\u00edb\u00f2, n\u00ed ilodisi m\u00e1tr\u00eds\u00ed,\n    k\u1ecd\u1ecdkan \u00ecl\u00e0 l\u00e8 n\u00ed \u00e0w\u1ecdn kolomu t\u00ed \u00f3 y\u00e0t\u1ecd\u0300.\n    N\u00edpa f\u00edfi lst, \u00e0ti n\u1ecd\u0301mb\u00e0 x, r\u00ed \u00e0w\u1ecdn n\u1ecd\u0301mb\u00e0 x n\u00edn\u00fa \u00e0k\u00f3j\u1ecdp\u1ecd\u0300,\n    \u00e0ti pad\u00e0 \u00e0w\u1ecdn \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn t\u1ecd\u0301p\u00f9l\u00f9, [, ...] b\u1eb9\u0301\u1eb9\u0300 t\u00ed\n    k\u1ecd\u1ecdkan t\u1ecd\u0301p\u00f9l\u00f9 j\u1eb9\u0301 t\u1ecd\u0301kas\u00ed -, b\u1eb9\u0300r\u1eb9\u0300 p\u1eb9\u0300l\u00fa 0.\n    T\u00edt\u1ecd\u0301n\u00e0 t\u1ecd\u0301kas\u00ed n\u00ed \u00ecb\u1eb9\u0300r\u1eb9\u0300 p\u1eb9\u0300l\u00fa \u00e0w\u1ecdn \u00ecl\u00e0 n\u00ed \u00e0\u1e63\u1eb9 t\u00ed \u0144 ga s\u00edl\u1eb9\u0300.\n    P\u1eb9\u0300l\u00fa n\u00e1\u00e0, t\u00edt\u1ecd\u0301n\u00e0 t\u1ecd\u0301kas\u00ed \u00ecl\u00e0 n\u00ed \u00e0\u1e63\u1eb9 t\u00ed \u0144 d\u00edn k\u00f9 n\u00ed \u00e0w\u1ecdn kolomu.\n    \n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [,,,,]\n    get_row == []\n    get_row == []\n    \"\"\"\n",
        "canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef sort_array(array):\n    \"\"\"\n    N\u00edpas\u1eb9\u0301 f\u00edfi \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn n\u01f9kan t\u00ed k\u00f2 n\u00ed iye \u00e8y\u00edk\u00e9y\u00ec\u00ed f\u00fan \u00e0p\u1eb9\u1eb9r\u1eb9, p\u00e0d\u00e1n\u00f9 \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 n\u00e1\u00e0 l\u1eb9\u0301y\u00ecn t\u00edt\u1ecd\u0301 \u00e0w\u1ecdn n\u01f9kan n\u00e1\u00e0 p\u1eb9\u0300l\u00fa t\u00edt\u1ecd\u0301 w\u1ecdn s\u00ed \u00e0t\u1eb9\u0300j\u00e1de, \u00ecw\u1ecd y\u00f3\u00f2 t\u1ecd\u0301 \u00e0w\u1ecdn n\u01f9kan n\u00e1\u00e0 s\u00ed \u00ecl\u00e0 t\u00f3 ga s\u00edw\u00e1j\u00fa b\u00ed \u1eb9ni p\u00e9 iye apap\u1ecd\u0300 j\u1eb9\u0301 \u00e0k\u00f3k\u00f2, t\u00e0b\u00ed t\u1ecd\u0301 w\u1ecdn s\u00ed \u00ecl\u00e0 t\u00f3 k\u00f9 b\u00ed \u1eb9ni p\u00e9 iye apap\u1ecd\u0300 j\u1eb9\u0301 \u00e0d\u00e0k\u1ecd.\n\n\u00c0k\u00edy\u00e8s\u00ed:\n* m\u00e1 \u1e63e y\u00edpad\u00e0 \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 n\u00e1\u00e0.\n\n\u00c0p\u1eb9\u1eb9r\u1eb9:\n* sort_array => []\n* sort_array => [5]\n* sort_array => [0, 1, 2, 3, 4, 5]\n* sort_array => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n",
        "canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef encrypt(s):\n    \"\"\"\u1e62\u1eb9da i\u1e63\u1eb9\u0301 kan t\u00ed \u0144 j\u1eb9\u0301 encrypt t\u00ed \u0144 gba okun g\u1eb9\u0301g\u1eb9\u0301 b\u00ed \u00e0rg\u00fam\u00e9\u0144t\u00ec \n    t\u00ed \u0144 s\u00ec pad\u00e0 okun t\u00ed a ti encrypt p\u1eb9\u0300l\u00fa p\u00edp\u00e0d\u00e0 l\u1eb9\u0301t\u00e0 alifabeti. \n    Alifabeti y\u00ed\u00f2 y\u1eb9\u0300 k\u00ed \u00f3 y\u00edpo n\u00ed \u00e0k\u00e0n\u1e63e kan t\u00f3 j\u1eb9\u0301 p\u00e9 l\u1eb9\u0301t\u00e0 y\u00ed\u00f3 y\u00edpo s\u00edl\u00e8 n\u00edbi m\u00e9j\u00ec t\u00ed a p\u00edn s\u00ed m\u00e9j\u00ec.\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    encrypt y\u00ed\u00f3 pad\u00e0 'lm'\n    encrypt y\u00ed\u00f3 pad\u00e0 'ewhjklnop'\n    encrypt y\u00ed\u00f3 pad\u00e0 'kj'\n    encrypt y\u00ed\u00f3 pad\u00e0 'ix'\n    \"\"\"\n",
        "canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef next_smallest(lst):\n    \"\"\"\n    O ti fun \u1ecd ni atok\u1ecd aw\u1ecdn n\u1ecdmba gidi.\n    K\u1ecd i\u1e63\u1eb9 \u1e63i\u1e63e kan ti a np\u00e8 ni next_smallest ti o pada nkan keji ti o kere jul\u1ecd ninu atok\u1ecd naa.\n    Pada None ti ko ba si nkan b\u1eb9\u1eb9.\n\n    next_smallest == 2\n    next_smallest == 2\n    next_smallest == None\n    next_smallest == None\n    \"\"\"\n",
        "canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_bored(S):\n    \"\"\"\n    Iw\u1ecd yoo fun ni okun \u1ecdr\u1ecd, ati i\u1e63\u1eb9 r\u1eb9 ni lati ka n\u1ecdmba aw\u1ecdn aif\u1ecdkanbale. Aif\u1ecdkanbal\u1eb9 j\u1eb9 gbolohun \u1ecdr\u1ecd ti o b\u1eb9r\u1eb9 p\u1eb9lu \u1ecdr\u1ecd \"Mo\". Aw\u1ecdn gbolohun \u1ecdr\u1ecd ni a ya s\u1ecdt\u1ecd nipas\u1eb9 '.' '?' tabi '!'.\n\nFun ap\u1eb9\u1eb9r\u1eb9:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n",
        "canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u00e2 -> True\n    \n    any_int(3, 2, 2) \u00e2 -> False\n\n    any_int(3, -2, 1) \u00e2 -> True\n    \n    any_int(3.6, -2.2, 2) \u00e2 -> False\n  \n\n    \n    '''\n",
        "canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef encode(message):\n    \"\"\"\n    K\u1ecd i\u1e63\u1eb9 kan ti o gba ifiran\u1e63\u1eb9 kan, o si \u1e63akop\u1ecd ni \u1ecdna kan \n    ti o yi \u1ecdran ti gbogbo aw\u1ecdn l\u1eb9ta pada, r\u1ecdpo gbogbo aw\u1ecdn \n    faweli ninu ifiran\u1e63\u1eb9 naa p\u1eb9lu l\u1eb9ta ti o han meji aw\u1ecdn ipo \n    siwaju faweli y\u1eb9n ninu aw\u1ecdn l\u1eb9ta G\u1eb9\u1eb9si.\n    \u1e62e akiyesi aw\u1ecdn l\u1eb9ta nikan.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n",
        "canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\n\ndef skjkasdkd(lst):\n    \"\"\"O ti fun \u1ecd ni atok\u1ecd ti aw\u1ecdn n\u1ecdmba gidi.\n    O nilo lati wa iye n\u1ecdmba ak\u1ecdk\u1ecd ti o tobi julo ki o si pada apap\u1ecd aw\u1ecdn d\u00edd\u00ect\u00ec r\u1eb9.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    Fun lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] o\u00fanj\u1eb9 y\u1eb9 ki o j\u1eb9 10\n    Fun lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] o\u00fanj\u1eb9 y\u1eb9 ki o j\u1eb9 25\n    Fun lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] o\u00fanj\u1eb9 y\u1eb9 ki o j\u1eb9 13\n    Fun lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] o\u00fanj\u1eb9 y\u1eb9 ki o j\u1eb9 11\n    Fun lst = [0,81,12,3,1,21] o\u00fanj\u1eb9 y\u1eb9 ki o j\u1eb9 3\n    Fun lst = [0,8,1,2,1,7] o\u00fanj\u1eb9 y\u1eb9 ki o j\u1eb9 7\n    \"\"\"\n",
        "canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"
    },
    {
        "prompt":"\ndef check_dict_case(dict):\n    \"\"\"\n    Ti a ba fun ni iwe-itum\u1ecd\u0301 kan, da pada True ti gbogbo aw\u1ecdn b\u1ecdtini ba j\u1eb9 aw\u1ecdn okun ni kekere tabi gbogbo aw\u1ecdn b\u1ecdtini j\u1eb9 aw\u1ecdn okun ni nla, bib\u1eb9\u1eb9k\u1ecd da pada False. I\u1e63\u1eb9-\u1e63i\u1e63e naa y\u1eb9 ki o da pada False ti iwe-itum\u1ecd\u0301 ti a fun j\u1eb9 ofo. \nAw\u1ecdn ap\u1eb9\u1eb9r\u1eb9:\ncheck_dict_case y\u1eb9 ki o da pada True.\ncheck_dict_case y\u1eb9 ki o da pada False.\ncheck_dict_case y\u1eb9 ki o da pada False.\ncheck_dict_case y\u1eb9 ki o da pada False.\ncheck_dict_case y\u1eb9 ki o da pada True.\n    \"\"\"\n",
        "canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"
    },
    {
        "prompt":"\ndef count_up_to(n):\n    \"\"\"\u1e62e idanim\u1ecd i\u1e63\u1eb9 kan ti o gba n\u1ecdmba ti kii \u1e63e odi ati pe o pada si array ti aw\u1ecdn n\u1ecdmba akoj\u1ecdp\u1ecd ak\u1ecdk\u1ecd ti n ti o kere ju n.\nFun ap\u1eb9\u1eb9r\u1eb9:\ncount_up_to => [2,3]\ncount_up_to => [2,3,5,7]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17,19]\ncount_up_to => []\ncount_up_to => [2,3,5,7,11,13,17]\n    \"\"\"\n",
        "canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"
    },
    {
        "prompt":"\ndef multiply(a, b):\n    \"\"\"Gba i\u1e63\u1eb9\u0301 ti o gba aw\u1ecdn integers meji ati pe o pada\n    iw\u1ecdn aw\u1ecdn n\u1ecdmba w\u1ecdn.\n    \u1e62e akiyesi pe \u00e0b\u00e1w\u1ecdl\u00e9 j\u1eb9\u0301 \u00ecw\u00f2ny\u00ed n\u00edgb\u00e0 gbogbo.\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    multiply y\u1eb9 ki o pada 16.\n    multiply y\u1eb9 ki o pada 72.\n    multiply y\u1eb9 ki o pada 0.\n    multiply y\u1eb9 ki o pada 20.\n    \"\"\"\n",
        "canonical_solution":"    return abs(a % 10) * abs(b % 10)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"
    },
    {
        "prompt":"\ndef count_upper(s):\n    \"\"\"\n    T\u00ed a b\u00e1 f\u00fan k\u00e1 n\u00ed ok\u00f9n s, k\u00e0 iye \u00e0w\u1ecdn faweli t\u00f3 w\u00e0 n\u00ed agbohun nla ni \u00e0w\u1ecdn \u00ect\u1ecd\u0301ka t\u00ed \u00f3 j\u00e9\u0323 \u00e0w\u1ecdn n\u01f9kan m\u00e9j\u00ec.\n\n    F\u00fan \u00e0p\u1eb9r\u1eb9:\n    count_upper y\u00f3\u00f2 p\u00e8s\u00e8 1\n    count_upper y\u00f3\u00f2 p\u00e8s\u00e8 0\n    count_upper y\u00f3\u00f2 p\u00e8s\u00e8 0\n    \"\"\"\n",
        "canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef closest_integer(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For Exampleclosest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n",
        "canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"
    },
    {
        "prompt":"\ndef make_a_pile(n):\n    \"\"\"\n    F\u00fan \u00ecye gbogbo n t\u00f3 j\u1eb9\u0301 \u00e0k\u00e0r\u00e0, o n\u00ed l\u00e1ti d\u00e1 \u00e0k\u00e0l\u00e0m\u00e0l\u00e0 t\u00ed \u00f3 n\u00ed \u00ecpele n.\n    \u00ccpele \u00e0k\u1ecd\u0301k\u1ecd\u0301 n\u00ed n \u00e0w\u1ecdn \u00e0p\u00e1ta.\n    \u00ccy\u00f3k\u00f9 \u00ecpele y\u00f3\u00f2 n\u00ed:\n        - \u00ecye \u00e0w\u1ecdn \u00e0p\u00e1ta t\u00f3 j\u1eb9\u0301 odd t\u00f3 b\u00e1 j\u1eb9\u0301 p\u00e9 n j\u1eb9\u0301 odd.\n        - \u00ecye \u00e0w\u1ecdn \u00e0p\u00e1ta t\u00f3 j\u1eb9\u0301 even t\u00f3 b\u00e1 j\u1eb9\u0301 p\u00e9 n j\u1eb9\u0301 even.\n    M\u00e1a pad\u00e0 \u00ecye \u00e0w\u1ecdn \u00e0p\u00e1ta n\u00ed gbogbo \u00ecpele s\u00edn\u00fa \u00e0k\u00f3j\u1ecd, n\u00edbi \u00e8y\u00ed t\u00ed \u00e8r\u00f2 t\u00f3 w\u00e0 n\u00ed \u00f2\u01f9k\u00e0\n    i d\u00far\u00f3 f\u00fan \u00ecye \u00e0w\u1ecdn \u00e0p\u00e1ta n\u00ed \u00ecpele.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n",
        "canonical_solution":"    return [n + 2*i for i in range(n)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef words_string(s):\n    \"\"\"\n    Iw\u1ecd yoo fun ni okun \u1ecdr\u1ecd ti o ya s\u1ecdt\u1ecd nipas\u1eb9 aw\u1ecdn koma tabi aw\u1ecdn alaaye. I\u1e63\u1eb9 r\u1eb9 ni \nlati pin okun \u1ecdr\u1ecd naa si aw\u1ecdn \u1ecdr\u1ecd ati pada akoj\u1ecdp\u1ecd aw\u1ecdn \u1ecdr\u1ecd naa.\n\nFun ap\u1eb9\u1eb9r\u1eb9:\nwords_string == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nwords_string == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n",
        "canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"
    },
    {
        "prompt":"\ndef choose_num(x, y):\n    \"\"\"\u1eb8s\u1eb9\u0301 y\u00ec\u00ed gba \u00e0w\u1ecdn n\u01f9kan m\u00e9j\u00ec t\u00f3 j\u1eb9\u0301 \u00e0w\u1ecdn \u1ecdn\u00e0 m\u00e9j\u00ec x \u00e0ti y w\u1ecd\u0301n, \u00f3 s\u00ec pada p\u1eb9\u0300l\u00fa\n    n\u01f9kan t\u00ed \u00f3 t\u00f3bi j\u00f9 l\u1ecd t\u00f3 j\u1eb9\u0301 \u1eb9\u0300d\u00e1 al\u00e1k\u1ecds\u00edl\u1eb9\u0300 t\u00ed \u00f3 w\u00e0 n\u00edn\u00fa \u00e0\u00e1r\u00edn [x, y] p\u1eb9\u0300l\u00fa. B\u00ed \n    \u1eb9\u0300d\u00e1 b\u1eb9\u0301\u1eb9\u0300 k\u00f2 b\u00e1 s\u00ec, \u1eb9s\u1eb9\u0301 y\u00ec\u00ed gb should pada p\u1eb9\u0300l\u00fa -1.\n\n    \u00c0p\u1eb9r\u1eb9:\n    choose_num = 14\n    choose_num = -1\n    \"\"\"\n",
        "canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"
    },
    {
        "prompt":"\ndef rounded_avg(n, m):\n    \"\"\"A gba aw\u1ecdn n\u1ecdmba alayokuro meji ti o dara n ati m, ati i\u1e63\u1eb9 r\u1eb9 ni lati \u1e63e i\u1e63iro apap\u1ecd ti aw\u1ecdn n\u1ecdmba lati n titi de m.\nYi idahun naa pada si n\u1ecdmba to sunm\u1ecd jul\u1ecd ati yi pada si binary.\nTi n ba tobi ju m l\u1ecd, da pada -1.\nApeere:\nrounded_avg => \"0b11\"\nrounded_avg => -1\nrounded_avg => \"0b1111\"\nrounded_avg => \"0b11010\"\n    \"\"\"\n",
        "canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"
    },
    {
        "prompt":"\ndef unique_digits(x):\n    \"\"\"F\u00fan \u00e0k\u00f3j\u1ecd \u00e0w\u1ecdn n\u01f9kan \u00ec\u1e63\u00f3di d\u00edd\u00e1 x. pad\u00e0 \u00e0k\u00f3j\u1ecd t\u00f3 ti \u1e63eto \u00e0w\u1ecdn n\u01f9kan gbogbo \n    t\u00ed k\u00f2 n\u00ed d\u00edj\u00edt\u00ec \u00e8\u00e9w\u00f2 kankan.\n\n    \u00c0k\u00edy\u00e8s\u00ed: \u00c0k\u00f3j\u1ecd t\u00ed a pad\u00e0 y\u1eb9 k\u00ed \u00f3 \u1e63eto n\u00ed atele.\n\n    Fun \u00e0p\u1eb9\u1eb9r\u1eb9:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n",
        "canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef by_length(arr):\n    \"\"\"\n    Ti o ba fun ni iranti ti aw\u1ecdn n\u1ecdmba g\u1eb9g\u1eb9bi \u1ecdkan, \u1e63eto aw\u1ecdn n\u1ecdmba ti o wa laarin 1 ati 9 ti o si yi iranti naa pada, l\u1eb9hinna r\u1ecdpo n\u1ecdmba k\u1ecd\u1ecdkan p\u1eb9lu oruk\u1ecd ti o baamu lati \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\nFun ap\u1eb9\u1eb9r\u1eb9:\n  arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n        -> \u1e63eto arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n        -> yi arr pada -> [8, 5, 4, 3, 2, 2, 1, 1]\n  pada [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n  Ti iranti ba \u1e63ofo, pada iranti ti o \u1e63ofo:\n  arr = []\n  pada []\n\n  Ti iranti ba ni n\u1ecdmba ajeji eyikeyi, foju r\u1eb9:\n  arr = [1, -1, 55] \n        -> \u1e63eto arr -> [-1, 1, 55]\n        -> yi arr pada -> [55, 1, -1]\n  pada = ['One']\n    \"\"\"\n",
        "canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"
    },
    {
        "prompt":"\ndef f(n):\n    \"\"\" Gbe i\u1e63\u1eb9\u0301 ti a np\u00e8 ni f kal\u1eb9\u0300 t\u00ed \u00f3 gba n g\u1eb9\u0301g\u1eb9\u0301 b\u00ed \u00e0w\u00e1\u00e0r\u00ed,\n    t\u00ed \u00f3 s\u00ec \u0144 pad\u00e0 \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 t\u00f3 n\u00ed iw\u1ecdn n, b\u1eb9\u0301\u1eb9\u0300 t\u00ed iye \u00e8r\u00f2j\u00e0 t\u00f3 w\u00e0 n\u00ed \u00eck\u00e0ns\u00ed i j\u1eb9\u0301 factorial ti i t\u00ed \u00f3 b\u00e1 j\u1eb9\u0301 \u00e8y\u00ed t\u00f3 y\u1eb9 \n    t\u00e0b\u00ed apap\u1ecd\u0300 \u00e0w\u1ecdn n\u01f9kan l\u00e1ti 1 s\u00ed i f\u00fan \u00e8y\u00ed t\u00ed k\u00f2 b\u00e1 y\u1eb9.\n    i b\u1eb9\u0300r\u1eb9\u0300 l\u00e1ti 1.\n    factorial ti i j\u1eb9\u0301 \u00ecsodip\u00fap\u00f2 \u00e0w\u1ecdn n\u01f9kan l\u00e1ti 1 s\u00ed i.\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    f == [1, 2, 6, 24, 15]\n    \"\"\"\n",
        "canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"
    },
    {
        "prompt":"\ndef even_odd_palindrome(n):\n    \"\"\"\n    Lati fun n\u1ecdmba odidi rere n, da pada tuple ti o ni n\u1ecdmba aw\u1ecdn palindromes odidi ti o j\u1eb9 deede ati ti ko j\u1eb9 deede ti o wa laarin ibiti, p\u1eb9lu.\n\nAp\u1eb9\u1eb9r\u1eb9 1:\n\n    Input: 3\n    Output:\n    Alaye:\n    Aw\u1ecdn palindrome odidi ni 1, 2, 3. \u1ecdkan ninu w\u1ecdn j\u1eb9 deede, ati meji ninu w\u1ecdn j\u1eb9 ti ko j\u1eb9 deede.\n\nAp\u1eb9\u1eb9r\u1eb9 2:\n\n    Input: 12\n    Output:\n    Alaye:\n    Aw\u1ecdn palindrome odidi ni 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. m\u1eb9rin ninu w\u1ecdn j\u1eb9 deede, ati m\u1eb9fa ninu w\u1ecdn j\u1eb9 ti ko j\u1eb9 deede.\n\nAkiyesi:\n    1. 1 <= n <= 10^3\n    2. tuple ti a da pada ni n\u1ecdmba aw\u1ecdn palindrome odidi ti o j\u1eb9 deede ati ti ko j\u1eb9 deede ni ibamu.\n    \"\"\"\n",
        "canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef count_nums(arr):\n    \"\"\"\n    Ko i\u1e63\u1eb9\u0301 \u00e0t\u1eb9\u0301w\u1ecd\u0301gba count_nums t\u00ed \u00f3 m\u00e1a gba \u00e0w\u00f2k\u1ecd \u00e0w\u1ecdn integer t\u00ed \u00f3 s\u00ec m\u00e1a pad\u00e0\n    iye \u00e0w\u1ecdn \u00e8y\u00e0 t\u00ed \u00f3 n\u00ed \u00e0k\u00f3\u00f3n\u00fa \u00e0w\u1ecdn \u00e0d\u00e0k\u1ecd t\u00ed \u00f3 t\u00f3bi ju 0 l\u1ecd.\n    B\u00ed iye n\u00e1\u00e0 b\u00e1 j\u1eb9\u0301 \u00f2d\u00ec, \u00e8y\u00ed t\u00ed \u00f3 k\u1ecd\u0301k\u1ecd\u0301 fi \u00ecm\u00fa\u1e63\u1eb9\u0300 \u00f2d\u00ed h\u00e0n y\u00f3\u00f2 j\u1eb9\u0301 \u00f2d\u00ed:\n    \u00e0p\u1eb9r\u1eb9, -123 n\u00ed \u00e0w\u1ecdn \u00e0d\u00e0k\u1ecd t\u00ed \u00f3 fi \u00f2d\u00ed h\u00e0n -1, 2, \u00e0ti 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef move_one_ball(arr):\n    \"\"\"A ni array 'arr' ti N aw\u1ecdn integer arr[1], arr[2], ..., arr[N]. Aw\u1ecdn n\u1ecdmba ninu array naa yoo wa ni a\u1e63\u1eb9 alaimu\u1e63in\u1e63in. I\u1e63\u1eb9 r\u1eb9 ni lati pinnu boya o \u1e63ee \u1e63e lati gba array ti o wa ni a\u1e63\u1eb9 ti ko ni dinku nipa \u1e63i\u1e63e i\u1e63\u1eb9 at\u1eb9le lori array ti a fun:\n    O gba \u1ecd laaye lati \u1e63e i\u1e63\u1eb9 gbigbe si apa \u1ecdtun ni n\u1ecdmba eyikeyi ti aw\u1ecdn akoko.\n\nI\u1e63\u1eb9 gbigbe si apa \u1ecdtun kan tum\u1ecd si gbigbe gbogbo aw\u1ecdn eroja ti array nipas\u1eb9 ipo kan si it\u1ecds\u1ecdna \u1ecdtun. Eroja ti o k\u1eb9hin ti array yoo gbe si ipo ib\u1eb9r\u1eb9 ninu array i.e. 0th index.\n\nTi o ba \u1e63ee \u1e63e lati gba array ti a \u1e63eto nipa \u1e63i\u1e63e i\u1e63\u1eb9 ti o wa loke, l\u1eb9hinna pada True bib\u1eb9k\u1ecd pada False.\nTi a fi array sil\u1eb9 sil\u1eb9 l\u1eb9hinna pada True.\n\nAkiyesi: A ti \u1e63e i\u1e63eduro pe akoj\u1ecd ti a fun ni aw\u1ecdn eroja alail\u1eb9gb\u1eb9.\n\nFun Ap\u1eb9\u1eb9r\u1eb9:\n\nmove_one_ball==>True\nAlaye: Nipa \u1e63i\u1e63e aw\u1ecdn i\u1e63\u1eb9 gbigbe si apa \u1ecdtun meji, a\u1e63\u1eb9 ti ko ni dinku le \u1e63e a\u1e63ey\u1ecdri fun array ti a fun.\nmove_one_ball==>False\nAlaye: Ko \u1e63ee \u1e63e lati gba a\u1e63\u1eb9 ti ko ni dinku fun array ti a fun nipa \u1e63i\u1e63e eyikeyi n\u1ecdmba ti aw\u1ecdn i\u1e63\u1eb9 gbigbe si apa \u1ecdtun.\n                \n    \"\"\"\n",
        "canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"
    },
    {
        "prompt":"\ndef exchange(lst1, lst2):\n    \"\"\"Ninu i\u1e63oro yii, iw\u1ecd yoo \u1e63e agbekal\u1eb9 i\u1e63\u1eb9 kan ti o mu aw\u1ecdn akoj\u1ecd meji ti aw\u1ecdn n\u1ecdmba,\nati pinnu boya o \u1e63ee\u1e63e lati \u1e63e pa\u1e63ipaar\u1ecd aw\u1ecdn eroja laarin w\u1ecdn lati \u1e63e lst1 di akoj\u1ecd aw\u1ecdn n\u1ecdmba ti o j\u1eb9 paapaa nikan.\nKo si opin lori n\u1ecdmba aw\u1ecdn eroja ti a pa\u1e63ipaar\u1ecd laarin lst1 ati lst2.\nTi o ba \u1e63ee \u1e63e lati pa\u1e63ipaar\u1ecd aw\u1ecdn eroja laarin lst1 ati lst2 lati j\u1eb9 ki gbogbo aw\u1ecdn eroja ti lst1 j\u1eb9 paapaa, da pada \"B\u1eb8\u1eb8NI\".\nBib\u1eb9\u1eb9k\u1ecd, da pada \"RARA\".\nFun ap\u1eb9\u1eb9r\u1eb9:\nexchange => \"B\u1eb8\u1eb8NI\"\nexchange => \"RARA\"\nA ro pe aw\u1ecdn akoj\u1ecd ti a fi sii kii yoo \u1e63ofo.\n    \"\"\"\n",
        "canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"
    },
    {
        "prompt":"\ndef histogram(test):\n    \"\"\"Fun \u1ecdr\u1ecd kan ti o nsoju l\u1eb9ta kekere ti o pin nipas\u1eb9 aaye, da dictionary pada ti l\u1eb9ta ti o ni i\u1e63afihan pup\u1ecd jul\u1ecd ati ti o ni kika to baamu. Ti \u1ecdp\u1ecdl\u1ecdp\u1ecd aw\u1ecdn l\u1eb9ta ba ni aw\u1ecdn igbagbogbo kanna, da gbogbo w\u1ecdn pada.\n\nAp\u1eb9\u1eb9r\u1eb9:\nhistogram == {'a': 1, 'b': 1, 'c': 1}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'a': 2, 'b': 2}\nhistogram == {'b': 4}\nhistogram == {}\n\n    \"\"\"\n",
        "canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef reverse_delete(s,c):\n    \"\"\"A \u1e63e fun wa l\u1eb9ta meji s ati c, o gb\u1ecdd\u1ecd pa gbogbo aw\u1ecdn ohun kik\u1ecd inu s ti o baamu eyikeyi ohun kik\u1ecd inu c \nl\u1eb9hinna \u1e63ay\u1eb9wo boya l\u1eb9ta abajade j\u1eb9 palindrome.\nA pe l\u1eb9ta kan ni palindrome ti o ba ka ni \u1ecdna kanna siwaju bi o \u1e63e j\u1eb9 s\u1eb9hin.\nO y\u1eb9 ki o pada tuple ti o ni l\u1eb9ta abajade ati Otit\u1ecd\/Ir\u1ecd fun ayewo naa.\nApeere\nFun s = \"abcde\", c = \"ae\", abajade y\u1eb9 ki o j\u1eb9\nFun s = \"abcdef\", c = \"b\" abajade y\u1eb9 ki o j\u1eb9\nFun s = \"abcdedcba\", c = \"ab\", abajade y\u1eb9 ki o j\u1eb9\n    \"\"\"\n",
        "canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n",
        "test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"
    },
    {
        "prompt":"\ndef odd_count(lst):\n    \"\"\"Fun atok\u1ecd aw\u1ecdn okun, nibiti \u1ecdk\u1ecd\u1ecdkan okun naa j\u1eb9 ti aw\u1ecdn n\u1ecdmba nikan, pada atok\u1ecd kan.\n    Gbogbo eroja i ti esi y\u1eb9 ki o j\u1eb9 \"n\u1ecdmba aw\u1ecdn eroja ti ko paapaa ninu\n    okun i ti \u1eb9nu-\u1ecdna.\" nibiti gbogbo aw\u1ecdn i y\u1eb9 ki o r\u1ecdpo nipas\u1eb9 n\u1ecdmba\n    aw\u1ecdn n\u1ecdmba ti ko paapaa ninu okun i ti \u1eb9nu-\u1ecdna.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n",
        "canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minSubArraySum(nums):\n    \"\"\"\n    Gb\u1ecd\u0301n \u00e0w\u1ecdn k\u00e0y\u00e9\u0323 \u00e0w\u1ecdn n\u01f9kan in\u00fa \u00e0k\u00f3j\u1ecd \u00e0w\u1ecdn \u00ect\u00f2\u0323n\u00e0 \u00ec\u1e63\u00edr\u00f2, w\u00e1 \u00ecs\u00fanm\u00edn\u00ecn\u00ed k\u00e9ker\u00e9 j\u00f9 l\u1ecd ti \u00e8y\u00edk\u00e9y\u00ec\u00ed \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 kankan t\u00ed k\u00f2 \u1e63\u00f3fo n\u00edn\u00fa \u00e0k\u00f3j\u1ecd n\u00e1\u00e0.\n\u00c0p\u1eb9\u1eb9r\u1eb9\nminSubArraySum == 1\nminSubArraySum == -6\n    \"\"\"\n",
        "canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"
    },
    {
        "prompt":"\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"\n    A o fun \u1ecd ni akoj\u1ecdp\u1ecd onigun m\u1eb9rin ti aw\u1ecdn kanga. \u1eb8ka k\u1ecd\u1ecdkan n \u1e63e a\u1e63oju kanga kan,\n    ati pe \u1ecdk\u1ecd\u1ecdkan 1 ninu \u1eb9ka kan n \u1e63e a\u1e63oju \u1eb9y\u1ecdkan omi kan.\n    Kanga k\u1ecd\u1ecdkan ni agbada ti o baamu ti a le lo lati fa omi jade lati inu r\u1eb9,\n    ati gbogbo aw\u1ecdn agbada ni agbara kanna.\n    I\u1e63\u1eb9 r\u1eb9 ni lati lo aw\u1ecdn agbada lati s\u1ecd aw\u1ecdn kanga di ofo.\n    Jade n\u1ecdmba igba ti o nilo lati s\u1ecd aw\u1ecdn agbada sil\u1eb9.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9 1:\n        Input:\n            akoj\u1ecdp\u1ecd: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            agbara_agbada: 1\n        Output: 6\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9 2:\n        Input:\n            akoj\u1ecdp\u1ecd: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            agbara_agbada: 2\n        Output: 5\n    \n    \u00c0p\u1eb9\u1eb9r\u1eb9 3:\n        Input:\n            akoj\u1ecdp\u1ecd: [[0,0,0], [0,0,0]]\n            agbara_agbada: 5\n        Output: 0\n\n    Aw\u1ecdn ilana:\n        * gbogbo aw\u1ecdn kanga ni gigun kanna\n        * 1 <= gigun.akoj\u1ecdp\u1ecd <= 10^2\n        * 1 <= gigun.akoj\u1ecdp\u1ecd[:,1] <= 10^2\n        * akoj\u1ecdp\u1ecd[i][j] -> 0 | 1\n        * 1 <= agbara <= 10\n    \"\"\"\n",
        "canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n",
        "test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"
    },
    {
        "prompt":"\ndef sort_array(arr):\n    \"\"\"\n    Ninu Kata yii, o ni lati \u1e63e tito l\u1eb9\u0161\u1eb9\u0161\u1eb9 array ti aw\u1ecdn integers ti kii \u1e63e odi ni ibamu si\n    n\u1ecdmba aw\u1ecdn \u1ecdkan ninu a\u1e63oju binary w\u1ecdn ni a\u1e63\u1eb9 il\u1ecdsiwaju.\n    Fun n\u1ecdmba aw\u1ecdn \u1ecdkan ti o j\u1ecdra, \u1e63e tito l\u1eb9\u0161\u1eb9\u0161\u1eb9 ni ibamu si iye on\u00edm\u1ecd\u0300kan.\n\n    O gb\u1ecdd\u1ecd \u1e63e b\u1eb9\u0300\u1eb9\u0300 g\u1eb9g\u1eb9 b\u00edi:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n",
        "canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef select_words(s, n):\n    \"\"\"Eyi ni gbolohun ti o wa ni Yoruba:\n\nF\u00fan \u1ecd\u0300r\u1ecd\u0300 s kan \u00e0ti iye \u00e0d\u00edd\u00e1 n kan, o ti fun \u1ecd ni i\u1e63\u1eb9\u0301 l\u00e1ti \u1e63e \u00ecm\u00fa\u1e63\u1eb9\u0301 i\u1e63\u1eb9\u0301 kan t\u00ed y\u00f3\u00f2 pad\u00e0 \n\u00e0t\u1eb9\u0300j\u00e1de gbogbo \u1ecd\u0300r\u1ecd\u0300 l\u00e1ti inu \u1ecd\u0300r\u1ecd\u0300 s t\u00ed \u00f3 n\u00ed gangan \nn konsonanti, n\u00ed a\u1e63\u1eb9 \u00e0w\u1ecdn \u1ecd\u0300r\u1ecd\u0300 y\u00ec\u00ed \u1e63e farah\u00e0n n\u00edn\u00fa \u1ecd\u0300r\u1ecd\u0300 s.\nT\u00ed \u1ecd\u0300r\u1ecd\u0300 s b\u00e1 \u1e63\u00f3fo\u0300, n\u00edgb\u00e0 n\u00e1\u00e0 i\u1e63\u1eb9\u0301 n\u00e1\u00e0 gb\u1ecd\u0301d\u1ecd\u0300 pad\u00e0 \u00e0t\u1eb9\u0300j\u00e1de \u00e0k\u00f3j\u1ecd \u00ec\u1e63\u00f3fo\u0300.\n\u00c0k\u00edy\u00e8s\u00ed: o l\u00e8 fura p\u00e9 \u1ecd\u0300r\u1ecd\u0300 \u00ecb\u00f9k\u00fan n\u00e1\u00e0 n\u00ed \u00e0w\u1ecdn l\u1eb9\u0301t\u00e0 \u00e0ti \u00e0w\u1ecdn \u00e0\u00e0y\u00e8 n\u00eckan.\n\u00c0p\u1eb9\u1eb9r\u1eb9:\nselect_words ==> [\"little\"]\nselect_words ==> [\"Mary\", \"lamb\"]\nselect_words ==> []\nselect_words ==> [\"world\"]\nselect_words ==> [\"Uncle\"]\n    \"\"\"\n",
        "canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"
    },
    {
        "prompt":"\ndef get_closest_vowel(word):\n    \"\"\"O j\u1eb9\u0301 k\u00ed o f\u00fan n\u00ed \u1ecd\u0300r\u1ecd\u0300 kan. \u00cc\u1e63\u1eb9\u0301 r\u1eb9 ni l\u00e1ti w\u00e1 faw\u00e9\u00e9l\u00ec t\u00f3 s\u00fan m\u1ecd\u0301 \u00e0w\u1ecdn f\u00e1w\u1ecd\u0301 y\u1eb9n t\u00ed \u00f3 w\u00e0 l\u00e1\u00e0\u00e1r\u00edn f\u00e1w\u1ecd\u0301 m\u00e9j\u00ec l\u00e1ti \u1eb9\u0300b\u00e1 \u1ecd\u0300t\u00fan \u1ecd\u0300r\u1ecd\u0300 n\u00e1\u00e0.\n\nFaw\u00e9\u00e9l\u00ec t\u00f3 w\u00e0 n\u00edb\u1eb9\u0300r\u00e8 \u00e0ti n\u00ed \u00ecpar\u00ed k\u00f2 \u1e63e k\u00e0. Pada s\u00eck\u00ecr\u00ec t\u00ed o b\u00e1 k\u1ecd\u0301 r\u00ed faw\u00e9\u00e9l\u00ec t\u00f3 b\u00e1 \u00ecl\u00e0n\u00e0 y\u00ec\u00ed mu.\n\nO l\u00e8 foj\u00fa b\u00e1y\u00e9 p\u00e9 \u1ecd\u0300r\u1ecd\u0300 f\u00fan un ni \u00e8d\u00e8 G\u1eb9\u0300\u1eb9\u0301s\u00ec n\u00eckan ni \u00f3 f\u00fan un.\n\n\u00c0p\u1eb9\u1eb9r\u1eb9:\nget_closest_vowel ==> \"u\"\nget_closest_vowel ==> \"U\"\nget_closest_vowel ==> \"\"\nget_closest_vowel ==> \"\"\n    \"\"\"\n",
        "canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n",
        "canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"
    },
    {
        "prompt":"\ndef maximum(arr, k):\n    \"\"\"\n    GIVEN an array arr of integers and a positive integer k, return a sorted list of length k with the maximum k numbers in arr.\n\nExample1:\n\nInput: arr = [-3, -4, 5], k = 3\nOutput: [-4, -3, 5]\n\nExample2:\n\nInput: arr = [4, -4, 4], k = 2\nOutput: [4, 4]\n\nExample3:\n\nInput: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\nOutput: [2]\n\nNote:\n1. The length of the array will be in the range of [1, 1000].\n2. The elements in the array will be in the range of [-1000, 1000].\n3. 0 <= k <= len\n\nYoruba Translation:\n\nFun array arr ti aw\u1ecdn n\u1ecdmba ati n\u1ecdmba k ti o dara, da pada atok\u1ecd ti o wa ni tito p\u1eb9lu gigun k p\u1eb9lu aw\u1ecdn n\u1ecdmba k ti o p\u1ecdju ninu arr.\n\nApeere1:\n\nIw\u1ecdle: arr = [-3, -4, 5], k = 3\nEsi: [-4, -3, 5]\n\nApeere2:\n\nIw\u1ecdle: arr = [4, -4, 4], k = 2\nEsi: [4, 4]\n\nApeere3:\n\nIw\u1ecdle: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\nEsi: [2]\n\nAkiyesi:\n1. Gigun array yoo wa ni ibiti [1, 1000].\n2. Aw\u1ecdn eroja ninu array yoo wa ni ibiti [-1000, 1000].\n3. 0 <= k <= len\n    \"\"\"\n",
        "canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"
    },
    {
        "prompt":"\ndef solution(lst):\n    \"\"\"Ti a ba fun akoj\u1ecd ti kii \u1e63e ofo ti aw\u1ecdn n\u1ecdmba odidi, pada apap\u1ecd gbogbo aw\u1ecdn eroja alail\u1eb9gb\u1eb9 ti o wa ni aw\u1ecdn ipo paapaa.\n\nAw\u1ecdn ap\u1eb9\u1eb9r\u1eb9\nsolution ==> 12\nsolution ==> 9\nsolution ==> 0\n    \"\"\"\n",
        "canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"
    },
    {
        "prompt":"\ndef add_elements(arr, k):\n    \"\"\"\n    Fun \u00e0t\u1eb9\u0301g\u00f9n \u00e0k\u1ecd\u0301k\u1ecd\u0301 ti \u00e0w\u1ecdn n\u01f9kan \u00e0\u00ecl\u00f2fo arr \u00e0ti \u00ec\u1e63\u1ecd\u0300kan k, pad\u00e0\n    iye \u00e0pap\u1ecd\u0300 \u00e0w\u1ecdn er\u00e9 t\u00ed \u00f3 m\u00e1 n\u00ed d\u00edg\u00ect\u00ec m\u00e9j\u00ec l\u00e1ti \u00e0w\u1ecdn er\u00e9 k \u00e0k\u1ecd\u0301k\u1ecd\u0301 ti arr.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n\n        \u00ccb\u1eb9\u0300r\u1eb9\u0300: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Ebi: 24 # sum of 21 + 3\n\n    \u00c0w\u1ecdn \u00ecd\u00edyel\u00e9:\n        1. 1 <= g\u00edg\u00f9n <= 100\n        2. 1 <= k <= g\u00edg\u00f9n\n    \"\"\"\n",
        "canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef get_odd_collatz(n):\n    \"\"\"\n    Nitorinaa fun n je iye odun to ni rere, pada si akojopo to ti wa ni itoka, ti o ni awon iye to je odun ninu ipawo Collatz.\n\n    Ipawo Collatz je ipawo ninu mathimatiki ti o ni ibatan si akojopo ti a se alaye\n    bi eyi: bere pelu iye odun to ni rere n. Leyin naa, olodun k\u1ecd\u1ecdkan ni a gba lati\n    odo olodun to tele bi eyi: ti olodun to tele ba je mejeeji, olodun to nbo ni idaji \n    ti olodun to tele. Ti olodun to tele ba je odun, olodun to nbo ni 3 igba ti olodun to tele\n    pelu 1. Ironu naa ni pe laibikita iye ti n je, akojopo naa yoo ma de 1 ni gbogbo igba.\n\n    Akosile:\n        1. Collatz je [1].\n        2. Akosile ti a pada si ni itoka ni ona to npo si.\n\n    Fun apeere:\n    get_odd_collatz pada [1, 5] # Ipawo collatz fun 5 je [5, 16, 8, 4, 2, 1], nitorina awon iye to je odun je 1 ati 5 nikan.\n    \"\"\"\n",
        "canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef valid_date(date):\n    \"\"\"O ni lati k\u1ecd i\u1e63\u1eb9 kan ti yoo \u1e63ay\u1eb9wo boya okun \u1ecdj\u1ecd kan j\u1eb9 deede ati\n    pada otit\u1ecd ti \u1ecdj\u1ecd naa ba j\u1eb9 deede bib\u1eb9\u1eb9k\u1ecd iro.\n    \u1eccj\u1ecd naa j\u1eb9 deede ti gbogbo aw\u1ecdn ofin w\u1ecdnyi ba ni it\u1eb9l\u1ecdrun:\n    1. Okun \u1ecdj\u1ecd ko y\u1eb9 ki o \u1e63ofo.\n    2. N\u1ecdmba aw\u1ecdn \u1ecdj\u1ecd ko y\u1eb9 ki o kere ju 1 tabi ju aw\u1ecdn \u1ecdj\u1ecd 31 l\u1ecd fun aw\u1ecdn o\u1e63u 1,3,5,7,8,10,12. Ati pe n\u1ecdmba aw\u1ecdn \u1ecdj\u1ecd ko y\u1eb9 ki o kere ju 1 tabi ju aw\u1ecdn \u1ecdj\u1ecd 30 l\u1ecd fun aw\u1ecdn o\u1e63u 4,6,9,11. Ati pe, n\u1ecdmba aw\u1ecdn \u1ecdj\u1ecd ko y\u1eb9 ki o kere ju 1 tabi ju aw\u1ecdn \u1ecdj\u1ecd 29 l\u1ecd fun o\u1e63u 2.\n    3. Aw\u1ecdn o\u1e63u ko y\u1eb9 ki o kere ju 1 tabi ju 12 l\u1ecd.\n    4. \u1eccj\u1ecd naa y\u1eb9 ki o wa ni \u1ecdna kika yii: mm-dd-yyyy\n\n    fun ap\u1eb9\u1eb9r\u1eb9:\n    valid_date => Otit\u1ecd\n\n    valid_date => Iro\n\n    valid_date => Iro\n\n    valid_date => Otit\u1ecd\n\n    valid_date => Iro\n    \"\"\"\n",
        "canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"
    },
    {
        "prompt":"\ndef split_words(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    split_words(\"Hello world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") \u00e2 -> [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n",
        "canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n",
        "test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"
    },
    {
        "prompt":"\ndef is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5]) \u00e2 -> False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u00e2 -> True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2 -> True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2 -> False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u00e2 -> True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u00e2 -> False\n    '''\n",
        "canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef intersection(interval1, interval2):\n    \"\"\"A ti fun \u1ecd ni aw\u1ecdn aaye meji, \n    nibiti \u1ecdk\u1ecd\u1ecdkan aaye j\u1eb9 t\u1ecdk\u1ecdtaya aw\u1ecdn n\u1ecdmba. Fun ap\u1eb9\u1eb9r\u1eb9, aaye = =.\n    Aw\u1ecdn aaye ti a fun ni ti pari eyi ti o tum\u1ecd si pe aaye\n    p\u1eb9lu mejeeji ib\u1eb9r\u1eb9 ati ipari.\n    Fun \u1ecdk\u1ecd\u1ecdkan aaye ti a fun, a ro pe ib\u1eb9r\u1eb9 r\u1eb9 kere tabi dogba si ipari r\u1eb9.\n    I\u1e63\u1eb9 r\u1eb9 ni lati pinnu boya gigun ti ifipam\u1ecd ti aw\u1ecdn aaye meji w\u1ecdnyi j\u1eb9 n\u1ecdmba alaibamu.\n    Ap\u1eb9\u1eb9r\u1eb9, ifipam\u1ecd ti aw\u1ecdn aaye, j\u1eb9\n    eyiti gigun r\u1eb9 j\u1eb9 1, eyiti kii \u1e63e n\u1ecdmba alaibamu.\n    Ti gigun ti ifipam\u1ecd j\u1eb9 n\u1ecdmba alaibamu, pada \"B\u1eb8\u1eb8NI\",\n    bib\u1eb9\u1eb9k\u1ecd, pada \"RARA\".\n    Ti aw\u1ecdn aaye meji ko ba ifipam\u1ecd, pada \"RARA\".\n\n    [ap\u1eb9\u1eb9r\u1eb9 ti igbew\u1ecdle\/igbesi jade]:\n    ifipam\u1ecd,) ==> \"RARA\"\n    ifipam\u1ecd,) ==> \"RARA\"\n    ifipam\u1ecd,) ==> \"B\u1eb8\u1eb8NI\"\n    \"\"\"\n",
        "canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"
    },
    {
        "prompt":"\ndef prod_signs(arr):\n    \"\"\"\n    O ti fun \u1ecd ni array arr ti aw\u1ecdn integers ati pe o nilo lati pada\n    apap\u1ecd aw\u1ecdn iw\u1ecdn ti aw\u1ecdn integers ti a p\u1ecd si nipas\u1eb9 \u1ecdja ti gbogbo aw\u1ecdn ami\n    ti n\u1ecdmba k\u1ecd\u1ecdkan ninu array, ti a \u1e63afihan nipas\u1eb9 1, -1 tabi 0.\n    Ak\u1ecdsil\u1eb9: pada Ko si fun arr ti ko ni nkankan.\n\n    Ap\u1eb9\u1eb9r\u1eb9:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n",
        "canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef minPath(grid, k):\n    \"\"\"\n    Eyi ni itum\u1ecd \u1ecdr\u1ecd naa si ede Yoruba:\n\nNi fifun akoj\u1ecdp\u1ecd p\u1eb9lu aw\u1ecdn ila N ati aw\u1ecdn iwe N ati n\u1ecdmba ti o dara k, \n    k\u1ecd\u1ecdkan ti akoj\u1ecdp\u1ecd naa ni iye kan. Gbogbo n\u1ecdmba laarin ibiti [1, N * N]\n    p\u1eb9lu han l\u1eb9\u1eb9kan \u1e63o\u1e63o lori aw\u1ecdn s\u1eb9\u1eb9li ti akoj\u1ecdp\u1ecd naa.\n\n    O ni lati wa \u1ecdna to kere jul\u1ecd ti o ni gigun k ninu akoj\u1ecdp\u1ecd naa. O le b\u1eb9r\u1eb9\n    lati eyikeyi s\u1eb9\u1eb9li, ati ni igbese k\u1ecd\u1ecdkan o le gbe si eyikeyi aw\u1ecdn s\u1eb9\u1eb9li aladugbo,\n    ni aw\u1ecdn \u1ecdr\u1ecd miiran, o le l\u1ecd si aw\u1ecdn s\u1eb9\u1eb9li ti o pin eti p\u1eb9lu s\u1eb9\u1eb9li l\u1ecdw\u1ecdl\u1ecdw\u1ecd r\u1eb9.\n    J\u1ecdw\u1ecd \u1e63e akiyesi pe \u1ecdna ti o ni gigun k tum\u1ecd si ibewo gangan ti k s\u1eb9\u1eb9li.\n    O KO le l\u1ecd jade kuro ninu akoj\u1ecdp\u1ecd naa.\n    \u1eccna A ni a \u1e63e akiyesi kere ju \u1ecdna B ti \n    l\u1eb9hin ti o \u1e63e aw\u1ecdn atok\u1ecd ti aw\u1ecdn iye lori aw\u1ecdn s\u1eb9\u1eb9li ti A ati B k\u1ecdja, \n    lst_A j\u1eb9 lexicographically kere ju lst_B, ni aw\u1ecdn \u1ecdr\u1ecd miiran, o wa n\u1ecdmba it\u1ecdka kan i\n    b\u1eb9 ti lst_A[i] < lst_B[i] ati fun eyikeyi j a ni\n    lst_A[j] = lst_B[j].\n    O ti ni idaniloju pe idahun naa j\u1eb9 alail\u1eb9gb\u1eb9.\n    Pada atok\u1ecd ti aw\u1ecdn iye lori aw\u1ecdn s\u1eb9\u1eb9li ti \u1ecdna to kere jul\u1ecd k\u1ecdja.\n\n    Aw\u1ecdn apeere:\n\n        Iw\u1ecdle: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Idahun: [1, 2, 1]\n\n        Iw\u1ecdle: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Idahun: [1]\n    \"\"\"\n",
        "canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"
    },
    {
        "prompt":"\ndef tri(n):\n    \"\"\"Gbogbo eniyan m\u1ecd Fibonacci l\u1eb9s\u1eb9s\u1eb9, aw\u1ecdn onim\u1ecd-j\u00ecy\u00e0 ti \u1e63e iwadii r\u1eb9 jinl\u1eb9 ni aw\u1ecdn \u1ecdg\u1ecdrun \u1ecddun di\u1eb9 to k\u1ecdja. Sib\u1eb9sib\u1eb9, ohun ti aw\u1ecdn eniyan ko m\u1ecd ni l\u1eb9s\u1eb9s\u1eb9 Tribonacci. L\u1eb9s\u1eb9s\u1eb9 Tribonacci j\u1eb9 as\u1ecdye nipas\u1eb9 if\u1eb9s\u1eb9mul\u1eb9:\n    tri = 3\n    tri = 1 + n \/ 2, ti n ba j\u1eb9 meji.\n    tri = tri + tri + tri, ti n ba j\u1eb9 kan.\n    Fun ap\u1eb9\u1eb9r\u1eb9:\n    tri = 1 + = 2\n    tri = 3\n    tri = tri + tri + tri\n           = 2 + 3 + 3 = 8\nO ti fun \u1ecd ni n\u1ecdmba integer ti kii \u1e63e odi n, o ni lati pada akoj\u1ecd ti aw\u1ecdn n\u1ecdmba ak\u1ecdk\u1ecd n + 1 ti l\u1eb9s\u1eb9s\u1eb9 Tribonacci.\n    Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9:\n    tri = [1, 3, 2, 8]\n    \"\"\"\n",
        "canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"
    },
    {
        "prompt":"\ndef digits(n):\n    \"\"\"Eyi ni nomba odidi rere n, pada \u1ecdja aw\u1ecdn n\u1ecdmba oni-n\u1ecdmba ti o j\u1eb9 alail\u1eb9gb\u1eb9.\n    Pada 0 ti gbogbo aw\u1ecdn n\u1ecdmba oni-n\u1ecdmba j\u1eb9 ani.\n    Fun ap\u1eb9\u1eb9r\u1eb9:\n    digits  == 1\n    digits  == 0\n    digits == 15\n    \"\"\"\n",
        "canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"
    },
    {
        "prompt":"\ndef is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    is_nested('[[]]') \u00e2 -> True\n    is_nested('[]]]]]]][[[[[]') \u00e2 -> False\n    is_nested('[][]') \u00e2 -> False\n    is_nested('[]') \u00e2 -> False\n    is_nested('[[][]]') \u00e2 -> True\n    is_nested('[[]][[') \u00e2 -> True\n    '''\n",
        "canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"
    },
    {
        "prompt":"\n\ndef sum_squares(lst):\n    \"\"\"O ti fun ni akoj\u1ecd ti aw\u1ecdn n\u1ecdmba.\n    O nilo lati da pada apap\u1ecd ti aw\u1ecdn n\u1ecdmba ti o j\u1eb9 onigun m\u1eb9rin ninu akoj\u1ecd ti a fun,\n    yika \u1ecdk\u1ecd\u1ecdkan ni akoj\u1ecd si n\u1ecdmba oke ak\u1ecdk\u1ecd.\n    Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9:\n    Fun lst = [1,2,3] esi y\u1eb9 ki o j\u1eb9 14\n    Fun lst = [1,4,9] esi y\u1eb9 ki o j\u1eb9 98\n    Fun lst = [1,3,5,7] esi y\u1eb9 ki o j\u1eb9 84\n    Fun lst = [1.4,4.2,0] esi y\u1eb9 ki o j\u1eb9 29\n    Fun lst = [-2.4,1,1] esi y\u1eb9 ki o j\u1eb9 6\n    \n\n    \"\"\"\n",
        "canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter(\"apple pie\") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"apple pi e\") \u00e2 -> True\n    check_if_last_char_is_a_letter(\"apple pi e \") \u00e2 -> False\n    check_if_last_char_is_a_letter(\"\") \u00e2 -> False \n    '''\n",
        "canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef can_arrange(arr):\n    \"\"\"Here's a translation of the provided text into Yoruba:\n\n\u1e62\u1eb9da i\u1e63\u1eb9 kan ti o pada ipinl\u1eb9 ti o tobi jul\u1ecd ti ohun kan ti ko tobi ju tabi d\u1ecdgba si ohun ti o wa l\u1eb9s\u1eb9k\u1eb9s\u1eb9 \u1e63aaju r\u1eb9. Ti ko ba si iru ohun b\u1eb9\u1eb9, l\u1eb9hinna pada -1. \u1eb8gb\u1eb9 ti a fun ko ni ni aw\u1ecdn iye ti o j\u1ecd.\n\n\u00c0p\u1eb9\u1eb9r\u1eb9:\ncan_arrange = 3\ncan_arrange = -1\n    \"\"\"\n",
        "canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"
    },
    {
        "prompt":"\ndef largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n",
        "canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"
    },
    {
        "prompt":"\ndef compare_one(a, b):\n    \"\"\"\n    \u1e62\u1eb9da i\u1e63\u1eb9 kan ti o gba aw\u1ecdn n\u1ecdmba gidi, boya w\u1ecdn j\u1eb9 integers, floats, tabi aw\u1ecdn okun ti o nsoju aw\u1ecdn n\u1ecdmba gidi, ki o si pada n\u1ecdmba ti o tobi jul\u1ecd ninu iru oniruuru r\u1eb9. Pada None ti aw\u1ecdn iye ba j\u1eb9 dogba.\nAkiyesi: Ti n\u1ecdmba gidi ba j\u1eb9 a\u1e63oju bi okun, aaye fif\u1eb9 le j\u1eb9 . tabi ,\n\ncompare_one -> 2.5\ncompare_one -> \"2,3\"\ncompare_one -> \"6\"\ncompare_one -> None\n    \"\"\"\n",
        "canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef is_equal_to_sum_even(n):\n    \"\"\"\u1e62e ay\u1eb9wo boya n\u1ecdmba ti a fun n le \u1e63ee k\u1ecd bi apap\u1ecd ti aw\u1ecdn n\u1ecdmba meji ti o dara jul\u1ecd 4.\n    Apeere\n    is_equal_to_sum_even == Iro\n    is_equal_to_sum_even == Iro\n    is_equal_to_sum_even == Otit\u1ecd\n    \"\"\"\n",
        "canonical_solution":"    return n%2 == 0 and n >= 8\n",
        "test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"
    },
    {
        "prompt":"\ndef special_factorial(n):\n    \"\"\"Fak\u00edt\u00f2r\u00ed\u00e0l\u00ec Br\u00e1s\u00edl\u00ec\u00e0n\u00ed ti wa ni as\u1ecdye bi:\n    brazilian_factorial = n! *! *! * ... * 1!\n    n\u00edbi t\u00ed n > 0\n\n    F\u00fan \u00e0p\u1eb9\u1eb9r\u1eb9:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n",
        "canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"
    },
    {
        "prompt":"\ndef fix_spaces(text):\n    \"\"\"\n    Gbe gbolohun ti a fun sinu ede Yoruba.\n\nTi a ba fun ni okun \u1ecdr\u1ecd kan, r\u1ecdpo gbogbo aw\u1ecdn aaye inu r\u1eb9 p\u1eb9lu aw\u1ecdn underscores, \nati pe ti okun \u1ecdr\u1ecd ba ni di\u1eb9 sii ju aw\u1ecdn aaye meji l\u1ecd ni at\u1eb9le, \nnigbana r\u1ecdpo gbogbo aw\u1ecdn aaye at\u1eb9le p\u1eb9lu -\n\nfix_spaces == \"Example\"\nfix_spaces == \"Example_1\"\nfix_spaces == \"_Example_2\"\nfix_spaces == \"_Example-3\"\n    \"\"\"\n",
        "canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef file_name_check(file_name):\n    \"\"\"\u1e62\u1eb9da i\u1e63\u1eb9 kan ti o gba okun ti o nsoju oruk\u1ecd faili kan, o si pada 'B\u1eb9\u1eb9ni' ti oruk\u1ecd faili naa ba j\u1eb9 \u1eb9t\u1ecd, o si pada 'Rara' bib\u1eb9\u1eb9k\u1ecd.\nOruk\u1ecd faili j\u1eb9 \u1eb9t\u1ecd ti ati nikan ti gbogbo aw\u1ecdn ipo w\u1ecdnyi ba pade:\n- Ko y\u1eb9 ki o ju aw\u1ecdn n\u1ecdmba m\u1eb9ta l\u1ecd ninu oruk\u1ecd faili naa.\n- Oruk\u1ecd faili naa ni gangan \u1ecdkan dot '.'\n- Apakan ti o wa \u1e63aaju dot ko y\u1eb9 ki o j\u1eb9 ofo, o si b\u1eb9r\u1eb9 p\u1eb9lu l\u1eb9ta lati inu alfabeti latin.\n- Apakan ti o wa l\u1eb9hin dot y\u1eb9 ki o j\u1eb9 \u1ecdkan ninu aw\u1ecdn w\u1ecdnyi: ['txt', 'exe', 'dll']\n\u00c0p\u1eb9\u1eb9r\u1eb9:\nfile_name_check # => 'B\u1eb9\u1eb9ni'\nfile_name_check # => 'Rara'\n    \"\"\"\n",
        "canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"
    },
    {
        "prompt":"\n\n\ndef sum_squares(lst):\n    \"\"\"\u1eb8s\u1eb9\u0301 y\u00ec\u00ed y\u00f3\u00f2 gba \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 \u00e0w\u1ecdn n\u01f9kan t\u00f3 j\u1eb9\u0301 \u00ecntegeru. Fun gbogbo ohun t\u00f3 w\u00e0 n\u00edn\u00fa \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 n\u00e1\u00e0, \u1eb9s\u1eb9\u0301 y\u00f3\u00f2 y\u1ecd\u0301 \u00ecntegeru n\u00e1\u00e0 s\u00ed square b\u00ed \u00f3 b\u00e1 j\u1eb9\u0301 p\u00e9 or\u00fak\u1ecd n\u01f9kan n\u00e1\u00e0 j\u1eb9\u0301 \u00e8y\u00ed t\u00ed \u00f3 j\u1eb9\u0301 \u00ecsej\u00fa m\u1eb9\u0301ta, y\u00f3\u00f2 s\u00ec y\u1ecd\u0301 \u00ecntegeru n\u00e1\u00e0 s\u00ed cube b\u00ed or\u00fak\u1ecd r\u1eb9\u0300 j\u1eb9\u0301 \u00e8y\u00ed t\u00ed \u00f3 j\u1eb9\u0301 \u00ecsej\u00fa m\u1eb9\u0301rin \u00e0ti p\u00e9 k\u00f2 j\u1eb9\u0301 \u00ecsej\u00fa m\u1eb9\u0301ta. \u1eb8s\u1eb9\u0301 n\u00e1\u00e0 m\u00e1a y\u00ed \u00e0w\u1ecdn n\u01f9kan n\u00edn\u00fa \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 n\u00e1\u00e0 t\u00ed or\u00fak\u1ecd w\u1ecdn k\u00f2 j\u1eb9\u0301 \u00ecsej\u00fa m\u1eb9\u0301ta t\u00e0b\u00ed m\u1eb9\u0301rin pad\u00e0. \u1eb8s\u1eb9\u0301 y\u00f3\u00f2 s\u00ec t\u00fan pad\u00e0 p\u1eb9\u0300l\u00fa \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 gbogbo \u00e0w\u1ecdn ohun t\u00ed \u00f3 w\u00e0 n\u00edn\u00fa \u00e0k\u00f3j\u1ecdp\u1ecd\u0300 n\u00e1\u00e0.\n\n\u00c0p\u1eb9\u1eb9r\u1eb9:\nFun lst = [1,2,3] \u00e8b\u00f9n n\u00e1\u00e0 y\u1eb9 k\u00ed \u00f3 j\u1eb9\u0301 6\nFun lst = [] \u00e8b\u00f9n n\u00e1\u00e0 y\u1eb9 k\u00ed \u00f3 j\u1eb9\u0301 0\nFun lst = [-1,-5,2,-1,-5] \u00e8b\u00f9n n\u00e1\u00e0 y\u1eb9 k\u00ed \u00f3 j\u1eb9\u0301 -126\n    \"\"\"\n",
        "canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef words_in_sentence(sentence):\n    \"\"\"\n    O ti fun \u1ecd ni okun kan ti o nsoju gbolohun kan,\n    gbolohun naa ni di\u1eb9 ninu aw\u1ecdn \u1ecdr\u1ecd ti a ya s\u1ecdt\u1ecd nipas\u1eb9 aaye,\n    ati pe o gb\u1ecdd\u1ecd da pada okun kan ti o ni aw\u1ecdn \u1ecdr\u1ecd lati inu gbolohun atil\u1eb9ba,\n    ti aw\u1ecdn gigun w\u1ecdn ba j\u1eb9 aw\u1ecdn n\u1ecdmba pataki,\n    a\u1e63\u1eb9 ti aw\u1ecdn \u1ecdr\u1ecd ni okun tuntun y\u1eb9 ki o j\u1eb9 kanna bi ti atil\u1eb9ba.\n\n    Ap\u1eb9\u1eb9r\u1eb91:\n        Input: gbolohun = \"This is a test\"\n        Output: \"is\"\n\n    Ap\u1eb9\u1eb9r\u1eb92:\n        Input: gbolohun = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Aw\u1ecdn iham\u1ecd:\n        * 1 <= len <= 100\n        * gbolohun naa ni aw\u1ecdn l\u1eb9ta nikan\n    \"\"\"\n",
        "canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"
    },
    {
        "prompt":"\ndef simplify(x, n):\n    \"\"\"Here is a translation of the given sentence into Yoruba:\n\n\u1eb8\u0300k\u1ecd\u0301 r\u1eb9 ni l\u00e1ti \u1e63e \u00e9to kan t\u00ed y\u00f3\u00f2 r\u1ecdr\u00f9n f\u00fan \u00ec\u1e63\u00e0k\u00f3so \u1ecdr\u1ecd\u0300 n\u00e1\u00e0\n    x * n. \u00c8t\u00f2 n\u00e1\u00e0 m\u00e1a \u0144 pada s\u00ed otit\u1ecd t\u00ed x * n b\u00e1 \u00e0 \u1e63e \u00ecd\u00e1nil\u00f3j\u00fa s\u00ed n\u00edn\u00fa \u00e0k\u00f3k\u00f2 t\u00f3 p\u00e9ye, \u00e0ti ir\u1ecd\u0301\n    n\u00edgb\u00e0 m\u00ec\u00edr\u00e0n. M\u00e9j\u00e8\u00e8j\u00ec x \u00e0ti n, j\u1eb9\u0301 a\u1e63\u00e0w\u00e1kiri ti \u00ec\u1e63\u00e8d\u00e1, \u00e0ti n\u00ed f\u1ecd\u1ecdm\u00f9 w\u00edw\u1ecdny\u00ed,\n    <numerator>\/<denominator> n\u00edbi t\u00ed m\u00e9j\u00e8\u00e8j\u00ec numerator \u00e0ti denominator j\u1eb9\u0301 \u00e0w\u1ecdn on\u00edye on\u00edn\u1ecdmb\u00e0 t\u00f3 p\u00e9ye.\n\n    O l\u00e8 gb\u00e9j\u1ecd\u0301r\u00f2 p\u00e9 x \u00e0ti n j\u1eb9\u0301 \u00e0w\u1ecdn \u00ec\u1e63\u00e8d\u00e1 t\u00f3 t\u1ecd\u0301, \u00e0ti p\u00e9 k\u00f2 n\u00ed zero g\u1eb9\u0301g\u1eb9\u0301 b\u00ed denominator.\n\n    simplify = Otit\u1ecd\n    simplify = Ir\u1ecd\u0301\n    simplify = Ir\u1ecd\u0301\n    \"\"\"\n",
        "canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n"
    },
    {
        "prompt":"\ndef order_by_points(nums):\n    \"\"\"\n    K\u1ecd\u0301 i\u1e63\u1eb9\u0301 kan t\u00ed y\u00f3\u00f2 t\u1ecd\u0301kas\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni \n    n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni \n    n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed a f\u00fanni n\u00ed \n    \u00e0t\u00f2j\u1ecd \u00e0w\u1ecdn n\u01f9kan t\u00ed\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n",
        "canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef specialFilter(nums):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 kan ti o gba array ti aw\u1ecdn n\u1ecdmba bi igbew\u1ecdle ati pada\n    n\u1ecdmba aw\u1ecdn eroja ninu array ti o tobi ju 10 ati mejeeji\n    n\u1ecdmba ak\u1ecdk\u1ecd ati n\u1ecdmba ik\u1eb9hin ti n\u1ecdmba j\u1eb9 odd.\n    Fun ap\u1eb9\u1eb9r\u1eb9:\n    specialFilter => 1 \n    specialFilter => 2\n    \"\"\"\n",
        "canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"
    },
    {
        "prompt":"\ndef get_max_triples(n):\n    \"\"\"\n    O ti fun ni n\u1ecdmba rere n. O ni lati \u1e63\u1eb9da \u00e0t\u00f2k\u1ecd \u00e0w\u00e1nj\u1ecd integer a ti gigun n.\n    Fun \u1ecdk\u1ecd\u1ecdkan i, iye ti a[i] = i * i - i + 1.\n    Pada n\u1ecdmba m\u1eb9\u0301ta-m\u1eb9\u0301ta ti a nibiti i < j < k,\n    ati pe a[i] + a[j] + a[k] j\u1eb9 \u1eb9y\u1ecd ti 3.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n        Input: n = 5\n        Output: 1\n        \u00c0l\u00e0y\u00e9:\n        a = [1, 3, 7, 13, 21]\n        \u1eb8y\u1ecd m\u1eb9\u0301ta t\u00f3 w\u00fal\u00f2 kan \u1e63o\u1e63o ni.\n    \"\"\"\n",
        "canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n",
        "test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"
    },
    {
        "prompt":"\ndef bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closerst to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n",
        "canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"
    },
    {
        "prompt":"\ndef sorted_list_sum(lst):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 kan ti o gba akoj\u1ecd aw\u1ecdn okun bi paramita,\n    pa aw\u1ecdn okun ti o ni gigun odd kuro ninu r\u1eb9,\n    ki o si pada aw\u1ecdn akoj\u1ecd ti o waye p\u1eb9lu a\u1e63\u1eb9 ti a \u1e63eto,\n    Akoj\u1ecd naa nigbagbogbo j\u1eb9 akoj\u1ecd aw\u1ecdn okun ati pe kii \u1e63e array aw\u1ecdn n\u1ecdmba,\n    ati pe o le ni aw\u1ecdn \u1eb9da.\n    A\u1e63\u1eb9 ti akoj\u1ecd y\u1eb9 ki o j\u1eb9 ni didasil\u1eb9 nipas\u1eb9 gigun ti \u1ecdr\u1ecd k\u1ecd\u1ecdkan, ati pe o\n    y\u1eb9 ki o pada akoj\u1ecd naa ti o \u1e63eto nipas\u1eb9 ofin y\u1eb9n.\n    Ti aw\u1ecdn \u1ecdr\u1ecd meji ba ni gigun kanna, \u1e63eto akoj\u1ecd naa ni alfabeti.\n    I\u1e63\u1eb9 naa y\u1eb9 ki o pada akoj\u1ecd aw\u1ecdn okun ni a\u1e63\u1eb9 ti a \u1e63eto.\n    O le ro pe gbogbo aw\u1ecdn \u1ecdr\u1ecd yoo ni gigun kanna.\n    Fun ap\u1eb9\u1eb9r\u1eb9:\n    assert list_sort => [\"aa\"]\n    assert list_sort => [\"ab\", \"cd\"]\n    \"\"\"\n",
        "canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"
    },
    {
        "prompt":"\ndef x_or_y(n, x, y):\n    \"\"\"\u1eb8\u0300t\u00f2 t\u00f3 r\u1ecdr\u00f9n t\u00f3 y\u1eb9 k\u00ed \u00f3 pad\u00e0 f\u00edfi iye x b\u00e1 n j\u1eb9\u0301 \n    n\u1ecd\u0301mb\u00e0 \u00e0k\u1ecd\u0301k\u1ecd\u0301 t\u00ed \u00f3 s\u00ec y\u1eb9 k\u00ed \u00f3 pad\u00e0 f\u00edfi iye y b\u00e1 n j\u1eb9\u0301 n\u1ecd\u0301mb\u00e0 m\u00ec\u00edr\u00e0n.\n\n    \u00c0p\u1eb9\u1eb9r\u1eb9:\n    f\u00fan x_or_y == 34\n    f\u00fan x_or_y == 5\n    \n    \"\"\"\n",
        "canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"
    },
    {
        "prompt":"\ndef double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n",
        "canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef compare(game,guess):\n    \"\"\"Mo ro pe gbogbo wa ranti ir\u1ecdl\u1eb9 y\u1eb9n nigba ti abajade i\u1e63\u1eb9l\u1eb9 ti a ti n duro de p\u1eb9\u0301p\u1eb9\u0301p\u1eb9\u0301 di mim\u1ecd\u0300 nik\u1eb9hin. Aw\u1ecdn \u1eb9mi ati aw\u1ecdn ero ti o ni ni akoko y\u1eb9n j\u1eb9 otit\u1ecd t\u1ecd lati \u1e63e akosile ati \u1e63e afiwe.\n\nI\u1e63\u1eb9 r\u1eb9 ni lati pinnu boya eniyan kan ti \u1e63e as\u1ecdt\u1eb9l\u1eb9 abajade aw\u1ecdn ere kan ni deede. A fun \u1ecd ni aw\u1ecdn akoj\u1ecdp\u1ecd meji ti aw\u1ecdn n\u1ecdmba ati aw\u1ecdn as\u1ecdt\u1eb9l\u1eb9 ti o ni gigun kanna, nibiti \u1ecdk\u1ecd\u1ecdkan aw\u1ecdn it\u1ecdka fihan ere kan. Pada akoj\u1ecdp\u1ecd ti o ni gigun kanna ti o nfihan bi w\u1ecdn \u1e63e jinna si as\u1ecdt\u1eb9l\u1eb9 k\u1ecd\u1ecdkan ti w\u1ecdn \u1e63e. Ti w\u1ecdn ba \u1e63e as\u1ecdt\u1eb9l\u1eb9 ni deede, iye naa j\u1eb9 0, ati ti kii ba \u1e63e b\u1eb9, iye naa j\u1eb9 iyat\u1ecd alayipo laarin as\u1ecdt\u1eb9l\u1eb9 ati abajade naa.\n\nAp\u1eb9\u1eb9r\u1eb9:\n\ncompare -> [0,0,0,0,3,3]\ncompare -> [4,4,1,0,0,6]\n    \"\"\"\n",
        "canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Iw\u1ecd yoo fun ni oruk\u1ecd kilasi kan ati akoj\u1ecd aw\u1ecdn it\u1eb9siwaju.\n    Aw\u1ecdn it\u1eb9siwaju naa ni lati lo lati gbe aw\u1ecdn kilasi afikun si kilasi naa. Agbara it\u1eb9siwaju naa j\u1eb9 bi at\u1eb9le: J\u1eb9 ki CAP j\u1eb9 n\u1ecdmba aw\u1ecdn l\u1eb9ta nla ninu oruk\u1ecd it\u1eb9siwaju naa, ki o j\u1eb9 ki SM j\u1eb9 n\u1ecdmba aw\u1ecdn l\u1eb9ta kekere ninu oruk\u1ecd it\u1eb9siwaju naa, agbara naa j\u1eb9 fun nipas\u1eb9 ipin CAP - SM.\n    O y\u1eb9 ki o wa it\u1eb9siwaju ti o lagbara jul\u1ecd ki o si pada \u1ecdr\u1ecd kan ninu \u1ecdna kika yii: ClassName.StrongestExtensionName.\n    Ti aw\u1ecdn it\u1eb9siwaju meji tabi di\u1eb9 sii ba ni agbara kanna, o y\u1eb9 ki o yan eyi ti o wa ak\u1ecdk\u1ecd ninu akoj\u1ecd naa.\n    Fun ap\u1eb9\u1eb9r\u1eb9, ti o ba ti fun \u1ecd ni \"Slices\" g\u1eb9g\u1eb9 bi kilasi ati akoj\u1ecd aw\u1ecdn it\u1eb9siwaju: ['SErviNGSliCes', 'Cheese', 'StuFfed'] l\u1eb9hinna o y\u1eb9 ki o pada 'Slices.SErviNGSliCes' nitori 'SErviNGSliCes' j\u1eb9 it\u1eb9siwaju ti o lagbara jul\u1ecd.\n    Ap\u1eb9\u1eb9r\u1eb9:\n    fun Strongest_Extension == 'my_class.AA'\n    \"\"\"\n",
        "canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"
    },
    {
        "prompt":"\ndef cycpattern_check(a , b):\n    \"\"\"A o fun \u1ecd ni aw\u1ecdn \u1ecdr\u1ecd meji. O nilo lati da pada True ti \u1ecdr\u1ecd keji tabi eyikeyi ti aw\u1ecdn iyipo r\u1eb9 ba j\u1eb9 substring ninu \u1ecdr\u1ecd ak\u1ecdk\u1ecd.\n    cycpattern_check => B\u1eb9\u1eb9k\u1ecd\n    cycpattern_check => B\u1eb9\u1eb9ni\n    cycpattern_check => B\u1eb9\u1eb9k\u1ecd\n    cycpattern_check => B\u1eb9\u1eb9ni\n    cycpattern_check => B\u1eb9\u1eb9k\u1ecd\n    cycpattern_check => B\u1eb9\u1eb9ni\n\n    \"\"\"\n",
        "canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"
    },
    {
        "prompt":"\ndef even_odd_count(num):\n    \"\"\"Ti a ba fun n\u1ecdmba gidi kan, pada tuple kan ti o ni n\u1ecdmba aw\u1ecdn n\u1ecdmba ti o j\u1eb9 paapaa ati aw\u1ecdn n\u1ecdmba ti o j\u1eb9 odd ni ibamu.\n\n     Ap\u1eb9\u1eb9r\u1eb9:\n        even_odd_count ==>\n        even_odd_count ==>\n    \"\"\"\n",
        "canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef int_to_mini_roman(number):\n    \"\"\"\n    Ti a ba fun n\u1ecdmba odidi ti o j\u1eb9 rere, gba n\u1ecdmba Roman r\u1eb9 ti o baamu bi okun,\n    ki o si da pada ni aw\u1ecdn l\u1eb9ta kekere.\n    Aw\u1ecdn iham\u1ecd: 1 <= n\u1ecdmba <= 1000\n\n    Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n",
        "canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n",
        "canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"
    },
    {
        "prompt":"\ndef find_max(words):\n    \"\"\"K\u1ecd i\u1e63\u1eb9 kan ti o gba atok\u1ecd ti aw\u1ecdn okun.\n\n    Atok\u1ecd naa ni aw\u1ecdn \u1ecdr\u1ecd ori\u1e63iri\u1e63i. Pada \u1ecdr\u1ecd ti o ni n\u1ecdmba ti o p\u1ecdju\n    ti aw\u1ecdn ohun kik\u1ecd alail\u1eb9gb\u1eb9. Ti aw\u1ecdn okun pup\u1ecd ba ni n\u1ecdmba ti o p\u1ecdju\n    ti aw\u1ecdn ohun kik\u1ecd alail\u1eb9gb\u1eb9, pada \u1eb9y\u1ecdkan ti o wa ni ak\u1ecdk\u1ecd ni a\u1e63\u1eb9 l\u1eb9ta.\n\n    find_max == \"string\"\n    find_max == \"enam\"\n    find_max == \"aaaaaaa\"\n    \"\"\"\n",
        "canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"
    },
    {
        "prompt":"\ndef eat(number, need, remaining):\n    \"\"\"\n    O j\u1eb9 ehoro ti o ni ebi, ati pe o ti ti j\u1eb9 n\u1ecdmba kan ti kar\u1ecd\u1ecdti,\n\u1e63ugb\u1ecdn nisisiyi o nilo lati j\u1eb9 di\u1eb9 sii aw\u1ecdn kar\u1ecd\u1ecdti lati pari ounj\u1eb9 \u1ecdj\u1ecd naa.\nO y\u1eb9 ki o pada p\u1eb9lu akoj\u1ecd kan ti [apap\u1ecd n\u1ecdmba ti aw\u1ecdn kar\u1ecd\u1ecdti ti o ti j\u1eb9 l\u1eb9hin ounj\u1eb9 r\u1eb9,\n                                    n\u1ecdmba ti aw\u1ecdn kar\u1ecd\u1ecdti ti o ku l\u1eb9hin ounj\u1eb9 r\u1eb9]\nti ko ba si to aw\u1ecdn kar\u1ecd\u1ecdti to ku, iw\u1ecd yoo j\u1eb9 gbogbo aw\u1ecdn kar\u1ecd\u1ecdti to ku, \u1e63ugb\u1ecdn iw\u1ecd yoo tun ni ebi.\n\nApeere:\n* eat -> [11, 4]\n* eat -> [12, 1]\n* eat -> [11, 0]\n* eat -> [7, 0]\n\nAw\u1ecdn oniyipada:\n@number : integer\n    n\u1ecdmba ti aw\u1ecdn kar\u1ecd\u1ecdti ti o ti j\u1eb9.\n@need : integer\n    n\u1ecdmba ti aw\u1ecdn kar\u1ecd\u1ecdti ti o nilo lati j\u1eb9.\n@remaining : integer\n    n\u1ecdmba ti aw\u1ecdn kar\u1ecd\u1ecdti to ku ti o wa ninu i\u1e63ura\n\nIdiw\u1ecdn:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nN\u00ed gb\u00e1d\u00f9n :)\n    \"\"\"\n",
        "canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"
    },
    {
        "prompt":"\ndef do_algebra(operator, operand):\n    \"\"\"\n    Fun aw\u1ecdn akoj\u1ecd meji ti a pese, oni\u1e63\u1eb9 ati operand. Akoj\u1ecd ak\u1ecdk\u1ecd ni aw\u1ecdn i\u1e63\u1eb9 algebra ipil\u1eb9, ati pe \nak\u1ecdj\u1ecd keji j\u1eb9 atok\u1ecd ti aw\u1ecdn n\u1ecdmba gangan. Lo aw\u1ecdn akoj\u1ecd meji ti a fun lati k\u1ecd \u1ecdr\u1ecd algebra ati \npada abajade ti \u1ecdr\u1ecd yii.\n\nAw\u1ecdn i\u1e63\u1eb9 algebra ipil\u1eb9:\nAfikun \nIyokuro \nIsepo \nPipin il\u1eb9 \nExponentiation \n\nApeere:\noni\u1e63\u1eb9['+', '*', '-']\nak\u1ecdj\u1ecd = [2, 3, 4, 5]\nabajade = 2 + 3 * 4 - 5\n=> abajade = 9\n\nAkiyesi:\nGigun akoj\u1ecd oni\u1e63\u1eb9 j\u1eb9 dogba si gigun akoj\u1ecd operand dinku \u1ecdkan.\nOperand j\u1eb9 atok\u1ecd ti aw\u1ecdn n\u1ecdmba ti kii \u1e63e odi.\nAkoj\u1ecd oni\u1e63\u1eb9 ni o kere ju oni\u1e63\u1eb9 kan, ati pe akoj\u1ecd operand ni o kere ju aw\u1ecdn operands meji.\n\n    \"\"\"\n",
        "canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    },
    {
        "prompt":"\ndef solve(s):\n    \"\"\"Here is the translation of the given sentence into Yoruba:\n\nO ti fun ni okun s.\n    ti s[i] ba j\u1eb9 l\u1eb9ta, yi irisi r\u1eb9 pada lati kekere si nla tabi idakeji,\n    bib\u1eb9\u1eb9k\u1ecd, j\u1eb9 ki o wa bi o ti ri.\n    Ti okun naa ko ba ni aw\u1ecdn l\u1eb9ta, yi okun naa pada.\n    I\u1e63\u1eb9 naa y\u1eb9 ki o pada okun abajade.\n    Aw\u1ecdn ap\u1eb9\u1eb9r\u1eb9\n    yanju = \"4321\"\n    yanju = \"AB\"\n    yanju = \"#A@c\"\n    \"\"\"\n",
        "canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"
    },
    {
        "prompt":"\ndef string_to_md5(text):\n    \"\"\"\n    Fun okun 'text', pada okun idanim\u1ecd md5 r\u1eb9.\n    Ti 'text' ba j\u1eb9 okun ofo, pada None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n",
        "canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"
    },
    {
        "prompt":"\ndef generate_integers(a, b):\n    \"\"\"\n    Ninu aw\u1ecdn n\u1ecdmba alail\u1eb9gb\u1eb9 meji a ati b, pada aw\u1ecdn n\u1ecdmba to j\u1eb9 mejila laarin a ati b, ni a\u1e63\u1eb9 t\u2019\u1ecdka.\n\nFun ap\u1eb9\u1eb9r\u1eb9:\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => [2, 4, 6, 8]\ngenerate_integers => []\n    \"\"\"\n",
        "canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n",
        "test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"
    }
]