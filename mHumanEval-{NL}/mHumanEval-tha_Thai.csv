prompt,canonical_solution,test
"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" ตรวจสอบว่ามีตัวเลขสองตัวในรายการตัวเลขที่กำหนดหรือไม่ ที่มีความใกล้กันมากกว่าค่าที่กำหนด
    ตัวอย่าง:
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    False
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    True
    """"""
","for idx, elem in enumerate(numbers):
    for idx2, elem2 in enumerate(numbers):
        if idx != idx2:
            distance = abs(elem - elem2)
            if distance < threshold:
                return True
return False
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

"
"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" อินพุตของฟังก์ชันนี้คือสตริงที่ประกอบด้วยกลุ่มของวงเล็บที่ซ้อนกันหลายกลุ่ม เป้าหมายของคุณคือ
แยกกลุ่มเหล่านั้นออกเป็นสตริงแยกต่างหากและคืนค่ารายการของสตริงเหล่านั้น
กลุ่มที่แยกออกมาแล้วจะสมดุล และไม่ซ้อนกันภายในกันและกัน
ให้ละเว้นช่องว่างใด ๆ ในสตริงอินพุต
ตัวอย่าง:
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    ['()', '(())', '(()())']
    """"""
","    result = []
    current_string = []
    current_depth = 0

    for c in paren_string:
        if c == '(':
            current_depth += 1
            current_string.append(c)
        elif c == ')':
            current_depth -= 1
            current_string.append(c)

            if current_depth == 0:
                result.append(''.join(current_string))
                current_string.clear()

    return result
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
"
"

def truncate_number(number: float) -> float:
    """""" ให้จำนวนจุดทศนิยมที่เป็นบวก สามารถแบ่งออกเป็นส่วนจำนวนเต็ม และส่วนทศนิยม

คืนค่าทศนิยมของจำนวนที่กำหนด
ตัวอย่าง:
    >>> truncate_number(3.5)
    0.5
    """"""
","    return number % 1.0
","def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
"
"from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" คุณได้รับรายการของการฝากและถอนเงินในบัญชีธนาคารที่เริ่มต้นด้วยยอดคงเหลือเป็นศูนย์ งานของคุณคือการตรวจสอบว่ามียอดคงเหลือในบัญชีลดลงต่ำกว่าศูนย์ในจุดใดจุดหนึ่งหรือไม่ และในจุดนั้นฟังก์ชันควรส่งคืนค่าเป็น True มิฉะนั้นควรส่งคืนค่าเป็น False
    ตัวอย่าง:
    >>> below_zero([1, 2, 3])
    False
    >>> below_zero([1, 2, -4, 5])
    True
    """"""
","    balance = 0

    for op in operations:
        balance += op
        if balance < 0:
            return True

    return False
","def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
"
"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" สำหรับรายการตัวเลขที่กำหนดมา คำนวณการเบี่ยงเบนเฉลี่ยสัมบูรณ์
    รอบค่าเฉลี่ยของชุดข้อมูลนี้
    การเบี่ยงเบนเฉลี่ยสัมบูรณ์คือค่าเฉลี่ยของค่าความแตกต่างสัมบูรณ์ระหว่างแต่ละ
    องค์ประกอบกับจุดศูนย์กลาง:
    MAD = ค่าเฉลี่ย | x - x_mean |
    ตัวอย่าง:
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    1.0
    """"""
","    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
","def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

"
"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" แทรกตัวเลข 'delimeter' ระหว่างทุกสององค์ประกอบที่ต่อเนื่องกันของรายการป้อนเข้า `numbers`
    >>> intersperse([], 4)
    []
    >>> intersperse([1, 2, 3], 4)
    [1, 4, 2, 4, 3]
    """"""
","    if not numbers:
        return []

    result = []

    for n in numbers[:-1]:
        result.append(n)
        result.append(delimeter)

    result.append(numbers[-1])

    return result
","def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
"
"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" อินพุตของฟังก์ชันนี้คือสตริงที่ประกอบด้วยกลุ่มหลายกลุ่มสำหรับวงเล็บที่ซ้อนกัน โดยแยกด้วยช่องว่าง
    สำหรับแต่ละกลุ่ม ให้แสดงระดับการซ้อนกันของวงเล็บที่ลึกที่สุด
    เช่น) มีระดับการซ้อนกันสูงสุดสองระดับ ในขณะที่)) มีสามระดับ

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    [2, 3, 1, 3]
    """"""
","    def parse_paren_group(s):
        depth = 0
        max_depth = 0
        for c in s:
            if c == '(':
                depth += 1
                max_depth = max(depth, max_depth)
            else:
                depth -= 1

        return max_depth

    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
","def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
"
"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" กรองรายการข้อมูลที่เป็นสตริงเพื่อให้ได้เฉพาะรายการที่มีส่วนของสตริงที่กำหนด
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
","    return [x for x in strings if substring in x]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
"
"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" สำหรับรายการของจำนวนเต็มที่กำหนดไว้ ให้คืนค่าทูเพิลที่ประกอบด้วยผลรวมและผลคูณของจำนวนเต็มทั้งหมดในรายการ
    ผลรวมของรายการว่างควรเท่ากับ 0 และผลคูณของรายการว่างควรเท่ากับ 1
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """"""
","    sum_value = 0
    prod_value = 1

    for n in numbers:
        sum_value += n
        prod_value *= n
    return sum_value, prod_value
","def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
"
"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" จากรายการของจำนวนเต็มที่กำหนด สร้างรายการของค่าสูงสุดที่พบจนถึงช่วงเวลาที่กำหนดในลำดับ
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    [1, 2, 3, 3, 3, 4, 4]
    """"""
","    running_max = None
    result = []

    for n in numbers:
        if running_max is None:
            running_max = n
        else:
            running_max = max(running_max, n)

        result.append(running_max)

    return result
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
"
"

def is_palindrome(string: str) -> bool:
    """""" ทดสอบว่าข้อความที่ให้มานั้นเป็นพาลินโดรมหรือไม่ """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    ''
    >>> make_palindrome('cat')
    'catac'
    >>> make_palindrome('cata')
    'catac'
    """"""
","    if not string:
        return ''

    beginning_of_suffix = 0

    while not is_palindrome(string[beginning_of_suffix:]):
        beginning_of_suffix += 1

    return string + string[:beginning_of_suffix][::-1]
","def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
"
"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" อินพุตคือสตริงสองชุด a และ b ที่ประกอบด้วยตัวเลข 1 และ 0 เท่านั้น
    ทำการ XOR แบบไบนารีบนอินพุตเหล่านี้และส่งคืนผลลัพธ์เป็นสตริง
    >>> string_xor('010', '110')
    '100'
    """"""
","    def xor(i, j):
        if i == j:
            return '0'
        else:
            return '1'

    return ''.join(xor(x, y) for x, y in zip(a, b))
","def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
"
"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" จากรายการของสตริง ให้คืนค่าสตริงที่ยาวที่สุด คืนค่าอันแรกในกรณีที่มีหลายสตริงที่มีความยาวเท่ากัน คืนค่า None ในกรณีที่รายการอินพุตว่างเปล่า
    >>> longest([])

    >>> longest(['a', 'b', 'c'])
    'a'
    >>> longest(['a', 'bb', 'ccc'])
    'ccc'
    """"""
","    if not strings:
        return None

    maxlen = max(len(x) for x in strings)
    for s in strings:
        if len(s) == maxlen:
            return s
","def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
"
"

def greatest_common_divisor(a: int, b: int) -> int:
    """""" ส่งคืนตัวหารร่วมมากของจำนวนเต็มสองจำนวน a และ b
    >>> greatest_common_divisor(3, 5)
    1
    >>> greatest_common_divisor(25, 15)
    5
    """"""
","    while b:
        a, b = b, a % b
    return a
","def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
"
"from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" ส่งคืนรายการของคำนำหน้าทั้งหมดจากสั้นที่สุดไปยาวที่สุดของสตริงที่ป้อนเข้า
    >>> all_prefixes('abc')
    ['a', 'ab', 'abc']
    """"""
","    result = []

    for i in range(len(string)):
        result.append(string[:i+1])
    return result
","def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
"
"

def string_sequence(n: int) -> str:
    """""" ส่งคืนสตริงที่ประกอบด้วยตัวเลขที่คั่นด้วยช่องว่าง เริ่มต้นจาก 0 ถึง n รวมถึง n ด้วย
    >>> string_sequence(0)
    '0'
    >>> string_sequence(5)
    '0 1 2 3 4 5'
    """"""
","    return ' '.join([str(x) for x in range(n + 1)])
","def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
"
"

def count_distinct_characters(string: str) -> int:
    """""" ให้สตริงหนึ่ง จงหาว่ามีตัวอักษรที่ไม่ซ้ำกันกี่ตัว
    >>> count_distinct_characters('xyzXYZ')
    3
    >>> count_distinct_characters('Jerry')
    4
    """"""
","    return len(set(string.lower()))
","def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
"
"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" อินพุตของฟังก์ชันนี้คือสตริงที่แสดงถึงโน้ตดนตรีในรูปแบบ ASCII พิเศษ
หน้าที่ของคุณคือการแยกวิเคราะห์สตริงนี้และคืนค่ารายการของจำนวนเต็มที่สอดคล้องกับจำนวนจังหวะที่แต่ละโน้ตกินเวลา

นี่คือตำนาน:
'o' - โน้ตเต็ม, กินเวลาสี่จังหวะ
'o|' - โน้ตครึ่ง, กินเวลาสองจังหวะ
'.|' - โน้ตหนึ่งในสี่, กินเวลาหนึ่งจังหวะ

    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]
    """"""
","    note_map = {'o': 4, 'o|': 2, '.|': 1}
    return [note_map[x] for x in music_string.split(' ') if x]
","def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
"
"

def how_many_times(string: str, substring: str) -> int:
    """""" ค้นหาว่ามีจำนวนครั้งที่สามารถพบสตริงย่อยที่กำหนดในสตริงต้นฉบับกี่ครั้ง นับรวมกรณีที่เหลื่อมกันด้วย
    >>> how_many_times('', 'a')
    0
    >>> how_many_times('aaa', 'a')
    3
    >>> how_many_times('aaaa', 'aa')
    3
    """"""
","    times = 0

    for i in range(len(string) - len(substring) + 1):
        if string[i:i+len(substring)] == substring:
            times += 1

    return times
","def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
"
"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" อินพุตเป็นสตริงที่แบ่งด้วยช่องว่างของตัวเลขตั้งแต่ 'zero' ถึง 'nine'
    ตัวเลือกที่ถูกต้องคือ 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' และ 'nine'
    คืนค่าสตริงที่มีตัวเลขเรียงจากน้อยไปมาก
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","    value_map = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
        'six': 6,
        'seven': 7,
        'eight': 8,
        'nine': 9
    }
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))
","def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
"
"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" จากรายการตัวเลขที่มีความยาวอย่างน้อยสองตัว ให้เลือกและส่งคืนสองตัวที่อยู่ใกล้กันที่สุด และส่งคืนในลำดับ
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """"""
","    closest_pair = None
    distance = None

    for idx, elem in enumerate(numbers):
        for idx2, elem2 in enumerate(numbers):
            if idx != idx2:
                if distance is None:
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                else:
                    new_distance = abs(elem - elem2)
                    if new_distance < distance:
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))

    return closest_pair
","def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

"
"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" ให้รายการตัวเลข ใช้การแปลงเชิงเส้นกับรายการนั้น
    เพื่อให้ตัวเลขที่เล็กที่สุดกลายเป็น 0 และตัวเลขที่ใหญ่ที่สุดกลายเป็น 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
","def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
"
"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" กรองรายการที่กำหนดเพื่อให้มีเฉพาะค่าที่เป็นจำนวนเต็มใน Python
    >>> filter_integers(['a', 3.14, 5])
    [5]
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    [1, 2, 3]
    """"""
","    return [x for x in values if isinstance(x, int)]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
"
"

def strlen(string: str) -> int:
    """""" คืนค่าความยาวของสตริงที่กำหนด
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","    return len(string)
","def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
"
"

def largest_divisor(n: int) -> int:
    """""" สำหรับจำนวนที่กำหนด n ให้หาจำนวนที่มากที่สุดที่หาร n ลงตัว และมีค่าน้อยกว่า n
    >>> largest_divisor(15)
    5
    """"""
","    for i in reversed(range(n)):
        if n % i == 0:
            return i
","def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
"
"from typing import List


def factorize(n: int) -> List[int]:
    """""" ส่งคืนรายการตัวประกอบเฉพาะของจำนวนเต็มที่กำหนด โดยเรียงลำดับจากน้อยไปหามาก แต่ละตัวประกอบควรถูกระบุจำนวนครั้งตามจำนวนครั้งที่ปรากฏในการแยกตัวประกอบ ตัวเลขที่ป้อนเข้ามาควรเท่ากับผลคูณของตัวประกอบทั้งหมด
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """"""
","    import math
    fact = []
    i = 2
    while i <= int(math.sqrt(n) + 1):
        if n % i == 0:
            fact.append(i)
            n //= i
        else:
            i += 1

    if n > 1:
        fact.append(n)
    return fact
","def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
"
"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" จากรายการจำนวนเต็ม ให้ลบองค์ประกอบทั้งหมดที่เกิดขึ้นมากกว่าหนึ่งครั้ง
    ให้คงลำดับขององค์ประกอบที่เหลือเหมือนกับในอินพุต
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """"""
","    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c[n] <= 1]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
"
"

def flip_case(string: str) -> str:
    """""" สำหรับสตริงที่กำหนด ให้เปลี่ยนอักขระตัวพิมพ์เล็กเป็นตัวพิมพ์ใหญ่ และตัวพิมพ์ใหญ่เป็นตัวพิมพ์เล็ก
    >>> flip_case('Hello')
    'hELLO'
    """"""
","    return string.swapcase()
","def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
"
"from typing import List


def concatenate(strings: List[str]) -> str:
    """""" เชื่อมโยงรายการของสายอักขระให้เป็นสายอักขระเดียว
    >>> concatenate([])
    ''
    >>> concatenate(['a', 'b', 'c'])
    'abc'
    """"""
","    return ''.join(strings)
","def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
"
"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" กรองรายการสตริงที่ป้อนเข้ามาโดยเลือกเฉพาะสตริงที่ขึ้นต้นด้วยคำนำหน้าที่กำหนด
    >>> filter_by_prefix([], 'a')
    []
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    ['abc', 'array']
    """"""
","    return [x for x in strings if x.startswith(prefix)]
","def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
"
"

def get_positive(l: list):
    """"""ส่งคืนเฉพาะตัวเลขบวกในรายการ
    >>> get_positive([-1, 2, -4, 5, 6])
    [2, 5, 6]
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    [5, 3, 2, 3, 9, 123, 1]
    """"""
","    return [e for e in l if e > 0]
","def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

"
"

def is_prime(n):
    """"""คืนค่า true หากตัวเลขที่กำหนดเป็นจำนวนเฉพาะ และ false หากไม่ใช่
    >>> is_prime(6)
    False
    >>> is_prime(101)
    True
    >>> is_prime(11)
    True
    >>> is_prime(13441)
    True
    >>> is_prime(61)
    True
    >>> is_prime(4)
    False
    >>> is_prime(1)
    False
    """"""
","    if n < 2:
        return False
    for k in range(2, n - 1):
        if n % k == 0:
            return False
    return True
","def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

"
"import math


def poly(xs: list, x: float):
    """"""
    ประเมินพหุนามที่มีสัมประสิทธิ์ xs ที่จุด x
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","    begin, end = -1., 1.
    while poly(xs, begin) * poly(xs, end) > 0:
        begin *= 2.0
        end *= 2.0
    while end - begin > 1e-10:
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0:
            begin = center
        else:
            end = center
    return begin
","def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

"
"

def sort_third(l: list):
    """"""ฟังก์ชันนี้รับลิสต์ l และคืนค่าลิสต์ l' โดยที่
    l' จะเหมือนกับ l ในดัชนีที่ไม่สามารถหารด้วยสามลงตัว ส่วนค่าในดัชนีที่สามารถหารด้วยสามลงตัวจะเท่ากับค่าของดัชนีที่สอดคล้องกันใน l แต่ถูกจัดเรียงใหม่ตามลำดับ
    >>> sort_third([1, 2, 3])
    [1, 2, 3]
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    [2, 6, 3, 4, 8, 9, 5]
    """"""
","    l = list(l)
    l[::3] = sorted(l[::3])
    return l
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

"
"

def unique(l: list):
    """"""ส่งคืนองค์ประกอบที่ไม่ซ้ำกันและเรียงลำดับในรายการ
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [0, 2, 3, 5, 9, 123]
    """"""
","    return sorted(list(set(l)))
","def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

"
"

def max_element(l: list):
    """"""คืนค่าส่วนประกอบที่มีค่ามากที่สุดในรายการ
    >>> max_element([1, 2, 3])
    3
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    123
    """"""
","    m = l[0]
    for e in l:
        if e > m:
            m = e
    return m
","def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
"
"

def fizz_buzz(n: int):
    """"""ส่งคืนจำนวนครั้งที่ตัวเลข 7 ปรากฏในจำนวนเต็มที่น้อยกว่า n ซึ่งหารด้วย 11 หรือ 13 ลงตัว
    >>> fizz_buzz(50)
    0
    >>> fizz_buzz(78)
    2
    >>> fizz_buzz(79)
    3
    """"""
","    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')
    return ans
","def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

"
"

def sort_even(l: list):
    """"""ฟังก์ชันนี้รับลิสต์ l และคืนค่าลิสต์ l' โดยที่
    l' จะเหมือนกับ l ในดัชนีที่เป็นเลขคี่ ในขณะที่ค่าของมันในดัชนีที่เป็นเลขคู่จะเท่ากับ
    ค่าของดัชนีที่เป็นเลขคู่ของ l แต่ถูกจัดเรียงใหม่
    >>> sort_even([1, 2, 3])
    [1, 2, 3]
    >>> sort_even([5, 6, 3, 4])
    [3, 6, 5, 4]
    """"""
","    evens = l[::2]
    odds = l[1::2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds):
        ans.extend([e, o])
    if len(evens) > len(odds):
        ans.append(evens[-1])
    return ans
","def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

"
"

def encode_cyclic(s: str):
    """"""
    ส่งคืนสตริงที่เข้ารหัสโดยการหมุนเวียนกลุ่มของตัวอักษรสามตัว
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","    return encode_cyclic(encode_cyclic(s))
","def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

"
"

def prime_fib(n: int):
    """"""
    prime_fib คืนค่าตัวเลขลำดับที่ n ที่เป็นทั้งตัวเลขฟีโบนัชชีและเป็นจำนวนเฉพาะด้วย
    >>> prime_fib(1)
    2
    >>> prime_fib(2)
    3
    >>> prime_fib(3)
    5
    >>> prime_fib(4)
    13
    >>> prime_fib(5)
    89
    """"""
","    import math

    def is_prime(p):
        if p < 2:
            return False
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):
            if p % k == 0:
                return False
        return True
    f = [0, 1]
    while True:
        f.append(f[-1] + f[-2])
        if is_prime(f[-1]):
            n -= 1
        if n == 0:
            return f[-1]
","def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

"
"

def triples_sum_to_zero(l: list):
    """"""
    `triples_sum_to_zero` รับรายการของจำนวนเต็มเป็นอินพุต
    มันจะคืนค่า True หากมีสามองค์ประกอบที่แตกต่างกันในรายการที่
    รวมกันแล้วได้ศูนย์ และคืนค่า False ถ้าไม่เป็นเช่นนั้น

    >>> triples_sum_to_zero([1, 3, 5, 0])
    False
    >>> triples_sum_to_zero([1, 3, -2, 1])
    True
    >>> triples_sum_to_zero([1, 2, 3, 7])
    False
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    True
    >>> triples_sum_to_zero([1])
    False
    """"""
","    for i in range(len(l)):
        for j in range(i + 1, len(l)):
            for k in range(j + 1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

"
"

def car_race_collision(n: int):
    """"""
    ลองจินตนาการถึงถนนที่เป็นเส้นตรงที่ยาวออกไปอย่างไม่มีที่สิ้นสุด
มีรถ n คันกำลังขับจากซ้ายไปขวา; ในเวลาเดียวกัน มีรถอีกชุดหนึ่งที่แตกต่างกันจำนวน n คัน 
กำลังขับจากขวาไปซ้าย รถทั้งสองชุดเริ่มต้นจากการอยู่ห่างไกลกันมาก 
รถทุกคันเคลื่อนที่ด้วยความเร็วเท่ากัน จะกล่าวว่ารถชนกันเมื่อรถที่ขับจากซ้ายไปขวาชนเข้ากับรถที่ขับจากขวาไปซ้าย 
อย่างไรก็ตาม รถเหล่านี้มีความแข็งแกร่งและทนทานอย่างไม่มีที่สิ้นสุด; ดังนั้นพวกมันจะยังคงเคลื่อนที่ตามเส้นทางของมัน
ราวกับว่ามันไม่ชนกัน

ฟังก์ชันนี้จะส่งออกจำนวนการชนกันแบบนี้
    """"""
","    return n**2
","def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

"
"

def incr_list(l: list):
    """"""ส่งคืนรายการที่มีองค์ประกอบเพิ่มขึ้นอีก 1
    >>> incr_list([1, 2, 3])
    [2, 3, 4]
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [6, 4, 6, 3, 4, 4, 10, 1, 124]
    """"""
","    return [(e + 1) for e in l]
","def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

"
"

def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero รับรายการของจำนวนเต็มเป็นอินพุต
    มันจะคืนค่า True ถ้ามีสององค์ประกอบที่แตกต่างกันในรายการที่รวมกันแล้วได้ศูนย์ และคืนค่า False หากไม่เป็นเช่นนั้น
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """"""
","    for i, l1 in enumerate(l):
        for j in range(i + 1, len(l)):
            if l1 + l[j] == 0:
                return True
    return False
","def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

"
"

def change_base(x: int, base: int):
    """"""เปลี่ยนฐานตัวเลขของตัวเลขนำเข้า x เป็นฐาน
    คืนค่าการแสดงผลในรูปแบบสตริงหลังจากการแปลง
    ตัวเลขฐานมีค่าน้อยกว่า 10
    >>> change_base(8, 3)
    '22'
    >>> change_base(8, 2)
    '1000'
    >>> change_base(7, 2)
    '111'
    """"""
","    ret = """"
    while x > 0:
        ret = str(x % base) + ret
        x //= base
    return ret
","def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

"
"

def triangle_area(a, h):
    """"""เมื่อให้ความยาวของด้านและความสูง จงหาพื้นที่ของสามเหลี่ยม
    >>> triangle_area(5, 3)
    7.5
    """"""
","    return a * h / 2.0
","def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

"
"

def fib4(n: int):
    """"""ลำดับตัวเลข Fib4 เป็นลำดับที่คล้ายกับลำดับฟีโบนัชชี โดยมีการกำหนดดังนี้:
    fib4 -> 0
    fib4 -> 0
    fib4 -> 2
    fib4 -> 0
    fib4 -> fib4 + fib4 + fib4 + fib4
    กรุณาเขียนฟังก์ชันเพื่อคำนวณค่าเอลิเมนต์ที่ n ของลำดับตัวเลข fib4 อย่างมีประสิทธิภาพ โดยไม่ใช้การเรียกตัวเองซ้ำ
    >>> fib4(5)
    4
    >>> fib4(6)
    8
    >>> fib4(7)
    14
    """"""
","    results = [0, 0, 2, 0]
    if n < 4:
        return results[n]

    for _ in range(4, n + 1):
        results.append(results[-1] + results[-2] + results[-3] + results[-4])
        results.pop(0)

    return results[-1]
","def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

"
"

def median(l: list):
    """"""คืนค่ามัธยฐานขององค์ประกอบในรายการ l
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """"""
","    l = sorted(l)
    if len(l) % 2 == 1:
        return l[len(l) // 2]
    else:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

"
"

def is_palindrome(text: str):
    """"""
    ตรวจสอบว่าสตริงที่ให้เป็นพาลินโดรมหรือไม่
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """"""
","    for i in range(len(text)):
        if text[i] != text[len(text) - 1 - i]:
            return False
    return True
","def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

"
"

def modp(n: int, p: int):
    """"""คืนค่า 2^n โมดูโล p
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """"""
","    ret = 1
    for i in range(n):
        ret = (2 * ret) % p
    return ret
","def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

"
"

def encode_shift(s: str):
    """"""
    คืนสตริงที่เข้ารหัสโดยการเลื่อนตัวอักษรทุกตัวในอักษร 5 ตัว
    """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""
    takes as input string encoded with encode_shift function. Returns decoded string.
    """"""
","    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])
","def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

"
"

def remove_vowels(text):
    """"""
    remove_vowels เป็นฟังก์ชันที่รับสตริงและส่งคืนสตริงที่ไม่มีสระ
    >>> remove_vowels('')
    ''
    >>> remove_vowels(""abcdef\nghijklm"")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """"""
","    return """".join([s for s in text if s.lower() not in [""a"", ""e"", ""i"", ""o"", ""u""]])
","def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

"
"

def below_threshold(l: list, t: int):
    """"""คืนค่า True หากตัวเลขทั้งหมดในรายการ l ต่ำกว่าค่า threshold t
    >>> below_threshold([1, 2, 4, 10], 100)
    True
    >>> below_threshold([1, 20, 4, 10], 5)
    False
    """"""
","    for e in l:
        if e >= t:
            return False
    return True
","def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

"
"

def add(x: int, y: int):
    """"""เพิ่มตัวเลขสองจำนวน x และ y
    >>> add(2, 3)
    5
    >>> add(5, 7)
    12
    """"""
","    return x + y
","def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

"
"

def same_chars(s0: str, s1: str):
    """"""
    ตรวจสอบว่าคำสองคำมีตัวอักษรเหมือนกันหรือไม่
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')
    True
    >>> same_chars('abcd', 'dddddddabc')
    True
    >>> same_chars('dddddddabc', 'abcd')
    True
    >>> same_chars('eabcd', 'dddddddabc')
    False
    >>> same_chars('abcd', 'dddddddabce')
    False
    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')
    False
    """"""
","    return set(s0) == set(s1)
","def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

"
"

def fib(n: int):
    """"""ส่งคืนเลขฟีโบนัชชีลำดับที่ n
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib(n - 1) + fib(n - 2)
","def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

"
"

def correct_bracketing(brackets: str):
    """""" วงเล็บเป็นสตริงของ ""<"" และ "">"".
    คืนค่า True หากวงเล็บเปิดทุกอันมีวงเล็บปิดที่ตรงกัน.

    >>> correct_bracketing(""<"")
    False
    >>> correct_bracketing(""<>"")
    True
    >>> correct_bracketing(""<<><>>"")
    True
    >>> correct_bracketing(""><<>"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""<"":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

"
"

def monotonic(l: list):
    """"""คืนค่า True หากสมาชิกในรายการมีการเพิ่มขึ้นหรือลดลงอย่างต่อเนื่อง
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """"""
","    if l == sorted(l) or l == sorted(l, reverse=True):
        return True
    return False
","def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

"
"

def common(l1: list, l2: list):
    """"""คืนค่าองค์ประกอบที่ซ้ำกันของทั้งสองรายการที่เรียงลำดับและไม่ซ้ำกัน
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """"""
","    ret = set()
    for e1 in l1:
        for e2 in l2:
            if e1 == e2:
                ret.add(e1)
    return sorted(list(ret))
","def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

"
"

def largest_prime_factor(n: int):
    """"""คืนตัวประกอบเฉพาะที่ใหญ่ที่สุดของ n โดยสมมติว่า n > 1 และไม่ใช่จำนวนเฉพาะ
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """"""
","    def is_prime(k):
        if k < 2:
            return False
        for i in range(2, k - 1):
            if k % i == 0:
                return False
        return True
    largest = 1
    for j in range(2, n + 1):
        if n % j == 0 and is_prime(j):
            largest = max(largest, j)
    return largest
","def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

"
"

def sum_to_n(n: int):
    """"""sum_to_n คือฟังก์ชันที่รวมผลบวกของตัวเลขจาก 1 ถึง n
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """"""
","    return sum(range(n + 1))
","def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

"
"

def correct_bracketing(brackets: str):
    """""" วงเล็บเป็นสายอักขระที่ประกอบด้วย """".
    คืนค่า True ถ้าทุกวงเล็บเปิดมีวงเล็บปิดที่สอดคล้องกัน.

    >>> correct_bracketing(""("")
    False
    >>> correct_bracketing(""()"")
    True
    >>> correct_bracketing(""(()())"")
    True
    >>> correct_bracketing("")(()"")
    False
    """"""
","    depth = 0
    for b in brackets:
        if b == ""("":
            depth += 1
        else:
            depth -= 1
        if depth < 0:
            return False
    return depth == 0
","def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

"
"

def derivative(xs: list):
    """""" xs แทนสัมประสิทธิ์ของพหุนาม
    xs[0] + xs[1] * x + xs[2] * x^2 + ....
    คืนอนุพันธ์ของพหุนามนี้ในรูปแบบเดียวกัน
    >>> derivative([3, 1, 2, 4, 5])
    [1, 4, 12, 20]
    >>> derivative([1, 2, 3])
    [2, 6]
    """"""
","    return [(i * x) for i, x in enumerate(xs)][1:]
","def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

"
"

def fibfib(n: int):
    """"""ลำดับหมายเลข FibFib เป็นลำดับที่คล้ายกับลำดับ Fibonacci ที่กำหนดไว้ดังนี้:
    fibfib == 0
    fibfib == 0
    fibfib == 1
    fibfib == fibfib + fibfib + fibfib.
กรุณาเขียนฟังก์ชันเพื่อคำนวณสมาชิกที่ n ของลำดับหมายเลข FibFib อย่างมีประสิทธิภาพ
    >>> fibfib(1)
    0
    >>> fibfib(5)
    4
    >>> fibfib(8)
    24
    """"""
","    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 1
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
","def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

"
"
FIX = """"""
เพิ่มกรณีทดสอบเพิ่มเติม
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:
    >>> vowels_count(""abcde"")
    2
    >>> vowels_count(""ACEDY"")
    3
    """"""
","    vowels = ""aeiouAEIOU""
    n_vowels = sum(c in vowels for c in s)
    if s[-1] == 'y' or s[-1] == 'Y':
        n_vowels += 1
    return n_vowels
","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def circular_shift(x, shift):
    """"""หมุนตัวเลขของจำนวนเต็ม x ไปทางขวาตามจำนวนที่กำหนด และคืนผลลัพธ์เป็นสตริง
หากจำนวนที่ต้องหมุนมากกว่าจำนวนหลัก ให้คืนค่าตัวเลขที่กลับด้านแทน
    >>> circular_shift(12, 1)
    ""21""
    >>> circular_shift(12, 2)
    ""12""
    """"""
","    s = str(x)
    if shift > len(s):
        return s[::-1]
    else:
        return s[len(s) - shift:] + s[:len(s) - shift]
","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def digitSum(s):
    """"""เขียนฟังก์ชันที่รับสตริงเป็นอินพุตและส่งคืนผลรวมของรหัส ASCII ของอักขระตัวใหญ่เท่านั้น

ตัวอย่าง:
- digitSum => 0
- digitSum => 131
- digitSum => 67
- digitSum => 69
- digitSum => 131
- digitSum => 153
    """"""
","    if s == """": return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

"
"
def fruit_distribution(s,n):
    """"""
    ในงานนี้ คุณจะได้รับสตริงที่แสดงถึงจำนวนแอปเปิ้ลและส้มที่ถูกแจกจ่ายในตะกร้าผลไม้ ตะกร้านี้มีแอปเปิ้ล ส้ม และมะม่วง ให้สตริงที่แสดงถึงจำนวนรวมของแอปเปิ้ลและส้ม และจำนวนเต็มที่แสดงถึงจำนวนรวมของผลไม้ในตะกร้า ให้หาจำนวนมะม่วงในตะกร้า
ตัวอย่างเช่น:
fruit_distribution -> 19 - 5 - 6 = 8
fruit_distribution -> 3 - 0 - 1 = 2
fruit_distribution -> 100 - 2 - 3 = 95
fruit_distribution -> 120 - 100 - 1 = 19
    """"""
","    lis = list()
    for i in s.split(' '):
        if i.isdigit():
            lis.append(int(i))
    return n - sum(lis)
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
"
"
def pluck(arr):
    """"""
    ให้แปลประโยคต่อไปนี้เป็นภาษาไทย:

""ให้ข้อมูลเป็นอาร์เรย์ที่แสดงถึงกิ่งของต้นไม้ที่มีโหนดเป็นจำนวนเต็มที่ไม่ติดลบ
    งานของคุณคือการดึงหนึ่งในโหนดออกมาและคืนค่าโหนดนั้น
    โหนดที่ถูกดึงออกมาควรเป็นโหนดที่มีค่าน้อยที่สุดที่เป็นเลขคู่
    หากพบโหนดหลายโหนดที่มีค่าน้อยที่สุดที่เป็นเลขคู่เหมือนกัน ให้คืนค่าโหนดที่มีดัชนีที่น้อยที่สุด

    โหนดที่ถูกดึงออกมาควรถูกส่งคืนในรูปแบบของรายการ [ค่าที่น้อยที่สุด, ดัชนีของมัน]
    หากไม่มีค่าเลขคู่หรืออาร์เรย์ที่ให้มาเป็นว่าง ให้คืน []

    ตัวอย่างที่ 1:
        ข้อมูลนำเข้า: [4,2,3]
        ข้อมูลส่งออก: [2, 1]
        คำอธิบาย: 2 มีค่าน้อยที่สุดที่เป็นเลขคู่ และ 2 มีดัชนีที่น้อยที่สุด

    ตัวอย่างที่ 2:
        ข้อมูลนำเข้า: [1,2,3]
        ข้อมูลส่งออก: [2, 1]
        คำอธิบาย: 2 มีค่าน้อยที่สุดที่เป็นเลขคู่ และ 2 มีดัชนีที่น้อยที่สุด 

    ตัวอย่างที่ 3:
        ข้อมูลนำเข้า: []
        ข้อมูลส่งออก: []
    
    ตัวอย่างที่ 4:
        ข้อมูลนำเข้า: [5, 0, 3, 0, 4, 2]
        ข้อมูลส่งออก: [0, 1]
        คำอธิบาย: 0 เป็นค่าน้อยที่สุด แต่มีศูนย์สองตัว
                     ดังนั้นเราจะเลือกศูนย์ตัวแรกซึ่งมีดัชนีที่น้อยที่สุด

    ข้อจำกัด:
        * 1 <= ความยาวของโหนด <= 10000
        * 0 <= ค่าโหนด""
    """"""
","    if(len(arr) == 0): return []
    evens = list(filter(lambda x: x%2 == 0, arr))
    if(evens == []): return []
    return [min(evens), arr.index(min(evens))]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

"
"
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","    frq = [0] * (max(lst) + 1)
    for i in lst:
        frq[i] += 1;

    ans = -1
    for i in range(1, len(frq)):
        if frq[i] >= i:
            ans = i
    
    return ans
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

"
"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","    res, switch = [], True
    while lst:
        res.append(min(lst) if switch else max(lst))
        lst.remove(res[-1])
        switch = not switch
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","    if a + b <= c or a + c <= b or b + c <= a:
        return -1 
    s = (a + b + c)/2    
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

"
"
def will_it_fly(q,w):
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) â -> False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) â -> False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) â -> True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) â -> True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
","    if sum(q) > w:
        return False

    i, j = 0, len(q)-1
    while i<j:
        if q[i] != q[j]:
            return False
        i+=1
        j-=1
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 2, 3], 9) is True
    assert candidate([1, 2], 5) is False
    assert candidate([3], 5) is True
    assert candidate([3, 2, 3], 1) is False


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3], 6) is False
    assert candidate([5], 5) is True

"
"
def smallest_change(arr):
    """"""
    ให้กำหนดอาร์เรย์ arr ของจำนวนเต็ม ให้หาจำนวนองค์ประกอบขั้นต่ำที่ต้องเปลี่ยนเพื่อทำให้อาร์เรย์นั้นเป็นอาร์เรย์แบบพาลินโดรม อาร์เรย์แบบพาลินโดรมคืออาร์เรย์ที่อ่านจากซ้ายไปขวาและขวาไปซ้ายได้เหมือนกัน ในการเปลี่ยนหนึ่งครั้ง คุณสามารถเปลี่ยนหนึ่งองค์ประกอบให้เป็นองค์ประกอบอื่นใดก็ได้

ตัวอย่างเช่น:
smallest_change == 4
smallest_change == 1
smallest_change == 0
    """"""
","    ans = 0
    for i in range(len(arr) // 2):
        if arr[i] != arr[len(arr) - i - 1]:
            ans += 1
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,5,4,7,9,6]) == 4
    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1
    assert candidate([1, 4, 2]) == 1
    assert candidate([1, 4, 4, 2]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, 2, 1]) == 0
    assert candidate([3, 1, 1, 3]) == 0
    assert candidate([1]) == 0
    assert candidate([0, 1]) == 1

"
"
def total_match(lst1, lst2):
    '''
    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.

    Examples
    total_match([], []) â -> []
    total_match(['hi', 'admin'], ['hI', 'Hi']) â -> ['hI', 'Hi']
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) â -> ['hi', 'admin']
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) â -> ['hI', 'hi', 'hi']
    total_match(['4'], ['1', '2', '3', '4', '5']) â -> ['4']
    '''
","    l1 = 0
    for st in lst1:
        l1 += len(st)
    
    l2 = 0
    for st in lst2:
        l2 += len(st)
    
    if l1 <= l2:
        return lst1
    else:
        return lst2
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([], []) == []
    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']
    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']
    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']
    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']
    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']


    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([], ['this']) == []
    assert candidate(['this'], []) == []

"
"
def is_multiply_prime(a):
    """"""เขียนฟังก์ชันที่คืนค่าเป็น true หากตัวเลขที่ให้มานั้นเป็นผลคูณของจำนวนเฉพาะ 3 ตัว 
และคืนค่าเป็น false หากไม่ใช่ 
โดยที่ มีค่าน้อยกว่า 100
ตัวอย่าง:
is_multiply_prime == True
30 = 2 * 3 * 5
    """"""
","    def is_prime(n):
        for j in range(2,n):
            if n%j == 0:
                return False
        return True

    for i in range(2,101):
        if not is_prime(i): continue
        for j in range(2,101):
            if not is_prime(j): continue
            for k in range(2,101):
                if not is_prime(k): continue
                if i*j*k == a: return True
    return False
","def check(candidate):

    assert candidate(5) == False
    assert candidate(30) == True
    assert candidate(8) == True
    assert candidate(10) == False
    assert candidate(125) == True
    assert candidate(3 * 5 * 7) == True
    assert candidate(3 * 6 * 7) == False
    assert candidate(9 * 9 * 9) == False
    assert candidate(11 * 9 * 9) == False
    assert candidate(11 * 13 * 7) == True

"
"
def is_simple_power(x, n):
    """"""งานของคุณคือการเขียนฟังก์ชันที่คืนค่าเป็นจริงหากตัวเลข x เป็นกำลังง่ายของ n และคืนค่าเป็นเท็จในกรณีอื่น ๆ
x เป็นกำลังง่ายของ n ถ้า n**จำนวนเต็ม=x
ตัวอย่างเช่น:
is_simple_power => true
is_simple_power => true
is_simple_power => true
is_simple_power => false
is_simple_power => false
is_simple_power => false
    """"""
","    if (n == 1): 
        return (x == 1) 
    power = 1
    while (power < x): 
        power = power * n 
    return (power == x) 
","def check(candidate):

    # Check some simple cases
    assert candidate(16, 2)== True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(143214, 16)== False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(4, 2)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(9, 3)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(16, 4)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(24, 2)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(128, 4)==False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(12, 6)==False, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1)==True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(1, 12)==True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''
","    a = abs(a)
    return int(round(a ** (1. / 3))) ** 3 == a
","def check(candidate):

    # Check some simple cases
    assert candidate(1) == True, ""First test error: "" + str(candidate(1))
    assert candidate(2) == False, ""Second test error: "" + str(candidate(2))
    assert candidate(-1) == True, ""Third test error: "" + str(candidate(-1))
    assert candidate(64) == True, ""Fourth test error: "" + str(candidate(64))
    assert candidate(180) == False, ""Fifth test error: "" + str(candidate(180))
    assert candidate(1000) == True, ""Sixth test error: "" + str(candidate(1000))


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == True, ""1st edge test error: "" + str(candidate(0))
    assert candidate(1729) == False, ""2nd edge test error: "" + str(candidate(1728))

"
"
def hex_key(num):
    """"""คุณได้รับมอบหมายให้เขียนฟังก์ชันที่รับหมายเลขฐานสิบหกเป็นสตริงและนับจำนวนหลักฐานสิบหกที่เป็นจำนวนเฉพาะ หลักฐานสิบหกประกอบด้วย 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F จำนวนเฉพาะได้แก่ 2, 3, 5, 7, 11, 13, 17,... ดังนั้นคุณต้องกำหนดจำนวนของหลักต่อไปนี้: 2, 3, 5, 7, B, D หมายเหตุ: คุณสามารถสมมติได้ว่าอินพุตถูกต้องเสมอหรือเป็นสตริงว่างเปล่า และสัญลักษณ์ A, B, C, D, E, F เป็นตัวพิมพ์ใหญ่เสมอ ตัวอย่าง: สำหรับ num = ""AB"" ผลลัพธ์ควรเป็น 1 สำหรับ num = ""1077E"" ผลลัพธ์ควรเป็น 2 สำหรับ num = ""ABED1A33"" ผลลัพธ์ควรเป็น 4 สำหรับ num = ""123456789ABCDEF0"" ผลลัพธ์ควรเป็น 6 สำหรับ num = ""2020"" ผลลัพธ์ควรเป็น 2
    """"""
","    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)):
        if num[i] in primes:
            total += 1
    return total
","def check(candidate):

    # Check some simple cases
    assert candidate(""AB"") == 1, ""First test error: "" + str(candidate(""AB""))      
    assert candidate(""1077E"") == 2, ""Second test error: "" + str(candidate(""1077E""))  
    assert candidate(""ABED1A33"") == 4, ""Third test error: "" + str(candidate(""ABED1A33""))      
    assert candidate(""2020"") == 2, ""Fourth test error: "" + str(candidate(""2020""))  
    assert candidate(""123456789ABCDEF0"") == 6, ""Fifth test error: "" + str(candidate(""123456789ABCDEF0""))      
    assert candidate(""112233445566778899AABBCCDDEEFF00"") == 12, ""Sixth test error: "" + str(candidate(""112233445566778899AABBCCDDEEFF00""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate([]) == 0

"
"
def decimal_to_binary(decimal):
    """"""คุณจะได้รับตัวเลขในรูปแบบทศนิยม และงานของคุณคือต้องแปลงเป็นรูปแบบฐานสอง ฟังก์ชันควรคืนค่าเป็นสตริง โดยแต่ละตัวอักษรแทนเลขฐานสอง แต่ละตัวอักษรในสตริงจะเป็น '0' หรือ '1'

จะมีตัวอักษรพิเศษ 'db' ที่จุดเริ่มต้นและจุดสิ้นสุดของสตริง ตัวอักษรพิเศษเหล่านี้มีไว้เพื่อช่วยในเรื่องรูปแบบ

ตัวอย่าง:
decimal_to_binary   # คืนค่า ""db1111db""
decimal_to_binary   # คืนค่า ""db100000db""
    """"""
","    return ""db"" + bin(decimal)[2:] + ""db""
","def check(candidate):

    # Check some simple cases
    assert candidate(0) == ""db0db""
    assert candidate(32) == ""db100000db""
    assert candidate(103) == ""db1100111db""
    assert candidate(15) == ""db1111db"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def is_happy(s):
    """"""คุณได้รับสตริง s
    งานของคุณคือการตรวจสอบว่าสตริงมีความสุขหรือไม่
    สตริงมีความสุขหากมีความยาวอย่างน้อย 3 ตัวอักษรและทุก 3 ตัวอักษรติดต่อกันไม่ซ้ำกัน
    ตัวอย่างเช่น:
    is_happy => ผิด
    is_happy => ผิด
    is_happy => ถูก
    is_happy => ผิด
    is_happy => ถูก
    is_happy => ผิด
    """"""
","    if len(s) < 3:
      return False

    for i in range(len(s) - 2):
      
      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate(""a"") == False , ""a""
    assert candidate(""aa"") == False , ""aa""
    assert candidate(""abcd"") == True , ""abcd""
    assert candidate(""aabb"") == False , ""aabb""
    assert candidate(""adb"") == True , ""adb""
    assert candidate(""xyy"") == False , ""xyy""
    assert candidate(""iopaxpoi"") == True , ""iopaxpoi""
    assert candidate(""iopaxioi"") == False , ""iopaxioi""
"
"
def numerical_letter_grade(grades):
    """"""สัปดาห์สุดท้ายของภาคการศึกษาและครูต้องให้คะแนนแก่นักเรียน ครูได้ทำอัลกอริทึมของตัวเองสำหรับการให้คะแนน ปัญหาเดียวคือเธอได้ทำโค้ดที่ใช้ในการให้คะแนนหายไป เธอได้ให้รายการเกรดเฉลี่ยสะสม ของนักเรียนบางคนแก่คุณ และคุณต้องเขียนฟังก์ชันที่สามารถส่งออกรายการเกรดเป็นตัวอักษรโดยใช้ตารางต่อไปนี้:

             GPA       |    เกรดตัวอักษร
              4.0                A+
            > 3.7                A 
            > 3.3                A- 
            > 3.0                B+
            > 2.7                B 
            > 2.3                B-
            > 2.0                C+
            > 1.7                C
            > 1.3                C-
            > 1.0                D+ 
            > 0.7                D 
            > 0.0                D-
              0.0                E

ตัวอย่าง:
grade_equation ==> ['A+', 'B', 'C-', 'C', 'A-']
    """"""
","
   
    letter_grade = []
    for gpa in grades:
        if gpa == 4.0:
            letter_grade.append(""A+"")
        elif gpa > 3.7:
            letter_grade.append(""A"")
        elif gpa > 3.3:
            letter_grade.append(""A-"")
        elif gpa > 3.0:
            letter_grade.append(""B+"")
        elif gpa > 2.7:
            letter_grade.append(""B"")
        elif gpa > 2.3:
            letter_grade.append(""B-"")
        elif gpa > 2.0:
            letter_grade.append(""C+"")
        elif gpa > 1.7:
            letter_grade.append(""C"")
        elif gpa > 1.3:
            letter_grade.append(""C-"")
        elif gpa > 1.0:
            letter_grade.append(""D+"")
        elif gpa > 0.7:
            letter_grade.append(""D"")
        elif gpa > 0.0:
            letter_grade.append(""D-"")
        else:
            letter_grade.append(""E"")
    return letter_grade
","def check(candidate):

    # Check some simple cases
    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']
    assert candidate([1.2]) == ['D+']
    assert candidate([0.5]) == ['D-']
    assert candidate([0.0]) == ['E']
    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']
    assert candidate([0, 0.7]) == ['E', 'D-']

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def prime_length(string):
    """"""เขียนฟังก์ชันที่รับสตริงและคืนค่า True หากความยาวของสตริงเป็นจำนวนเฉพาะ มิฉะนั้นคืนค่า False
ตัวอย่าง
prime_length == True
prime_length == True
prime_length == True
prime_length == False
    """"""
","    l = len(string)
    if l == 0 or l == 1:
        return False
    for i in range(2, l):
        if l % i == 0:
            return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello') == True
    assert candidate('abcdcba') == True
    assert candidate('kittens') == True
    assert candidate('orange') == False
    assert candidate('wow') == True
    assert candidate('world') == True
    assert candidate('MadaM') == True
    assert candidate('Wow') == True
    assert candidate('') == False
    assert candidate('HI') == True
    assert candidate('go') == True
    assert candidate('gogo') == False
    assert candidate('aaaaaaaaaaaaaaa') == False

    # Check some edge cases that are easy to work out by hand.
    assert candidate('Madam') == True
    assert candidate('M') == False
    assert candidate('0') == False

"
"
def starts_one_ends(n):
    """"""
    กำหนดจำนวนเต็มบวก n ให้คืนค่าจำนวนตัวเลขของจำนวนเต็มบวก n หลักที่ขึ้นต้นหรือสิ้นสุดด้วย 1
    """"""
","    if n == 1: return 1
    return 18 * (10 ** (n - 2))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1) == 1
    assert candidate(2) == 18
    assert candidate(3) == 180
    assert candidate(4) == 1800
    assert candidate(5) == 18000

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def solve(N):
    """"""ให้จำนวนเต็มบวก N ให้คืนผลรวมทั้งหมดของตัวเลขในฐานสอง

    ตัวอย่าง
        สำหรับ N = 1000, ผลรวมของตัวเลขจะเป็น 1 ผลลัพธ์ที่ได้ควรเป็น ""1""
        สำหรับ N = 150, ผลรวมของตัวเลขจะเป็น 6 ผลลัพธ์ที่ได้ควรเป็น ""110""
        สำหรับ N = 147, ผลรวมของตัวเลขจะเป็น 12 ผลลัพธ์ที่ได้ควรเป็น ""1100""
    
    ตัวแปร:
        @N จำนวนเต็ม
             ข้อจำกัด: 0 ≤ N ≤ 10000
    ผลลัพธ์:
         สตริงของเลขฐานสอง
    """"""
","    return bin(sum(int(i) for i in str(N)))[2:]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1000) == ""1"", ""Error""
    assert candidate(150) == ""110"", ""Error""
    assert candidate(147) == ""1100"", ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(333) == ""1001"", ""Error""
    assert candidate(963) == ""10010"", ""Error""

"
"
def add(lst):
    """"""ให้รายการที่ไม่ว่างของจำนวนเต็ม lst ให้บวกตัวเลขที่เป็นจำนวนคู่ซึ่งอยู่ในตำแหน่งเลขคี่

    ตัวอย่าง:
        add ==> 2 
    """"""
","    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])
","def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    
"
"
def anti_shuffle(s):
    """"""
    เขียนฟังก์ชันที่รับสตริงและคืนค่าสตริงที่เรียงลำดับใหม่
    สตริงที่เรียงลำดับใหม่คือสตริงที่คำทั้งหมด
    ถูกแทนที่ด้วยคำใหม่ที่ตัวอักษรทั้งหมดเรียงลำดับ
    ตามค่าของอักขระ ascii ในลำดับเพิ่มขึ้น
    หมายเหตุ: คุณควรรักษาลำดับของคำและช่องว่างในประโยค

    ตัวอย่างเช่น:
    anti_shuffle คืนค่า 'Hi'
    anti_shuffle คืนค่า 'ehllo'
    anti_shuffle คืนค่า 'Hello !!!Wdlor'
    """"""
","    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
","def check(candidate):

    # Check some simple cases
    assert candidate('Hi') == 'Hi'
    assert candidate('hello') == 'ehllo'
    assert candidate('number') == 'bemnru'
    assert candidate('abcd') == 'abcd'
    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'
    assert candidate('') == ''
    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'
    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def get_row(lst, x):
    """"""
    คุณได้รับข้อมูลสองมิติในรูปแบบของรายการซ้อนกัน ซึ่งคล้ายกับเมทริกซ์ แต่ต่างจากเมทริกซ์ตรงที่แต่ละแถวอาจมีจำนวนคอลัมน์ที่แตกต่างกัน ให้รายการ lst และจำนวนเต็ม x ค้นหาจำนวนเต็ม x ในรายการ และคืนรายการของทูเพิล [, ...] โดยที่แต่ละทูเพิลเป็นพิกัด เริ่มจาก 0 จัดเรียงพิกัดตามแถวในลำดับจากน้อยไปมาก และจัดเรียงพิกัดของแถวตามคอลัมน์ในลำดับจากมากไปน้อย

ตัวอย่าง:
get_row([
  [1,2,3,4,5,6],
  [1,2,3,4,1,6],
  [1,2,3,4,5,1]
], 1) == [,,,,]
get_row == []
get_row == []
    """"""
","    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]
    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])
","def check(candidate):

    # Check some simple cases
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,2,3,4,5,6]
    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
    assert candidate([
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
        [1,1,3,4,5,6],
        [1,2,1,4,5,6],
        [1,2,3,1,5,6],
        [1,2,3,4,1,6],
        [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]
    assert candidate([], 1) == []
    assert candidate([[1]], 2) == []
    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def sort_array(array):
    """"""
    ให้กำหนดอาร์เรย์ของจำนวนเต็มที่ไม่เป็นค่าลบ และคืนสำเนาของอาร์เรย์นั้นหลังจากการเรียงลำดับ
คุณจะเรียงลำดับอาร์เรย์ในลำดับจากน้อยไปหามากถ้าผลรวม เป็นเลขคี่
หรือเรียงลำดับในลำดับจากมากไปหาน้อยถ้าผลรวม เป็นเลขคู่

หมายเหตุ:
* ห้ามเปลี่ยนอาร์เรย์ที่กำหนด

ตัวอย่าง:
* sort_array => []
* sort_array => [5]
* sort_array => [0, 1, 2, 3, 4, 5]
* sort_array => [6, 5, 4, 3, 2, 1, 0]
    """"""
","    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) 
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == [], ""Error""
    assert candidate([5]) == [5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], ""Error""
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([2, 1]) == [1, 2], ""Error""
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], ""Error""
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], ""Error""

"
"
def encrypt(s):
    """"""สร้างฟังก์ชัน encrypt ที่รับสตริงเป็นอาร์กิวเมนต์และ
    คืนค่าสตริงที่ถูกเข้ารหัสด้วยการหมุนตัวอักษร
    ตัวอักษรควรถูกหมุนในลักษณะที่ตัวอักษรเลื่อนลงไปโดยสองคูณด้วยสองตำแหน่ง
    ตัวอย่างเช่น:
    encrypt คืนค่า 'lm'
    encrypt คืนค่า 'ewhjklnop'
    encrypt คืนค่า 'kj'
    encrypt คืนค่า 'ix'
    """"""
","    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s:
        if c in d:
            out += d[(d.index(c)+2*2) % 26]
        else:
            out += c
    return out
","def check(candidate):

    # Check some simple cases
    assert candidate('hi') == 'lm', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('asdfghjkl') == 'ewhjklnop', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('gf') == 'kj', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('et') == 'ix', ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate('faewfawefaewg')=='jeiajeaijeiak', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('hellomyfriend')=='lippsqcjvmirh', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', ""This prints if this assert fails 3 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate('a')=='e', ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def next_smallest(lst):
    """"""
    คุณได้รับรายการของจำนวนเต็ม
    เขียนฟังก์ชัน next_smallest ที่คืนค่าตัวที่เล็กที่สุดอันดับที่ 2 ของรายการ
    คืนค่า None ถ้าไม่มีตัวที่เล็กที่สุดอันดับที่ 2

    next_smallest == 2
    next_smallest == 2
    next_smallest == None
    next_smallest == None
    """"""
","    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst[1]
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4, 5]) == 2
    assert candidate([5, 1, 4, 3, 2]) == 2
    assert candidate([]) == None
    assert candidate([1, 1]) == None
    assert candidate([1,1,1,1,0]) == 1
    assert candidate([1, 0**0]) == None
    assert candidate([-35, 34, 12, -45]) == -35

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def is_bored(S):
    """"""
    คุณจะได้รับสตริงของคำ และงานของคุณคือการนับจำนวนของความเบื่อหน่าย ความเบื่อหน่ายคือประโยคที่เริ่มต้นด้วยคำว่า ""ฉัน"" ประโยคถูกแยกด้วย '.' '?' หรือ '!'.

ตัวอย่างเช่น:
    >>> is_bored(""Hello world"")
    0
    >>> is_bored(""The sky is blue. The sun is shining. I love this weather"")
    1
    """"""
","    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence[0:2] == 'I ' for sentence in sentences)
","def check(candidate):

    # Check some simple cases
    assert candidate(""Hello world"") == 0, ""Test 1""
    assert candidate(""Is the sky blue?"") == 0, ""Test 2""
    assert candidate(""I love It !"") == 1, ""Test 3""
    assert candidate(""bIt"") == 0, ""Test 4""
    assert candidate(""I feel good today. I will be productive. will kill It"") == 2, ""Test 5""
    assert candidate(""You and I are going for a walk"") == 0, ""Test 6""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def any_int(x, y, z):
    '''
    Create a function that takes 3 numbers.
    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
    Returns false in any other cases.
    
    Examples
    any_int(5, 2, 7) â -> True
    
    any_int(3, 2, 2) â -> False

    any_int(3, -2, 1) â -> True
    
    any_int(3.6, -2.2, 2) â -> False
  

    
    '''
","    
    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):
        if (x+y==z) or (x+z==y) or (y+z==x):
            return True
        return False
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 3, 1)==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(2.5, 2, 3)==False, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(1.5, 5, 3.5)==False, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate(2, 6, 2)==False, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(4, 2, 2)==True, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate(2.2, 2.2, 2.2)==False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate(-4, 6, 2)==True, ""This prints if this assert fails 7 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2,1,1)==True, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate(3,4,7)==True, ""This prints if this assert fails 9 (also good for debugging!)""
    assert candidate(3.0,4,7)==False, ""This prints if this assert fails 10 (also good for debugging!)""

"
"
def encode(message):
    """"""
    เขียนฟังก์ชั่นที่รับข้อความและเข้ารหัสข้อความนั้นโดยการสลับตัวพิมพ์ใหญ่และตัวพิมพ์เล็กของตัวอักษรทั้งหมด และแทนที่สระทั้งหมดในข้อความด้วยตัวอักษรที่ปรากฏอยู่ 2 ตำแหน่งข้างหน้าของสระนั้นในตัวอักษรภาษาอังกฤษ
สมมติว่ามีเพียงตัวอักษรเท่านั้น

ตัวอย่าง:
    >>> encode('test')
    'TGST'
    >>> encode('This is a message')
    'tHKS KS C MGSSCGG'
    """"""
","    vowels = ""aeiouAEIOU""
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace[i] if i in vowels else i for i in message])
","def check(candidate):

    # Check some simple cases
    assert candidate('TEST') == 'tgst', ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('Mudasir') == 'mWDCSKR', ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('YES') == 'ygs', ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(""I DoNt KnOw WhAt tO WrItE"") == 'k dQnT kNqW wHcT Tq wRkTg', ""This prints if this assert fails 2 (also good for debugging!)""

"
"

def skjkasdkd(lst):
    """"""คุณได้รับรายการของจำนวนเต็ม
    คุณต้องหาค่าของจำนวนเฉพาะที่ใหญ่ที่สุดและคืนผลรวมของหลักของมัน

    ตัวอย่าง:
    สำหรับ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ผลลัพธ์ควรเป็น 10
    สำหรับ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ผลลัพธ์ควรเป็น 25
    สำหรับ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ผลลัพธ์ควรเป็น 13
    สำหรับ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ผลลัพธ์ควรเป็น 11
    สำหรับ lst = [0,81,12,3,1,21] ผลลัพธ์ควรเป็น 3
    สำหรับ lst = [0,8,1,2,1,7] ผลลัพธ์ควรเป็น 7
    """"""
","    def isPrime(n):
        for i in range(2,int(n**0.5)+1):
            if n%i==0:
                return False

        return True
    maxx = 0
    i = 0
    while i < len(lst):
        if(lst[i] > maxx and isPrime(lst[i])):
            maxx = lst[i]
        i+=1
    result = sum(int(digit) for digit in str(maxx))
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, ""This prints if this assert fails 2 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, ""This prints if this assert fails 3 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, ""This prints if this assert fails 4 (also good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,81,12,3,1,21]) == 3, ""This prints if this assert fails 5 (also good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([0,8,1,2,1,7]) == 7, ""This prints if this assert fails 6 (also good for debugging!)""

    assert candidate([8191]) == 19, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate([8191, 123456, 127, 7]) == 19, ""This prints if this assert fails 8 (also good for debugging!)""
    assert candidate([127, 97, 8192]) == 10, ""This prints if this assert fails 9 (also good for debugging!)""
"
"
def check_dict_case(dict):
    """"""
    ให้พจนานุกรมหนึ่งตัว คืนค่า True หากคีย์ทั้งหมดเป็นสตริงในรูปแบบตัวพิมพ์เล็กทั้งหมดหรือตัวพิมพ์ใหญ่ทั้งหมด มิฉะนั้นให้คืนค่า False ฟังก์ชันควรคืนค่า False หากพจนานุกรมที่ให้มาว่างเปล่า
ตัวอย่าง:
check_dict_case ควรคืนค่า True
check_dict_case ควรคืนค่า False
check_dict_case ควรคืนค่า False
check_dict_case ควรคืนค่า False
check_dict_case ควรคืนค่า True
    """"""
","    if len(dict.keys()) == 0:
        return False
    else:
        state = ""start""
        for key in dict.keys():

            if isinstance(key, str) == False:
                state = ""mixed""
                break
            if state == ""start"":
                if key.isupper():
                    state = ""upper""
                elif key.islower():
                    state = ""lower""
                else:
                    break
            elif (state == ""upper"" and not key.isupper()) or (state == ""lower"" and not key.islower()):
                    state = ""mixed""
                    break
            else:
                break
        return state == ""upper"" or state == ""lower"" 
","def check(candidate):

    # Check some simple cases
    assert candidate({""p"":""pineapple"", ""b"":""banana""}) == True, ""First test error: "" + str(candidate({""p"":""pineapple"", ""b"":""banana""}))
    assert candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}) == False, ""Second test error: "" + str(candidate({""p"":""pineapple"", ""A"":""banana"", ""B"":""banana""}))
    assert candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}) == False, ""Third test error: "" + str(candidate({""p"":""pineapple"", 5:""banana"", ""a"":""apple""}))
    assert candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}) == False, ""Fourth test error: "" + str(candidate({""Name"":""John"", ""Age"":""36"", ""City"":""Houston""}))
    assert candidate({""STATE"":""NC"", ""ZIP"":""12345"" }) == True, ""Fifth test error: "" + str(candidate({""STATE"":""NC"", ""ZIP"":""12345"" }))      
    assert candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }) == True, ""Fourth test error: "" + str(candidate({""fruit"":""Orange"", ""taste"":""Sweet"" }))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate({}) == False, ""1st edge test error: "" + str(candidate({}))

"
"
def count_up_to(n):
    """"""เขียนฟังก์ชันที่รับจำนวนเต็มที่ไม่เป็นลบและส่งคืนอาเรย์ของจำนวนเต็ม n ตัวแรกที่เป็นจำนวนเฉพาะและน้อยกว่า n.
ตัวอย่างเช่น:
count_up_to => [2,3]
count_up_to => [2,3,5,7]
count_up_to => []
count_up_to => [2,3,5,7,11,13,17,19]
count_up_to => []
count_up_to => [2,3,5,7,11,13,17]
    """"""
","    primes = []
    for i in range(2, n):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes

","def check(candidate):

    assert candidate(5) == [2,3]
    assert candidate(6) == [2,3,5]
    assert candidate(7) == [2,3,5]
    assert candidate(10) == [2,3,5,7]
    assert candidate(0) == []
    assert candidate(22) == [2,3,5,7,11,13,17,19]
    assert candidate(1) == []
    assert candidate(18) == [2,3,5,7,11,13,17]
    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]
    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

"
"
def multiply(a, b):
    """"""เขียนฟังก์ชันที่รับจำนวนเต็มสองจำนวนและคืนค่าผลคูณของตัวเลขหลักหน่วยของทั้งสองจำนวน
    สมมติว่าข้อมูลที่ป้อนเข้าเป็นข้อมูลที่ถูกต้องเสมอ
    ตัวอย่าง:
    multiply จะคืนค่า 16
    multiply จะคืนค่า 72
    multiply จะคืนค่า 0
    multiply จะคืนค่า 20
    """"""
","    return abs(a % 10) * abs(b % 10)
","def check(candidate):

    # Check some simple cases
    assert candidate(148, 412) == 16, ""First test error: "" + str(candidate(148, 412))                    
    assert candidate(19, 28) == 72, ""Second test error: "" + str(candidate(19, 28))           
    assert candidate(2020, 1851) == 0, ""Third test error: "" + str(candidate(2020, 1851))
    assert candidate(14,-15) == 20, ""Fourth test error: "" + str(candidate(14,-15))      
    assert candidate(76, 67) == 42, ""Fifth test error: "" + str(candidate(76, 67))      
    assert candidate(17, 27) == 49, ""Sixth test error: "" + str(candidate(17, 27))      


    # Check some edge cases that are easy to work out by hand.
    assert candidate(0, 1) == 0, ""1st edge test error: "" + str(candidate(0, 1))
    assert candidate(0, 0) == 0, ""2nd edge test error: "" + str(candidate(0, 0))

"
"
def count_upper(s):
    """"""
    ให้สตริง s นับจำนวนสระตัวพิมพ์ใหญ่ในดัชนีเลขคู่

    ตัวอย่างเช่น:
    count_upper คืนค่า 1
    count_upper คืนค่า 0
    count_upper คืนค่า 0
    """"""
","    count = 0
    for i in range(0,len(s),2):
        if s[i] in ""AEIOU"":
            count += 1
    return count
","def check(candidate):

    # Check some simple cases
    assert candidate('aBCdEf')  == 1
    assert candidate('abcdefg') == 0
    assert candidate('dBBE') == 0
    assert candidate('B')  == 0
    assert candidate('U')  == 1
    assert candidate('') == 0
    assert candidate('EEEE') == 2

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def closest_integer(value):
    '''
    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Examples
    >>> closest_integer(""10"")
    10
    >>> closest_integer(""15.3"")
    15

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For Exampleclosest_integer(""14.5"") should
    return 15 and closest_integer(""-14.5"") should return -15.
    '''
","    from math import floor, ceil

    if value.count('.') == 1:
        # remove trailing zeros
        while (value[-1] == '0'):
            value = value[:-1]

    num = float(value)
    if value[-2:] == '.5':
        if num > 0:
            res = ceil(num)
        else:
            res = floor(num)
    elif len(value) > 0:
        res = int(round(num))
    else:
        res = 0

    return res

","def check(candidate):

    # Check some simple cases
    assert candidate(""10"") == 10, ""Test 1""
    assert candidate(""14.5"") == 15, ""Test 2""
    assert candidate(""-15.5"") == -16, ""Test 3""
    assert candidate(""15.3"") == 15, ""Test 3""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""0"") == 0, ""Test 0""

"
"
def make_a_pile(n):
    """"""
    ให้จำนวนเต็มบวก n คุณต้องทำกองหินที่มี n ระดับ
    ระดับแรกมีหิน n ก้อน
    จำนวนหินในระดับถัดไปคือ:
        - เลขคี่ถัดไปถ้า n เป็นเลขคี่
        - เลขคู่ถัดไปถ้า n เป็นเลขคู่
    ส่งคืนจำนวนหินในแต่ละระดับในรูปแบบของรายการ โดยที่องค์ประกอบที่ดัชนี i แทนจำนวนหินในระดับที่

    ตัวอย่าง:
    >>> make_a_pile(3)
    [3, 5, 7]
    """"""
","    return [n + 2*i for i in range(n)]
","def check(candidate):

    # Check some simple cases
    assert candidate(3) == [3, 5, 7], ""Test 3""
    assert candidate(4) == [4,6,8,10], ""Test 4""
    assert candidate(5) == [5, 7, 9, 11, 13]
    assert candidate(6) == [6, 8, 10, 12, 14, 16]
    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def words_string(s):
    """"""
    คุณจะได้รับสตริงของคำที่คั่นด้วยเครื่องหมายจุลภาคหรือช่องว่าง งานของคุณคือแยกสตริงออกเป็นคำและส่งคืนเป็นอาร์เรย์ของคำ

ตัวอย่างเช่น:  
words_string == [""Hi"", ""my"", ""name"", ""is"", ""John""]  
words_string == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    """"""
","    if not s:
        return []

    s_list = []

    for letter in s:
        if letter == ',':
            s_list.append(' ')
        else:
            s_list.append(letter)

    s_list = """".join(s_list)
    return s_list.split()
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Hi, my name is John"") == [""Hi"", ""my"", ""name"", ""is"", ""John""]
    assert candidate(""One, two, three, four, five, six"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]
    assert candidate(""Hi, my name"") == [""Hi"", ""my"", ""name""]
    assert candidate(""One,, two, three, four, five, six,"") == [""One"", ""two"", ""three"", ""four"", ""five"", ""six""]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("""") == []
    assert candidate(""ahmed     , gamal"") == [""ahmed"", ""gamal""]

"
"
def choose_num(x, y):
    """"""ฟังก์ชันนี้รับตัวเลขบวกสองจำนวน x และ y และส่งคืนจำนวนเต็มคู่ที่ใหญ่ที่สุดที่อยู่ในช่วง [x, y] รวมทั้งสองขอบเขต ถ้าไม่มีจำนวนดังกล่าว ฟังก์ชันจะส่งคืน -1

ตัวอย่างเช่น:
choose_num = 14
choose_num = -1
    """"""
","    if x > y:
        return -1
    if y % 2 == 0:
        return y
    if x == y:
        return -1
    return y - 1
","def check(candidate):

    # Check some simple cases
    assert candidate(12, 15) == 14
    assert candidate(13, 12) == -1
    assert candidate(33, 12354) == 12354
    assert candidate(5234, 5233) == -1
    assert candidate(6, 29) == 28
    assert candidate(27, 10) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 7) == -1
    assert candidate(546, 546) == 546

"
"
def rounded_avg(n, m):
    """"""คุณได้รับจำนวนเต็มบวกสองจำนวน n และ m และงานของคุณคือการคำนวณค่าเฉลี่ยของจำนวนเต็มจาก n ถึง m ให้ปัดคำตอบไปยังจำนวนเต็มที่ใกล้ที่สุดและแปลงเป็นเลขฐานสอง หาก n มากกว่า m ให้คืนค่า -1 ตัวอย่าง:
rounded_avg => ""0b11""
rounded_avg => -1
rounded_avg => ""0b1111""
rounded_avg => ""0b11010""
    """"""
","    if m < n:
        return -1
    summation = 0
    for i in range(n, m+1):
        summation += i
    return bin(round(summation/(m - n + 1)))
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == ""0b11""
    assert candidate(7, 13) == ""0b1010""
    assert candidate(964,977) == ""0b1111001010""
    assert candidate(996,997) == ""0b1111100100""
    assert candidate(560,851) == ""0b1011000010""
    assert candidate(185,546) == ""0b101101110""
    assert candidate(362,496) == ""0b110101101""
    assert candidate(350,902) == ""0b1001110010""
    assert candidate(197,233) == ""0b11010111""


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == ""0b101""

"
"
def unique_digits(x):
    """"""เนื่องจากมีรายการของจำนวนเต็มบวก x ให้คืนรายการที่เรียงลำดับขององค์ประกอบทั้งหมดที่ไม่มีตัวเลขคู่

หมายเหตุ: รายการที่คืนควรถูกเรียงลำดับในลำดับที่เพิ่มขึ้น

ตัวอย่างเช่น:
    >>> unique_digits([15, 33, 1422, 1])
    [1, 15, 33]
    >>> unique_digits([152, 323, 1422, 10])
    []
    """"""
","    odd_digit_elements = []
    for i in x:
        if all (int(c) % 2 == 1 for c in str(i)):
            odd_digit_elements.append(i)
    return sorted(odd_digit_elements)
","def check(candidate):

    # Check some simple cases
    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]
    assert candidate([152, 323, 1422, 10]) == []
    assert candidate([12345, 2033, 111, 151]) == [111, 151]
    assert candidate([135, 103, 31]) == [31, 135]

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def by_length(arr):
    """"""
    ให้ค่าอาร์เรย์ของจำนวนเต็ม ทำการจัดเรียงจำนวนเต็มที่อยู่ระหว่าง 1 ถึง 9 รวมทั้งสิ้น
    จากนั้นทำการกลับลำดับของอาร์เรย์ที่ได้ และแทนที่แต่ละหลักด้วยชื่อที่สอดคล้องกันจาก 
    ""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine""

    ตัวอย่างเช่น:
      arr = [2, 1, 1, 4, 5, 8, 2, 3]   
            -> จัดเรียง arr -> [1, 1, 2, 2, 3, 4, 5, 8] 
            -> กลับลำดับ arr -> [8, 5, 4, 3, 2, 2, 1, 1]
      return [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""]
    
      หากอาร์เรย์ว่างเปล่า ให้คืนค่าอาร์เรย์ว่างเปล่า:
      arr = []
      return []
    
      หากอาร์เรย์มีจำนวนที่ไม่ถูกต้อง ให้ข้ามมัน:
      arr = [1, -1 , 55] 
            -> จัดเรียง arr -> [-1, 1, 55]
            -> กลับลำดับ arr -> [55, 1, -1]
      return = ['One']
    """"""
","    dic = {
        1: ""One"",
        2: ""Two"",
        3: ""Three"",
        4: ""Four"",
        5: ""Five"",
        6: ""Six"",
        7: ""Seven"",
        8: ""Eight"",
        9: ""Nine"",
    }
    sorted_arr = sorted(arr, reverse=True)
    new_arr = []
    for var in sorted_arr:
        try:
            new_arr.append(dic[var])
        except:
            pass
    return new_arr
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [""Eight"", ""Five"", ""Four"", ""Three"", ""Two"", ""Two"", ""One"", ""One""], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([1, -1 , 55]) == ['One'], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, -1, 3, 2]) == [""Three"", ""Two"", ""One""]
    assert candidate([9, 4, 8]) == [""Nine"", ""Eight"", ""Four""]

"
"
def f(n):
    """""" ให้เขียนฟังก์ชัน f ที่รับพารามิเตอร์ n และคืนค่าลิสต์ขนาด n โดยค่าขององค์ประกอบที่ตำแหน่ง i จะเป็นค่าแฟกทอเรียลของ i หาก i เป็นเลขคู่ หรือผลรวมของตัวเลขจาก 1 ถึง i หาก i เป็นเลขคี่
i เริ่มจาก 1
แฟกทอเรียลของ i คือการคูณของตัวเลขจาก 1 ถึง i
ตัวอย่าง:
f == [1, 2, 6, 24, 15]
    """"""
","    ret = []
    for i in range(1,n+1):
        if i%2 == 0:
            x = 1
            for j in range(1,i+1): x *= j
            ret += [x]
        else:
            x = 0
            for j in range(1,i+1): x += j
            ret += [x]
    return ret
","def check(candidate):

    assert candidate(5) == [1, 2, 6, 24, 15]
    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]
    assert candidate(1) == [1]
    assert candidate(3) == [1, 2, 6]
"
"
def even_odd_palindrome(n):
    """"""
    ให้จำนวนเต็มบวก n คืนค่าเป็นคู่ที่ประกอบด้วยจำนวนของจำนวนเต็มที่เป็นพาลินโดรมที่เป็นเลขคู่และเลขคี่ซึ่งอยู่ในช่วง รวมทั้งสิ้น

ตัวอย่างที่ 1:

    Input: 3
    Output:
    คำอธิบาย:
    จำนวนเต็มพาลินโดรมคือ 1, 2, 3 หนึ่งในนั้นเป็นเลขคู่ และสองในนั้นเป็นเลขคี่

ตัวอย่างที่ 2:

    Input: 12
    Output:
    คำอธิบาย:
    จำนวนเต็มพาลินโดรมคือ 1, 2, 3, 4, 5, 6, 7, 8, 9, 11 สี่ในนั้นเป็นเลขคู่ และหกในนั้นเป็นเลขคี่

หมายเหตุ:
    1. 1 <= n <= 10^3
    2. คู่ที่ได้คืนค่ามีจำนวนของพาลินโดรมที่เป็นเลขคู่และเลขคี่ตามลำดับ
    """"""
","    def is_palindrome(n):
        return str(n) == str(n)[::-1]

    even_palindrome_count = 0
    odd_palindrome_count = 0

    for i in range(1, n+1):
        if i%2 == 1 and is_palindrome(i):
                odd_palindrome_count += 1
        elif i%2 == 0 and is_palindrome(i):
            even_palindrome_count += 1
    return (even_palindrome_count, odd_palindrome_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(123) == (8, 13)
    assert candidate(12) == (4, 6)
    assert candidate(3) == (1, 2)
    assert candidate(63) == (6, 8)
    assert candidate(25) == (5, 6)
    assert candidate(19) == (4, 6)
    assert candidate(9) == (4, 5), ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == (0, 1), ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def count_nums(arr):
    """"""
    เขียนฟังก์ชันที่ชื่อว่า count_nums ซึ่งรับอาร์เรย์ของจำนวนเต็มและคืนค่าจำนวนของสมาชิกที่มีผลรวมของตัวเลขหลัก > 0
ถ้าจำนวนเป็นค่าลบ ตัวเลขหลักแรกจะเป็นค่าลบ:
เช่น -123 มีตัวเลขหลักเป็น -1, 2, และ 3
    >>> count_nums([]) == 0
    >>> count_nums([-1, 11, -11]) == 1
    >>> count_nums([1, 1, 2]) == 3
    """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0
    assert candidate([-1, -2, 0]) == 0
    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6
    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5
    assert candidate([1, 100, 98, -7, 1, -1]) == 4
    assert candidate([12, 23, 34, -45, -56, 0]) == 5
    assert candidate([-0, 1**0]) == 1
    assert candidate([1]) == 1

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def move_one_ball(arr):
    """"""เรามีอาร์เรย์ 'arr' ที่ประกอบด้วยจำนวนเต็ม N ตัว arr[1], arr[2], ..., arr[N] โดยตัวเลขในอาร์เรย์จะถูกจัดเรียงแบบสุ่ม งานของคุณคือการตรวจสอบว่ามันเป็นไปได้หรือไม่ที่จะทำให้อาร์เรย์เรียงลำดับแบบไม่ลดลงโดยการทำงานต่อไปนี้กับอาร์เรย์ที่กำหนด:
    คุณสามารถทำการเลื่อนขวาได้หลายครั้งตามต้องการ

การเลื่อนขวาหนึ่งครั้งหมายถึงการเลื่อนทุกองค์ประกอบของอาร์เรย์ไปทางขวา 1 ตำแหน่ง องค์ประกอบสุดท้ายของอาร์เรย์จะถูกย้ายไปยังตำแหน่งเริ่มต้นของอาร์เรย์คือดัชนีที่ 0

ถ้าเป็นไปได้ที่จะได้อาร์เรย์ที่เรียงลำดับโดยการทำงานดังกล่าว ให้คืนค่า True มิฉะนั้น ให้คืนค่า False
ถ้าอาร์เรย์ที่กำหนดว่างเปล่า ให้คืนค่า True

หมายเหตุ: รายการที่กำหนดรับประกันว่าจะมีองค์ประกอบที่ไม่ซ้ำกัน

ตัวอย่าง:

move_one_ball==>True
คำอธิบาย: โดยการเลื่อนขวา 2 ครั้ง อาร์เรย์สามารถเรียงลำดับแบบไม่ลดลงได้
move_one_ball==>False
คำอธิบาย: ไม่สามารถทำให้เรียงลำดับแบบไม่ลดลงได้โดยการเลื่อนขวาใดๆ
                
    """"""
","    if len(arr)==0:
      return True
    sorted_array=sorted(arr)
    my_arr=[]
    
    min_value=min(arr)
    min_index=arr.index(min_value)
    my_arr=arr[min_index:]+arr[0:min_index]
    for i in range(len(arr)):
      if my_arr[i]!=sorted_array[i]:
        return False
    return True
","def check(candidate):

    # Check some simple cases
    assert candidate([3, 4, 5, 1, 2])==True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([3, 5, 10, 1, 2])==True
    assert candidate([4, 3, 1, 2])==False
    # Check some edge cases that are easy to work out by hand.
    assert candidate([3, 5, 4, 1, 2])==False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([])==True
"
"
def exchange(lst1, lst2):
    """"""ในปัญหานี้ คุณจะต้องเขียนฟังก์ชันที่รับลิสต์ของตัวเลขสองลิสต์ และตรวจสอบว่ามีความเป็นไปได้หรือไม่ที่จะแลกเปลี่ยนองค์ประกอบระหว่างลิสต์เหล่านี้เพื่อทำให้ลิสต์แรก เป็นลิสต์ที่มีแต่ตัวเลขคู่เท่านั้น ไม่มีข้อจำกัดในจำนวนขององค์ประกอบที่แลกเปลี่ยนระหว่าง lst1 และ lst2 หากสามารถแลกเปลี่ยนองค์ประกอบระหว่าง lst1 และ lst2 เพื่อทำให้องค์ประกอบทั้งหมดของ lst1 เป็นเลขคู่ ให้คืนค่า ""YES"" มิฉะนั้น ให้คืนค่า ""NO"" ตัวอย่างเช่น:
exchange => ""YES""
exchange => ""NO""
สมมติว่าลิสต์ที่รับเข้ามาจะไม่ว่างเปล่า
    """"""
","    odd = 0
    even = 0
    for i in lst1:
        if i%2 == 1:
            odd += 1
    for i in lst2:
        if i%2 == 0:
            even += 1
    if even >= odd:
        return ""YES""
    return ""NO""
            
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == ""YES""
    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == ""NO""
    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == ""YES"" 
    assert candidate([5, 7, 3], [2, 6, 4]) == ""YES""
    assert candidate([5, 7, 3], [2, 6, 3]) == ""NO"" 
    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == ""NO""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([100, 200], [200, 200]) == ""YES""

"
"
def histogram(test):
    """"""ให้สตริงที่แสดงถึงตัวอักษรตัวพิมพ์เล็กที่คั่นด้วยช่องว่าง ให้คืนค่าเป็นพจนานุกรมของตัวอักษรที่มีการซ้ำมากที่สุดและมีจำนวนที่ตรงกัน หากมีหลายตัวอักษรที่มีจำนวนการเกิดขึ้นเท่ากัน ให้คืนค่าทั้งหมด

ตัวอย่าง:
histogram == {'a': 1, 'b': 1, 'c': 1}
histogram == {'a': 2, 'b': 2}
histogram == {'a': 2, 'b': 2}
histogram == {'b': 4}
histogram == {}

    """"""
","    dict1={}
    list1=test.split("" "")
    t=0

    for i in list1:
        if(list1.count(i)>t) and i!='':
            t=list1.count(i)
    if t>0:
        for i in list1:
            if(list1.count(i)==t):
                
                dict1[i]=t
    return dict1
","def check(candidate):

    # Check some simple cases
    assert candidate('a b b a') == {'a':2,'b': 2}, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('a b c a b') == {'a': 2, 'b': 2}, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate('b b b b a') == {'b': 4}, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, ""This prints if this assert fails 6 (good for debugging!)""
    
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == {}, ""This prints if this assert fails 7 (also good for debugging!)""
    assert candidate('a') == {'a': 1}, ""This prints if this assert fails 8 (also good for debugging!)""

"
"
def reverse_delete(s,c):
    """"""งาน
    เรามีสตริงสองสตริง s และ c ให้คุณลบตัวอักษรทั้งหมดใน s ที่เท่ากับตัวอักษรใด ๆ ใน c
    จากนั้นตรวจสอบว่าสตริงผลลัพธ์เป็นพาลินโดรมหรือไม่
    สตริงจะเรียกว่าพาลินโดรมถ้ามันอ่านเหมือนกันทั้งจากซ้ายไปขวาและจากขวาไปซ้าย
    คุณจะต้องคืนทูเพิลที่ประกอบด้วยสตริงผลลัพธ์และค่า True/False สำหรับการตรวจสอบนั้น
    ตัวอย่าง
    สำหรับ s = ""abcde"", c = ""ae"", ผลลัพธ์ควรเป็น
    สำหรับ s = ""abcdef"", c = ""b"" ผลลัพธ์ควรเป็น
    สำหรับ s = ""abcdedcba"", c = ""ab"", ผลลัพธ์ควรเป็น
    """"""
","    s = ''.join([char for char in s if char not in c])
    return (s,s[::-1] == s)
","def check(candidate):

    assert candidate(""abcde"",""ae"") == ('bcd',False)
    assert candidate(""abcdef"", ""b"") == ('acdef',False)
    assert candidate(""abcdedcba"",""ab"") == ('cdedc',True)
    assert candidate(""dwik"",""w"") == ('dik',False)
    assert candidate(""a"",""a"") == ('',True)
    assert candidate(""abcdedcba"","""") == ('abcdedcba',True)
    assert candidate(""abcdedcba"",""v"") == ('abcdedcba',True)
    assert candidate(""vabba"",""v"") == ('abba',True)
    assert candidate(""mamma"", ""mia"") == ("""", True)
"
"
def odd_count(lst):
    """"""ให้รายการของสตริง ซึ่งแต่ละสตริงประกอบด้วยตัวเลขเท่านั้น ให้ส่งคืนรายการ
    แต่ละองค์ประกอบ i ของผลลัพธ์ควรจะเป็น ""จำนวนของตัวเลขคี่ในสตริงที่ i ของอินพุต"" ซึ่งตัว i ทุกตัวควรถูกแทนที่ด้วยจำนวนของตัวเลขคี่ในสตริงที่ i ของอินพุต

    >>> odd_count(['1234567'])
    [""the number of odd elements 4n the str4ng 4 of the 4nput.""]
    >>> odd_count(['3',""11111111""])
    [""the number of odd elements 1n the str1ng 1 of the 1nput."",
     ""the number of odd elements 8n the str8ng 8 of the 8nput.""]
    """"""
","    res = []
    for arr in lst:
        n = sum(int(d)%2==1 for d in arr)
        res.append(""the number of odd elements "" + str(n) + ""n the str""+ str(n) +""ng ""+ str(n) +"" of the ""+ str(n) +""nput."")
    return res
","def check(candidate):

    # Check some simple cases
    assert candidate(['1234567']) == [""the number of odd elements 4n the str4ng 4 of the 4nput.""], ""Test 1""
    assert candidate(['3',""11111111""]) == [""the number of odd elements 1n the str1ng 1 of the 1nput."", ""the number of odd elements 8n the str8ng 8 of the 8nput.""], ""Test 2""
    assert candidate(['271', '137', '314']) == [
        'the number of odd elements 2n the str2ng 2 of the 2nput.',
        'the number of odd elements 3n the str3ng 3 of the 3nput.',
        'the number of odd elements 2n the str2ng 2 of the 2nput.'
    ]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def minSubArraySum(nums):
    """"""
    กำหนดให้มีอาเรย์ของจำนวนเต็ม nums ให้หาผลรวมที่น้อยที่สุดของซับอาเรย์ที่ไม่ว่างเปล่าของ nums
ตัวอย่าง
minSubArraySum == 1
minSubArraySum == -6
    """"""
","    max_sum = 0
    s = 0
    for num in nums:
        s += -num
        if (s < 0):
            s = 0
        max_sum = max(s, max_sum)
    if max_sum == 0:
        max_sum = max(-i for i in nums)
    min_sum = -max_sum
    return min_sum
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 3, 4, 1, 2, 4]) == 1, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1, -2, -3]) == -6
    assert candidate([-1, -2, -3, 2, -10]) == -14
    assert candidate([-9999999999999999]) == -9999999999999999
    assert candidate([0, 10, 20, 1000000]) == 0
    assert candidate([-1, -2, -3, 10, -5]) == -6
    assert candidate([100, -1, -2, -3, 10, -5]) == -6
    assert candidate([10, 11, 13, 8, 3, 4]) == 3
    assert candidate([100, -33, 32, -1, 0, -2]) == -33

    # Check some edge cases that are easy to work out by hand.
    assert candidate([-10]) == -10, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([7]) == 7
    assert candidate([1, -1]) == -1
"
"
def max_fill(grid, capacity):
    import math
    """"""
    คุณได้รับกริดสี่เหลี่ยมของบ่อน้ำ แต่ละแถวแสดงถึงบ่อน้ำหนึ่งบ่อ และแต่ละ 1 ในแถวแสดงถึงหน่วยน้ำหนึ่งหน่วย แต่ละบ่อมีถังที่สามารถใช้ในการสูบน้ำออกจากบ่อ และทุกถังมีความจุเท่ากัน งานของคุณคือการใช้ถังเพื่อนำน้ำออกจากบ่อทั้งหมด ให้แสดงจำนวนครั้งที่คุณต้องลดถังลง

ตัวอย่างที่ 1:
    อินพุต: 
        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]
        bucket_capacity: 1
    เอาต์พุต: 6

ตัวอย่างที่ 2:
    อินพุต: 
        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]
        bucket_capacity: 2
    เอาต์พุต: 5

ตัวอย่างที่ 3:
    อินพุต: 
        grid: [[0,0,0], [0,0,0]]
        bucket_capacity: 5
    เอาต์พุต: 0

ข้อจำกัด:
    * ทุกบ่อมีความยาวเท่ากัน
    * 1 <= grid.length <= 10^2
    * 1 <= grid[:,1].length <= 10^2
    * grid[i][j] -> 0 | 1
    * 1 <= capacity <= 10
    """"""
","    return sum([math.ceil(sum(arr)/capacity) for arr in grid])
","def check(candidate):


    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, ""Error""
    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, ""Error""
    assert candidate([[0,0,0], [0,0,0]], 5) == 0, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, ""Error""
    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, ""Error""

"
"
def sort_array(arr):
    """"""
    ใน Kata นี้ คุณจะต้องเรียงลำดับอาร์เรย์ของจำนวนเต็มที่ไม่เป็นลบตามจำนวนเลขหนึ่งในรูปแบบไบนารีของพวกมันในลำดับจากน้อยไปมาก
สำหรับจำนวนเลขหนึ่งที่คล้ายกัน ให้เรียงลำดับตามค่าทศนิยม

มันจะต้องถูกดำเนินการในลักษณะนี้:
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """"""
","    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]
    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]
    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]
    assert candidate([]) == []
    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]
    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]
    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def select_words(s, n):
    """"""ให้สตริง s และตัวเลขธรรมชาติ n คุณได้รับมอบหมายให้เขียนฟังก์ชันที่คืนค่าเป็นลิสต์ของคำทั้งหมดจากสตริง s ที่มีพยัญชนะเท่ากับ n ตัว โดยคำเหล่านี้จะต้องเรียงตามลำดับที่ปรากฏในสตริง s
หากสตริง s ว่างเปล่า ฟังก์ชันควรคืนค่าลิสต์ว่างเปล่า
หมายเหตุ: คุณสามารถสมมติได้ว่าสตริงที่ป้อนเข้ามีเพียงตัวอักษรและช่องว่างเท่านั้น
ตัวอย่าง:
select_words ==> [""little""]
select_words ==> [""Mary"", ""lamb""]
select_words ==> []
select_words ==> [""world""]
select_words ==> [""Uncle""]
    """"""
","    result = []
    for word in s.split():
        n_consonants = 0
        for i in range(0, len(word)):
            if word[i].lower() not in [""a"",""e"",""i"",""o"",""u""]:
                n_consonants += 1 
        if n_consonants == n:
            result.append(word)
    return result

","def check(candidate):

    # Check some simple cases
    assert candidate(""Mary had a little lamb"", 4) == [""little""], ""First test error: "" + str(candidate(""Mary had a little lamb"", 4))      
    assert candidate(""Mary had a little lamb"", 3) == [""Mary"", ""lamb""], ""Second test error: "" + str(candidate(""Mary had a little lamb"", 3))  
    assert candidate(""simple white space"", 2) == [], ""Third test error: "" + str(candidate(""simple white space"", 2))      
    assert candidate(""Hello world"", 4) == [""world""], ""Fourth test error: "" + str(candidate(""Hello world"", 4))  
    assert candidate(""Uncle sam"", 3) == [""Uncle""], ""Fifth test error: "" + str(candidate(""Uncle sam"", 3))


    # Check some edge cases that are easy to work out by hand.
    assert candidate("""", 4) == [], ""1st edge test error: "" + str(candidate("""", 4))
    assert candidate(""a b c d e f"", 1) == [""b"", ""c"", ""d"", ""f""], ""2nd edge test error: "" + str(candidate(""a b c d e f"", 1))

"
"
def get_closest_vowel(word):
    """"""คุณได้รับคำหนึ่งคำ งานของคุณคือการหาสระที่ใกล้ที่สุดที่อยู่ระหว่างพยัญชนะสองตัวจากด้านขวาของคำ

สระที่อยู่ในตอนเริ่มต้นและตอนจบจะไม่นับ รวมถึงไม่ต้องคืนค่าใด ๆ หากไม่พบสระที่ตรงกับเงื่อนไขข้างต้น

คุณสามารถสมมติว่าข้อความที่ให้มาประกอบด้วยตัวอักษรภาษาอังกฤษเท่านั้น

ตัวอย่าง:
get_closest_vowel ==> ""u""
get_closest_vowel ==> ""U""
get_closest_vowel ==> """"
get_closest_vowel ==> """"
    """"""
","    if len(word) < 3:
        return """"

    vowels = {""a"", ""e"", ""i"", ""o"", ""u"", ""A"", ""E"", 'O', 'U', 'I'}
    for i in range(len(word)-2, 0, -1):
        if word[i] in vowels:
            if (word[i+1] not in vowels) and (word[i-1] not in vowels):
                return word[i]
    return """"
","def check(candidate):

    # Check some simple cases
    assert candidate(""yogurt"") == ""u""
    assert candidate(""full"") == ""u""
    assert candidate(""easy"") == """"
    assert candidate(""eAsy"") == """"
    assert candidate(""ali"") == """"
    assert candidate(""bad"") == ""a""
    assert candidate(""most"") == ""o""
    assert candidate(""ab"") == """"
    assert candidate(""ba"") == """"
    assert candidate(""quick"") == """"
    assert candidate(""anime"") == ""i""
    assert candidate(""Asia"") == """"
    assert candidate(""Above"") == ""o""

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''
","    def check(s):
        val = 0
        for i in s:
            if i == '(':
                val = val + 1
            else:
                val = val - 1
            if val < 0:
                return False
        return True if val == 0 else False

    S1 = lst[0] + lst[1]
    S2 = lst[1] + lst[0]
    return 'Yes' if check(S1) or check(S2) else 'No'
","def check(candidate):

    # Check some simple cases
    assert candidate(['()(', ')']) == 'Yes'
    assert candidate([')', ')']) == 'No'
    assert candidate(['(()(())', '())())']) == 'No'
    assert candidate([')())', '(()()(']) == 'Yes'
    assert candidate(['(())))', '(()())((']) == 'Yes'
    assert candidate(['()', '())']) == 'No'
    assert candidate(['(()(', '()))()']) == 'Yes'
    assert candidate(['((((', '((())']) == 'No'
    assert candidate([')(()', '(()(']) == 'No'
    assert candidate([')(', ')(']) == 'No'
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(['(', ')']) == 'Yes'
    assert candidate([')', '(']) == 'Yes' 

"
"
def maximum(arr, k):
    """"""
    ให้ arr ซึ่งเป็นอาร์เรย์ของจำนวนเต็มและ k ซึ่งเป็นจำนวนเต็มบวก ผลลัพธ์ที่ต้องการคือการคืนลิสต์ที่เรียงลำดับแล้วมีความยาว k ซึ่งประกอบด้วยจำนวนที่มากที่สุด k ตัวใน arr

    ตัวอย่างที่ 1:

        อินพุต: arr = [-3, -4, 5], k = 3
        ผลลัพธ์: [-4, -3, 5]

    ตัวอย่างที่ 2:

        อินพุต: arr = [4, -4, 4], k = 2
        ผลลัพธ์: [4, 4]

    ตัวอย่างที่ 3:

        อินพุต: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1
        ผลลัพธ์: [2]

    หมายเหตุ:
        1. ความยาวของอาร์เรย์จะอยู่ในช่วง [1, 1000]
        2. องค์ประกอบในอาร์เรย์จะอยู่ในช่วง [-1000, 1000]
        3. 0 <= k <= len
    """"""
","    if k == 0:
        return []
    arr.sort()
    ans = arr[-k:]
    return ans
","def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []

"
"
def solution(lst):
    """"""ให้ลิสต์ที่ไม่ว่างเปล่าของจำนวนเต็ม คืนค่าผลรวมของทุกองค์ประกอบที่เป็นเลขคี่ในตำแหน่งเลขคู่

    ตัวอย่าง
    solution ==> 12
    solution ==> 9
    solution ==> 0
    """"""
","    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])
","def check(candidate):

    # Check some simple cases
    assert candidate([5, 8, 7, 1])    == 12
    assert candidate([3, 3, 3, 3, 3]) == 9
    assert candidate([30, 13, 24, 321]) == 0
    assert candidate([5, 9]) == 5
    assert candidate([2, 4, 8]) == 0
    assert candidate([30, 13, 23, 32]) == 23
    assert candidate([3, 13, 2, 9]) == 3

    # Check some edge cases that are easy to work out by hand.

"
"
def add_elements(arr, k):
    """"""
    ให้ arr เป็นอาร์เรย์ของจำนวนเต็มที่ไม่ว่างเปล่า และ k เป็นจำนวนเต็ม ให้คืนค่าผลรวมของสมาชิกที่มีไม่เกินสองหลักจาก k สมาชิกแรกของ arr

ตัวอย่าง:

    อินพุต: arr = [111,21,3,4000,5,6,7,8,9], k = 4
    เอาต์พุต: 24 # ผลรวมของ 21 และ 3

ข้อจำกัด:
    1. 1 <= ความยาวของ arr <= 100
    2. 1 <= k <= ความยาวของ arr
    """"""
","    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)
","def check(candidate):

    # Check some simple cases
    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4
    assert candidate([111,121,3,4000,5,6], 2) == 0
    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125
    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1], 1) == 1, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def get_odd_collatz(n):
    """"""
    ให้จำนวนเต็มบวก n คืนรายการที่เรียงลำดับซึ่งมีเฉพาะเลขคี่ในลำดับ Collatz

    ข้อสันนิษฐานของ Collatz เป็นข้อสันนิษฐานในคณิตศาสตร์ที่เกี่ยวข้องกับลำดับที่กำหนด
    ดังนี้: เริ่มต้นด้วยจำนวนเต็มบวก n ใดๆ จากนั้นแต่ละพจน์จะได้มาจาก
    พจน์ก่อนหน้า ดังนี้: ถ้าพจน์ก่อนหน้าเป็นเลขคู่ พจน์ถัดไปจะเป็นครึ่งหนึ่งของ
    พจน์ก่อนหน้า ถ้าพจน์ก่อนหน้าเป็นเลขคี่ พจน์ถัดไปจะเป็น 3 เท่าของพจน์ก่อนหน้า 
    บวก 1 ข้อสันนิษฐานคือไม่ว่า n จะมีค่าเท่าใด ลำดับจะไปถึง 1 เสมอ

    หมายเหตุ: 
        1. Collatz คือ [1]
        2. รายการที่คืนมาจะเรียงลำดับในลำดับที่เพิ่มขึ้น

    ตัวอย่างเช่น:
    get_odd_collatz จะคืนค่า [1, 5] # ลำดับ Collatz สำหรับ 5 คือ [5, 16, 8, 4, 2, 1] ดังนั้นเลขคี่จะมีเพียง 1 และ 5
    """"""
","    if n%2==0:
        odd_collatz = [] 
    else:
        odd_collatz = [n]
    while n > 1:
        if n % 2 == 0:
            n = n/2
        else:
            n = n*3 + 1
            
        if n%2 == 1:
            odd_collatz.append(int(n))

    return sorted(odd_collatz)
","def check(candidate):

    # Check some simple cases
    assert candidate(14) == [1, 5, 7, 11, 13, 17]
    assert candidate(5) == [1, 5]
    assert candidate(12) == [1, 3, 5], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == [1], ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def valid_date(date):
    """"""คุณต้องเขียนฟังก์ชันที่ตรวจสอบความถูกต้องของสตริงวันที่ที่กำหนดและคืนค่า True หากวันที่นั้นถูกต้อง มิฉะนั้นคืนค่า False

วันที่นั้นถูกต้องหากกฎทั้งหมดดังต่อไปนี้เป็นจริง:
1. สตริงวันที่ต้องไม่ว่างเปล่า
2. จำนวนวันต้องไม่น้อยกว่า 1 หรือมากกว่า 31 วันสำหรับเดือน 1, 3, 5, 7, 8, 10, 12 และจำนวนวันต้องไม่น้อยกว่า 1 หรือมากกว่า 30 วันสำหรับเดือน 4, 6, 9, 11 และจำนวนวันต้องไม่น้อยกว่า 1 หรือมากกว่า 29 สำหรับเดือน 2
3. เดือนต้องไม่ต่ำกว่า 1 หรือมากกว่า 12
4. วันที่ต้องอยู่ในรูปแบบ: mm-dd-yyyy

ตัวอย่างเช่น:
valid_date => True

valid_date => False

valid_date => False

valid_date => True

valid_date => False
    """"""
","    try:
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12:
            return False
        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:
            return False
        if month in [4,6,9,11] and day < 1 or day > 30:
            return False
        if month == 2 and day < 1 or day > 29:
            return False
    except:
        return False

    return True
","def check(candidate):

    # Check some simple cases
    assert candidate('03-11-2000') == True

    assert candidate('15-01-2012') == False

    assert candidate('04-0-2040') == False

    assert candidate('06-04-2020') == True

    assert candidate('01-01-2007') == True

    assert candidate('03-32-2011') == False

    assert candidate('') == False

    assert candidate('04-31-3000') == False

    assert candidate('06-06-2005') == True

    assert candidate('21-31-2000') == False

    assert candidate('04-12-2003') == True

    assert candidate('04122003') == False

    assert candidate('20030412') == False

    assert candidate('2003-04') == False

    assert candidate('2003-04-12') == False

    assert candidate('04-2003') == False
"
"
def split_words(txt):
    '''
    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    Examples
    split_words(""Hello world!"") â -> [""Hello"", ""world!""]
    split_words(""Hello,world!"") â -> [""Hello"", ""world!""]
    split_words(""abcdef"") == 3 
    '''
","    if "" "" in txt:
        return txt.split()
    elif "","" in txt:
        return txt.replace(',',' ').split()
    else:
        return len([i for i in txt if i.islower() and ord(i)%2 == 0])
","def check(candidate):

    assert candidate(""Hello world!"") == [""Hello"",""world!""]
    assert candidate(""Hello,world!"") == [""Hello"",""world!""]
    assert candidate(""Hello world,!"") == [""Hello"",""world,!""]
    assert candidate(""Hello,Hello,world !"") == [""Hello,Hello,world"",""!""]
    assert candidate(""abcdef"") == 3
    assert candidate(""aaabb"") == 2
    assert candidate(""aaaBb"") == 1
    assert candidate("""") == 0
"
"
def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) â -> True
    is_sorted([1, 2, 3, 4, 5]) â -> True
    is_sorted([1, 3, 2, 4, 5]) â -> False
    is_sorted([1, 2, 3, 4, 5, 6]) â -> True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) â -> True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) â -> False
    is_sorted([1, 2, 2, 3, 3, 4]) â -> True
    is_sorted([1, 2, 2, 2, 3, 4]) â -> False
    '''
","    count_digit = dict([(i, 0) for i in lst])
    for i in lst:
        count_digit[i]+=1 
    if any(count_digit[i] > 2 for i in lst):
        return False
    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):
        return True
    else:
        return False
    
    
","def check(candidate):

    # Check some simple cases
    assert candidate([5]) == True
    assert candidate([1, 2, 3, 4, 5]) == True
    assert candidate([1, 3, 2, 4, 5]) == False
    assert candidate([1, 2, 3, 4, 5, 6]) == True
    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True
    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([]) == True, ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([1]) == True, ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([3, 2, 1]) == False, ""This prints if this assert fails 4 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 2, 2, 3, 4]) == False, ""This prints if this assert fails 5 (good for debugging!)""
    assert candidate([1, 2, 3, 3, 3, 4]) == False, ""This prints if this assert fails 6 (good for debugging!)""
    assert candidate([1, 2, 2, 3, 3, 4]) == True, ""This prints if this assert fails 7 (good for debugging!)""
    assert candidate([1, 2, 3, 4]) == True, ""This prints if this assert fails 8 (good for debugging!)""

"
"
def intersection(interval1, interval2):
    """"""คุณได้รับช่วงสองช่วง ซึ่งแต่ละช่วงเป็นคู่ของจำนวนเต็ม ตัวอย่างเช่น ช่วง = = ช่วงที่ให้มาเป็นช่วงปิดซึ่งหมายความว่าช่วง รวมถึงจุดเริ่มต้นและจุดสิ้นสุด สำหรับแต่ละช่วงที่ให้มา จะถือว่าจุดเริ่มต้นมีค่าน้อยกว่าหรือเท่ากับจุดสิ้นสุด งานของคุณคือการตรวจสอบว่าความยาวของช่วงที่สองช่วงนี้ตัดกันเป็นจำนวนเฉพาะหรือไม่ ตัวอย่างเช่น การตัดกันของช่วง, คือ ซึ่งความยาวของมันคือ 1 ซึ่งไม่ใช่จำนวนเฉพาะ ถ้าความยาวของการตัดกันเป็นจำนวนเฉพาะ ให้คืนค่า ""YES"" มิฉะนั้น ให้คืนค่า ""NO"" ถ้าสองช่วงไม่ตัดกัน ให้คืนค่า ""NO""

ตัวอย่างการป้อนข้อมูล/ผลลัพธ์:
การตัดกัน,) ==> ""NO""
การตัดกัน,) ==> ""NO""
การตัดกัน,) ==> ""YES""
    """"""
","    def is_prime(num):
        if num == 1 or num == 0:
            return False
        if num == 2:
            return True
        for i in range(2, num):
            if num%i == 0:
                return False
        return True

    l = max(interval1[0], interval2[0])
    r = min(interval1[1], interval2[1])
    length = r - l
    if length > 0 and is_prime(length):
        return ""YES""
    return ""NO""
","def check(candidate):

    # Check some simple cases
    assert candidate((1, 2), (2, 3)) == ""NO""
    assert candidate((-1, 1), (0, 4)) == ""NO""
    assert candidate((-3, -1), (-5, 5)) == ""YES""
    assert candidate((-2, 2), (-4, 0)) == ""YES""

    # Check some edge cases that are easy to work out by hand.
    assert candidate((-11, 2), (-1, -1)) == ""NO""
    assert candidate((1, 2), (3, 5)) == ""NO""
    assert candidate((1, 2), (1, 2)) == ""NO""
    assert candidate((-2, -2), (-3, -2)) == ""NO""

"
"
def prod_signs(arr):
    """"""
    คุณได้รับอาร์เรย์ arr ของจำนวนเต็มและคุณจำเป็นต้องคืนค่า
    ผลรวมของขนาดของจำนวนเต็มที่คูณด้วยผลคูณของเครื่องหมาย
    ของแต่ละตัวเลขในอาร์เรย์ ซึ่งแทนด้วย 1, -1 หรือ 0
    หมายเหตุ: คืนค่า None สำหรับ arr ที่ว่างเปล่า

    ตัวอย่าง:
    >>> prod_signs([1, 2, 2, -4]) == -9
    >>> prod_signs([0, 1]) == 0
    >>> prod_signs([]) == None
    """"""
","    if not arr: return None
    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1, 2, 2, -4]) == -9
    assert candidate([0, 1]) == 0
    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10
    assert candidate([]) == None
    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20
    assert candidate([-1, 1, -1, 1]) == 4
    assert candidate([-1, 1, 1, 1]) == -4
    assert candidate([-1, 1, 1, 0]) == 0

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def minPath(grid, k):
    """"""
    ให้ตารางที่มี N แถวและ N คอลัมน์ และจำนวนเต็มบวก k แต่ละช่องของตารางมีค่า แต่ละจำนวนเต็มในช่วง [1, N * N] จะปรากฏเพียงครั้งเดียวในช่องของตาราง

คุณต้องหาทางเดินที่มีความยาวขั้นต่ำ k ในตาราง คุณสามารถเริ่มจากช่องใดก็ได้ และในแต่ละขั้นตอนคุณสามารถย้ายไปยังช่องเพื่อนบ้านใดก็ได้ กล่าวอีกนัยหนึ่งคือ คุณสามารถไปยังช่องที่มีขอบร่วมกับช่องปัจจุบันของคุณ

โปรดทราบว่าทางเดินที่มีความยาว k หมายถึงการเยี่ยมชม k ช่องพอดี คุณไม่สามารถออกนอกตารางได้ ทางเดิน A ถือว่าน้อยกว่าทางเดิน B ถ้าหลังจากทำรายการเรียงลำดับของค่าบนช่องที่ทางเดิน A และ B ผ่าน lst_A น้อยกว่า lst_B ตามลำดับพจนานุกรม กล่าวอีกนัยหนึ่งคือมีดัชนีจำนวนเต็ม i ที่ lst_A[i] < lst_B[i] และสำหรับ j ใด ๆ เรามี lst_A[j] = lst_B[j] รับรองว่าคำตอบเป็นเอกลักษณ์ คืนรายการเรียงลำดับของค่าบนช่องที่ทางเดินขั้นต่ำผ่าน

ตัวอย่าง:

    Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3
    Output: [1, 2, 1]

    Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1
    Output: [1]
    """"""
","    n = len(grid)
    val = n * n + 1
    for i in range(n):
        for j in range(n):
            if grid[i][j] == 1:
                temp = []
                if i != 0:
                    temp.append(grid[i - 1][j])

                if j != 0:
                    temp.append(grid[i][j - 1])

                if i != n - 1:
                    temp.append(grid[i + 1][j])

                if j != n - 1:
                    temp.append(grid[i][j + 1])

                val = min(temp)

    ans = []
    for i in range(k):
        if i % 2 == 0:
            ans.append(1)
        else:
            ans.append(val)
    return ans
","def check(candidate):

    # Check some simple cases
    print
    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]
    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]
    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]
    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]
    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]
    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]
    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]
    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]
    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]

"
"
def tri(n):
    """"""ทุกคนรู้จักลำดับฟีโบนัชชี มันถูกศึกษาลึกซึ้งโดยนักคณิตศาสตร์ในช่วงสองสามศตวรรษที่ผ่านมา อย่างไรก็ตาม สิ่งที่คนไม่รู้คือ ลำดับไตรโบนัชชี
ลำดับไตรโบนัชชีถูกกำหนดโดยสมการเวียนเกิด:
tri = 3
tri = 1 + n / 2, ถ้า n เป็นจำนวนคู่
tri = tri + tri + tri, ถ้า n เป็นจำนวนคี่
ตัวอย่างเช่น:
tri = 1 + = 2
tri = 3
tri = tri + tri + tri
         = 2 + 3 + 3 = 8
คุณได้รับหมายเลขจำนวนเต็มไม่เป็นลบ n คุณต้องคืนค่ารายการของตัวเลขลำดับไตรโบนัชชี n + 1 ตัวแรก
ตัวอย่าง:
tri = [1, 3, 2, 8]
    """"""
","    if n == 0:
        return [1]
    my_tri = [1, 3]
    for i in range(2, n + 1):
        if i % 2 == 0:
            my_tri.append(i / 2 + 1)
        else:
            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)
    return my_tri
","def check(candidate):

    # Check some simple cases
    
    assert candidate(3) == [1, 3, 2.0, 8.0]
    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]
    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]
    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]
    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]
    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]
    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]
    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]

    # Check some edge cases that are easy to work out by hand.
    assert candidate(0) == [1]
    assert candidate(1) == [1, 3]
"
"
def digits(n):
    """"""กำหนดจำนวนเต็มบวก n ให้คืนค่าผลคูณของตัวเลขที่เป็นเลขคี่
    คืนค่า 0 ถ้าตัวเลขทั้งหมดเป็นเลขคู่
    ตัวอย่างเช่น:
    digits  == 1
    digits  == 0
    digits == 15
    """"""
","    product = 1
    odd_count = 0
    for digit in str(n):
        int_digit = int(digit)
        if int_digit%2 == 1:
            product= product*int_digit
            odd_count+=1
    if odd_count ==0:
        return 0
    else:
        return product
","def check(candidate):

    # Check some simple cases
    assert candidate(5) == 5
    assert candidate(54) == 5
    assert candidate(120) ==1
    assert candidate(5014) == 5
    assert candidate(98765) == 315
    assert candidate(5576543) == 2625

    # Check some edge cases that are easy to work out by hand.
    assert candidate(2468) == 0

"
"
def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') â -> True
    is_nested('[]]]]]]][[[[[]') â -> False
    is_nested('[][]') â -> False
    is_nested('[]') â -> False
    is_nested('[[][]]') â -> True
    is_nested('[[]][[') â -> True
    '''
","    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)):
        if string[i] == '[':
            opening_bracket_index.append(i)
        else:
            closing_bracket_index.append(i)
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index:
        if i < l and idx < closing_bracket_index[i]:
            cnt += 1
            i += 1
    return cnt >= 2

    
","def check(candidate):

    # Check some simple cases
    assert candidate('[[]]') == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate('[]]]]]]][[[[[]') == False
    assert candidate('[][]') == False
    assert candidate(('[]')) == False
    assert candidate('[[[[]]]]') == True
    assert candidate('[]]]]]]]]]]') == False
    assert candidate('[][][[]]') == True
    assert candidate('[[]') == False
    assert candidate('[]]') == False
    assert candidate('[[]][[') == True
    assert candidate('[[][]]') == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate('') == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate('[[[[[[[[') == False
    assert candidate(']]]]]]]]') == False

"
"

def sum_squares(lst):
    """"""คุณได้รับรายการตัวเลข
    คุณต้องคืนค่าผลรวมของตัวเลขที่ยกกำลังสองในรายการที่ให้มา
    ปัดตัวเลขแต่ละตัวในรายการขึ้นเป็นจำนวนเต็มก่อน
    ตัวอย่าง:
    สำหรับ lst = [1,2,3] ผลลัพธ์ควรเป็น 14
    สำหรับ lst = [1,4,9] ผลลัพธ์ควรเป็น 98
    สำหรับ lst = [1,3,5,7] ผลลัพธ์ควรเป็น 84
    สำหรับ lst = [1.4,4.2,0] ผลลัพธ์ควรเป็น 29
    สำหรับ lst = [-2.4,1,1] ผลลัพธ์ควรเป็น 6
    

    """"""
","    import math
    squared = 0
    for i in lst:
        squared += math.ceil(i)**2
    return squared
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.0,2,3])==14, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,3,5,7])==84, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1.4,4.2,0])==29, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-2.4,1,1])==6, ""This prints if this assert fails 1 (good for debugging!)""

    assert candidate([100,1,15,2])==10230, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([10000,10000])==200000000, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,4.6,6.3])==75, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([-1.4,17.9,18.9,19.9])==1086, ""This prints if this assert fails 1 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([0])==0, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1])==1, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([-1,1,0])==2, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def check_if_last_char_is_a_letter(txt):
    '''
    Create a function that returns True if the last character
    of a given string is an alphabetical character and is not
    a part of a word, and False otherwise.
    Note: ""word"" is a group of characters separated by space.

    Examples:
    check_if_last_char_is_a_letter(""apple pie"") â -> False
    check_if_last_char_is_a_letter(""apple pi e"") â -> True
    check_if_last_char_is_a_letter(""apple pi e "") â -> False
    check_if_last_char_is_a_letter("""") â -> False 
    '''
"," 
    check = txt.split(' ')[-1]
    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False
","def check(candidate):

    # Check some simple cases
    assert candidate(""apple"") == False
    assert candidate(""apple pi e"") == True
    assert candidate(""eeeee"") == False
    assert candidate(""A"") == True
    assert candidate(""Pumpkin pie "") == False
    assert candidate(""Pumpkin pie 1"") == False
    assert candidate("""") == False
    assert candidate(""eeeee e "") == False
    assert candidate(""apple pie"") == False
    assert candidate(""apple pi e "") == False

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def can_arrange(arr):
    """"""สร้างฟังก์ชันที่คืนค่าดัชนีที่ใหญ่ที่สุดขององค์ประกอบที่ไม่มากกว่าหรือเท่ากับองค์ประกอบก่อนหน้าทันที ถ้าไม่มีองค์ประกอบดังกล่าว ให้คืนค่า -1 อาร์เรย์ที่ให้มาจะไม่มีค่าที่ซ้ำกัน

ตัวอย่าง:
can_arrange = 3
can_arrange = -1
    """"""
","    ind=-1
    i=1
    while i<len(arr):
      if arr[i]<arr[i-1]:
        ind=i
      i+=1
    return ind
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,4,3,5])==3
    assert candidate([1,2,4,5])==-1
    assert candidate([1,4,2,5,6,7,8,9,10])==2
    assert candidate([4,8,5,7,3])==4

    # Check some edge cases that are easy to work out by hand.
    assert candidate([])==-1

"
"
def largest_smallest_integers(lst):
    '''
    Create a function that returns a tuple (a, b), where 'a' is
    the largest of negative integers, and 'b' is the smallest
    of positive integers in a list.
    If there is no negative or positive integers, return them as None.

    Examples:
    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)
    largest_smallest_integers([]) == (None, None)
    largest_smallest_integers([0]) == (None, None)
    '''
","    smallest = list(filter(lambda x: x < 0, lst))
    largest = list(filter(lambda x: x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
","def check(candidate):

    # Check some simple cases
    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)
    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)
    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)
    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)
    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)
    assert candidate([]) == (None, None)
    assert candidate([0]) == (None, None)
    assert candidate([-1, -3, -5, -6]) == (-1, None)
    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)
    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)
    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)

    # Check some edge cases that are easy to work out by hand.
    assert True
"
"
def compare_one(a, b):
    """"""
    สร้างฟังก์ชันที่รับค่าเป็นจำนวนเต็ม, จำนวนทศนิยม, หรือสตริง ที่แสดงถึงตัวเลขจริง และคืนค่าตัวแปรที่มีค่ามากกว่าในประเภทของตัวแปรที่กำหนด
คืนค่า None หากค่าทั้งสองเท่ากัน
หมายเหตุ: หากตัวเลขจริงถูกแสดงเป็นสตริง จุดทศนิยมอาจเป็น . หรือ ,

compare_one -> 2.5
compare_one -> ""2,3""
compare_one -> ""6""
compare_one -> None
    """"""
","    temp_a, temp_b = a, b
    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')
    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')
    if float(temp_a) == float(temp_b): return None
    return a if float(temp_a) > float(temp_b) else b 
","def check(candidate):

    # Check some simple cases
    assert candidate(1, 2) == 2
    assert candidate(1, 2.5) == 2.5
    assert candidate(2, 3) == 3
    assert candidate(5, 6) == 6
    assert candidate(1, ""2,3"") == ""2,3""
    assert candidate(""5,1"", ""6"") == ""6""
    assert candidate(""1"", ""2"") == ""2""
    assert candidate(""1"", 1) == None

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def is_equal_to_sum_even(n):
    """"""ตรวจสอบว่าจำนวนที่กำหนด n สามารถเขียนเป็นผลรวมของจำนวนคู่บวก 4 จำนวนได้หรือไม่
    ตัวอย่าง
    is_equal_to_sum_even == ผิด
    is_equal_to_sum_even == ผิด
    is_equal_to_sum_even == ถูกต้อง
    """"""
","    return n%2 == 0 and n >= 8
","def check(candidate):
    assert candidate(4) == False
    assert candidate(6) == False
    assert candidate(8) == True
    assert candidate(10) == True
    assert candidate(11) == False
    assert candidate(12) == True
    assert candidate(13) == False
    assert candidate(16) == True
"
"
def special_factorial(n):
    """"""แฟกทอเรียลแบบบราซิลถูกกำหนดไว้ดังนี้:
    brazilian_factorial = n! *! *! * ... * 1!
    เมื่อ n > 0

    ตัวอย่างเช่น:
    >>> special_factorial(4)
    288

    The function will receive an integer as input and should return the special
    factorial of this integer.
    """"""
","    fact_i = 1
    special_fact = 1
    for i in range(1, n+1):
        fact_i *= i
        special_fact *= fact_i
    return special_fact
","def check(candidate):

    # Check some simple cases
    assert candidate(4) == 288, ""Test 4""
    assert candidate(5) == 34560, ""Test 5""
    assert candidate(7) == 125411328000, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1) == 1, ""Test 1""

"
"
def fix_spaces(text):
    """"""
    สมมติว่ามีสตริง text ให้แทนที่ช่องว่างทั้งหมดในนั้นด้วยขีดล่าง
และถ้าสตริงมีช่องว่างต่อเนื่องกันมากกว่า 2 ช่องให้แทนที่ช่องว่างต่อเนื่องทั้งหมดด้วยขีดกลาง

fix_spaces == ""Example""
fix_spaces == ""Example_1""
fix_spaces == ""_Example_2""
fix_spaces == ""_Example-3""
    """"""
","    new_text = """"
    i = 0
    start, end = 0, 0
    while i < len(text):
        if text[i] == "" "":
            end += 1
        else:
            if end - start > 2:
                new_text += ""-""+text[i]
            elif end - start > 0:
                new_text += ""_""*(end - start)+text[i]
            else:
                new_text += text[i]
            start, end = i+1, i+1
        i+=1
    if end - start > 2:
        new_text += ""-""
    elif end - start > 0:
        new_text += ""_""
    return new_text
","def check(candidate):

    # Check some simple cases
    assert candidate(""Example"") == ""Example"", ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(""Mudasir Hanif "") == ""Mudasir_Hanif_"", ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"", ""This prints if this assert fails 3 (good for debugging!)""
    
    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Exa   mple"") == ""Exa-mple"", ""This prints if this assert fails 4 (good for debugging!)""
    assert candidate(""   Exa 1 2 2 mple"") == ""-Exa_1_2_2_mple"", ""This prints if this assert fails 4 (good for debugging!)""

"
"
def file_name_check(file_name):
    """"""สร้างฟังก์ชันที่รับสตริงที่แสดงถึงชื่อไฟล์ และคืนค่า 'Yes' หากชื่อไฟล์นั้นถูกต้อง และคืนค่า 'No' หากไม่ถูกต้อง
ชื่อไฟล์จะถือว่าถูกต้องก็ต่อเมื่อเงื่อนไขทั้งหมดต่อไปนี้เป็นจริง:
- ต้องไม่มีตัวเลข มากกว่าสามตัวในชื่อไฟล์
- ชื่อไฟล์ต้องมีจุด '.' เพียงหนึ่งเดียว
- ส่วนที่อยู่ก่อนจุดจะต้องไม่ว่างเปล่า และต้องเริ่มต้นด้วยตัวอักษรจากอักษรละติน
- ส่วนที่อยู่หลังจุดจะต้องเป็นหนึ่งในนี้: ['txt', 'exe', 'dll']
ตัวอย่าง:
file_name_check # => 'Yes'
file_name_check # => 'No'
    """"""
","    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep='.')
    if len(lst) != 2:
        return 'No'
    if not lst[1] in suf:
        return 'No'
    if len(lst[0]) == 0:
        return 'No'
    if not lst[0][0].isalpha():
        return 'No'
    t = len([x for x in lst[0] if x.isdigit()])
    if t > 3:
        return 'No'
    return 'Yes'
","def check(candidate):

    # Check some simple cases
    assert candidate(""example.txt"") == 'Yes'
    assert candidate(""1example.dll"") == 'No'
    assert candidate('s1sdf3.asd') == 'No'
    assert candidate('K.dll') == 'Yes'
    assert candidate('MY16FILE3.exe') == 'Yes'
    assert candidate('His12FILE94.exe') == 'No'
    assert candidate('_Y.txt') == 'No'
    assert candidate('?aREYA.exe') == 'No'
    assert candidate('/this_is_valid.dll') == 'No'
    assert candidate('this_is_valid.wow') == 'No'
    assert candidate('this_is_valid.txt') == 'Yes'
    assert candidate('this_is_valid.txtexe') == 'No'
    assert candidate('#this2_i4s_5valid.ten') == 'No'
    assert candidate('@this1_is6_valid.exe') == 'No'
    assert candidate('this_is_12valid.6exe4.txt') == 'No'
    assert candidate('all.exe.txt') == 'No'
    assert candidate('I563_No.exe') == 'Yes'
    assert candidate('Is3youfault.txt') == 'Yes'
    assert candidate('no_one#knows.dll') == 'Yes'
    assert candidate('1I563_Yes3.exe') == 'No'
    assert candidate('I563_Yes3.txtt') == 'No'
    assert candidate('final..txt') == 'No'
    assert candidate('final132') == 'No'
    assert candidate('_f4indsartal132.') == 'No'
    
        

    # Check some edge cases that are easy to work out by hand.
    assert candidate('.txt') == 'No'
    assert candidate('s.') == 'No'

"
"


def sum_squares(lst):
    """"""ฟังก์ชันนี้จะรับรายการของจำนวนเต็ม สำหรับทุกค่าที่อยู่ในรายการ ฟังก์ชันนี้จะยกกำลังสองของค่าจำนวนเต็มหากดัชนีของมันเป็นผลคูณของ 3 และจะยกกำลังสามของค่าจำนวนเต็มหากดัชนีของมันเป็นผลคูณของ 4 แต่ไม่เป็นผลคูณของ 3 ฟังก์ชันจะไม่เปลี่ยนแปลงค่าที่อยู่ในรายการที่ดัชนีของมันไม่เป็นผลคูณของ 3 หรือ 4 จากนั้นฟังก์ชันจะคืนค่าผลรวมของทุกค่าในรายการ

ตัวอย่าง:
สำหรับ lst = [1,2,3] ผลลัพธ์ควรจะเป็น 6
สำหรับ lst = [] ผลลัพธ์ควรจะเป็น 0
สำหรับ lst = [-1,-5,2,-1,-5] ผลลัพธ์ควรจะเป็น -126
    """"""
","    result =[]
    for i in range(len(lst)):
        if i %3 == 0:
            result.append(lst[i]**2)
        elif i % 4 == 0 and i%3 != 0:
            result.append(lst[i]**3)
        else:
            result.append(lst[i])
    return sum(result)
","def check(candidate):

    # Check some simple cases
    
    assert candidate([1,2,3]) == 6
    assert candidate([1,4,9]) == 14
    assert candidate([]) == 0
    assert candidate([1,1,1,1,1,1,1,1,1]) == 9
    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3
    assert candidate([0]) == 0
    assert candidate([-1,-5,2,-1,-5]) == -126
    assert candidate([-56,-99,1,0,-2]) == 3030
    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0
    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196
    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448
    
    
    # Don't remove this line:
"
"
def words_in_sentence(sentence):
    """"""
    คุณได้รับสตริงที่แทนประโยคหนึ่ง ประโยคนี้มีคำหลายคำที่ถูกคั่นด้วยช่องว่าง และคุณต้องคืนสตริงที่มีคำจากประโยคเดิมที่ความยาวของคำเป็นจำนวนเฉพาะ โดยลำดับของคำในสตริงใหม่ควรเหมือนกับลำดับในประโยคเดิม

ตัวอย่างที่ 1:
    อินพุต: sentence = ""This is a test""
    เอาต์พุต: ""is""

ตัวอย่างที่ 2:
    อินพุต: sentence = ""lets go for swimming""
    เอาต์พุต: ""go for""

ข้อจำกัด:
    * 1 <= len <= 100
    * ประโยคมีเฉพาะตัวอักษรเท่านั้น
    """"""
","    new_lst = []
    for word in sentence.split():
        flg = 0
        if len(word) == 1:
            flg = 1
        for i in range(2, len(word)):
            if len(word)%i == 0:
                flg = 1
        if flg == 0 or len(word) == 2:
            new_lst.append(word)
    return "" "".join(new_lst)
","def check(candidate):

    # Check some simple cases
    assert candidate(""This is a test"") == ""is""
    assert candidate(""lets go for swimming"") == ""go for""
    assert candidate(""there is no place available here"") == ""there is no place""
    assert candidate(""Hi I am Hussein"") == ""Hi am Hussein""
    assert candidate(""go for it"") == ""go for it""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""here"") == """"
    assert candidate(""here is"") == ""is""

"
"
def simplify(x, n):
    """"""งานของคุณคือการสร้างฟังก์ชันที่สามารถทำให้สมการ
    x * n ง่ายขึ้น ฟังก์ชันจะคืนค่า True หาก x * n เป็นจำนวนเต็ม และคืนค่า False
    หากไม่ใช่ ทั้ง x และ n เป็นสตริงที่แสดงถึงเศษส่วน และมีรูปแบบดังนี้
    <ตัวเศษ>/<ตัวส่วน> ซึ่งทั้งตัวเศษและตัวส่วนเป็นจำนวนเต็มบวก

    คุณสามารถสมมติว่า x และ n เป็นเศษส่วนที่ถูกต้อง และไม่มีตัวส่วนเป็นศูนย์

    simplify = จริง
    simplify = ไม่จริง
    simplify = ไม่จริง
    """"""
","    a, b = x.split(""/"")
    c, d = n.split(""/"")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator/denom == int(numerator/denom)):
        return True
    return False
","def check(candidate):

    # Check some simple cases
    assert candidate(""1/5"", ""5/1"") == True, 'test1'
    assert candidate(""1/6"", ""2/1"") == False, 'test2'
    assert candidate(""5/1"", ""3/1"") == True, 'test3'
    assert candidate(""7/10"", ""10/2"") == False, 'test4'
    assert candidate(""2/10"", ""50/10"") == True, 'test5'
    assert candidate(""7/2"", ""4/2"") == True, 'test6'
    assert candidate(""11/6"", ""6/1"") == True, 'test7'
    assert candidate(""2/3"", ""5/2"") == False, 'test8'
    assert candidate(""5/2"", ""3/5"") == False, 'test9'
    assert candidate(""2/4"", ""8/4"") == True, 'test10'


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""2/4"", ""4/2"") == True, 'test11'
    assert candidate(""1/5"", ""5/1"") == True, 'test12'
    assert candidate(""1/5"", ""1/5"") == False, 'test13'

"
"
def order_by_points(nums):
    """"""
    เขียนฟังก์ชันที่จัดเรียงรายการของจำนวนเต็มที่ให้มาในลำดับเพิ่มขึ้นตามผลรวมของตัวเลข
หมายเหตุ: ถ้ามีหลายรายการที่มีผลรวมของตัวเลขเท่ากัน ให้เรียงลำดับตามตำแหน่งในรายการเดิม

ตัวอย่าง:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """"""
","    def digits_sum(n):
        neg = 1
        if n < 0: n, neg = -1 * n, -1 
        n = [int(i) for i in str(n)]
        n[0] = n[0] * neg
        return sum(n)
    return sorted(nums, key=digits_sum)
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]
    assert candidate([]) == []
    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]
    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]
    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def specialFilter(nums):
    """"""เขียนฟังก์ชันที่รับอาเรย์ของตัวเลขเป็นอินพุตและคืนค่าจำนวนขององค์ประกอบในอาเรย์ที่มีค่ามากกว่า 10 และทั้งตัวเลขหลักแรกและหลักสุดท้ายเป็นเลขคี่
ตัวอย่างเช่น:
specialFilter => 1
specialFilter => 2
    """"""
","    
    count = 0
    for num in nums:
        if num > 10:
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:
                count += 1
        
    return count 
","def check(candidate):

    # Check some simple cases
    assert candidate([5, -2, 1, -5]) == 0  
    assert candidate([15, -73, 14, -15]) == 1
    assert candidate([33, -2, -3, 45, 21, 109]) == 2
    assert candidate([43, -12, 93, 125, 121, 109]) == 4
    assert candidate([71, -2, -33, 75, 21, 19]) == 3


    # Check some edge cases that are easy to work out by hand.
    assert candidate([1]) == 0              
    assert candidate([]) == 0                   

"
"
def get_max_triples(n):
    """"""
    คุณได้รับจำนวนเต็มบวก n คุณต้องสร้างอาร์เรย์ของจำนวนเต็ม a ที่มีความยาว n
สำหรับแต่ละ i ค่า a[i] = i * i - i + 1
คืนค่าจำนวนของชุดสามตัว ของ a ที่ i < j < k และ a[i] + a[j] + a[k] เป็นพหุคูณของ 3

ตัวอย่าง:
    อินพุต: n = 5
    เอาต์พุต: 1
    คำอธิบาย:
    a = [1, 3, 7, 13, 21]
    ชุดสามตัวที่ถูกต้องเพียงชุดเดียวคือ
    """"""
","    A = [i*i - i + 1 for i in range(1,n+1)]
    ans = []
    for i in range(n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if (A[i]+A[j]+A[k])%3 == 0:
                    ans += [(A[i],A[j],A[k])]
    return len(ans)
","def check(candidate):

    assert candidate(5) == 1
    assert candidate(6) == 4
    assert candidate(10) == 36
    assert candidate(100) == 53361
"
"
def bf(planet1, planet2):
    '''
    There are eight planets in our solar system: the closerst to the Sun 
    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    Uranus, Neptune.
    Write a function that takes two planet names as strings planet1 and planet2. 
    The function should return a tuple containing all planets whose orbits are 
    located between the orbit of planet1 and the orbit of planet2, sorted by 
    the proximity to the sun. 
    The function should return an empty tuple if planet1 or planet2
    are not correct planet names. 
    Examples
    bf(""Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"")
    bf(""Earth"", ""Mercury"") ==> (""Venus"")
    bf(""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"")
    '''
","    planet_names = (""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune"")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:
        return ()
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index:
        return (planet_names[planet1_index + 1: planet2_index])
    else:
        return (planet_names[planet2_index + 1 : planet1_index])
","def check(candidate):

    # Check some simple cases
    assert candidate(""Jupiter"", ""Neptune"") == (""Saturn"", ""Uranus""), ""First test error: "" + str(len(candidate(""Jupiter"", ""Neptune"")))      
    assert candidate(""Earth"", ""Mercury"") == (""Venus"",), ""Second test error: "" + str(candidate(""Earth"", ""Mercury""))  
    assert candidate(""Mercury"", ""Uranus"") == (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""), ""Third test error: "" + str(candidate(""Mercury"", ""Uranus""))      
    assert candidate(""Neptune"", ""Venus"") == (""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""), ""Fourth test error: "" + str(candidate(""Neptune"", ""Venus""))  


    # Check some edge cases that are easy to work out by hand.
    assert candidate(""Earth"", ""Earth"") == ()
    assert candidate(""Mars"", ""Earth"") == ()
    assert candidate(""Jupiter"", ""Makemake"") == ()

"
"
def sorted_list_sum(lst):
    """"""เขียนฟังก์ชันที่รับลิสต์ของสตริงเป็นพารามิเตอร์,
    ลบสตริงที่มีความยาวเป็นเลขคี่ออกจากลิสต์,
    และคืนค่าลิสต์ที่ได้โดยเรียงลำดับ,
    ลิสต์จะเป็นลิสต์ของสตริงเสมอและไม่เคยเป็นอาเรย์ของตัวเลข,
    และอาจมีค่าเหมือนกันได้.
    ลำดับของลิสต์ควรเรียงตามความยาวของแต่ละคำในลำดับจากน้อยไปมาก,
    และคุณควรคืนค่าลิสต์ที่เรียงตามกฎนี้.
    หากสองคำมีความยาวเท่ากัน ให้เรียงลิสต์ตามลำดับตัวอักษร.
    ฟังก์ชันควรคืนค่าลิสต์ของสตริงที่เรียงลำดับแล้ว.
    คุณสามารถสมมติได้ว่าคำทั้งหมดจะมีความยาวเท่ากัน.
    ตัวอย่างเช่น:
    assert list_sort => [""aa""]
    assert list_sort => [""ab"", ""cd""]
    """"""
","    lst.sort()
    new_lst = []
    for i in lst:
        if len(i)%2 == 0:
            new_lst.append(i)
    return sorted(new_lst, key=len)
","def check(candidate):

    # Check some simple cases
    assert candidate([""aa"", ""a"", ""aaa""]) == [""aa""]
    assert candidate([""school"", ""AI"", ""asdf"", ""b""]) == [""AI"", ""asdf"", ""school""]
    assert candidate([""d"", ""b"", ""c"", ""a""]) == []
    assert candidate([""d"", ""dcba"", ""abcd"", ""a""]) == [""abcd"", ""dcba""]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([""AI"", ""ai"", ""au""]) == [""AI"", ""ai"", ""au""]
    assert candidate([""a"", ""b"", ""b"", ""c"", ""c"", ""a""]) == []
    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [""cc"", ""dd"", ""aaaa"", ""bbbb""]

"
"
def x_or_y(n, x, y):
    """"""โปรแกรมง่ายๆ ซึ่งควรคืนค่าของ x หาก n เป็นจำนวนเฉพาะ และควรคืนค่าของ y ในกรณีอื่นๆ

ตัวอย่าง:
สำหรับ x_or_y == 34
สำหรับ x_or_y == 5
    
    """"""
","    if n == 1:
        return y
    for i in range(2, n):
        if n % i == 0:
            return y
            break
    else:
        return x
","def check(candidate):

    # Check some simple cases
    assert candidate(7, 34, 12) == 34
    assert candidate(15, 8, 5) == 5
    assert candidate(3, 33, 5212) == 33
    assert candidate(1259, 3, 52) == 3
    assert candidate(7919, -1, 12) == -1
    assert candidate(3609, 1245, 583) == 583
    assert candidate(91, 56, 129) == 129
    assert candidate(6, 34, 1234) == 1234
    

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 2, 0) == 0
    assert candidate(2, 2, 0) == 2

"
"
def double_the_difference(lst):
    '''
    Given a list of numbers, return the sum of squares of the numbers
    in the list that are odd. Ignore numbers that are negative or not integers.
    
    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10
    double_the_difference([-1, -2, 0]) == 0
    double_the_difference([9, -2]) == 81
    double_the_difference([0]) == 0  
   
    If the input list is empty, return 0.
    '''
","    return sum([i**2 for i in lst if i > 0 and i%2!=0 and ""."" not in str(i)])
","def check(candidate):

    # Check some simple cases
    assert candidate([]) == 0 , ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([5, 4]) == 25 , ""This prints if this assert fails 2 (good for debugging!)""
    assert candidate([0.1, 0.2, 0.3]) == 0 , ""This prints if this assert fails 3 (good for debugging!)""
    assert candidate([-10, -20, -30]) == 0 , ""This prints if this assert fails 4 (good for debugging!)""


    # Check some edge cases that are easy to work out by hand.
    assert candidate([-1, -2, 8]) == 0, ""This prints if this assert fails 5 (also good for debugging!)""
    assert candidate([0.2, 3, 5]) == 34, ""This prints if this assert fails 6 (also good for debugging!)""
    lst = list(range(-99, 100, 2))
    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])
    assert candidate(lst) == odd_sum , ""This prints if this assert fails 7 (good for debugging!)""

"
"
def compare(game,guess):
    """"""ฉันคิดว่าพวกเราทุกคนจำความรู้สึกนั้นได้เมื่อผลลัพธ์ของเหตุการณ์ที่รอคอยมานานที่สุดท้ายก็ถูกเปิดเผย ความรู้สึกและความคิดที่คุณมีในขณะนั้นแน่นอนว่าควรจะถูกจดบันทึกและเปรียบเทียบ งานของคุณคือการตรวจสอบว่าบุคคลเดาผลการแข่งขันได้ถูกต้องหรือไม่ คุณจะได้รับอาเรย์สองชุดซึ่งประกอบด้วยคะแนนและการเดาที่มีความยาวเท่ากัน โดยแต่ละดัชนีแสดงถึงการแข่งขัน คืนค่าอาเรย์ที่มีความยาวเท่ากันซึ่งแสดงถึงความคลาดเคลื่อนของการเดาแต่ละครั้ง หากพวกเขาเดาถูกต้อง ค่าจะเป็น 0 และหากไม่ถูกต้อง ค่าจะเป็นความแตกต่างอย่างสัมบูรณ์ระหว่างการเดาและคะแนน

ตัวอย่าง:

compare -> [0,0,0,0,3,3]
compare -> [4,4,1,0,0,6]
    """"""
","    return [abs(x-y) for x,y in zip(game,guess)]
","def check(candidate):

    # Check some simple cases
    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def Strongest_Extension(class_name, extensions):
    """"""คุณจะได้รับชื่อของคลาส และรายชื่อของส่วนขยาย
    ส่วนขยายเหล่านี้จะถูกใช้เพื่อโหลดคลาสเพิ่มเติมไปยังคลาสหลัก
    ความแข็งแรงของส่วนขยายถูกคำนวณดังนี้: ให้ CAP เป็นจำนวนของตัวอักษรพิมพ์ใหญ่
    ในชื่อของส่วนขยาย และให้ SM เป็นจำนวนตัวอักษรพิมพ์เล็กในชื่อของส่วนขยาย ความแข็งแรงจะถูกคำนวณจากเศษส่วน CAP - SM
    คุณควรหาส่วนขยายที่แข็งแรงที่สุดและคืนค่าสตริงในรูปแบบนี้: ClassName.StrongestExtensionName
    หากมีส่วนขยายสองส่วนหรือมากกว่าที่มีความแข็งแรงเท่ากัน คุณควรเลือกส่วนขยายที่อยู่ก่อนหน้าในรายการ
    ตัวอย่างเช่น หากคุณได้รับ ""Slices"" เป็นคลาส และรายชื่อส่วนขยาย: ['SErviNGSliCes', 'Cheese', 'StuFfed'] คุณควรคืนค่า 'Slices.SErviNGSliCes' เนื่องจาก 'SErviNGSliCes' เป็นส่วนขยายที่แข็งแรงที่สุด
    ตัวอย่าง:
    สำหรับ Strongest_Extension == 'my_class.AA'
    """"""
","    strong = extensions[0]
    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])
    for s in extensions:
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val:
            strong = s
            my_val = val

    ans = class_name + ""."" + strong
    return ans

","def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    
"
"
def cycpattern_check(a , b):
    """"""คุณได้รับคำ 2 คำ คุณต้องคืนค่า True ถ้าคำที่สองหรือการหมุนใด ๆ ของมันเป็นส่วนหนึ่งของคำแรก
    cycpattern_check => False
    cycpattern_check => True
    cycpattern_check => False
    cycpattern_check => True
    cycpattern_check => False
    cycpattern_check => True

    """"""
","    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1):
        for j in range(l + 1):
            if a[i:i+l] == pat[j:j+l]:
                return True
    return False
","def check(candidate):

    # Check some simple cases
    #assert True, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    #assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert  candidate(""xyzw"",""xyw"") == False , ""test #0""
    assert  candidate(""yello"",""ell"") == True , ""test #1""
    assert  candidate(""whattup"",""ptut"") == False , ""test #2""
    assert  candidate(""efef"",""fee"") == True , ""test #3""
    assert  candidate(""abab"",""aabb"") == False , ""test #4""
    assert  candidate(""winemtt"",""tinem"") == True , ""test #5""

"
"
def even_odd_count(num):
    """"""กำหนดจำนวนเต็ม จงคืนค่าเป็นทูเพิลที่มีจำนวนตัวเลขคู่และตัวเลขคี่ตามลำดับ

     ตัวอย่าง:
        even_odd_count ==>
        even_odd_count ==>
    """"""
","    even_count = 0
    odd_count = 0
    for i in str(abs(num)):
        if int(i)%2==0:
            even_count +=1
        else:
            odd_count +=1
    return (even_count, odd_count)
","def check(candidate):

    # Check some simple cases
    assert candidate(7) == (0, 1)
    assert candidate(-78) == (1, 1)
    assert candidate(3452) == (2, 2)
    assert candidate(346211) == (3, 3)
    assert candidate(-345821) == (3, 3)
    assert candidate(-2) == (1, 0)
    assert candidate(-45347) == (2, 3)
    assert candidate(0) == (1, 0)


    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def int_to_mini_roman(number):
    """"""
    เมื่อได้รับจำนวนเต็มบวก ให้แปลงเป็นเลขโรมันในรูปแบบสตริง
    และคืนค่าในรูปแบบตัวพิมพ์เล็ก
    ข้อจำกัด: 1 <= num <= 1000

    ตัวอย่าง:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """"""
","    num = [1, 4, 5, 9, 10, 40, 50, 90,  
           100, 400, 500, 900, 1000] 
    sym = [""I"", ""IV"", ""V"", ""IX"", ""X"", ""XL"",  
           ""L"", ""XC"", ""C"", ""CD"", ""D"", ""CM"", ""M""] 
    i = 12
    res = ''
    while number: 
        div = number // num[i] 
        number %= num[i] 
        while div: 
            res += sym[i] 
            div -= 1
        i -= 1
    return res.lower()
","def check(candidate):

    # Check some simple cases
    assert candidate(19) == 'xix'
    assert candidate(152) == 'clii'
    assert candidate(251) == 'ccli'
    assert candidate(426) == 'cdxxvi'
    assert candidate(500) == 'd'
    assert candidate(1) == 'i'
    assert candidate(4) == 'iv'
    assert candidate(43) == 'xliii'
    assert candidate(90) == 'xc'
    assert candidate(94) == 'xciv'
    assert candidate(532) == 'dxxxii'
    assert candidate(900) == 'cm'
    assert candidate(994) == 'cmxciv'
    assert candidate(1000) == 'm'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def right_angle_triangle(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
","    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 3) == False
    assert candidate(10, 6, 8) == True
    assert candidate(2, 2, 2) == False
    assert candidate(7, 24, 25) == True
    assert candidate(10, 5, 7) == False
    assert candidate(5, 12, 13) == True
    assert candidate(15, 8, 17) == True
    assert candidate(48, 55, 73) == True

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == False, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == False

"
"
def find_max(words):
    """"""เขียนฟังก์ชันที่รับรายการของสตริง
    รายการนี้มีคำที่แตกต่างกัน ให้คืนค่าคำที่มีจำนวนอักขระที่ไม่ซ้ำกันมากที่สุด 
    หากมีสตริงหลายตัวที่มีจำนวนอักขระที่ไม่ซ้ำกันสูงสุด ให้คืนค่าตัวที่อยู่ก่อนในลำดับตามตัวอักษร

    find_max == ""string""
    find_max == ""enam""
    find_max == ""aaaaaaa""
    """"""
","    return sorted(words, key = lambda x: (-len(set(x)), x))[0]
","def check(candidate):

    # Check some simple cases
    assert (candidate([""name"", ""of"", ""string""]) == ""string""), ""t1""
    assert (candidate([""name"", ""enam"", ""game""]) == ""enam""), 't2'
    assert (candidate([""aaaaaaa"", ""bb"", ""cc""]) == ""aaaaaaa""), 't3'
    assert (candidate([""abc"", ""cba""]) == ""abc""), 't4'
    assert (candidate([""play"", ""this"", ""game"", ""of"",""footbott""]) == ""footbott""), 't5'
    assert (candidate([""we"", ""are"", ""gonna"", ""rock""]) == ""gonna""), 't6'
    assert (candidate([""we"", ""are"", ""a"", ""mad"", ""nation""]) == ""nation""), 't7'
    assert (candidate([""this"", ""is"", ""a"", ""prrk""]) == ""this""), 't8'

    # Check some edge cases that are easy to work out by hand.
    assert (candidate([""b""]) == ""b""), 't9'
    assert (candidate([""play"", ""play"", ""play""]) == ""play""), 't10'

"
"
def eat(number, need, remaining):
    """"""
    คุณเป็นกระต่ายที่หิวโซ และคุณได้กินแครอทไปแล้วจำนวนหนึ่ง
แต่ตอนนี้คุณต้องกินแครอทเพิ่มเพื่อให้ครบอาหารในแต่ละวัน
คุณควรส่งกลับเป็นอาร์เรย์ของ [ จำนวนแครอทที่กินทั้งหมดหลังมื้ออาหาร,
                                    จำนวนแครอทที่เหลือหลังมื้ออาหาร ]
ถ้าแครอทที่เหลือไม่เพียงพอ คุณจะกินแครอทที่เหลือทั้งหมด แต่ก็ยังคงหิวอยู่

ตัวอย่าง:
* eat -> [11, 4]
* eat -> [12, 1]
* eat -> [11, 0]
* eat -> [7, 0]

ตัวแปร:
@number : จำนวนเต็ม
    จำนวนแครอทที่คุณได้กินไปแล้ว
@need : จำนวนเต็ม
    จำนวนแครอทที่คุณต้องการจะกิน
@remaining : จำนวนเต็ม
    จำนวนแครอทที่เหลืออยู่ในสต๊อก

ข้อกำหนด:
* 0 <= number <= 1000
* 0 <= need <= 1000
* 0 <= remaining <= 1000

ขอให้สนุกนะ :)
    """"""
","    if(need <= remaining):
        return [ number + need , remaining-need ]
    else:
        return [ number + remaining , 0]
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(5, 6, 10) == [11, 4], ""Error""
    assert candidate(4, 8, 9) == [12, 1], ""Error""
    assert candidate(1, 10, 10) == [11, 0], ""Error""
    assert candidate(2, 11, 5) == [7, 0], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(4, 5, 7) == [9, 2], ""Error""
    assert candidate(4, 5, 1) == [5, 0], ""Error""

"
"
def do_algebra(operator, operand):
    """"""
    จากสองรายการ operator และ operand รายการแรกมีการดำเนินการพีชคณิตพื้นฐาน และรายการที่สองเป็นรายการจำนวนเต็ม ใช้สองรายการที่ให้มาเพื่อสร้างนิพจน์พีชคณิตและคืนค่าการประเมินผลของนิพจน์นี้

การดำเนินการพีชคณิตพื้นฐาน:
การบวก 
การลบ 
การคูณ 
การหารปัดเศษลง 
การยกกำลัง 

ตัวอย่าง:
operator['+', '*', '-']
array = [2, 3, 4, 5]
result = 2 + 3 * 4 - 5
=> result = 9

หมายเหตุ:
รายการ operator มีความยาวเท่ากับความยาวของรายการ operand ลบด้วยหนึ่ง
operand เป็นรายการของจำนวนเต็มที่ไม่เป็นลบ
รายการ operator มีอย่างน้อยหนึ่งการดำเนินการ และรายการ operand มีอย่างน้อยสองตัวเลข

    """"""
","    expression = str(operand[0])
    for oprt, oprn in zip(operator, operand[1:]):
        expression+= oprt + str(oprn)
    return eval(expression)
","def check(candidate):

    # Check some simple cases
    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37
    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9
    assert candidate(['//', '*'], [7, 3, 4]) == 8, ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
"
def solve(s):
    """"""คุณได้รับสตริง s
    ถ้า s[i] เป็นตัวอักษร ให้สลับกรณีจากตัวพิมพ์เล็กเป็นตัวพิมพ์ใหญ่หรือในทางกลับกัน
    ถ้าไม่ใช่ ให้คงไว้ตามเดิม
    ถ้าสตริงไม่มีตัวอักษร ให้กลับสตริง
    ฟังก์ชันควรคืนค่าสตริงที่ได้ผลลัพธ์
    ตัวอย่าง
    solve = ""4321""
    solve = ""AB""
    solve = ""#A@c""
    """"""
","    flg = 0
    idx = 0
    new_str = list(s)
    for i in s:
        if i.isalpha():
            new_str[idx] = i.swapcase()
            flg = 1
        idx += 1
    s = """"
    for i in new_str:
        s += i
    if flg == 0:
        return s[len(s)::-1]
    return s
","def check(candidate):

    # Check some simple cases
    assert candidate(""AsDf"") == ""aSdF""
    assert candidate(""1234"") == ""4321""
    assert candidate(""ab"") == ""AB""
    assert candidate(""#a@C"") == ""#A@c""
    assert candidate(""#AsdfW^45"") == ""#aSDFw^45""
    assert candidate(""#6@2"") == ""2@6#""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(""#$a^D"") == ""#$A^d""
    assert candidate(""#ccc"") == ""#CCC""

    # Don't remove this line:
"
"
def string_to_md5(text):
    """"""
    ให้สตริง 'text' คืนค่าข้อความที่เป็น md5 hash ที่เทียบเท่ากัน
    ถ้า 'text' เป็นสตริงว่าง ให้คืนค่าเป็น None

    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    """"""
","    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
","def check(candidate):

    # Check some simple cases
    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'
    assert candidate('') == None
    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'
    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'

    # Check some edge cases that are easy to work out by hand.
    assert True

"
"
def generate_integers(a, b):
    """"""
    กำหนดให้จำนวนเต็มบวกสองจำนวน a และ b ให้คืนค่าตัวเลขคู่ระหว่าง a และ b ในลำดับจากน้อยไปมาก

ตัวอย่างเช่น:
generate_integers => [2, 4, 6, 8]
generate_integers => [2, 4, 6, 8]
generate_integers => []
    """"""
","    lower = max(2, min(a, b))
    upper = min(8, max(a, b))

    return [i for i in range(lower, upper+1) if i % 2 == 0]
","def check(candidate):

    # Check some simple cases
    assert candidate(2, 10) == [2, 4, 6, 8], ""Test 1""
    assert candidate(10, 2) == [2, 4, 6, 8], ""Test 2""
    assert candidate(132, 2) == [2, 4, 6, 8], ""Test 3""
    assert candidate(17,89) == [], ""Test 4""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

"
